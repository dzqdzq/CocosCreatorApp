"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.Grid=void 0;const linear_ticks_1=require("./linear-ticks"),utils_1=require("./utils");class Grid{constructor(i,s){if(this.multi=1,this.axisMargin=20,this.negative=!1,this.lineWidth=1,this.showX=!1,this.showY=!1,this.xAxisScale=1,this.yAxisScale=1,this.axisXConfig={lods:[5,2],minScale:20,maxScale:100,startOffset:0,showLine:!0,lineWidth:.5,lineColor:"#ccc"},this.axisYConfig={lods:[5,2],minScale:20,maxScale:100,startOffset:0,showLine:!0,lineWidth:.5,lineColor:"#ccc"},this.xAxisOffset=0,this.xAnchor=.5,this.yAxisOffset=0,this.yAnchor=.5,this.xAxisMinStep=50,this.yAxisMinStep=50,this.xMaxValue=0,this.yMaxValue=0,this.canvas=i,this.ctx=i.getContext("2d"),this.ctx.strokeStyle="#ccc",!s.axisXConfig&&!s.axisYConfig)throw new Error("至少显示一种坐标轴");this.axisMargin=s.axisMargin||0,this.showX=!!s.axisXConfig,this.showY=!!s.axisYConfig,this.negative=s.negative||s.axisYConfig&&s.axisYConfig.minValue<0,this.showX&&(this.axisXConfig=Object.assign(this.axisXConfig,s.axisXConfig)),this.showY&&(this.axisYConfig=Object.assign(this.axisYConfig,s.axisYConfig)),this.showX&&this._initXAxios(),this.showY&&this._initYAxios()}get height(){return this.negative?this.canvas.height/2:this.canvas.height}get xRange(){return{left:0,right:this.canvas.width}}get anchorInfo(){return{x:0+this.axisMargin-this.lineWidth-.5,y:0+this.axisMargin-this.lineWidth-.5,w:this.canvas.width-2*this.axisMargin+2*this.lineWidth+.5,h:this.canvas.height-2*this.axisMargin+2*this.lineWidth+.5}}resize(i,s){if(!i||!s){const t=this.canvas.getBoundingClientRect();i=i||t.width,s=s||t.height,i=Math.round(i),s=Math.round(s)}this.canvas.width===i&&this.canvas.height===s||(this.canvas.width=i,this.canvas.height=s,this.render())}render(){this.clear(),this.updateGrids(),this.updateLabels()}transfer(i,s){return{x:this.transferX&&this.transferX(i)||0,y:this.transferY&&this.transferY(s)}}updateLabels(){this.renderLabelX&&this.renderLabelX(),this.renderLabelY&&this.renderLabelY()}clear(){var i;null===(i=this.ctx)||void 0===i||i.clearRect(-10,-10,this.canvas.width+10,this.canvas.height+10)}updateGrids(){this.ctx.save(),this.ctx.rect(this.anchorInfo.x,this.anchorInfo.y,this.anchorInfo.w,this.anchorInfo.h),this.ctx.clip(),this.renderX&&this.renderX(),this.renderY&&this.renderY(),this.ctx.restore()}valueToPixel(i){var s,t;return{x:null!==(s=this.valueToPixelX&&this.valueToPixelX(i.x))&&void 0!==s?s:i.x,y:null!==(t=this.valueToPixelY&&this.valueToPixelY(i.y))&&void 0!==t?t:i.y}}pixelToValue(i){var s,t;return{x:null!==(s=this.pixelToValueX&&this.pixelToValueX(i.x))&&void 0!==s?s:i.x,y:null!==(t=this.pixelToValueY&&this.pixelToValueY(i.y))&&void 0!==t?t:i.y}}valueToFormat(i){var s,t;return{x:null!==(s=this.xDefaultFormat&&this.xDefaultFormat(i.x))&&void 0!==s?s:i.x,y:null!==(t=this.yDefaultFormat&&this.yDefaultFormat(i.y))&&void 0!==t?t:i.y}}checkPointInRange(i){const s=this.valueToFormat(this.pixelToValue(i));if(this.axisXConfig&&(this.axisXConfig.maxValue<s.x||s.x<this.axisXConfig.minValue)){const{maxValue:t,minValue:a}=this.axisXConfig;return s.x=s.x>t?t:a,i.x=this.valueToPixelX(s.x*this.xMaxValue),!1}if(this.axisYConfig&&(this.axisYConfig.maxValue<s.y||s.y<this.axisYConfig.minValue)){const{maxValue:t,minValue:a}=this.axisYConfig;return s.y=s.y>t?t:a,i.y=this.valueToPixelY(s.y*this.yMaxValue),!1}return!0}checkXInRange(i){return!this.axisXConfig||!(this.axisXConfig.maxValue<i||i<this.axisXConfig.minValue)}_initXAxios(){const{lods:i,minScale:s,maxScale:t,startOffset:a,showLine:e,$container:h,format:n,maxValue:l,minValue:x}=this.axisXConfig;this.xAxisOffset=null!==a&&void 0!==a?a:0,this.xTicks=new linear_ticks_1.default,this.xTicks.initTicks(i,s,t).spacing(10,100),this.xAxisScale=utils_1.clamp(this.xAxisScale,this.xTicks.minValueScale,this.xTicks.maxValueScale),this.pixelToValueX=(i=>((i-=this.axisMargin)-this.xAxisOffset)/this.xAxisScale),this.valueToPixelX=(i=>i*this.xAxisScale+this.xAxisOffset+this.axisMargin);const o=this.pixelToValueX(0+this.axisMargin),r=this.pixelToValueX(this.canvas.width-2*this.axisMargin);this.xTicks.range(o,r,this.canvas.width-2*this.axisMargin),this.xMaxValue=this.xTicks.maxValue,this.transferX=(i=>{const{startOffset:s}=this.axisXConfig;if(this.xAxisOffset===s&&i>0)return 0;let t=this.xAxisOffset+i;return t>s&&(t=s),this.xAxisOffset=t}),this.xAxisScaleAt=((i,s)=>{const t=this.pixelToValueX(i);this.xAxisScale=utils_1.clamp(s,this.xTicks.minValueScale,this.xTicks.maxValueScale);const a=this.valueToPixelX(t);return this.transferX(i-a),this.xAxisScale}),this.xDefaultFormat=(i=>parseFloat((i*(l||1)/this.xMaxValue).toFixed(2))),this.xFormat=n||this.xDefaultFormat,h&&(this.renderLabelX=(()=>{const i=this.xTicks.levelForStep(this.xAxisMinStep);let s="";this.xTicks.ticksAtLevel(i,!1).forEach(i=>{const t=Math.floor(this.valueToPixelX(i))-5,a=this.xFormat?this.xFormat(i):i;s+=`<span style="transform: translateX(${Math.floor(t)}px);">${a}</span>`}),this.axisXConfig.$container.innerHTML=s})),e&&(this.renderX=(()=>{let i,s,t;const a=this.ctx,e=this.pixelToValueX(0+this.axisMargin),h=this.pixelToValueX(this.canvas.width-2*this.axisMargin);this.xTicks.range(e,h,this.canvas.width-2*this.axisMargin);const n=i=>{a.beginPath(),t=this.valueToPixelX(i),a.moveTo(Math.floor(t)+.5,0),a.lineTo(Math.floor(t)+.5,this.canvas.height),a.stroke()};for(let t=this.xTicks.minTickLevel;t<=this.xTicks.maxTickLevel;++t)if((s=this.xTicks.tickRatios[t])>0){a.strokeStyle=`rgba(99, 99, 99, ${3*s})`,i=this.xTicks.ticksAtLevel(t,!0);for(const s of i)n(s)}}))}_initYAxios(){const{lods:i,minScale:s,maxScale:t,startOffset:a,showLine:e,$container:h,format:n,maxValue:l}=this.axisYConfig;this.yAxisOffset=a||0;const{w:x}=this.anchorInfo,o=Math.floor(x/10);this.yTicks=new linear_ticks_1.default,this.yTicks.initTicks(i,s,t).spacing(x/20,o),this.yAxisScale=utils_1.clamp(this.yAxisScale,this.yTicks.minValueScale,this.yTicks.maxValueScale),this.yAxisMinStep=x/20,this.pixelToValueY=(i=>(i+=this.axisMargin,(this.height-i+this.yAxisOffset)/this.yAxisScale)),this.valueToPixelY=(i=>-i*this.yAxisScale+this.height+this.yAxisOffset-this.axisMargin);const r=this.pixelToValueY(0+this.axisMargin),c=this.pixelToValueY(this.canvas.height-2*this.axisMargin);this.yTicks.range(r,c,this.canvas.height-2*this.axisMargin),this.yMaxValue=this.yTicks.maxValue,this.yDefaultFormat=(i=>parseFloat((i*(l||1)/this.yMaxValue).toFixed(2))),this.yFormat=n||this.yDefaultFormat,this.transferY=(i=>{if(!this.showY)return 0;const s=this.yAxisOffset+i;return!this.negative&&s<0?0:this.yAxisOffset=s}),h&&(this.renderLabelY=(()=>{const i=this.yTicks.levelForStep(this.yAxisMinStep);let s="";this.yTicks.ticksAtLevel(i,!1).forEach(i=>{const t=Math.floor(this.valueToPixelY(i))-10,a=this.yFormat?this.yFormat(i):i;s+=`<span style="transform: translateY(${Math.floor(t)}px);">${a}</span>`}),this.axisYConfig.$container.innerHTML=s})),e&&(this.renderY=(()=>{let i,s,t;const a=this.ctx,e=this.pixelToValueY(0+this.axisMargin),h=this.pixelToValueY(this.canvas.height-2*this.axisMargin);this.yTicks.range(e,h,this.canvas.height-2*this.axisMargin);const n=i=>{a.beginPath(),t=this.valueToPixelY(i),a.moveTo(0,Math.floor(t)+.5),a.lineTo(this.canvas.width,Math.floor(t)+.5),a.stroke()};for(let t=this.yTicks.minTickLevel;t<=this.yTicks.maxTickLevel;++t)if((s=this.yTicks.tickRatios[t])>0){a.strokeStyle=`rgba(99, 99, 99, ${3*s})`,i=this.yTicks.ticksAtLevel(t,!0);for(const s of i)n(s)}})),this.yAxisScaleAt=function(i,s){const t=this.pixelToValueY(i);this.yAxisScale=utils_1.clamp(s,this.yTicks.minValueScale,this.yTicks.maxValueScale);const a=this.valueToPixelY(t);return this.transferY(i-a),this.yAxisScale}}}exports.Grid=Grid;