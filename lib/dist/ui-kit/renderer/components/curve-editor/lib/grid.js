"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.Grid=void 0;const linear_ticks_1=require("./linear-ticks"),utils_1=require("./utils");class Grid{constructor(i,s){if(this.multi=1,this.axisMargin=20,this.negative=!1,this.lineWidth=1,this.showX=!1,this.showY=!1,this.xAxisScale=1,this.yAxisScale=1,this.axisXConfig={lods:[5,2],minScale:20,maxScale:100,startOffset:0,showLine:!0,lineWidth:.5,lineColor:"#ccc"},this.axisYConfig={lods:[5,2],minScale:20,maxScale:100,startOffset:0,showLine:!0,lineWidth:.5,lineColor:"#ccc"},this.xAxisOffset=0,this.xAnchor=.5,this.yAxisOffset=0,this.yAnchor=.5,this.xAxisMinStep=50,this.yAxisMinStep=50,this.xMaxValue=0,this.yMaxValue=0,this.canvas=i,this.ctx=i.getContext("2d"),this.ctx.strokeStyle="#ccc",!s.axisXConfig&&!s.axisYConfig)throw new Error("至少显示一种坐标轴");this.axisMargin=s.axisMargin||0,this.showX=!!s.axisXConfig,this.showY=!!s.axisYConfig,this.negative=s.negative||s.axisYConfig&&s.axisYConfig.minValue<0,this.showX&&(this.axisXConfig=Object.assign(this.axisXConfig,s.axisXConfig)),this.showY&&(this.axisYConfig=Object.assign(this.axisYConfig,s.axisYConfig)),this.showX&&this._initXAxios(),this.showY&&this._initYAxios()}get height(){return this.negative?this.canvas.height/2:this.canvas.height}get xRange(){return{left:0,right:this.canvas.width}}get anchorInfo(){return{x:0+this.axisMargin-this.lineWidth-.5,y:0+this.axisMargin-this.lineWidth-.5,w:this.canvas.width-2*this.axisMargin+2*this.lineWidth+.5,h:this.canvas.height-2*this.axisMargin+2*this.lineWidth+.5}}resize(i,s){if(!i||!s){const t=this.canvas.getBoundingClientRect();i=i||t.width,s=s||t.height,i=Math.round(i),s=Math.round(s)}this.canvas.width===i&&this.canvas.height===s||(this.canvas.width=i,this.canvas.height=s,this.render())}render(){this.clear(),this.updateGrids(),this.updateLabels()}transfer(i,s){return{x:this.transferX&&this.transferX(i)||0,y:this.transferY&&this.transferY(s)}}updateLabels(){this.renderLabelX&&this.renderLabelX(),this.renderLabelY&&this.renderLabelY()}clear(){var i;null===(i=this.ctx)||void 0===i||i.clearRect(-10,-10,this.canvas.width+10,this.canvas.height+10)}updateGrids(){this.ctx.save(),this.ctx.rect(this.anchorInfo.x,this.anchorInfo.y,this.anchorInfo.w,this.anchorInfo.h),this.ctx.clip(),this.renderX&&this.renderX(),this.renderY&&this.renderY(),this.ctx.restore()}valueToPixel(i){var s,t;return{x:null!==(s=this.valueToPixelX&&this.valueToPixelX(i.x))&&void 0!==s?s:i.x,y:null!==(t=this.valueToPixelY&&this.valueToPixelY(i.y))&&void 0!==t?t:i.y}}pixelToValue(i){var s,t;return{x:null!==(s=this.pixelToValueX&&this.pixelToValueX(i.x))&&void 0!==s?s:i.x,y:null!==(t=this.pixelToValueY&&this.pixelToValueY(i.y))&&void 0!==t?t:i.y}}_initXAxios(){const{lods:i,minScale:s,maxScale:t,startOffset:e,showLine:a,$container:h,format:n,maxValue:l}=this.axisXConfig;this.xAxisOffset=null!==e&&void 0!==e?e:0,this.xTicks=new linear_ticks_1.default,this.xTicks.initTicks(i,s,t).spacing(10,100),this.xAxisScale=utils_1.clamp(this.xAxisScale,this.xTicks.minValueScale,this.xTicks.maxValueScale),this.pixelToValueX=(i=>{i-=this.axisMargin,this.xAxisOffset,this.xAxisScale;return Math.round((i-this.xAxisOffset)/this.xAxisScale)}),this.valueToPixelX=(i=>i*this.xAxisScale+this.xAxisOffset+this.axisMargin);const r=this.pixelToValueX(0+this.axisMargin),x=this.pixelToValueX(this.canvas.width-2*this.axisMargin);this.xTicks.range(r,x,this.canvas.width-2*this.axisMargin),this.xMaxValue=this.xTicks.maxValue,this.transferX=(i=>{const{startOffset:s}=this.axisXConfig;if(this.xAxisOffset===s&&i>0)return 0;let t=this.xAxisOffset+i;return t>s&&(t=s),this.xAxisOffset=t}),this.xAxisScaleAt=((i,s)=>{const t=this.pixelToValueX(i);this.xAxisScale=utils_1.clamp(s,this.xTicks.minValueScale,this.xTicks.maxValueScale);const e=this.valueToPixelX(t);return this.transferX(i-e),this.xAxisScale}),this.xFormat=n||(i=>parseFloat((i*(l||1)/this.xMaxValue).toFixed(2))),h&&(this.renderLabelX=(()=>{const i=this.xTicks.levelForStep(this.xAxisMinStep);let s="";this.xTicks.ticksAtLevel(i,!1).forEach(i=>{const t=Math.floor(this.valueToPixelX(i))-5,e=this.xFormat?this.xFormat(i):i;s+=`<span style="transform: translateX(${Math.floor(t)}px);">${e}</span>`}),this.axisXConfig.$container.innerHTML=s})),a&&(this.renderX=(()=>{let i,s,t;const e=this.ctx,a=this.pixelToValueX(0+this.axisMargin),h=this.pixelToValueX(this.canvas.width-2*this.axisMargin);this.xTicks.range(a,h,this.canvas.width-2*this.axisMargin);const n=i=>{e.beginPath(),t=this.valueToPixelX(i),e.moveTo(Math.floor(t)+.5,0),e.lineTo(Math.floor(t)+.5,this.canvas.height),e.stroke()};for(let t=this.xTicks.minTickLevel;t<=this.xTicks.maxTickLevel;++t)if((s=this.xTicks.tickRatios[t])>0){e.strokeStyle=`rgba(99, 99, 99, ${3*s})`,i=this.xTicks.ticksAtLevel(t,!0);for(const s of i)n(s)}}))}_initYAxios(){const{lods:i,minScale:s,maxScale:t,startOffset:e,showLine:a,$container:h,format:n,maxValue:l}=this.axisYConfig;this.yAxisOffset=e||0;const{w:r}=this.anchorInfo,x=Math.floor(r/10);this.yTicks=new linear_ticks_1.default,this.yTicks.initTicks(i,s,t).spacing(r/20,x),this.yAxisScale=utils_1.clamp(this.yAxisScale,this.yTicks.minValueScale,this.yTicks.maxValueScale),this.yAxisMinStep=r/20,this.pixelToValueY=(i=>(i+=this.axisMargin,Math.floor((this.height-i+this.yAxisOffset)/this.yAxisScale))),this.valueToPixelY=(i=>Math.floor(-i*this.yAxisScale+this.height+this.yAxisOffset)-this.axisMargin);const o=this.pixelToValueY(0+this.axisMargin),c=this.pixelToValueY(this.canvas.height-2*this.axisMargin);this.yTicks.range(o,c,this.canvas.height-2*this.axisMargin),this.yMaxValue=this.yTicks.maxValue,this.yFormat=n||(i=>parseFloat((i*(l||1)/this.yMaxValue).toFixed(2))),this.transferY=(i=>{if(!this.showY)return 0;const s=this.yAxisOffset+i;return!this.negative&&s<0?0:this.yAxisOffset=s}),h&&(this.renderLabelY=(()=>{const i=this.yTicks.levelForStep(this.yAxisMinStep);let s="";this.yTicks.ticksAtLevel(i,!1).forEach(i=>{const t=Math.floor(this.valueToPixelY(i))-10,e=this.yFormat?this.yFormat(i):i;s+=`<span style="transform: translateY(${Math.floor(t)}px);">${e}</span>`}),this.axisYConfig.$container.innerHTML=s})),a&&(this.renderY=(()=>{let i,s,t;const e=this.ctx,a=this.pixelToValueY(0+this.axisMargin),h=this.pixelToValueY(this.canvas.height-2*this.axisMargin);this.yTicks.range(a,h,this.canvas.height-2*this.axisMargin);const n=i=>{e.beginPath(),t=this.valueToPixelY(i),e.moveTo(0,Math.floor(t)+.5),e.lineTo(this.canvas.width,Math.floor(t)+.5),e.stroke()};for(let t=this.yTicks.minTickLevel;t<=this.yTicks.maxTickLevel;++t)if((s=this.yTicks.tickRatios[t])>0){e.strokeStyle=`rgba(99, 99, 99, ${3*s})`,i=this.yTicks.ticksAtLevel(t,!0);for(const s of i)n(s)}})),this.yAxisScaleAt=function(i,s){const t=this.pixelToValueY(i);this.yAxisScale=utils_1.clamp(s,this.yTicks.minValueScale,this.yTicks.maxValueScale);const e=this.valueToPixelY(t);return this.transferY(i-e),this.yAxisScale}}}exports.Grid=Grid;