"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.Hermite=void 0;const curve_base_1=require("./curve-base"),utils_1=require("./utils");class Hermite extends curve_base_1.CurveBase{constructor(e,t,i){super(e,t,i),this.hermiteArgs=[],this.config={strokeStyle:"red",lineWidth:1,strokeStyleAxu:"rgba(255, 0, 0, 0.3)",showKey:!0},this.keyframes=[],this.curveCache=new Path2D}static calcArgs(e,t,i,s){if(t===Number.POSITIVE_INFINITY||s===Number.POSITIVE_INFINITY)return{a:0,b:0,c:0,d:e.y,md5:Hermite.calcHermitArgsMd5(e,t,i,s)};const r=e.x,n=e.y,a=i.x,o=i.y;let h,c,l,u,g,p,m,y;const f=[1,r,r*r,r*r*r,1,a,a*a,a*a*a,0,1,2*r,3*r*r,0,1,2*a,3*a*a];for(y=(e=>e[0]*e[4]*e[8]+e[1]*e[5]*e[6]+e[2]*e[3]*e[7]-e[2]*e[4]*e[6]-e[1]*e[3]*e[8]-e[0]*e[5]*e[7]),h=m=0;h<4;m+=y(p)*f[h]*(h%2?-1:1),h++)if(f[h])for(c=4,p=[];c<f.length;c++)c%4!==h&&p.push(f[c]);for(g=[],h=0;h<4;h++)for(c=0;c<4;g[h+4*c]=((h+c)%2?-1:1)*y(p)/m,c++)for(p=[],l=0;l<3;l++)for(u=0;u<3;u++)p.push(f[(h+l+1)%4*4+(c+u+1)%4]);const x=n*g[0]+o*g[1]+t*g[2]+s*g[3],d=n*g[4]+o*g[5]+t*g[6]+s*g[7],T=n*g[8]+o*g[9]+t*g[10]+s*g[11];return{a:n*g[12]+o*g[13]+t*g[14]+s*g[15],b:T,c:d,d:x,md5:Hermite.calcHermitArgsMd5(e,t,i,s)}}static getRenderFunc(e){const{a:t,b:i,c:s,d:r}=e;return e=>t*e*e*e+i*e*e+s*e+r}static quickPaint(e,t,i){if(0===e.length||!t)return console.error("paint hermit need keyframes and canvas!"),!1;const s=t.width,r=t.height,n=t.getContext("2d");let a;n.clearRect(0,0,s,r),n.strokeStyle="red",a=i?r/s/2:r/s;const o=e.map(e=>{return{point:{x:e.point.x*s,y:e.point.y*r},outTangent:"number"==typeof e.outTangent?e.outTangent*a:1/0,inTangent:"number"==typeof e.inTangent?e.inTangent*a:1/0}});for(let e=0;e<o.length-1;e++){const t=o[e+1],s=o[e],a=Hermite.calcArgs(s.point,s.outTangent,t.point,t.inTangent),h=Hermite.getRenderFunc(a);n.beginPath();for(let e=s.point.x;e<=t.point.x;e++)i?n.lineTo(e,r-.5*h(e)-r/2):n.lineTo(e,r-h(e));s.outTangent!==Number.POSITIVE_INFINITY&&t.inTangent!==Number.POSITIVE_INFINITY||(n.lineTo(t.point.x,r-t.point.y),n.stroke()),n.stroke()}return i&&(n.strokeStyle="#ccc",n.lineWidth=.5,n.beginPath(),n.moveTo(0,r/2),n.lineTo(s,r/2),n.stroke()),!0}static calcHermitArgsMd5(e,t,i,s){return JSON.stringify({p1:e,k1:t,p2:i,k2:s})}translate(e,t){}initKeyData(e){try{this.keyframes=require("lodash").cloneDeep(e)}catch(e){return void console.error(e)}}paint(e){try{this.keyframes=require("lodash").cloneDeep(e)}catch(e){return void console.error(e)}this.hermiteArgs=[],this.paintRect(),this.paintInWrapMode()}rePaint(){this.clear(),this.paintRect(),this.paintInWrapMode()}paintWithCache(e){e.stroke(this.curveCache)}paintKeyFrame(e){this.ctx.save(),this.ctx.fillStyle="gold",this.ctx.beginPath(),this.ctx.arc(e.x,e.y,1,0,2*Math.PI),this.ctx.closePath(),this.ctx.stroke(),this.ctx.fill(),this.ctx.restore()}paintRect(e){const t=(null===e||void 0===e?void 0:e.end)||this.keyframes.length-1,i=(null===e||void 0===e?void 0:e.start)||0;this.curveCache=new Path2D;for(let e=i;e<t;e++){const t=this.keyframes[e+1],s=this.keyframes[e],r=this.grid.valueToPixel(s.point);e===i&&this.curveCache.moveTo(r.x,r.y);const n=this.getRenderFunc(s.point,s.outTangent,t.point,t.inTangent,e);for(let e=s.point.x;e<=t.point.x;e++){const t=this.grid.valueToPixel({x:e,y:n(e)});this.curveCache.lineTo(t.x,t.y)}if(s.outTangent===Number.POSITIVE_INFINITY||t.inTangent===Number.POSITIVE_INFINITY){const e=this.grid.valueToPixel(t.point);this.curveCache.lineTo(e.x,e.y)}this.paintKeyFrame(r)}this.ctx.stroke(this.curveCache)}paintInWrapMode(){this.paintPostWrapMode(),this.paintPreWrapMode()}paintPreWrapMode(){if("number"!=typeof this.config.preWrapMode)return;this.ctx.save(),this.ctx.strokeStyle=this.config.strokeStyleAxu;const e=this.grid.valueToPixel(this.keyframes[this.keyframes.length-1].point),t=this.grid.valueToPixel(this.keyframes[0].point),i=e.x-t.x;if(0===i)return void console.debug("The key frame distance is 0");this.ctx.clearRect(0,0,t.x+1,this.canvas.height);const s=Math.ceil(t.x/i),r=new Path2D;switch(this.config.preWrapMode){case 4:case 0:r.moveTo(t.x,t.y),r.lineTo(this.grid.axisMargin,t.y);break;case 2:{let n=utils_1.createMatrix();for(let a=0;a<s;a++)r.moveTo(t.x-i*a,t.y),n.translateSelf(-i,0),r.lineTo(t.x-i*a,e.y),r.addPath(this.curveCache,n);break}case 3:case 22:{const e=new Path2D;let n=utils_1.createMatrix();e.addPath(this.curveCache,n.scaleSelf(-1,1));let a=utils_1.createMatrix();for(let n=0;n<=s;n++)a=a.translateSelf(-i,0),n%2==0?r.addPath(e,utils_1.createMatrix().translateSelf(2*t.x-i*n)):r.addPath(this.curveCache,a);break}}this.ctx.stroke(r),this.ctx.restore()}paintPostWrapMode(){if("number"!=typeof this.config.postWrapMode)return;this.ctx.save(),this.ctx.strokeStyle=this.config.strokeStyleAxu;const e=this.grid.valueToPixel(this.keyframes[this.keyframes.length-1].point),t=this.grid.valueToPixel(this.keyframes[0].point),i=e.x-t.x;if(0===i)return void console.debug("The key frame distance is 0");this.ctx.clearRect(e.x,0,this.canvas.width-e.x+1,this.canvas.height);const s=Math.ceil((this.canvas.width-e.x)/i),r=new Path2D;switch(r.moveTo(e.x,e.y),this.config.postWrapMode){case 4:case 0:r.lineTo(this.canvas.width-this.grid.axisMargin,e.y);break;case 2:{let n=utils_1.createMatrix();for(let a=0;a<s;a++)n.translateSelf(i,0),r.lineTo(e.x+i*a,t.y),r.addPath(this.curveCache,n);break}case 22:case 3:{const t=new Path2D;let n=utils_1.createMatrix();t.addPath(this.curveCache,n.scaleSelf(-1,1));let a=utils_1.createMatrix();for(let n=0;n<=s;n++)a=a.translateSelf(i,0),n%2==0?r.addPath(t,utils_1.createMatrix().translateSelf(2*e.x+i*n)):r.addPath(this.curveCache,a);break}}this.wrapModeCurveCache=r,this.ctx.stroke(r),this.ctx.restore()}moveAllY(e){if(0===e)return!1;this.clear();const t=new Path2D;let i=utils_1.createMatrix();i=i.translateSelf(0,e),t.addPath(this.curveCache,i),this.curveCache=t,this.ctx.stroke(this.curveCache),this.paintInWrapMode(),e/=this.grid.yAxisScale;for(let t=0;t<this.keyframes.length;t++){const i=this.keyframes[t],{point:s}=i;s.y+=-e,t<this.keyframes.length-1&&(this.hermiteArgs[t].d+=-e)}return!0}moveKeys(e,t){return e.find(e=>!this.grid.checkPointInRange(e.point))?(console.debug("move keys outRange"),!1):(e.forEach(e=>{e.point.x+=t.x,e.point.y+=t.y}),this.keyframes.sort((e,t)=>e.point.x-t.point.x),!0)}moveKey(e,t,i){const s={x:e,y:t};this.grid.checkPointInRange(s)||console.debug("move key outRange");const r=JSON.parse(JSON.stringify(this.keyframes[i])),n=this.grid.pixelToValue(s);if(n.x===r.point.x&&n.y===r.point.y)return-1;r.point=n;let a=this.keyframes[i+1],o=this.keyframes[i-1];return o&&n.x===o.point.x||a&&n.x===a.point.x?-1:a&&r.point.x>a.point.x?(this.keyframes.splice(i,1),this.keyframes.splice(i+1,0,r),i++,o=a,(a=this.keyframes[i+1])&&(a.outTangent=a.inTangent),i):o&&r.point.x<o.point.x?(this.keyframes.splice(i,1),this.keyframes.splice(i-1,0,r),i--,a=o,(o=this.keyframes[i-1])&&(o.inTangent=o.outTangent),i):(this.keyframes[i]=r,i)}updateTan(e,t,i){if(0===e&&"inTangent"===i||e===this.keyframes.length-1&&"outTangent"===i)return;this.keyframes[e][i]=t}addKeyFrame(e){var t;let i=this.calcKeyIndexFromX(e.x);const s={point:e};if(0===this.keyframes.length)return this.keyframes.push({point:e,inTangent:0,outTangent:0}),0;!i&&this.keyframes[this.keyframes.length-1].point.x<e.x&&(i=this.keyframes.length-1);let r="number"==typeof i?i+1:0,n=this.keyframes[r];if("number"==typeof i){const t=this.keyframes[i];s.inTangent=this.calcSlopeWithPoints(t.point,e),t.outTangent=t.outTangent||t.inTangent,this.hermiteArgs[i]=Hermite.calcArgs(t.point,t.outTangent,s.point,s.inTangent)}return this.keyframes.splice(r,0,s),n&&(s.outTangent=null!==(t=s.inTangent)&&void 0!==t?t:this.calcSlopeWithPoints(e,n.point),n.inTangent=n.inTangent||n.outTangent,this.hermiteArgs.splice(r,0,Hermite.calcArgs(s.point,s.outTangent,n.point,n.inTangent))),r}addKeyFrameInCurveAt(e){const t=this.calcKeyIndexFromX(e);if(null===t)return null;const i=this.hermiteArgs[t],s=this.calcSlopeInCurveAt(e,i),r=Hermite.getRenderFunc(i)(e);return this.hermiteArgs.splice(t+1,0,i),this.keyframes.splice(t+1,0,{point:{x:e,y:r},outTangent:s,inTangent:s}),t+1}delKeyFrame(e){const t=this.keyframes[e+1],i=this.keyframes[e-1];if(t&&i&&i.outTangent&&t.inTangent){const s=Hermite.calcArgs(i.point,i.outTangent,t.point,t.inTangent);this.hermiteArgs.splice(e-1,0,s)}else t&&this.hermiteArgs.splice(e,1),i&&this.hermiteArgs.splice(e-1,1);this.keyframes.splice(e,1)}clear(){this.ctx.clearRect(0,0,this.canvas.width,this.canvas.height)}getRenderFunc(e,t,i,s,r){const n=Hermite.calcHermitArgsMd5(e,t,i,s);return this.hermiteArgs[r]&&this.hermiteArgs[r].md5===n||(this.hermiteArgs[r]=Hermite.calcArgs(e,t,i,s)),Hermite.getRenderFunc(this.hermiteArgs[r])}calcSlopeWithPoints(e,t){return t.x-e.x==0?1/0:(t.y-e.y)/(t.x-e.x)}calcSlopeInCurveAt(e,t){const{a:i,b:s,c:r}=t;return 3*i*e*e+2*s*e+r}calcKeyIndexFromX(e){let t=null;for(let i=0;i<this.keyframes.length-1;i++){const s=this.keyframes[i].point,r=this.keyframes[i+1].point;if(e>s.x&&r.x>e){t=i;break}}return t}}exports.Hermite=Hermite;