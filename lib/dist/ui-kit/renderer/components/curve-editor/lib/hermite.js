"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.Hermite=void 0;const curve_base_1=require("./curve-base"),utils_1=require("./utils");class Hermite extends curve_base_1.CurveBase{constructor(t,e,n){super(t,e,n),this.hermiteArgs=[],this.config={strokeStyle:"red",lineWidth:1,strokeStyleAxu:"rgba(255, 0, 0, 0.3)",showKey:!0,preWrapMode:1,postWrapMode:1,wrapMode:1,sample:1},this.keyframes=[],this.config.sample=n.sample,this.curveCache=new Path2D}static calcArgs(t,e,n,i){if(e===Number.POSITIVE_INFINITY||i===Number.POSITIVE_INFINITY)return{a:0,b:0,c:0,d:t.y,md5:Hermite.calcHermitArgsMd5(t,e,n,i)};const s=t.x,a=t.y,r=n.x,o=n.y;let h,c,l,g,u,p,y;const x=[1,s,s*s,s*s*s,1,r,r*r,r*r*r,0,1,2*s,3*s*s,0,1,2*r,3*r*r],d=t=>t[0]*t[4]*t[8]+t[1]*t[5]*t[6]+t[2]*t[3]*t[7]-t[2]*t[4]*t[6]-t[1]*t[3]*t[8]-t[0]*t[5]*t[7];for(h=y=0;h<4;y+=d(p)*x[h]*(h%2?-1:1),h++)if(x[h])for(c=4,p=[];c<x.length;c++)c%4!==h&&p.push(x[c]);for(u=[],h=0;h<4;h++)for(c=0;c<4;u[h+4*c]=((h+c)%2?-1:1)*d(p)/y,c++)for(p=[],l=0;l<3;l++)for(g=0;g<3;g++)p.push(x[(h+l+1)%4*4+(c+g+1)%4]);const f=a*u[0]+o*u[1]+e*u[2]+i*u[3],T=a*u[4]+o*u[5]+e*u[6]+i*u[7],m=a*u[8]+o*u[9]+e*u[10]+i*u[11];return{a:a*u[12]+o*u[13]+e*u[14]+i*u[15],b:m,c:T,d:f,md5:Hermite.calcHermitArgsMd5(t,e,n,i)}}static getRenderFunc(t){const{a:e,b:n,c:i,d:s}=t;return t=>e*t*t*t+n*t*t+i*t+s}static quickPaint(t,e,n){if(0===t.length||!e)return console.error("paint hermit need keyframes and canvas!"),!1;const i=e.width,s=n?e.height/2:e.height,a=e.getContext("2d"),r=s/i;function o(t){return{x:t.x*i,y:s-t.y*s}}const h=t.map(t=>{const e="number"==typeof t.outTangent?t.outTangent*r:1/0,n="number"==typeof t.inTangent?t.inTangent*r:1/0;return Object.assign(Object.assign({},t),{canvas:o(t.point),outTangent:e,inTangent:n})});a.clearRect(0,0,i,e.height),n&&(a.save(),a.strokeStyle="#d9dde8",a.lineWidth=.5,a.beginPath(),a.moveTo(0,s),a.lineTo(i,s),a.stroke(),a.closePath(),a.restore()),a.beginPath(),a.strokeStyle="red",a.moveTo(h[0].canvas.x,h[0].canvas.y);for(let t=0;t<h.length-1;t++){const e=h[t+1],n=h[t];switch(n.interpMode){case 1:a.lineTo(e.canvas.x,n.canvas.y),a.lineTo(e.canvas.x,e.canvas.y);break;case 0:case 2:{if(0===n.interpMode&&(1===e.interpMode||e.inTangent===Number.NEGATIVE_INFINITY)){a.lineTo(e.canvas.x,n.canvas.y),a.lineTo(e.canvas.x,e.canvas.y);break}if(0===n.interpMode&&0===e.interpMode||0===n.outTangent&&0===e.inTangent&&n.canvas.y===e.canvas.y){a.moveTo(n.canvas.x,n.canvas.y),a.lineTo(e.canvas.x,e.canvas.y);break}patchCtrlPoint(n,1,void 0,e),patchCtrlPoint(e,1,n);const t=o(n.outCtrlPoint),i=o(e.inCtrlPoint),s=o(e.point);a.bezierCurveTo(t.x,t.y,i.x,i.y,s.x,s.y)}}n.outTangent!==Number.POSITIVE_INFINITY&&e.inTangent!==Number.POSITIVE_INFINITY||(a.lineTo(e.point.x,s-e.point.y),a.stroke()),a.stroke()}return a.closePath(),!0}static calcHermitArgsMd5(t,e,n,i){return JSON.stringify({p1:t,k1:e,p2:n,k2:i})}translate(t,e){}isPointInCurve(t,e=3){if(!this.curveCache||!this.keyframes.length)return!1;this.ctx.save(),this.ctx.lineWidth=e;const n=this.ctx.isPointInStroke(this.curveCache,t.x,t.y);return this.ctx.restore(),n}findPointInKeys(t,e=3){return this.keyframes.length?this.keyframes.findIndex(n=>{const{x:i,y:s}=n.canvas;return Math.abs(t.x-i)<e&&Math.abs(t.y-s)<e}):-1}findCurveClipInKeys(t){if(!this.curveCache||!this.keyframes.length)return null;for(let e=0;e<this.keyframes.length;e++){const n=this.keyframes[e],i=this.keyframes[e+1];if(!i)break;if(t.x>n.canvas.x&&t.x<i.canvas.x)return{start:e,end:e+1,curveName:""}}return null}paint(t,e){if(e&&Object.assign(this.config,e),this.clear(),this.preCurveCache=null,this.postCurveCache=null,this.curveCache=void 0,this.hermiteArgs=[],t&&t.length){try{this.keyframes=t.map((e,n)=>{const i=this.transformKey(e);return this.patchCtrlPoint(i,t[n-1],t[n+1]),i}),this.checkCurveTangent()}catch(t){return void console.error(t)}this.curveCache=this.paintRect(),this.paintInWrapMode()}else this.keyframes=[]}transformKey(t){var e;return Object.assign(Object.assign({},t),{broken:null!==(e=t.broken)&&void 0!==e?e:t.inTangent!==t.outTangent,canvas:this.grid.valueToPixel(t.point)})}rePaint(){this.clear(),this.curveCache=this.paintRect(),this.paintInWrapMode()}paintWithCache(t){this.curveCache&&t.stroke(this.curveCache)}paintKeyFrame(t){this.ctx.save(),this.ctx.fillStyle="gold",this.ctx.beginPath(),this.ctx.arc(t.x,t.y,1,0,2*Math.PI),this.ctx.closePath(),this.ctx.stroke(),this.ctx.fill(),this.ctx.restore()}paintRect(t){if(!this.keyframes.length)return null;const e=t&&t.end||this.keyframes.length-1,n=t&&t.start||0,i=new Path2D;for(let t=n;t<e;t++){const e=this.keyframes[t+1],s=this.keyframes[t],a=s.canvas;switch(t===n&&i.moveTo(a.x,a.y),"number"!=typeof s.interpMode&&(s.interpMode=0),s.interpMode){case 1:i.moveTo(a.x,a.y),i.lineTo(e.canvas.x,a.y),i.lineTo(e.canvas.x,e.canvas.y);break;case 0:i.moveTo(a.x,a.y),i.lineTo(e.canvas.x,e.canvas.y);break;case 2:{s.outCtrlPoint||this.patchCtrlPoint(s,void 0,e),e.inCtrlPoint||this.patchCtrlPoint(e,s);const t=this.grid.valueToPixel(s.outCtrlPoint),n=this.grid.valueToPixel(e.inCtrlPoint),a=this.grid.valueToPixel(e.point);i.bezierCurveTo(t.x,t.y,n.x,n.y,a.x,a.y)}}this.paintKeyFrame(a)}const s=t&&t.ctx||this.ctx;return this.ctx.strokeStyle=this.config.strokeStyle,s.stroke(i),i}paintInWrapMode(){if(!this.keyframes.length)return;if(this.ctx.save(),this.ctx.strokeStyle=this.config.strokeStyleAxu,1===this.keyframes.length){this.curveCache=null;const t=new Path2D;return t.moveTo(0,this.keyframes[0].canvas.y),t.lineTo(this.canvas.width,this.keyframes[0].canvas.y),this.ctx.stroke(t),void this.ctx.restore()}let t=this.config.duration?this.grid.valueToPixelX(this.config.duration):this.canvas.width;const e=this.keyframes[this.keyframes.length-1].canvas.x;t=Math.max(e,t);const n=this.paintPostWrapMode(t),i=this.paintPreWrapMode();this.paintMainCurveWrapMode(i,n),this.ctx.restore()}paintPreWrapMode(){const t=this.grid.valueToPixel(this.keyframes[0].point);if("number"!=typeof this.config.preWrapMode)return this.preCurveCache=null,t;const e=this.grid.valueToPixel(this.keyframes[this.keyframes.length-1].point);this.ctx.clearRect(0,0,t.x,this.canvas.height);const n={x:this.grid.valueToPixelX(0),y:t.y};if(t.x===n.x)return this.preCurveCache=null,n;const i=e.x-t.x;if(0===i)return console.debug("The key frame distance is 0"),n;this.ctx.clearRect(0,0,t.x+1,this.canvas.height);const s=Math.ceil(t.x/i),a=new Path2D;switch(a.moveTo(n.x,n.y),this.config.preWrapMode){case 1:a.lineTo(t.x,t.y);break;case 2:{const r=utils_1.createMatrix();for(let n=0;n<s;n++)a.moveTo(t.x-i*n,t.y),r.translateSelf(-i,0),a.lineTo(t.x-i*n,e.y),a.addPath(this.curveCache,r);const o=this.grid.valueToPixelX(t.x-s*i);n.y=this.calcValueFromX(o);break}case 3:{const r=new Path2D,o=utils_1.createMatrix();r.addPath(this.curveCache,o.scaleSelf(-1,1));let h=utils_1.createMatrix();for(let e=0;e<=s;e++)h=h.translateSelf(-i,0),e%2==0?a.addPath(r,utils_1.createMatrix().translateSelf(2*t.x-i*e)):a.addPath(this.curveCache,h);let c=this.grid.valueToPixelX(t.x-s*i);s%2!=0&&(c=e.x-t.x-c),n.y=this.calcValueFromX(c);break}}return this.preCurveCache=a,t.x<0?n:(this.ctx.strokeStyle=this.config.strokeStyleAxu,this.ctx.stroke(a),n)}paintPostWrapMode(t){const e=this.grid.valueToPixel(this.keyframes[this.keyframes.length-1].point);if("number"!=typeof this.config.postWrapMode)return this.postCurveCache=null,e;if(t=t||this.canvas.width,this.ctx.clearRect(e.x,0,t-e.x+1,this.canvas.height),t===e.x||t<e.x)return e;const n=this.grid.valueToPixel(this.keyframes[0].point),i=e.x-n.x,s=Math.ceil((t-e.x)/i),a=new Path2D;a.moveTo(e.x,e.y);const r={x:t,y:e.y};switch(this.config.postWrapMode){case 1:a.lineTo(r.x,r.y);break;case 2:{const o=utils_1.createMatrix();for(let t=0;t<=s;t++)o.translateSelf(i,0),a.lineTo(e.x+i*t,n.y),a.addPath(this.curveCache,o);const h=this.grid.pixelToValueX(t-e.x-i*(s-1));r.y=this.calcValueFromX(h);break}case 3:{const o=new Path2D,h=utils_1.createMatrix();o.addPath(this.curveCache,h.scaleSelf(-1,1));let c=utils_1.createMatrix();for(let t=0;t<=s;t++)c=c.translateSelf(i,0),t%2==0?a.addPath(o,utils_1.createMatrix().translateSelf(2*e.x+i*t)):a.addPath(this.curveCache,c);let l=this.grid.pixelToValueX(t-e.x-i*(s-1));s%2==0&&(l=e.x-n.x-l),r.y=this.calcValueFromX(l);break}}return this.postCurveCache=a,this.ctx.strokeStyle=this.config.strokeStyleAxu,this.ctx.stroke(a),r}checkCurveTangent(){this.keyframes.forEach((t,e)=>{if(0===t.interpMode){const n=this.keyframes[e-1],i=this.keyframes[e+1];n&&(t.inTangent=(t.point.y-n.point.y)/(t.point.x-n.point.x)),i&&(t.outTangent=(i.point.y-t.point.y)/(i.point.x-t.point.x)),this.patchCtrlPoint(t,n,i)}})}checkAllKeyCtrl(){this.keyframes.forEach((t,e)=>{const n=this.keyframes[e-1],i=this.keyframes[e+1];0===t.interpMode&&(n&&(t.inTangent=(t.point.y-n.point.y)/(t.point.x-n.point.x)),i&&(t.outTangent=(i.point.y-t.point.y)/(i.point.x-t.point.x))),this.patchCtrlPoint(t,n,i)})}paintMainCurveWrapMode(t,e){if("number"!=typeof this.config.wrapMode)return;const n=new Path2D;this.preCurveCache&&n.addPath(this.preCurveCache),n.addPath(this.curveCache),this.postCurveCache&&n.addPath(this.postCurveCache);const i=e.x-t.x,s=Math.ceil((this.canvas.width-e.x)/i);if(0===s)return;const a=new Path2D;switch(a.moveTo(e.x,e.y),this.config.wrapMode){case 1:a.lineTo(this.canvas.width,e.y);break;case 2:{const r=utils_1.createMatrix();for(let o=0;o<=s;o++)a.moveTo(e.x+i*o,e.y),r.translateSelf(i,0),a.lineTo(e.x+i*o,t.y),a.addPath(n,r);break}case 22:{const t=new Path2D,r=utils_1.createMatrix();t.addPath(n,r.scaleSelf(-1,1));let o=utils_1.createMatrix();for(let r=0;r<=s;r++)o=o.translateSelf(i,0),r%2==0?a.addPath(t,utils_1.createMatrix().translateSelf(2*e.x+i*r)):a.addPath(n,o);break}}this.ctx.strokeStyle=this.config.strokeStyleAxu,this.ctx.stroke(a)}moveAllY(t){if(0===t)return!1;const e=[];return this.keyframes.find(n=>{const i={x:n.canvas.x,y:n.canvas.y+t},s=this.grid.patchPointInRange(i);return s?e.push({canvas:this.grid.valueToPixel(s),point:s}):e.push({canvas:i,point:this.grid.pixelToValue(i)}),s})?(console.debug("move keys outRange"),!1):(this.keyframes.forEach((t,n)=>{Object.assign(t,e[n])}),this.keyframes.sort((t,e)=>t.point.x-e.point.x),this.checkAllKeyCtrl(),!0)}moveKeys(t,e){return t.find(t=>{const n={x:t.canvas.x+e.x,y:t.canvas.y+e.y},i=this.grid.patchPointInRange(n);return i?(t.canvas=this.grid.valueToPixel(i),t.point=i):(t.canvas=n,t.point=this.grid.pixelToValue(n)),i})&&console.debug("move keys outRange"),this.keyframes.sort((t,e)=>t.point.x-e.point.x),this.checkAllKeyCtrl(),!0}scaleKeys(t,e){const{changeValue:n,base:i,scale:s}=e;t.forEach(t=>{const e=t.canvas[n]-i;t.canvas[n]=i+e*s,t.point=this.grid.pixelToValue(t.canvas)}),this.checkAllKeyCtrl()}spacingKeys(t,e){for(let n=1;n<t.length;n++){const i=t[n];i.point.x=t[n-1].point.x+e,i.canvas=this.grid.valueToPixel(i.point)}return this.keyframes.sort((t,e)=>t.point.x-e.point.x),this.checkAllKeyCtrl(),!0}moveKey(t,e,n){let i=this.grid.patchPointInRange({x:t,y:e}),s={x:t,y:e};return i?(console.debug("move key outRange"),s=this.grid.valueToPixel(i)):i=this.grid.pixelToValue(s),this.editKey(n,i,s)}editKey(t,e,n){const i=require("lodash").cloneDeep(this.keyframes[t]);if(!i)return-1;let s=this.keyframes[t+1],a=this.keyframes[t-1];return a&&e.x===a.point.x||s&&e.x===s.point.x?-1:(i.point=e,i.canvas=n||this.grid.valueToPixel(e),s&&i.point.x>s.point.x?(this.keyframes.splice(t,1),this.keyframes.splice(t+1,0,i),t++,a=s,(s=this.keyframes[t+1])&&(s.outTangent=s.inTangent),t):a&&i.point.x<a.point.x?(this.keyframes.splice(t,1),this.keyframes.splice(t-1,0,i),t--,s=a,(a=this.keyframes[t-1])&&(a.inTangent=a.outTangent),t):(this.keyframes[t]=i,this.checkCurveTangent(),this.patchCtrlPoint(i,a,s),t))}applyBezierToCurveClip(t,e,n){const i=this.keyframes[t],s=this.keyframes[e];if(!i||!s)return!1;const a=s.point.x-i.point.x,r=Math.abs(s.point.y-i.point.y);i.interpMode=2,i.broken=!0,this.ensureTangentMode(i,curve_base_1.TangentWeightMode.RIGHT),s.interpMode=2,s.broken=!0,this.ensureTangentMode(s,curve_base_1.TangentWeightMode.LEFT),s.point.y<i.point.y&&((n=JSON.parse(JSON.stringify(n)))[1]=-n[1],n[3]=-n[3]),i.outCtrlPoint={x:i.point.x+a*n[0],y:i.point.y+r*n[1]},s.inCtrlPoint={x:i.point.x+a*n[2],y:i.point.y+r*n[3]};const o=(i.outCtrlPoint.y-i.point.y)/((i.outCtrlPoint.x-i.point.x)/this.config.sample),h=(s.inCtrlPoint.y-s.point.y)/((s.inCtrlPoint.x-s.point.x)/this.config.sample);return this.updateTangentWeight(t,i.outCtrlPoint,o,"outTangent"),this.updateTangentWeight(e,s.inCtrlPoint,h,"inTangent"),!0}updateTan(t,e,n){const i=this.keyframes[t];i[n]=e;let s=n;i.broken||(s="both"),"inTangent"!==s&&"number"==typeof i.outTangent&&(i.outTangent=e),"outTangent"!==s&&"number"==typeof i.inTangent&&(i.inTangent=e),this.patchCtrlPoint(i,this.keyframes[t-1],this.keyframes[t+1])}updateTangentWeight(t,e,n,i){const s=this.keyframes[t];this.updateTan(t,n,i);const a=Math.atan(n);return"inTangent"===i?(s.inCtrlPoint=e,s.inTangentWeight=(s.point.x-e.x)/this.config.sample/Math.cos(a)):(s.outCtrlPoint=e,s.outTangentWeight=(e.x-s.point.x)/this.config.sample/Math.cos(a)),this.patchCtrlPoint(s,this.keyframes[t-1],this.keyframes[t+1]),!0}changeInterpMode(t,e){const n=this.keyframes[t];if(n.interpMode!==e){switch(n.interpMode=e,e){case 1:n.inTangent=0,n.outTangent=0;break;case 0:{const e=this.keyframes[t-1],i=this.keyframes[t+1];e&&(n.inTangent=(n.point.y-e.point.y)/(n.point.x-e.point.x)),i&&(n.outTangent=(i.point.y-n.point.y)/(i.point.x-n.point.x)),e||(n.inTangent=n.outTangent),i||(n.outTangent=n.inTangent)}break;case 2:n.inTangent&&(n.inTangent=0),n.outTangent&&(n.outTangent=0)}this.patchCtrlPoint(n,this.keyframes[t-1],this.keyframes[t+1])}}changeTangentWeight(t,e){const n=this.keyframes[t];if(![curve_base_1.TangentWeightMode.NONE,curve_base_1.TangentWeightMode.RIGHT].includes(e)&&[curve_base_1.TangentWeightMode.RIGHT,curve_base_1.TangentWeightMode.NONE].includes(n.tangentWeightMode)){const e=this.keyframes[t+1];this.patchTangentWeight(n,void 0,e)}if(![curve_base_1.TangentWeightMode.NONE,curve_base_1.TangentWeightMode.LEFT].includes(e)&&[curve_base_1.TangentWeightMode.LEFT,curve_base_1.TangentWeightMode.NONE].includes(n.tangentWeightMode)){const e=this.keyframes[t-1];this.patchTangentWeight(n,e)}n.tangentWeightMode=e,this.patchCtrlPoint(n,this.keyframes[t-1],this.keyframes[t+1])}patchTangentWeight(t,e,n){if(e){const n=Math.atan(t.outTangent),i=t.point.x-e.point.x;t.inTangentWeight=1/3*i/Math.cos(n)/this.config.sample}if(n){const e=Math.atan(t.outTangent),i=n.point.x-t.point.x;t.outTangentWeight=1/3*i/Math.cos(e)/this.config.sample}}pasteKeys(t,e,n){const i=this.calcKeyIndexFromX(e),s=t[0].point.x,a=t[0].point.y,r=t.map((t,i)=>{t.point.x=t.point.x-s+e,n&&(t.point.y=t.point.y-a+n);const r=this.keyframes.findIndex(e=>this.grid.xFormat(e.point.x)===this.grid.xFormat(t.point.x));return-1!==r&&this.keyframes.splice(r,1),this.transformKey(t)});return-1===i?this.keyframes.push(...r):this.keyframes.splice(i,0,...r),this.keyframes.sort((t,e)=>t.point.x-e.point.x),this.checkAllKeyCtrl(),r}createNewKey(t){let e=this.calcKeyIndexFromX(t.x);const n={point:t,canvas:this.grid.valueToPixel(t),interpMode:2,tangentWeightMode:curve_base_1.TangentWeightMode.NONE,inTangent:0,outTangent:0};if(0===this.keyframes.length)return this.keyframes.push(n),0;!e&&this.keyframes[this.keyframes.length-1].point.x<t.x&&(e=this.keyframes.length-1);const i="number"==typeof e?e+1:0;return this.keyframes.splice(i,0,n),this.patchCtrlPoint(n,this.keyframes[i-1],this.keyframes[i+1]),i}createKeyInCurveAt(t){const e=this.calcKeyIndexFromX(t);if(-1===e)return null;const n=this.keyframes[e],i=this.keyframes[e+1],s={outTangent:0,inTangent:0,interpMode:n.interpMode,tangentWeightMode:curve_base_1.TangentWeightMode.NONE,outTangentWeight:1,inTangentWeight:1};let a;switch(n.interpMode){case 1:a=Object.assign(s,{point:{x:t,y:n.point.y},canvas:this.grid.valueToPixel({x:t,y:n.point.y})});break;case 0:{const e={x:t,y:n.point.y+t*n.outTangent};a=Object.assign(s,{point:e,canvas:this.grid.valueToPixel(e)})}break;case 2:return a=this.spliteCurveAt(t,n,i),this.keyframes.splice(e+1,0,a),e+1}return this.keyframes.splice(e+1,0,a),this.checkCurveTangent(),this.patchCtrlPoint(a,this.keyframes[e],this.keyframes[e+2]),e+1}spliteCurveAt(t,e,n){const i=n.point.x-e.point.x,s=(t-e.point.x)/i,a=this.calcAssistPoint(e.point,e.outCtrlPoint,s),r=this.calcAssistPoint(e.outCtrlPoint,n.inCtrlPoint,s),o=this.calcAssistPoint(n.inCtrlPoint,n.point,s),h=this.calcAssistPoint(a,r,s),c=this.calcAssistPoint(r,o,s),l=this.calcAssistPoint(h,c,s),g={inCtrlPoint:h,outCtrlPoint:c,point:l,canvas:this.grid.valueToPixel(l),interpMode:2,inTangent:this.calcSlopeWithPoints(h,l),outTangent:this.calcSlopeWithPoints(l,c),tangentWeightMode:curve_base_1.TangentWeightMode.BOTH,inTangentWeight:1,outTangentWeight:1};return e.outCtrlPoint=a,n.inCtrlPoint=o,this.patchTangentWeight(g,e,n),[curve_base_1.TangentWeightMode.RIGHT,curve_base_1.TangentWeightMode.BOTH].includes(e.tangentWeightMode)&&this.patchTangentWeight(e,void 0,g),[curve_base_1.TangentWeightMode.LEFT,curve_base_1.TangentWeightMode.BOTH].includes(n.tangentWeightMode)&&this.patchTangentWeight(n,g),g}calcAssistPoint(t,e,n){return{x:t.x*(1-n)+e.x*n,y:t.y*(1-n)+e.y*n}}calcValueFromX(t){const e=this.calcKeyIndexFromX(t);if(-1===e)return null;const n=this.keyframes[e],i=this.keyframes[e+1],s=this.getArgs(n.point,n.outTangent,i.point,i.inTangent,e);return Hermite.getRenderFunc(s)(t)}delKeyFrame(t){this.keyframes.splice(t,1),this.checkCurveTangent(),this.patchCtrlPoint(this.keyframes[t-1],void 0,this.keyframes[t+1]),this.keyframes[t]&&this.patchCtrlPoint(this.keyframes[t],this.keyframes[t-1],void 0)}clear(){this.ctx.clearRect(0,0,this.canvas.width,this.canvas.height)}ensureTangentMode(t,e){t.tangentWeightMode!==e&&([curve_base_1.TangentWeightMode.BOTH,curve_base_1.TangentWeightMode.NONE].includes(e)?t.tangentWeightMode=e:t.tangentWeightMode!==curve_base_1.TangentWeightMode.NONE?t.tangentWeightMode=curve_base_1.TangentWeightMode.BOTH:t.tangentWeightMode=e)}getArgs(t,e,n,i,s){const a=Hermite.calcHermitArgsMd5(t,e,n,i);return this.hermiteArgs[s]&&this.hermiteArgs[s].md5===a||(this.hermiteArgs[s]=Hermite.calcArgs(t,e,n,i)),this.hermiteArgs[s]}calcSlopeWithPoints(t,e){return e.x-t.x==0?1/0:(e.y-t.y)/(e.x-t.x)}calcSlopeInCurveAt(t,e){const{a:n,b:i,c:s}=e;return 3*n*t*t+2*i*t+s}calcKeyIndexFromX(t){let e=-1;for(let n=0;n<this.keyframes.length-1;n++){const i=this.keyframes[n].point,s=this.keyframes[n+1].point;if(t>i.x&&s.x>t){e=n;break}}return-1===e&&this.keyframes.length&&t>this.keyframes[this.keyframes.length-1].point.x&&(e=this.keyframes.length-1),e}patchCtrlPoint(t,e,n){patchCtrlPoint(t,this.config.sample,e,n)}}function patchCtrlPoint(t,e,n,i){if(t){if(i)if([curve_base_1.TangentWeightMode.BOTH,curve_base_1.TangentWeightMode.RIGHT].includes(t.tangentWeightMode)&&t.outTangentWeight){const n=Math.atan(t.outTangent);t.outCtrlPoint={x:t.point.x+t.outTangentWeight*Math.cos(n)*e,y:t.point.y+t.outTangentWeight*Math.sin(n)}}else{const n=i.point.x-t.point.x;t.outCtrlPoint={x:t.point.x+1/3*n,y:t.point.y+1/3*t.outTangent*n/e}}if(n)if([curve_base_1.TangentWeightMode.BOTH,curve_base_1.TangentWeightMode.LEFT].includes(t.tangentWeightMode)&&t.inTangentWeight){const n=Math.atan(t.inTangent);t.inCtrlPoint={x:t.point.x-t.inTangentWeight*Math.cos(n)*e,y:t.point.y-t.inTangentWeight*Math.sin(n)}}else{const i=t.point.x-n.point.x;t.inCtrlPoint={x:t.point.x-1/3*i,y:t.point.y-1/3*t.inTangent*i/e}}}else console.debug("patchCtrlPoint no target")}exports.Hermite=Hermite;