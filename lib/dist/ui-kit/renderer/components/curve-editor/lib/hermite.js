"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.Hermite=void 0;const curve_base_1=require("./curve-base"),utils_1=require("./utils");class Hermite extends curve_base_1.CurveBase{constructor(t,e,i){super(t,e,i),this.hermiteArgs=[],this.config={strokeStyle:"red",lineWidth:1,strokeStyleAxu:"rgba(255, 0, 0, 0.3)",showKey:!0,preWrapMode:1,postWrapMode:1,wrapMode:1,sample:1},this.keyframes=[],this.config.sample=i.sample,this.curveCache=new Path2D}static calcArgs(t,e,i,n){if(e===Number.POSITIVE_INFINITY||n===Number.POSITIVE_INFINITY)return{a:0,b:0,c:0,d:t.y,md5:Hermite.calcHermitArgsMd5(t,e,i,n)};const s=t.x,a=t.y,r=i.x,o=i.y;let h,c,l,g,u,p,y;const x=[1,s,s*s,s*s*s,1,r,r*r,r*r*r,0,1,2*s,3*s*s,0,1,2*r,3*r*r],d=t=>t[0]*t[4]*t[8]+t[1]*t[5]*t[6]+t[2]*t[3]*t[7]-t[2]*t[4]*t[6]-t[1]*t[3]*t[8]-t[0]*t[5]*t[7];for(h=y=0;h<4;y+=d(p)*x[h]*(h%2?-1:1),h++)if(x[h])for(c=4,p=[];c<x.length;c++)c%4!==h&&p.push(x[c]);for(u=[],h=0;h<4;h++)for(c=0;c<4;u[h+4*c]=((h+c)%2?-1:1)*d(p)/y,c++)for(p=[],l=0;l<3;l++)for(g=0;g<3;g++)p.push(x[(h+l+1)%4*4+(c+g+1)%4]);const f=a*u[0]+o*u[1]+e*u[2]+n*u[3],T=a*u[4]+o*u[5]+e*u[6]+n*u[7],m=a*u[8]+o*u[9]+e*u[10]+n*u[11];return{a:a*u[12]+o*u[13]+e*u[14]+n*u[15],b:m,c:T,d:f,md5:Hermite.calcHermitArgsMd5(t,e,i,n)}}static getRenderFunc(t){const{a:e,b:i,c:n,d:s}=t;return t=>e*t*t*t+i*t*t+n*t+s}static quickPaint(t,e,i){if(0===t.length||!e)return console.error("paint hermit need keyframes and canvas!"),!1;const n=e.width,s=i?e.height/2:e.height,a=e.getContext("2d"),r=s/n;function o(t){return{x:t.x*n,y:s-t.y*s}}const h=t.map(t=>{const e="number"==typeof t.outTangent?t.outTangent*r:1/0,i="number"==typeof t.inTangent?t.inTangent*r:1/0;return Object.assign(Object.assign({},t),{canvas:o(t.point),outTangent:e,inTangent:i})});a.clearRect(0,0,n,e.height),i&&(a.save(),a.strokeStyle="#333",a.lineWidth=.5,a.beginPath(),a.moveTo(0,s),a.lineTo(n,s),a.stroke(),a.closePath(),a.restore()),a.beginPath(),a.strokeStyle="red",a.moveTo(h[0].canvas.x,h[0].canvas.y);for(let t=0;t<h.length-1;t++){const e=h[t+1],i=h[t];switch(i.interpMode){case 1:a.lineTo(e.canvas.x,i.canvas.y),a.lineTo(e.canvas.x,e.canvas.y);break;case 0:case 2:{if(0===i.interpMode&&(1===e.interpMode||e.inTangent===Number.NEGATIVE_INFINITY)){a.lineTo(e.canvas.x,i.canvas.y),a.lineTo(e.canvas.x,e.canvas.y);break}if(0===i.interpMode&&0===e.interpMode||0===i.outTangent&&0===e.inTangent&&i.canvas.y===e.canvas.y){a.moveTo(i.canvas.x,i.canvas.y),a.lineTo(e.canvas.x,e.canvas.y);break}patchCtrlPoint(i,1,void 0,e),patchCtrlPoint(e,1,i);const t=o(i.outCtrlPoint),n=o(e.inCtrlPoint),s=o(e.point);a.bezierCurveTo(t.x,t.y,n.x,n.y,s.x,s.y)}}i.outTangent!==Number.POSITIVE_INFINITY&&e.inTangent!==Number.POSITIVE_INFINITY||(a.lineTo(e.point.x,s-e.point.y),a.stroke()),a.stroke()}return a.closePath(),!0}static calcHermitArgsMd5(t,e,i,n){return JSON.stringify({p1:t,k1:e,p2:i,k2:n})}translate(t,e){}isPointInCurve(t,e=3){if(!this.curveCache||!this.keyframes.length)return!1;this.ctx.save(),this.ctx.lineWidth=e;const i=this.ctx.isPointInStroke(this.curveCache,t.x,t.y);return this.ctx.restore(),i}checkPointInKeys(t,e=3){return this.curveCache&&this.keyframes.length?this.keyframes.findIndex(i=>{const{x:n,y:s}=i.canvas;return Math.abs(t.x-n)<e&&Math.abs(t.y-s)<e}):-1}paint(t,e){if(e&&Object.assign(this.config,e),this.clear(),this.preCurveCache=null,this.postCurveCache=null,this.curveCache=void 0,this.hermiteArgs=[],t&&t.length){try{this.keyframes=t.map((e,i)=>{const n=this.transformKey(e);return this.patchCtrlPoint(n,t[i-1],t[i+1]),n}),this.checkCurveTangent()}catch(t){return void console.error(t)}this.paintRect(),this.paintInWrapMode()}else this.keyframes=[]}transformKey(t){return Object.assign(Object.assign({},t),{canvas:this.grid.valueToPixel(t.point)})}rePaint(){this.clear(),this.paintRect(),this.paintInWrapMode()}paintWithCache(t){this.curveCache&&t.stroke(this.curveCache)}paintKeyFrame(t){this.ctx.save(),this.ctx.fillStyle="gold",this.ctx.beginPath(),this.ctx.arc(t.x,t.y,1,0,2*Math.PI),this.ctx.closePath(),this.ctx.stroke(),this.ctx.fill(),this.ctx.restore()}paintRect(t){if(!this.keyframes.length)return;const e=this.keyframes.length-1,i=new Path2D;for(let t=0;t<e;t++){const e=this.keyframes[t+1],n=this.keyframes[t],s=n.canvas;switch(0===t&&i.moveTo(s.x,s.y),"number"!=typeof n.interpMode&&(n.interpMode=0),n.interpMode){case 1:i.moveTo(s.x,s.y),i.lineTo(e.canvas.x,s.y),i.lineTo(e.canvas.x,e.canvas.y);break;case 0:i.moveTo(s.x,s.y),i.lineTo(e.canvas.x,e.canvas.y);break;case 2:{n.outCtrlPoint||this.patchCtrlPoint(n,void 0,e),e.inCtrlPoint||this.patchCtrlPoint(e,n);const t=this.grid.valueToPixel(n.outCtrlPoint),s=this.grid.valueToPixel(e.inCtrlPoint),a=this.grid.valueToPixel(e.point);i.bezierCurveTo(t.x,t.y,s.x,s.y,a.x,a.y)}}this.paintKeyFrame(s)}this.ctx.strokeStyle=this.config.strokeStyle,this.ctx.stroke(i),this.curveCache=i}paintInWrapMode(){if(!this.keyframes.length)return;if(this.ctx.save(),this.ctx.strokeStyle=this.config.strokeStyleAxu,1===this.keyframes.length){this.curveCache=null;const t=new Path2D;return t.moveTo(0,this.keyframes[0].canvas.y),t.lineTo(this.canvas.width,this.keyframes[0].canvas.y),this.ctx.stroke(t),void this.ctx.restore()}let t=this.config.duration?this.grid.valueToPixelX(this.config.duration):this.canvas.width;const e=this.keyframes[this.keyframes.length-1].canvas.x;t=Math.max(e,t);const i=this.paintPostWrapMode(t),n=this.paintPreWrapMode();this.paintMainCurveWrapMode(n,i),this.ctx.restore()}paintPreWrapMode(){const t=this.grid.valueToPixel(this.keyframes[0].point);if("number"!=typeof this.config.preWrapMode)return this.preCurveCache=null,t;const e=this.grid.valueToPixel(this.keyframes[this.keyframes.length-1].point);this.ctx.clearRect(0,0,t.x,this.canvas.height);const i={x:this.grid.valueToPixelX(0),y:t.y};if(t.x===i.x)return this.preCurveCache=null,i;const n=e.x-t.x;if(0===n)return console.debug("The key frame distance is 0"),i;this.ctx.clearRect(0,0,t.x+1,this.canvas.height);const s=Math.ceil(t.x/n),a=new Path2D;switch(a.moveTo(i.x,i.y),this.config.preWrapMode){case 1:a.lineTo(t.x,t.y);break;case 2:{const r=utils_1.createMatrix();for(let i=0;i<s;i++)a.moveTo(t.x-n*i,t.y),r.translateSelf(-n,0),a.lineTo(t.x-n*i,e.y),a.addPath(this.curveCache,r);const o=this.grid.valueToPixelX(t.x-s*n);i.y=this.calcValueFromX(o);break}case 3:{const r=new Path2D,o=utils_1.createMatrix();r.addPath(this.curveCache,o.scaleSelf(-1,1));let h=utils_1.createMatrix();for(let e=0;e<=s;e++)h=h.translateSelf(-n,0),e%2==0?a.addPath(r,utils_1.createMatrix().translateSelf(2*t.x-n*e)):a.addPath(this.curveCache,h);let c=this.grid.valueToPixelX(t.x-s*n);s%2!=0&&(c=e.x-t.x-c),i.y=this.calcValueFromX(c);break}}return this.preCurveCache=a,t.x<0?i:(this.ctx.strokeStyle=this.config.strokeStyleAxu,this.ctx.stroke(a),i)}paintPostWrapMode(t){const e=this.grid.valueToPixel(this.keyframes[this.keyframes.length-1].point);if("number"!=typeof this.config.postWrapMode)return this.postCurveCache=null,e;if(t=t||this.canvas.width,this.ctx.clearRect(e.x,0,t-e.x+1,this.canvas.height),t===e.x||t<e.x)return e;const i=this.grid.valueToPixel(this.keyframes[0].point),n=e.x-i.x,s=Math.ceil((t-e.x)/n),a=new Path2D;a.moveTo(e.x,e.y);const r={x:t,y:e.y};switch(this.config.postWrapMode){case 1:a.lineTo(r.x,r.y);break;case 2:{const o=utils_1.createMatrix();for(let t=0;t<=s;t++)o.translateSelf(n,0),a.lineTo(e.x+n*t,i.y),a.addPath(this.curveCache,o);const h=this.grid.pixelToValueX(t-e.x-n*(s-1));r.y=this.calcValueFromX(h);break}case 3:{const o=new Path2D,h=utils_1.createMatrix();o.addPath(this.curveCache,h.scaleSelf(-1,1));let c=utils_1.createMatrix();for(let t=0;t<=s;t++)c=c.translateSelf(n,0),t%2==0?a.addPath(o,utils_1.createMatrix().translateSelf(2*e.x+n*t)):a.addPath(this.curveCache,c);let l=this.grid.pixelToValueX(t-e.x-n*(s-1));s%2==0&&(l=e.x-i.x-l),r.y=this.calcValueFromX(l);break}}return this.postCurveCache=a,this.ctx.strokeStyle=this.config.strokeStyleAxu,this.ctx.stroke(a),r}checkCurveTangent(){this.keyframes.forEach((t,e)=>{if(0===t.interpMode){const i=this.keyframes[e-1],n=this.keyframes[e+1];i&&(t.inTangent=(t.point.y-i.point.y)/(t.point.x-i.point.x)),n&&(t.outTangent=(n.point.y-t.point.y)/(n.point.x-t.point.x)),this.patchCtrlPoint(t,i,n)}})}checkAllKeyCtrl(){this.keyframes.forEach((t,e)=>{const i=this.keyframes[e-1],n=this.keyframes[e+1];0===t.interpMode&&(i&&(t.inTangent=(t.point.y-i.point.y)/(t.point.x-i.point.x)),n&&(t.outTangent=(n.point.y-t.point.y)/(n.point.x-t.point.x))),this.patchCtrlPoint(t,i,n)})}paintMainCurveWrapMode(t,e){if("number"!=typeof this.config.wrapMode)return;const i=new Path2D;this.preCurveCache&&i.addPath(this.preCurveCache),i.addPath(this.curveCache),this.postCurveCache&&i.addPath(this.postCurveCache);const n=e.x-t.x,s=Math.ceil((this.canvas.width-e.x)/n);if(0===s)return;const a=new Path2D;switch(a.moveTo(e.x,e.y),this.config.wrapMode){case 1:a.lineTo(this.canvas.width,e.y);break;case 2:{const r=utils_1.createMatrix();for(let o=0;o<=s;o++)a.moveTo(e.x+n*o,e.y),r.translateSelf(n,0),a.lineTo(e.x+n*o,t.y),a.addPath(i,r);break}case 22:{const t=new Path2D,r=utils_1.createMatrix();t.addPath(i,r.scaleSelf(-1,1));let o=utils_1.createMatrix();for(let r=0;r<=s;r++)o=o.translateSelf(n,0),r%2==0?a.addPath(t,utils_1.createMatrix().translateSelf(2*e.x+n*r)):a.addPath(i,o);break}}this.ctx.strokeStyle=this.config.strokeStyleAxu,this.ctx.stroke(a)}moveAllY(t){if(0===t)return!1;const e=[];return this.keyframes.find(i=>{const n={x:i.canvas.x,y:i.canvas.y+t},s=this.grid.patchPointInRange(n);return s?e.push({canvas:this.grid.valueToPixel(s),point:s}):e.push({canvas:n,point:this.grid.pixelToValue(n)}),s})?(console.debug("move keys outRange"),!1):(this.keyframes.forEach((t,i)=>{Object.assign(t,e[i])}),this.keyframes.sort((t,e)=>t.point.x-e.point.x),this.checkAllKeyCtrl(),!0)}moveKeys(t,e){return t.find(t=>{const i={x:t.canvas.x+e.x,y:t.canvas.y+e.y},n=this.grid.patchPointInRange(i);return n?(t.canvas=this.grid.valueToPixel(n),t.point=n):(t.canvas=i,t.point=this.grid.pixelToValue(i)),n})&&console.debug("move keys outRange"),this.keyframes.sort((t,e)=>t.point.x-e.point.x),this.checkAllKeyCtrl(),!0}scaleKeys(t,e){const{changeValue:i,base:n,scale:s}=e;t.forEach(t=>{const e=t.canvas[i]-n;t.canvas[i]=n+e*s,t.point=this.grid.pixelToValue(t.canvas)}),this.checkCurveTangent()}spacingKeys(t,e){for(let i=1;i<t.length;i++){const n=t[i];n.point.x=t[i-1].point.x+e,n.canvas=this.grid.valueToPixel(n.point)}return this.keyframes.sort((t,e)=>t.point.x-e.point.x),this.checkCurveTangent(),!0}moveKey(t,e,i){let n=this.grid.patchPointInRange({x:t,y:e}),s={x:t,y:e};return n?(console.debug("move key outRange"),s=this.grid.valueToPixel(n)):n=this.grid.pixelToValue(s),this.editKey(i,n,s)}editKey(t,e,i){const n=require("lodash").cloneDeep(this.keyframes[t]);let s=this.keyframes[t+1],a=this.keyframes[t-1];return a&&e.x===a.point.x||s&&e.x===s.point.x?-1:(n.point=e,n.canvas=i||this.grid.valueToPixel(e),s&&n.point.x>s.point.x?(this.keyframes.splice(t,1),this.keyframes.splice(t+1,0,n),t++,a=s,(s=this.keyframes[t+1])&&(s.outTangent=s.inTangent),t):a&&n.point.x<a.point.x?(this.keyframes.splice(t,1),this.keyframes.splice(t-1,0,n),t--,s=a,(a=this.keyframes[t-1])&&(a.inTangent=a.outTangent),t):(this.keyframes[t]=n,this.checkCurveTangent(),this.patchCtrlPoint(n,a,s),t))}updateTan(t,e,i){const n=this.keyframes[t];n[i]=e;let s=i;n.broken&&n.tangentWeightMode!==curve_base_1.TangentWeightMode.BOTH||(s="both"),"inTangent"!==s&&"number"==typeof n.outTangent&&(n.outTangent=e),"outTangent"!==s&&"number"==typeof n.inTangent&&(n.inTangent=e),this.patchCtrlPoint(n,this.keyframes[t-1],this.keyframes[t+1])}updateTangentWeight(t,e,i,n){const s=this.keyframes[t];this.updateTan(t,i,n);const a=Math.atan(i);return"inTangent"===n?(s.inCtrlPoint=e,s.inTangentWeight=(s.point.y-e.y)/Math.sin(a)):(s.outCtrlPoint=e,s.outTangentWeight=(e.y-s.point.y)/Math.sin(a)),this.patchCtrlPoint(s,this.keyframes[t-1],this.keyframes[t+1]),!0}changeInterpMode(t,e){const i=this.keyframes[t];if(i.interpMode!==e){switch(i.interpMode=e,e){case 1:i.inTangent=0,i.outTangent=0;break;case 0:{const e=this.keyframes[t-1],n=this.keyframes[t+1];e&&(i.inTangent=(i.point.y-e.point.y)/(i.point.x-e.point.x)),n&&(i.outTangent=(n.point.y-i.point.y)/(n.point.x-i.point.x)),e||(i.inTangent=i.outTangent),n||(i.outTangent=i.inTangent)}break;case 2:i.inTangent&&(i.inTangent=0),i.outTangent&&(i.outTangent=0)}this.patchCtrlPoint(i,this.keyframes[t-1],this.keyframes[t+1])}}changeTangentWeight(t,e){const i=this.keyframes[t];if(![curve_base_1.TangentWeightMode.NONE,curve_base_1.TangentWeightMode.RIGHT].includes(e)&&[curve_base_1.TangentWeightMode.RIGHT,curve_base_1.TangentWeightMode.NONE].includes(i.tangentWeightMode)){const e=this.keyframes[t+1];this.patchTangentWeight(i,void 0,e)}if(![curve_base_1.TangentWeightMode.NONE,curve_base_1.TangentWeightMode.LEFT].includes(e)&&[curve_base_1.TangentWeightMode.LEFT,curve_base_1.TangentWeightMode.NONE].includes(i.tangentWeightMode)){const e=this.keyframes[t-1];this.patchTangentWeight(i,e)}i.tangentWeightMode=e,this.patchCtrlPoint(i,this.keyframes[t-1],this.keyframes[t+1])}patchTangentWeight(t,e,i){if(e){const i=Math.atan(t.outTangent),n=t.point.x-e.point.x;t.inTangentWeight=1/3*n/Math.cos(i)/this.config.sample}if(i){const e=Math.atan(t.outTangent),n=i.point.x-t.point.x;t.outTangentWeight=1/3*n/Math.cos(e)/this.config.sample}}pasteKeys(t,e,i){const n=this.calcKeyIndexFromX(e),s=t[0].point.x,a=t[0].point.y,r=t.map((t,n)=>{t.point.x=t.point.x-s+e,i&&(t.point.y=t.point.y-a+i);const r=this.keyframes.findIndex(e=>this.grid.xFormat(e.point.x)===this.grid.xFormat(t.point.x));return-1!==r&&this.keyframes.splice(r,1),this.transformKey(t)});return-1===n?this.keyframes.push(...r):this.keyframes.splice(n,0,...r),this.keyframes.sort((t,e)=>t.point.x-e.point.x),this.checkAllKeyCtrl(),r}createNewKey(t){let e=this.calcKeyIndexFromX(t.x);const i={point:t,canvas:this.grid.valueToPixel(t),interpMode:2,tangentWeightMode:curve_base_1.TangentWeightMode.NONE,inTangent:0,outTangent:0};if(0===this.keyframes.length)return this.keyframes.push(i),0;!e&&this.keyframes[this.keyframes.length-1].point.x<t.x&&(e=this.keyframes.length-1);const n="number"==typeof e?e+1:0;return this.keyframes.splice(n,0,i),this.patchCtrlPoint(i,this.keyframes[n-1],this.keyframes[n+1]),n}createKeyInCurveAt(t){const e=this.calcKeyIndexFromX(t);if(-1===e)return null;const i=this.keyframes[e],n=this.keyframes[e+1],s={outTangent:0,inTangent:0,interpMode:i.interpMode,tangentWeightMode:curve_base_1.TangentWeightMode.NONE,outTangentWeight:1,inTangentWeight:1};let a;switch(i.interpMode){case 1:a=Object.assign(s,{point:{x:t,y:i.point.y},canvas:this.grid.valueToPixel({x:t,y:i.point.y})});break;case 0:{const e={x:t,y:i.point.y+t*i.outTangent};a=Object.assign(s,{point:e,canvas:this.grid.valueToPixel(e)})}break;case 2:return a=this.spliteCurveAt(t,i,n),this.keyframes.splice(e+1,0,a),e+1}return this.keyframes.splice(e+1,0,a),this.checkCurveTangent(),this.patchCtrlPoint(a,this.keyframes[e],this.keyframes[e+2]),e+1}spliteCurveAt(t,e,i){const n=i.point.x-e.point.x,s=(t-e.point.x)/n,a=this.calcAssistPoint(e.point,e.outCtrlPoint,s),r=this.calcAssistPoint(e.outCtrlPoint,i.inCtrlPoint,s),o=this.calcAssistPoint(i.inCtrlPoint,i.point,s),h=this.calcAssistPoint(a,r,s),c=this.calcAssistPoint(r,o,s),l=this.calcAssistPoint(h,c,s);console.debug(l,t);const g={inCtrlPoint:h,outCtrlPoint:c,point:l,canvas:this.grid.valueToPixel(l),interpMode:2,inTangent:this.calcSlopeWithPoints(h,l),outTangent:this.calcSlopeWithPoints(l,c),tangentWeightMode:curve_base_1.TangentWeightMode.BOTH,inTangentWeight:1,outTangentWeight:1};return e.outCtrlPoint=a,i.inCtrlPoint=o,this.patchTangentWeight(g,e,i),[curve_base_1.TangentWeightMode.RIGHT,curve_base_1.TangentWeightMode.BOTH].includes(e.tangentWeightMode)&&this.patchTangentWeight(e,void 0,g),[curve_base_1.TangentWeightMode.LEFT,curve_base_1.TangentWeightMode.BOTH].includes(i.tangentWeightMode)&&this.patchTangentWeight(i,g),g}calcAssistPoint(t,e,i){return{x:t.x*(1-i)+e.x*i,y:t.y*(1-i)+e.y*i}}calcValueFromX(t){const e=this.calcKeyIndexFromX(t);if(-1===e)return null;const i=this.keyframes[e],n=this.keyframes[e+1],s=this.getArgs(i.point,i.outTangent,n.point,n.inTangent,e);return Hermite.getRenderFunc(s)(t)}delKeyFrame(t){this.keyframes.splice(t,1),this.checkCurveTangent(),this.patchCtrlPoint(this.keyframes[t-1],void 0,this.keyframes[t+1]),this.patchCtrlPoint(this.keyframes[t],this.keyframes[t-1],void 0)}clear(){this.ctx.clearRect(0,0,this.canvas.width,this.canvas.height)}getArgs(t,e,i,n,s){const a=Hermite.calcHermitArgsMd5(t,e,i,n);return this.hermiteArgs[s]&&this.hermiteArgs[s].md5===a||(this.hermiteArgs[s]=Hermite.calcArgs(t,e,i,n)),this.hermiteArgs[s]}calcSlopeWithPoints(t,e){return e.x-t.x==0?1/0:(e.y-t.y)/(e.x-t.x)}calcSlopeInCurveAt(t,e){const{a:i,b:n,c:s}=e;return 3*i*t*t+2*n*t+s}calcKeyIndexFromX(t){let e=-1;for(let i=0;i<this.keyframes.length-1;i++){const n=this.keyframes[i].point,s=this.keyframes[i+1].point;if(t>n.x&&s.x>t){e=i;break}}return-1===e&&this.keyframes.length&&t>this.keyframes[this.keyframes.length-1].point.x&&(e=this.keyframes.length-1),e}patchCtrlPoint(t,e,i){patchCtrlPoint(t,this.config.sample,e,i)}}function patchCtrlPoint(t,e,i,n){if(n)if([curve_base_1.TangentWeightMode.BOTH,curve_base_1.TangentWeightMode.RIGHT].includes(t.tangentWeightMode)&&t.outTangentWeight){const i=Math.atan(t.outTangent);t.outCtrlPoint={x:t.point.x+t.outTangentWeight*Math.cos(i)*e,y:t.point.y+t.outTangentWeight*Math.sin(i)}}else{const i=n.point.x-t.point.x;t.outCtrlPoint={x:t.point.x+1/3*i,y:t.point.y+1/3*t.outTangent*i/e}}if(i)if([curve_base_1.TangentWeightMode.BOTH,curve_base_1.TangentWeightMode.LEFT].includes(t.tangentWeightMode)&&t.inTangentWeight){const i=Math.atan(t.inTangent);t.inCtrlPoint={x:t.point.x-t.inTangentWeight*Math.cos(i)*e,y:t.point.y-t.inTangentWeight*Math.sin(i)}}else{const n=t.point.x-i.point.x;t.inCtrlPoint={x:t.point.x-1/3*n,y:t.point.y-1/3*t.inTangent*n/e}}}exports.Hermite=Hermite;