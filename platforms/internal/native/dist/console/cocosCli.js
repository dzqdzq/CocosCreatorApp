"use strict";var __createBinding=this&&this.__createBinding||(Object.create?function(e,t,r,s){void 0===s&&(s=r),Object.defineProperty(e,s,{enumerable:!0,get:function(){return t[r]}})}:function(e,t,r,s){void 0===s&&(s=r),e[s]=t[r]}),__setModuleDefault=this&&this.__setModuleDefault||(Object.create?function(e,t){Object.defineProperty(e,"default",{enumerable:!0,value:t})}:function(e,t){e.default=t}),__importStar=this&&this.__importStar||function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)"default"!==r&&Object.prototype.hasOwnProperty.call(e,r)&&__createBinding(t,e,r);return __setModuleDefault(t,e),t};Object.defineProperty(exports,"__esModule",{value:!0}),exports.NativeConsole=exports.cchelper=exports.EXT_LIST=exports.CCPlugin=exports.pa=void 0;const fs=__importStar(require("fs")),path=__importStar(require("path")),ml=__importStar(require("./multiLanguage")),cocosConfig_1=require("./cocosConfig"),os=__importStar(require("os")),afs_1=require("./afs"),childProcess=__importStar(require("child_process")),default_1=require("./default"),iconv=require("iconv-lite");var ArgumentItemType;!function(e){e[e.BOOLFLAG=0]="BOOLFLAG",e[e.STRINGVALUE=1]="STRINGVALUE",e[e.ACTION=2]="ACTION",e[e.ENUM=3]="ENUM"}(ArgumentItemType||(ArgumentItemType={})),exports.pa={help:{short:"-h",long:"--help",help:"show this message",argType:ArgumentItemType.ACTION},srcDir:{short:"-s",long:"--src",help:ml.getString("COCOSHELPARGSRC"),argType:ArgumentItemType.STRINGVALUE},quiet:{short:"-q",long:"--quiet",help:ml.getString("COCOS_HELP_ARG_QUIET"),argType:ArgumentItemType.BOOLFLAG},platform:{short:"-p",long:"--platform",help:ml.getString("COCOSHELPARGPLATFORM"),argType:ArgumentItemType.ENUM,enumValues:cocosConfig_1.cocosConfig.platforms},doListPlatforms:{short:"",long:"--list-platforms",help:"list available platforms",argType:ArgumentItemType.ACTION},projDir:{short:"",long:"--proj-dir",help:ml.getString("COCOSHELPARGPROJDIR"),argType:ArgumentItemType.STRINGVALUE},buildDir:{short:"",long:"--build-dir",help:"specify directory where to build project",argType:ArgumentItemType.STRINGVALUE},packageName:{short:"-p",long:"--package",help:ml.getString("NEWARGPACKAGE"),argType:ArgumentItemType.STRINGVALUE},directory:{short:"-d",long:"--directory",help:ml.getString("NEWARGDIR"),argType:ArgumentItemType.STRINGVALUE},iosBundleid:{short:"",long:"--ios-bundleid",help:ml.getString("NEWARGIOSBUNDLEID"),argType:ArgumentItemType.STRINGVALUE},macBundleid:{short:"",long:"--mac-bundleid",help:ml.getString("NEWARGMACBUNDLEID"),argType:ArgumentItemType.STRINGVALUE},enginePath:{short:"-e",long:"--engine-path",help:ml.getString("NEWARGENGINEPATH"),argType:ArgumentItemType.STRINGVALUE},portrait:{short:"",long:"--portrait",help:ml.getString("NEWARGPORTRAIT"),argType:ArgumentItemType.BOOLFLAG},noNative:{short:"",long:"--no-native",help:ml.getString("NEWARGNONATIVE"),argType:ArgumentItemType.BOOLFLAG},language:{short:"-l",long:"--language",help:ml.getString("NEWARGLANG"),argType:ArgumentItemType.ENUM,enumValues:cocosConfig_1.cocosConfig.languages},doListTemplates:{short:"",long:"--list-templates",help:"List available templates. To be used with --template option.",argType:ArgumentItemType.ACTION},templateName:{short:"-k",long:"--template-name",help:"Name of the template to be used to create the game. To list available names, use --list-templates.",argType:ArgumentItemType.STRINGVALUE},cmakeGenerator:{short:"-G",long:"--cmake-generator",help:"Set cmake generator",argType:ArgumentItemType.STRINGVALUE},cmakePath:{short:"",long:"--cmake-path",help:"path to cmake.exe or cmake",argType:ArgumentItemType.STRINGVALUE},iosSimulator:{short:"",long:"--ios-simulator",help:"enable iOS simulator support",argType:ArgumentItemType.BOOLFLAG},teamid:{short:"",long:"--team-id",help:"Apple developer team id",argType:ArgumentItemType.STRINGVALUE},sharedDir:{short:"",long:"--shared-dir",help:"Shared source directory",argType:ArgumentItemType.STRINGVALUE}};class CCPlugin{constructor(e){this._cocos2dPath=null,this._templatePath=null,this._pluginName=null,this.extArgs=[],this.parser=e,this.nativeTemplateDir=path.join(Editor.Project.path,"native","engine")}get platformTemplatePath(){return path.join(this.nativeTemplateDir,this.platformTemplateDirName)}get sourceTemplatePath(){return path.join(this.getTemplatesRootPath(),this.parser.platform)}get platformTemplateDirName(){let e=this.parser.platform;return e===default_1.PLATFORM_ENUM.WINDOWS&&(e="win32"===this.parser.win.targetPlatform?"win32":"win64"),e}extendArgv(e){this.extArgs=this.extArgs.concat(e)}getCocosRoot(){const e=this.getEnginePath();return e||(this._cocos2dPath||(this._cocos2dPath=path.join(__dirname,"../../.."),fs.existsSync(path.join(this._cocos2dPath,"cocos"))||(console.warn(ml.getString("COCOS_WARNING_ENGINE_NOT_FOUND")),this._cocos2dPath=null)),this._cocos2dPath)}getConsleRoot(){const e=this.getEnginePath();return e?path.join(e,"tools/cocos-console"):path.join(__dirname,"..")}getTemplatesRootPath(){const e=this.getEnginePath();if(e)return path.join(e,"templates");if(!this._templatePath){const e=this.getCocosRoot();this._templatePath=e?path.join(e,"templates"):null}return this._templatePath}get projectDir(){const e=this.args.directory;return cchelper.replaceEnvVariables(e)}getCmakeGenerator(){return this.args.cmakeGenerator}getBuildDir(){return this.args.buildDir}isAppleSilicon(){const e=os.cpus(),t=e&&e[0]&&e[0].model?e[0].model:"";return/Apple/.test(t)&&"darwin"===process.platform}getXcodeMajorVerion(){try{const e=childProcess.execSync("xcrun xcodebuild -version").toString("utf8");return Number.parseInt(e.match(/Xcode\s(\d+)\.\d+/)[1])}catch(e){return console.error(e),11}}selectExecutable(e){return"win32"===process.platform&&(e=e.map(e=>e+".exe")),e.map(e=>path.join(Editor.App.path,e)).find(e=>fs.existsSync(e))}getCmakePath(){let e=this.args.cmakePath;if(!e&&!(e=this.selectExecutable(["../tools/cmake/bin/cmake",`../tools/cmake/${this.isAppleSilicon()?"arm64":"x86_64"}/bin/cmake`])))throw new Error("cmake command is not found!");return"win32"===process.platform&&(e=e.replace(/(\s+)/g,'"$1"')),e=e.replace(/ /g,"\\ ")}enableIosSimulator(){return this.args.ios.simulator}getAppTeamId(){return this.args.teamid}async runXcodeBuild(e){const t={};return Object.assign(t,process.env),Object.keys(t).filter(e=>e.toLowerCase().startsWith("npm_")).forEach(e=>delete t[e]),new Promise((r,s)=>{console.log(`run xcodebuild with ${e.join(" ")}`);const o=cchelper.which("xcodebuild");if(o){console.log(`run xcodebuild with ${e.join(" ")}`);const n=childProcess.spawn(o,e,{stdio:["pipe","pipe","pipe"],env:t,shell:!0});n.stdout.on("data",e=>{console.log(`[xcodebuild] ${iconv.decode(e,"gbk").toString()}`)}),n.stderr.on("data",e=>{console.error(`[xcodebuild] ${iconv.decode(e,"gbk").toString()}`)}),n.on("close",(t,o)=>{0===t?r():s(new Error(`run xcodebuild failed "xcodebuild ${e.join(" ")}", code: ${t}, signal: ${o}`))})}else console.error("'xcodebuild' is not in the path")})}async runCmake(e){const t={};return Object.assign(t,process.env),Object.keys(t).filter(e=>e.toLowerCase().startsWith("npm_")).forEach(e=>delete t[e]),new Promise((r,s)=>{console.log(`run cmake with ${e.join(" ")}`);const o=childProcess.spawn(this.getCmakePath(),e,{stdio:["pipe","pipe","pipe"],env:t,shell:!0});o.stdout.on("data",e=>{console.log(`[cmake] ${iconv.decode(e,"gbk").toString()}`)}),o.stderr.on("data",e=>{console.error(`[cmake-err] ${iconv.decode(e,"gbk").toString()}`)}),o.on("close",(t,o)=>{0===t?r():s(new Error(`run cmake failed "cmake ${e.join(" ")}", code: ${t}, signal: ${o}`))})})}doListPlatforms(){console.log("support platforms:");for(const e of cocosConfig_1.cocosConfig.platforms)console.log(` - ${e}`)}doShowHelp(){this.parser}setEnv(e,t){process.env[e]=t}getEnv(e){return process.env[e]}getCurrentPlatform(){const e=os.platform();return"darwin"===e?default_1.PLATFORM_ENUM.MAC:"win32"===e?default_1.PLATFORM_ENUM.WINDOWS:(console.warn(`platform ${e} is not supported!`),default_1.PLATFORM_ENUM.UNKNOWN)}getEnginePath(){return this.args.enginePath}getTemplatesDirNames(){const e=this.getTemplatesRootPath();let t=[];return e&&(t=(t=fs.readdirSync(e).filter(e=>!e.startsWith("."))).filter(t=>{const r=path.join(e,t);return fs.statSync(r).isDirectory()})),t}getTemplateDirPaths(){const e=this.getTemplatesRootPath();return this.getTemplatesDirNames().map(t=>path.join(e,t))}getPlatform(){let e=this.parser.platform;return e||(e=this.getCurrentPlatform(),console.log(`platform not specified, use current platform ${e}`)),e}setPlatform(e){this.parser.platform=e}getPluginName(){return this._pluginName}setPluginName(e){this._pluginName=e}async exec(){console.log(`[plugin ${this.getPluginName()}]: running ...`),this.init(),await this.run(),console.log(`  [plugin ${this.getPluginName()}]: done!`)}get args(){return this.parser}}exports.CCPlugin=CCPlugin,exports.EXT_LIST=[".js",".ccc",".ccd",".jsg",".jsc"];class cchelper{static replaceEnvVariables(e){return e.replace(/\$\{([^}]*)\}/g,(e,t)=>void 0===process.env[t]?e:process.env[t]).replace(/(~)/g,(e,t)=>process.env.HOME)}static fixPath(e){return e=this.replaceEnvVariables(e),"win32"===os.platform()?e.replace(/\\/g,"/").replace(/\/+/,"/"):e}static async delay(e){return new Promise((t,r)=>{setTimeout(async()=>{t()},e)})}static join(e,...t){const r=t.map(e=>this.replaceEnvVariables(e));return path.isAbsolute(r[r.length-1])?r[r.length-1]:path.join(this.replaceEnvVariables(e),...t)}static copyFileSync(e,t,r,s){e=this.replaceEnvVariables(e),t=this.replaceEnvVariables(t),r=this.replaceEnvVariables(r),s=this.replaceEnvVariables(s);const o=path.isAbsolute(t)?t:path.join(e,t),n=path.isAbsolute(s)?s:path.join(r,s);this.makeDirectoryRecursive(path.dirname(n)),fs.copyFileSync(o,n)}static async copyFileAsync(e,t){this.makeDirectoryRecursive(path.parse(t).dir),await afs_1.afs.copyFile(e,t)}static async copyRecursiveAsync(e,t){e=this.replaceEnvVariables(e),t=this.replaceEnvVariables(t);const r=[],s=await afs_1.afs.stat(e);if(s){if(s.isDirectory()){this.makeDirectoryRecursive(t);const s=await afs_1.afs.readdir(e);for(const o of s){if("."===o||".."===o)continue;const s=path.join(e,o),n=this.copyRecursiveAsync(s,path.join(t,o));r.push(n)}await Promise.all(r)}else if(s.isFile())try{await this.copyFileAsync(e,t)}catch(r){await this.delay(10),await this.copyFileAsync(e,t)}}else console.error(`failed to stat ${e}`)}static prepareDirsForFiles(e,t,r){const s={};for(const e of t){const t=e.split("/");let r=s;for(const e of t)r=e in r?r[e]:r[e]={}}const o=(e,t,r)=>{if(fs.statSync(e).isDirectory()){fs.existsSync(r)||fs.mkdirSync(r);for(const s in t)"."!==s&&".."!==s&&o(path.join(e,s),t[s],path.join(r,s))}};o(e,s,r)}static parallelCopyFiles(e,t,r,s){let o=0;return s=this.replaceEnvVariables(s),cchelper.prepareDirsForFiles(t,r,s),new Promise((n,i)=>{const a=async(e,t)=>{o+=1,await this.copyRecursiveAsync(e,t),o-=1,l()},l=()=>{if(r.length>0&&o<e){const e=r.shift(),o=path.join(t,e);fs.existsSync(o)?a(o,path.join(s,e)):console.warn(`warning: copyFile: ${o} not exists!`)}0===r.length&&0===o&&n()};for(let t=0;t<e;t++)l()})}static makeDirectoryRecursive(e){if(0===e.length)return;const t=[];let r=e;for(;!fs.existsSync(r);)t.push(r),r=path.join(r,"..");for(;t.length>0;)fs.mkdirSync(t[t.length-1]),t.length=t.length-1}static async removeDirectoryRecursive(e){const t=await afs_1.afs.stat(e);if(t.isFile())await afs_1.afs.unlink(e);else if(t.isDirectory()){const t=await afs_1.afs.readdir(e),r=[];for(const s of t){if("."===s||".."===s)continue;const t=path.join(e,s);r.push(this.removeDirectoryRecursive(t))}await Promise.all(r),await afs_1.afs.rmdir(e)}}static async copyFilesWithConfig(e,t,r){if(!fs.existsSync(t))return void console.error(`copy file srcRoot ${t} is not exists!`);t=this.replaceEnvVariables(t),r=this.replaceEnvVariables(r);let s=this.replaceEnvVariables(e.from),o=this.replaceEnvVariables(e.to);path.isAbsolute(s)&&(t=s,s="."),path.isAbsolute(o)&&(r=o,o=".");const n=e=>{const t={},r=e.map(e=>Array.from(e));for(;r.length>0;){const e=r.shift();let s=t;for(;e.length>0;){const t=e.shift();t in s||(s[t]={}),s=s[t]}}return t},i=(e,t)=>{if(null===t)return!1;const r=Array.from(e);let s=0,o=t;for(;r[s]in o;)o=o[r[s]],s++;return s===r.length&&0===Object.keys(o).length},a=e.include?n(e.include):null,l=e.exclude?n(e.exclude):null,c=async(e,t,r)=>{const s=path.join(e,t),o=await afs_1.afs.stat(s);if(o.isDirectory()){const o=await afs_1.afs.readdir(s),n=[];for(const s of o){if("."===s||".."===s)continue;const o=path.join(t,s);!l||!i(o,l)||a&&i(o,a)?n.push(c(e,o,r)):console.log(` - skip copy ${e} ${o} to ${r}`)}await Promise.all(n)}else o.isFile()&&await this.copyFileAsync(s,path.join(r,t))},p=(this.replaceEnvVariables(path.normalize(path.join(t,s))),this.replaceEnvVariables(path.normalize(path.join(r,o))));await c(t,s,p)}static async replaceInFile(e,t){if(t=this.replaceEnvVariables(t),!fs.existsSync(t))return;const r=(await afs_1.afs.readFile(t)).toString("utf8").split("\n").map(t=>(e.forEach(e=>{t=t.replace(new RegExp(e.reg),this.replaceEnvVariables(e.text))}),t)).join("\n");await afs_1.afs.writeFile(t,r)}static exactValueFromFile(e,t,r){if(!fs.existsSync(t))return void console.error(`file ${t} not exist!`);const s=fs.readFileSync(t).toString("utf-8").split("\n");for(const t of s){const s=t.match(e);if(s)return s[r]}}static async runCmd(e,t,r,s){return new Promise((o,n)=>{console.log(`[runCmd]: ${e} ${t.join(" ")}`);const i=childProcess.spawn(e,t,{shell:!0,env:process.env,cwd:s||process.cwd()});r||(i.stdout.on("data",t=>{console.log(`[runCmd ${e}] ${t}`)}),i.stderr.on("data",t=>{console.log(`[runCmd ${e} - error] ${t}`)})),i.on("close",(s,i)=>{0===s||r?o():n(`failed to exec ${e} ${t.join(" ")}`)})})}static existsSync(e){const t=path.extname(e),r=path.basename(e,t);return e=path.join(path.dirname(e),r),!!exports.EXT_LIST.find(t=>fs.existsSync(e+t))}static checkJavaHome(){process.env.JAVA_HOME||console.warn("$JAVA_HOME is not set!");const e=cchelper.which("java");if(e)try{const t=childProcess.execSync(`${e} --version`).toString();if(/Java\(TM\)/.test(t))return!0;console.error("Oracle JDK is expected.")}catch(e){console.error("Error checking java runtime..."),console.error(e)}else console.error("'java' is not found in PATH");return!1}static accessSync(e,t){try{return fs.accessSync(e,t),!0}catch(e){}return!1}static which(e){var t,r;const s=[e],o="win32"===os.platform();o&&s.push(e+".exe");const n=o?null===(t=process.env.PATH)||void 0===t?void 0:t.split(";"):null===(r=process.env.PATH)||void 0===r?void 0:r.split(":");if(!n||0===n.length)return null;for(const e of n)for(const t of s){const r=path.join(e,t);if(fs.existsSync(r)&&(o||cchelper.accessSync(r,fs.constants.X_OK)))return r}return null}}exports.cchelper=cchelper;class NativeConsole{constructor(e){this._params=e}loadPlugin(e){let t=null;const r=path.join(__dirname,`plugin${e}`);if(!cchelper.existsSync(r))return console.error(`Plugin ${e} is not defined!`),t;const s=require(r),o=`CCPlugin${e.toUpperCase()}`;return o in s?((t=new s[o](this._params)).setPluginName(e),t):(console.error(`${o} not defined in plugin_${e}.js`),t)}async run(){let e=this._params.pluginName;const t=[];let r;do{r=this.loadPlugin(e),t.push(r),e=r.depends()}while(null!==e);for(let e=t.length-1;e>=0;e--)await t[e].exec()}}exports.NativeConsole=NativeConsole,process.on("unhandledRejection",(e,t)=>{console.error("----unhandledRejection---"),console.error(e)});