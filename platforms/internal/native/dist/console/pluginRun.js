"use strict";var __createBinding=this&&this.__createBinding||(Object.create?function(t,e,n,r){void 0===r&&(r=n),Object.defineProperty(t,r,{enumerable:!0,get:function(){return e[n]}})}:function(t,e,n,r){void 0===r&&(r=n),t[r]=e[n]}),__setModuleDefault=this&&this.__setModuleDefault||(Object.create?function(t,e){Object.defineProperty(t,"default",{enumerable:!0,value:e})}:function(t,e){t.default=e}),__importStar=this&&this.__importStar||function(t){if(t&&t.__esModule)return t;var e={};if(null!=t)for(var n in t)"default"!==n&&Object.prototype.hasOwnProperty.call(t,n)&&__createBinding(e,t,n);return __setModuleDefault(e,t),e};Object.defineProperty(exports,"__esModule",{value:!0}),exports.CCPluginRUN=void 0;const cocosCli_1=require("./cocosCli"),path=__importStar(require("path")),fs=__importStar(require("fs-extra")),os=__importStar(require("os")),childProcess=__importStar(require("child_process")),default_1=require("./default"),crypto_1=require("crypto"),PackageNewConfig="cocos-project-template.json";class CCPluginRUN extends cocosCli_1.CCPlugin{depends(){return null}init(){return!0}async run(){const t=this.getPlatform();return t===default_1.PLATFORM_ENUM.MAC?new MacRunCMD(this).run():t===default_1.PLATFORM_ENUM.IOS?new IOSRunCMD(this).run():t===default_1.PLATFORM_ENUM.ANDROID||t===default_1.PLATFORM_ENUM["HUAWEI-AGC"]?new AndroidRunCMD(this).run():t===default_1.PLATFORM_ENUM.WIN32?new Win32RunCMD(this).run():t!==default_1.PLATFORM_ENUM.OHOS||new OHOSRunCMD(this).run()}getProjectNameFromCmake(){const t=path.join(this.getBuildDir(),"CMakeCache.txt");return fs.existsSync(t)||console.error(`can not find "CMakeCache.txt" in ${this.getBuildDir()}, please run "cmake -G" first`),cocosCli_1.cchelper.exactValueFromFile(/CMAKE_PROJECT_NAME:\w+=(.*)/,t,1)}}exports.CCPluginRUN=CCPluginRUN;class PlatformRunCmd{constructor(t){this.plugin=t}get projectName(){return this.plugin.args.projectName||this.plugin.getProjectNameFromCmake()}}class MacRunCMD extends PlatformRunCmd{async run(){return this.macRun(this.projectName),!0}macOpen(t){console.log(`open ${t}`);const e=childProcess.spawn("open",[t],{shell:!0,env:process.env});e.stdout.on("data",t=>{console.log(`[open app] ${t}`)}),e.stderr.on("data",t=>{console.error(`[open app error] ${t}`)}),e.on("close",(e,n)=>{console.log(`${t} exit with ${e}, sig: ${n}`)})}macRun(t){const e=path.join(this.plugin.getBuildDir(),this.plugin.args.debug?"Debug":"Release");if(!fs.existsSync(e))throw new Error(`[mac run] ${e} is not exist!`);let n;if(t&&(n=path.join(e,`${t}-desktop.app`),fs.existsSync(n)))return void this.macOpen(n);const r=fs.readdirSync(e).filter(t=>t.endsWith(".app"));if(1===r.length)return this.macOpen(path.join(e,r[0]));throw new Error(`found ${r.length} apps, failed to open.`)}}class IOSRunCMD extends PlatformRunCmd{run(){return this.runIosSimulator()}selectSimulatorId(){const t=t=>(t=t.split("[")[0].substr(6),100*parseInt(t)+t.length),e=childProcess.execSync("xcrun instruments -s").toString("utf-8").split("\n").filter(t=>t.startsWith("iPhone")&&t.indexOf("Simulator")>=0).filter(t=>t.indexOf("Apple Watch")<0).sort((e,n)=>t(n)-t(e))[0],n=e.match(/iPhone\s*[^\[]*\[([^\]]*)\].*/);return console.log(`selected simualtor ${e}`),n[1]}selectIosDevices(){const t=childProcess.execSync("xcrun simctl list").toString("utf-8").split("\n"),e=((t,e)=>{for(;e<t.length&&!t[e].match(/== Devices ==/);)e++;return e<t.length?e:-1})(t,0);return e<0?(console.error("can not find devices section!"),[]):((t,e)=>{const n=[];for(;!t[e].match(/-- iOS [^ ]* --/);)e++;if(t[e].indexOf("iOS")<0)return console.error("can not find iOS section!"),n;for(e++;t[e].startsWith(" ");)n.push(t[e++]);return n.map(t=>t.trim())})(t,e).filter(t=>t.startsWith("iPhone"))}readBundleId(){const t=this.projectName,e=fs.readdirSync(path.join(this.plugin.getBuildDir(),"CMakeFiles")).filter(e=>e.startsWith(t))[0],n=path.join(this.plugin.getBuildDir(),"CMakeFiles",e,"Info.plist");if(fs.existsSync(n)){const t=fs.readFileSync(n).toString("utf-8").split("\n");for(let e=0;e<t.length;e++)if(t[e].match(/CFBundleIdentifier/)){for(e++;!t[e].match(/<string>/);)e++;return t[e].match(/<string>([^<]*)<\/string>/)[1]}}else console.error(`Info.plist not found ${n}`);return null}queryIosDevice(){const t=childProcess.execSync("xcrun instruments -s devices").toString("utf-8").split("\n"),e=[];for(let n=1;n<t.length;n++)t[n].endsWith("(Simulator)")||t[n].match(/iPhone|iPad|iPod/)&&e.push(t[n]);return e.length>0?(console.log(`select ios device ${e[0]}`),e[0].match(/[^\[]]*\[([^\]]*)\]/)[1]):null}async runIosDevice(){const t=this.plugin.getBuildDir(),e=childProcess.execSync(`find ${t} -name "*.app"`).toString("utf-8").split("\n").filter(t=>t.trim().length>0),n=this.queryIosDevice();if(!n)return console.error("no connected device found!"),!1;if(e.length>0){const t=fs.mkdtempSync(path.join(os.tmpdir(),this.projectName));await cocosCli_1.cchelper.runCmd("xcrun",["instruments","-t","Blank","-w",n,e[0]],!1,t)}return!0}async runIosSimulator(){const t=this.selectSimulatorId(),e=this.plugin.getBuildDir(),n=this.readBundleId();console.log(` - build dir ${e} - simId ${t}`),console.log(` - bundle id ${n}`);const r=childProcess.execSync(`find ${e} -name "*.app"`).toString("utf-8").split("\n").filter(t=>t.trim().length>0);return r.length>0&&n&&(await cocosCli_1.cchelper.runCmd("xcrun",["simctl","boot",t],!0),await cocosCli_1.cchelper.runCmd("open",["`xcode-select -p`/Applications/Simulator.app"],!0),await cocosCli_1.cchelper.runCmd("xcrun",["simctl","boot",t],!0),await cocosCli_1.cchelper.runCmd("xcrun",["simctl","install",t,r[0].trim()],!1),await cocosCli_1.cchelper.runCmd("xcrun",["simctl","launch",t,`"${n}"`],!1)),!1}}class Win32RunCMD extends PlatformRunCmd{async run(){const t=path.join(this.plugin.getBuildDir(),this.plugin.args.debug?"Debug":"Release",`${this.plugin.args.projectName}.exe`);return fs.existsSync(t)?(await cocosCli_1.cchelper.runCmd(t,[],!1),!0):(console.error("exe file not found at",t),!1)}}class AndroidRunCMD extends PlatformRunCmd{async run(){return!!await this.install()&&await this.startApp()}getAdbPath(){return path.join(this.plugin.args.android.sdkPath,`platform-tools/adb${"win32"===process.platform?".exe":""}`)}getApkPath(){const t=this.plugin.args.debug?"debug":"release",e=`${this.plugin.args.projectName}-${t}.apk`;return path.join(this.plugin.projectDir,`proj/build/${this.plugin.args.projectName}/outputs/apk/${t}/${e}`)}async install(){const t=this.getApkPath(),e=this.getAdbPath();return fs.existsSync(t)?fs.existsSync(e)?(await this.checkApkInstalled()&&await cocosCli_1.cchelper.runCmd(e,["uninstall",this.plugin.args.android.packageName],!1),await cocosCli_1.cchelper.runCmd(e,["install",t],!1),!0):(console.error("can not find adb at",e),!1):(console.error("can not find apk at",t),!1)}async checkApkInstalled(){return(await new Promise((t,e)=>{const n=this.getAdbPath(),r=childProcess.spawn(n,["shell pm list packages | grep",this.plugin.args.android.packageName],{shell:!0,env:process.env,cwd:process.cwd()});r.stdout.on("data",e=>{t(e.toString())}),r.stderr.on("data",e=>{t("")}),r.on("close",(e,n)=>{t("")})})).includes(this.plugin.args.android.packageName)}async startApp(){const t=this.getAdbPath();return await cocosCli_1.cchelper.runCmd(t,["shell","am","start","-n",`${this.plugin.args.android.packageName}/com.cocos.game.AppActivity`],!1),!0}}class OHOSRunCMD extends PlatformRunCmd{async run(){const t=this.plugin.args.ohos.packageName,e=this.plugin.platformTemplatePath,n=this.plugin.args.debug?"debug":"release",r=this.selectHap(e,n);if(!fs.existsSync(r))return console.error(`File ${r} does not exist!`),!1;const i=this.hdcPath;if(!i)return console.error("Failed to locate hdc"),!1;const s=`/sdcard/${this.randString(32)}`;try{await cocosCli_1.cchelper.runCmd(i,["shell","am","force-stop",t],!0),await cocosCli_1.cchelper.runCmd(i,["shell","bm","uninstall",t],!0),await cocosCli_1.cchelper.runCmd(i,["file","send",cocosCli_1.cchelper.fixPath(r),cocosCli_1.cchelper.fixPath(path.join(s,"entry-debug-signed.hap"))],!1),await cocosCli_1.cchelper.runCmd(i,["shell","bm","install","-p",s],!1),await cocosCli_1.cchelper.runCmd(i,["shell","am","start","-n",`"${t}/com.example.cocosdemo.MainAbilityShellActivity"`],!1)}catch(t){throw t}finally{await cocosCli_1.cchelper.runCmd(i,["shell","rm","-rf",s],!0)}return!0}selectHap(t,e){const n=path.join(t,`entry/build/outputs/hap/${e}`);return path.join(n,this.selectHapFile(n,e))}selectHapFile(t,e){if(!fs.existsSync(t))throw new Error(`directory ${t} does not exist!`);let n=fs.readdirSync(t).filter(t=>t.endsWith(".hap"));if(0==n.length)throw new Error(`no hap found in ${t}`);if(1==n.length)return n[0];let r=n.filter(t=>t.endsWith("-signed.hap")&&t.startsWith(`entry-${e}-`)),i=n.filter(t=>t.startsWith(`entry-${e}`));return r.length>0?r[0]:i.length>0?i[0]:n[0]}get hdcPath(){if(this.plugin.args.ohos.sdkPath)return path.join(this.plugin.args.ohos.sdkPath,"toolchains/hdc")}randString(t){if(t<=0)return"";let e="";try{e=crypto_1.randomBytes(Math.ceil(t/2)).toString("hex").slice(0,t)}catch(n){e="";const r=t%8,i=(t-r)/8;let s=0;for(;s<i;s++)e+=Math.random().toString(16).slice(2);r>0&&(e+=Math.random().toString(16).slice(2,s))}return e}}