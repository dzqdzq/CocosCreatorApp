"use strict";var __createBinding=this&&this.__createBinding||(Object.create?function(t,e,n,i){void 0===i&&(i=n),Object.defineProperty(t,i,{enumerable:!0,get:function(){return e[n]}})}:function(t,e,n,i){void 0===i&&(i=n),t[i]=e[n]}),__setModuleDefault=this&&this.__setModuleDefault||(Object.create?function(t,e){Object.defineProperty(t,"default",{enumerable:!0,value:e})}:function(t,e){t.default=e}),__importStar=this&&this.__importStar||function(t){if(t&&t.__esModule)return t;var e={};if(null!=t)for(var n in t)"default"!==n&&Object.prototype.hasOwnProperty.call(t,n)&&__createBinding(e,t,n);return __setModuleDefault(e,t),e};Object.defineProperty(exports,"__esModule",{value:!0}),exports.CCPluginRUN=void 0;const childProcess=__importStar(require("child_process")),crypto_1=require("crypto"),fs=__importStar(require("fs-extra")),os=__importStar(require("os")),path=__importStar(require("path")),cocosCli_1=require("./cocosCli"),default_1=require("./default"),PackageNewConfig="cocos-project-template.json";class CCPluginRUN extends cocosCli_1.CCPlugin{depends(){return null}init(){return!0}async run(){const t=this.getPlatform();return t===default_1.PLATFORM_ENUM.MAC?await new MacRunCMD(this).run():t===default_1.PLATFORM_ENUM.IOS?await new IOSRunCMD(this).run():t===default_1.PLATFORM_ENUM.ANDROID||t===default_1.PLATFORM_ENUM["HUAWEI-AGC"]?await new AndroidRunCMD(this).run():t===default_1.PLATFORM_ENUM.WINDOWS?await new WindowsRunCMD(this).run():t!==default_1.PLATFORM_ENUM.OHOS||await new OHOSRunCMD(this).run()}getProjectNameFromCmake(){const t=path.join(this.getBuildDir(),"CMakeCache.txt");return fs.existsSync(t)||console.error(`can not find "CMakeCache.txt" in ${this.getBuildDir()}, please run "cmake -G" first`),cocosCli_1.cchelper.exactValueFromFile(/CMAKE_PROJECT_NAME:\w+=(.*)/,t,1)}}exports.CCPluginRUN=CCPluginRUN;class PlatformRunCmd{constructor(t){this.plugin=t}get projectName(){return this.plugin.args.projectName||this.plugin.getProjectNameFromCmake()}}class MacRunCMD extends PlatformRunCmd{async run(){return await this.macRun(this.projectName),!0}macOpen(t){console.log(`open ${t}`);const e=childProcess.spawn("open",[t],{shell:!0,env:process.env});e.stdout.on("data",t=>{console.log(`[open app] ${t}`)}),e.stderr.on("data",t=>{console.error(`[open app error] ${t}`)}),e.on("close",(e,n)=>{console.log(`${t} exit with ${e}, sig: ${n}`)})}macRun(t){const e=path.join(this.plugin.getBuildDir(),this.plugin.args.debug?"Debug":"Release");if(!fs.existsSync(e))throw new Error(`[mac run] ${e} is not exist!`);let n;if(t&&(n=path.join(e,`${t}-desktop.app`),fs.existsSync(n)))return void this.macOpen(n);const i=fs.readdirSync(e).filter(t=>t.endsWith(".app"));if(1!==i.length)throw new Error(`found ${i.length} apps, failed to open.`);this.macOpen(path.join(e,i[0]))}}class IOSRunCMD extends PlatformRunCmd{async run(){return await this.runIosSimulator()}selectSimulatorId(){const t=t=>{const e=t.split("(")[0].substr(6),n=t.match(/\((\d+\.\d+)\)/);return n?parseInt(n[1])+n.index:100*parseInt(e)+t.length},e=childProcess.execSync("xcrun xctrace list devices").toString("utf-8").split("\n").filter(t=>t.startsWith("iPhone")&&t.indexOf("Simulator")>=0).filter(t=>t.indexOf("Apple Watch")<0).sort((e,n)=>t(n)-t(e))[0],n=e.match(/\(([A-Z0-9-]+)\)/);return console.log(`selected simualtor ${e}`),n[1]}selectIosDevices(){const t=childProcess.execSync("xcrun simctl list").toString("utf-8").split("\n"),e=((t,e)=>{for(;e<t.length&&!t[e].match(/== Devices ==/);)e++;return e<t.length?e:-1})(t,0);return e<0?(console.error("can not find devices section!"),[]):((t,e)=>{const n=[];for(;!t[e].match(/-- iOS [^ ]* --/);)e++;if(t[e].indexOf("iOS")<0)return console.error("can not find iOS section!"),n;for(e++;t[e].startsWith(" ");)n.push(t[e++]);return n.map(t=>t.trim())})(t,e).filter(t=>t.startsWith("iPhone"))}readBundleId(){const t=this.projectName,e=fs.readdirSync(path.join(this.plugin.getBuildDir(),"CMakeFiles")).filter(e=>e.startsWith(t))[0],n=path.join(this.plugin.getBuildDir(),"CMakeFiles",e,"Info.plist");if(fs.existsSync(n)){const t=fs.readFileSync(n).toString("utf-8").split("\n");for(let e=0;e<t.length;e++)if(t[e].match(/CFBundleIdentifier/)){for(e++;!t[e].match(/<string>/);)e++;return t[e].match(/<string>([^<]*)<\/string>/)[1]}}else console.error(`Info.plist not found ${n}`);return null}queryIosDevice(){const t=childProcess.execSync("xcrun xctrace list devices").toString("utf-8").split("\n"),e=[];for(let n=1;n<t.length;n++)t[n].indexOf("Simulator")>=0||t[n].match(/iPhone|iPad|iPod/)&&e.push(t[n]);return e.length>0?(console.log(`select ios device ${e[0]}`),e[0].match(/\(([A-Z0-9-]+)\)/)[1]):null}async runIosDevice(){const t=this.plugin.getBuildDir(),e=childProcess.execSync(`find ${t} -name "*.app"`).toString("utf-8").split("\n").filter(t=>t.trim().length>0),n=this.queryIosDevice();if(!n)return console.error("no connected device found!"),!1;if(e.length>0){const t=fs.mkdtempSync(path.join(os.tmpdir(),this.projectName));await cocosCli_1.cchelper.runCmd("xcrun",["xctrace","record","--template","'App Launch'","--device",`'${n}'`,"--launch","--",`${e[0]}`],!1,t)}return!0}async runIosSimulator(){const t=this.selectSimulatorId(),e=this.plugin.getBuildDir(),n=this.readBundleId();console.log(` - build dir ${e} - simId ${t}`),console.log(` - bundle id ${n}`);const i=childProcess.execSync(`find ${e} -name "*.app"`).toString("utf-8").split("\n").filter(t=>t.trim().length>0);return i.length>0&&n&&(await cocosCli_1.cchelper.runCmd("xcrun",["simctl","boot",t],!0),await cocosCli_1.cchelper.runCmd("open",["`xcode-select -p`/Applications/Simulator.app"],!0),await cocosCli_1.cchelper.runCmd("xcrun",["simctl","boot",t],!0),await cocosCli_1.cchelper.runCmd("xcrun",["simctl","install",t,i[0].trim()],!1),await cocosCli_1.cchelper.runCmd("xcrun",["simctl","launch",t,`"${n}"`],!1)),!1}}class WindowsRunCMD extends PlatformRunCmd{async run(){const t=path.join(this.plugin.getBuildDir(),this.plugin.args.debug?"Debug":"Release",`${this.plugin.args.projectName}.exe`);return fs.existsSync(t)?(await cocosCli_1.cchelper.runCmd(t,[],!1),!0):(console.error("exe file not found at"+t),!1)}}class AndroidRunCMD extends PlatformRunCmd{async run(){return!!await this.install()&&await this.startApp()}getAdbPath(){return path.join(this.plugin.args.android.sdkPath,`platform-tools/adb${"win32"===process.platform?".exe":""}`)}getApkPath(){const t=this.plugin.args.debug?"debug":"release",e=`${this.plugin.args.projectName}-${t}.apk`;return path.join(this.plugin.projectDir,`proj/build/${this.plugin.args.projectName}/outputs/apk/${t}/${e}`)}get applicationID(){return this.plugin.args.android.packageName}async install(){const t=this.getApkPath(),e=this.getAdbPath();return fs.existsSync(t)?fs.existsSync(e)?(await this.checkApkInstalled()&&await cocosCli_1.cchelper.runCmd(e,["uninstall",this.applicationID],!1),await cocosCli_1.cchelper.runCmd(e,["install","-r",t],!1),!0):(console.error("can not find adb at",e),!1):(console.error("can not find apk at",t),!1)}async checkApkInstalled(){return(await new Promise((t,e)=>{const n=this.getAdbPath(),i=childProcess.spawn(n,["shell pm list packages | grep",this.applicationID],{shell:!0,env:process.env,cwd:process.cwd()});i.stdout.on("data",e=>{t(e.toString())}),i.stderr.on("data",e=>{t("")}),i.on("close",(e,n)=>{t("")})})).includes(this.applicationID)}async startApp(){const t=this.getAdbPath();return await cocosCli_1.cchelper.runCmd(t,["shell","am","start","-n",`${this.applicationID}/com.cocos.game.AppActivity`],!1),!0}}class OHOSRunCMD extends PlatformRunCmd{async run(){const t=this.plugin.args.ohos.packageName,e=this.plugin.platformTemplatePath,n=this.plugin.args.debug?"debug":"release",i=this.selectHap(e,n);if(!fs.existsSync(i))return console.error(`File ${i} does not exist!`),!1;const r=this.hdcPath;if(!r)return console.error("Failed to locate hdc"),!1;const s=`/sdcard/${this.randString(32)}`;try{await cocosCli_1.cchelper.runCmd(r,["shell","am","force-stop",t],!0),await cocosCli_1.cchelper.runCmd(r,["shell","bm","uninstall",t],!0),await cocosCli_1.cchelper.runCmd(r,["file","send",cocosCli_1.cchelper.fixPath(i),cocosCli_1.cchelper.fixPath(path.join(s,"entry-debug-signed.hap"))],!1),await cocosCli_1.cchelper.runCmd(r,["shell","bm","install","-p",s],!1),await cocosCli_1.cchelper.runCmd(r,["shell","am","start","-n",`"${t}/com.example.cocosdemo.MainAbilityShellActivity"`],!1)}finally{await cocosCli_1.cchelper.runCmd(r,["shell","rm","-rf",s],!0)}return!0}selectHap(t,e){const n=path.join(t,`entry/build/outputs/hap/${e}`);return path.join(n,this.selectHapFile(n,e))}selectHapFile(t,e){if(!fs.existsSync(t))throw new Error(`directory ${t} does not exist!`);const n=fs.readdirSync(t).filter(t=>t.endsWith(".hap"));if(0===n.length)throw new Error(`no hap found in ${t}`);if(1===n.length)return n[0];const i=n.filter(t=>t.endsWith("-signed.hap")&&t.startsWith(`entry-${e}-`)),r=n.filter(t=>t.startsWith(`entry-${e}`));return i.length>0?i[0]:r.length>0?r[0]:n[0]}get hdcPath(){return this.plugin.args.ohos.sdkPath?path.join(this.plugin.args.ohos.sdkPath,"toolchains/hdc"):null}randString(t){if(t<=0)return"";let e="";try{e=crypto_1.randomBytes(Math.ceil(t/2)).toString("hex").slice(0,t)}catch(n){e="";const i=t%8,r=(t-i)/8;let s=0;for(;s<r;s++)e+=Math.random().toString(16).slice(2);i>0&&(e+=Math.random().toString(16).slice(2,s))}return e}}