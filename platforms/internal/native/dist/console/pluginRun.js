"use strict";var __createBinding=this&&this.__createBinding||(Object.create?function(e,t,n,r){void 0===r&&(r=n),Object.defineProperty(e,r,{enumerable:!0,get:function(){return t[n]}})}:function(e,t,n,r){void 0===r&&(r=n),e[r]=t[n]}),__setModuleDefault=this&&this.__setModuleDefault||(Object.create?function(e,t){Object.defineProperty(e,"default",{enumerable:!0,value:t})}:function(e,t){e.default=t}),__importStar=this&&this.__importStar||function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var n in e)"default"!==n&&Object.prototype.hasOwnProperty.call(e,n)&&__createBinding(t,e,n);return __setModuleDefault(t,e),t};Object.defineProperty(exports,"__esModule",{value:!0}),exports.CCPluginRUN=void 0;const cocosCli_1=require("./cocosCli"),path=__importStar(require("path")),fs=__importStar(require("fs-extra")),os=__importStar(require("os")),childProcess=__importStar(require("child_process")),default_1=require("./default"),PackageNewConfig="cocos-project-template.json";class CCPluginRUN extends cocosCli_1.CCPlugin{depends(){return null}init(){return!0}async run(){let e=this.getPlatform();return e==default_1.PLATFORM_ENUM.MAC?new MacRunCMD(this).run():e==default_1.PLATFORM_ENUM.IOS?new IOSRunCMD(this).run():e==default_1.PLATFORM_ENUM.ANDROID||e===default_1.PLATFORM_ENUM["HUAWEI-AGC"]?new AndroidRunCMD(this).run():e!=default_1.PLATFORM_ENUM.WIN32||new Win32RunCMD(this).run()}getProjectNameFromCmake(){let e=path.join(this.getBuildDir(),"CMakeCache.txt");return fs.existsSync(e)||console.error(`can not find "CMakeCache.txt" in ${this.getBuildDir()}, please run "cmake -G" first`),cocosCli_1.cchelper.exactValueFromFile(/CMAKE_PROJECT_NAME:\w+=(.*)/,e,1)}}exports.CCPluginRUN=CCPluginRUN;class PlatformRunCmd{constructor(e){this.plugin=e}get projectName(){return this.plugin.args.projectName||this.plugin.getProjectNameFromCmake()}}class MacRunCMD extends PlatformRunCmd{async run(){return this.macRun(this.projectName),!0}macOpen(e){console.log(`open ${e}`);let t=childProcess.spawn("open",[e],{shell:!0,env:process.env});t.stdout.on("data",e=>{console.log(`[open app] ${e}`)}),t.stderr.on("data",e=>{console.error(`[open app error] ${e}`)}),t.on("close",(t,n)=>{console.log(`${e} exit with ${t}, sig: ${n}`)})}macRun(e){let t,n=path.join(this.plugin.getBuildDir(),this.plugin.args.debug?"Debug":"Release");if(!fs.existsSync(n))throw new Error(`[mac run] ${n} is not exist!`);if(e&&(t=path.join(n,`${e}-desktop.app`),fs.existsSync(t)))return void this.macOpen(t);let r=fs.readdirSync(n).filter(e=>e.endsWith(".app"));if(1==r.length)return this.macOpen(path.join(n,r[0]));throw new Error(`found ${r.length} apps, failed to open.`)}}class IOSRunCMD extends PlatformRunCmd{run(){return this.runIosSimulator()}selectSimulatorId(){const e=e=>(e=e.split("[")[0].substr(6),100*parseInt(e)+e.length);let t=childProcess.execSync("xcrun instruments -s").toString("utf-8").split("\n").filter(e=>e.startsWith("iPhone")&&e.indexOf("Simulator")>=0).filter(e=>e.indexOf("Apple Watch")<0).sort((t,n)=>e(n)-e(t))[0],n=t.match(/iPhone\s*[^\[]*\[([^\]]*)\].*/);return console.log(`selected simualtor ${t}`),n[1]}selectIosDevices(){let e=childProcess.execSync("xcrun simctl list").toString("utf-8").split("\n"),t=((e,t)=>{for(;t<e.length&&!e[t].match(/== Devices ==/);)t++;return t<e.length?t:-1})(e,0);return t<0?(console.error("can not find devices section!"),[]):((e,t)=>{let n=[];for(;!e[t].match(/-- iOS [^ ]* --/);)t++;if(e[t].indexOf("iOS")<0)return console.error("can not find iOS section!"),n;for(t++;e[t].startsWith(" ");)n.push(e[t++]);return n.map(e=>e.trim())})(e,t).filter(e=>e.startsWith("iPhone"))}readBundleId(){let e=this.projectName,t=fs.readdirSync(path.join(this.plugin.getBuildDir(),"CMakeFiles")).filter(t=>t.startsWith(e))[0],n=path.join(this.plugin.getBuildDir(),"CMakeFiles",t,"Info.plist");if(fs.existsSync(n)){let e=fs.readFileSync(n).toString("utf-8").split("\n");for(let t=0;t<e.length;t++)if(e[t].match(/CFBundleIdentifier/)){for(t++;!e[t].match(/<string>/);)t++;return e[t].match(/<string>([^<]*)<\/string>/)[1]}}else console.error(`Info.plist not found ${n}`);return null}queryIosDevice(){let e=childProcess.execSync("xcrun instruments -s devices").toString("utf-8").split("\n"),t=[];for(let n=1;n<e.length;n++)e[n].endsWith("(Simulator)")||e[n].match(/iPhone|iPad|iPod/)&&t.push(e[n]);return t.length>0?(console.log(`select ios device ${t[0]}`),t[0].match(/[^\[]]*\[([^\]]*)\]/)[1]):null}async runIosDevice(){let e=this.plugin.getBuildDir(),t=childProcess.execSync(`find ${e} -name "*.app"`).toString("utf-8").split("\n").filter(e=>e.trim().length>0),n=this.queryIosDevice();if(!n)return console.error("no connected device found!"),!1;if(t.length>0){let e=fs.mkdtempSync(path.join(os.tmpdir(),this.projectName));await cocosCli_1.cchelper.runCmd("xcrun",["instruments","-t","Blank","-w",n,t[0]],!1,e)}return!0}async runIosSimulator(){let e=this.selectSimulatorId(),t=this.plugin.getBuildDir(),n=this.readBundleId();console.log(` - build dir ${t} - simId ${e}`),console.log(` - bundle id ${n}`);let r=childProcess.execSync(`find ${t} -name "*.app"`).toString("utf-8").split("\n").filter(e=>e.trim().length>0);return r.length>0&&n&&(await cocosCli_1.cchelper.runCmd("xcrun",["simctl","boot",e],!0),await cocosCli_1.cchelper.runCmd("open",["`xcode-select -p`/Applications/Simulator.app"],!0),await cocosCli_1.cchelper.runCmd("xcrun",["simctl","boot",e],!0),await cocosCli_1.cchelper.runCmd("xcrun",["simctl","install",e,r[0].trim()],!1),await cocosCli_1.cchelper.runCmd("xcrun",["simctl","launch",e,`"${n}"`],!1)),!1}}class Win32RunCMD extends PlatformRunCmd{async run(){let e=path.join(this.plugin.getBuildDir(),this.plugin.args.debug?"Debug":"Release",`${this.plugin.args.projectName}.exe`);return fs.existsSync(e)?(await cocosCli_1.cchelper.runCmd(e,[],!1),!0):(console.error("exe file not found at",e),!1)}}class AndroidRunCMD extends PlatformRunCmd{async run(){return!!await this.install()&&await this.startApp()}getAdbPath(){return path.join(this.plugin.args.android.sdkPath,`platform-tools/adb${"win32"===process.platform?".exe":""}`)}getApkPath(){let e=this.plugin.args.debug?"debug":"release",t=`${this.plugin.args.projectName}-${e}.apk`;return path.join(this.plugin.projectDir,`proj/build/${this.plugin.args.projectName}/outputs/apk/${e}/${t}`)}async install(){let e=this.getApkPath(),t=this.getAdbPath();return fs.existsSync(e)?fs.existsSync(t)?(await this.checkApkInstalled()&&await cocosCli_1.cchelper.runCmd(t,["uninstall",this.plugin.args.android.packageName],!1),await cocosCli_1.cchelper.runCmd(t,["install",e],!1),!0):(console.error("can not find adb at",t),!1):(console.error("can not find apk at",e),!1)}async checkApkInstalled(){return(await new Promise((e,t)=>{let n=this.getAdbPath(),r=childProcess.spawn(n,["shell pm list packages | grep",this.plugin.args.android.packageName],{shell:!0,env:process.env,cwd:process.cwd()});r.stdout.on("data",t=>{e(t.toString())}),r.stderr.on("data",t=>{e("")}),r.on("close",(t,n)=>{e("")})})).includes(this.plugin.args.android.packageName)}async startApp(){let e=this.getAdbPath();return await cocosCli_1.cchelper.runCmd(e,["shell","am","start","-n",`${this.plugin.args.android.packageName}/com.cocos.game.AppActivity`],!1),!0}}