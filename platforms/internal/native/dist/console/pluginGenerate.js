"use strict";var __createBinding=this&&this.__createBinding||(Object.create?function(e,t,i,r){void 0===r&&(r=i),Object.defineProperty(e,r,{enumerable:!0,get:function(){return t[i]}})}:function(e,t,i,r){void 0===r&&(r=i),e[r]=t[i]}),__setModuleDefault=this&&this.__setModuleDefault||(Object.create?function(e,t){Object.defineProperty(e,"default",{enumerable:!0,value:t})}:function(e,t){e.default=t}),__importStar=this&&this.__importStar||function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var i in e)"default"!==i&&Object.prototype.hasOwnProperty.call(e,i)&&__createBinding(t,e,i);return __setModuleDefault(t,e),t};Object.defineProperty(exports,"__esModule",{value:!0}),exports.CCPluginGENERATE=void 0;const cocosCli_1=require("./cocosCli"),os=__importStar(require("os")),cocosConfig_1=require("./cocosConfig"),childProcess=__importStar(require("child_process")),afs_1=require("./afs"),default_1=require("./default"),path=__importStar(require("path")),fs=__importStar(require("fs-extra")),PackageNewConfig="cocos-project-template.json";class CCPluginGENERATE extends cocosCli_1.CCPlugin{depends(){return null}init(){return cocosConfig_1.cocosConfig.platforms.indexOf(this.getPlatform())<0&&console.error(`invalidate platform "${this.getPlatform()}"`),!0}async run(){let e=this.parser.platform;if(e)await this.generatePlatform(e);else{let e=cocosConfig_1.cocosConfig.defaultGeneratePlatforms[this.getCurrentPlatform()];for(let t of e)await this.generatePlatform(t)}return!0}async generatePlatform(e){let t=this.getCurrentPlatform();"ios-simulator"==e&&(e="ios",this.setPlatform(default_1.PLATFORM_ENUM.IOS),this.extendArgv(["--ios-simulator"]),this.args.ios.simulator=!0);let i=cocosConfig_1.cocosConfig.availableTargetPlatforms[t];i?i.indexOf(e)<0?console.error(`target platform "${e}" is not listed [${i.join(", ")}]`):"mac"===e?await this.generateMac():"ios"==e?await this.generateIos():"win32"==e?await this.generateWin32():"android"==e?await this.generateAndroid():"huawei-agc"==e&&await this.generateAndroid():console.error(`current host platform ${t} is not supported.`)}async generateAndroid(){console.log("generate android")}async generateIos(){await new IOSGenerateCMD(this).generate()}async generateMac(){await new MacGenerateCMD(this).generate()}async generateWin32(){await new Win32GenerateCMD(this).generate()}}exports.CCPluginGENERATE=CCPluginGENERATE;class PlatformGenerateCmd{constructor(e){this.plugin=e}get projectSrcDir(){return path.join(this.plugin.projectDir,"..",`common-${this.plugin.args.templateName}`)}appendCmakeResDirArgs(e){e.push(`-DRES_DIR="${cocosCli_1.cchelper.fixPath(this.plugin.projectDir)}"`)}}class IOSGenerateCMD extends PlatformGenerateCmd{async generate(){let e=this.plugin.getBuildDir(),t=path.join(this.plugin.platformTemplatePath,"CMakeLists.txt");if(!fs.existsSync(t))throw new Error(`CMakeLists.txt not found in ${t}`);fs.existsSync(e)||cocosCli_1.cchelper.makeDirectoryRecursive(e);let i=["-DCMAKE_CXX_COMPILER=clang++","-DCMAKE_C_COMPILER=clang"],r=this.plugin.getAppTeamId();r&&i.push(`-DDEVELOPMENT_TEAM=${r}`),this.appendCmakeResDirArgs(i);return await this.plugin.runCmake(["-S",`${this.plugin.platformTemplatePath}`,"-GXcode",`-B${e}`,"-DCMAKE_SYSTEM_NAME=iOS"].concat(i)),!0}}class MacGenerateCMD extends PlatformGenerateCmd{async generate(){let e=this.plugin.getBuildDir(),t=path.join(this.plugin.platformTemplatePath,"CMakeLists.txt");if(!fs.existsSync(t))throw new Error(`CMakeLists.txt not found in ${t}`);fs.existsSync(e)||cocosCli_1.cchelper.makeDirectoryRecursive(e);let i=["-S",`${this.plugin.platformTemplatePath}`,"-GXcode",`-B${e}`,"-DCMAKE_SYSTEM_NAME=Darwin"];return this.appendCmakeResDirArgs(i),await this.plugin.runCmake(i),!0}}class Win32GenerateCMD extends PlatformGenerateCmd{async win32SelectCmakeGeneratorArgs(){console.log("selecting visual studio generator ...");const e=cocosConfig_1.cocosConfig.cmake.win32.generators;let t=await afs_1.afs.mkdtemp(path.join(os.tmpdir(),"cmakeTest_")),i=path.join(t,"CMakeLists.txt"),r=path.join(t,"test.cpp");{let e="\n            cmake_minimum_required(VERSION 3.8)\n            set(APP_NAME test-cmake)\n            project(${APP_NAME} CXX)\n            add_library(${APP_NAME} test.cpp)\n            ",t='\n            #include<iostream>\n            int main(int argc, char **argv)\n            {\n                std::cout << "Hello World" << std::endl;\n                return 0;\n            }\n            ';await afs_1.afs.writeFile(i,e),await afs_1.afs.writeFile(r,t)}let a=(e,t)=>new Promise((i,r)=>{childProcess.spawn(this.plugin.getCmakePath(),e,{cwd:t,env:process.env,shell:!0}).on("close",(e,t)=>{i(0==e)})}),s=[];for(let i of e){let e=path.join(t,`build_${i.G.replace(/ /g,"_")}`),r=[`-S"${t}"`,`-G"${i.G}"`,`-B"${e}"`];if("A"in i&&r.push("-A",i.A),await afs_1.afs.mkdir(e),await a(r,e)){s.push(i.G);break}await cocosCli_1.cchelper.removeDirectoryRecursive(e)}await cocosCli_1.cchelper.removeDirectoryRecursive(t);let n=[];if(0==s.length)return[];let o=e.filter(e=>e.G==s[0])[0];for(let e in o)n.push(`-${e}"${o[e]}"`);return console.log(` using ${o.G}`),n}async generate(){let e=this.plugin.getBuildDir(),t=path.join(this.plugin.platformTemplatePath,"CMakeLists.txt");if(!fs.existsSync(t))throw new Error(`CMakeLists.txt not found in ${t}`);fs.existsSync(e)||cocosCli_1.cchelper.makeDirectoryRecursive(e);let i=this.plugin.getCmakeGenerator(),r=[];if(i){let e=cocosConfig_1.cocosConfig.cmake.win32.generators.filter(e=>e.G.toLowerCase()==i.toLowerCase());if(0==e.length)r.push(`-G"${i}"`);else{let t=e[0];for(let e of t)r.push(`-${e}"${t[e]}"`)}}else r=r.concat(await this.win32SelectCmakeGeneratorArgs());return this.appendCmakeResDirArgs(r),await this.plugin.runCmake([`-S"${cocosCli_1.cchelper.fixPath(this.plugin.platformTemplatePath)}"`,`-B"${cocosCli_1.cchelper.fixPath(e)}"`].concat(r)),!0}}