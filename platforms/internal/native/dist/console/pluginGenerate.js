"use strict";var __createBinding=this&&this.__createBinding||(Object.create?function(e,t,i,s){void 0===s&&(s=i),Object.defineProperty(e,s,{enumerable:!0,get:function(){return t[i]}})}:function(e,t,i,s){void 0===s&&(s=i),e[s]=t[i]}),__setModuleDefault=this&&this.__setModuleDefault||(Object.create?function(e,t){Object.defineProperty(e,"default",{enumerable:!0,value:t})}:function(e,t){e.default=t}),__importStar=this&&this.__importStar||function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var i in e)"default"!==i&&Object.prototype.hasOwnProperty.call(e,i)&&__createBinding(t,e,i);return __setModuleDefault(t,e),t};Object.defineProperty(exports,"__esModule",{value:!0}),exports.CCPluginGENERATE=void 0;const cocosCli_1=require("./cocosCli"),os=__importStar(require("os")),cocosConfig_1=require("./cocosConfig"),childProcess=__importStar(require("child_process")),afs_1=require("./afs"),default_1=require("./default"),path=__importStar(require("path")),fs=__importStar(require("fs-extra")),PackageNewConfig="cocos-project-template.json";class CCPluginGENERATE extends cocosCli_1.CCPlugin{depends(){return null}init(){return cocosConfig_1.cocosConfig.platforms.indexOf(this.getPlatform())<0&&console.error(`invalidate platform "${this.getPlatform()}"`),!0}async run(){const e=this.parser.platform;if(e)await this.generatePlatform(e);else{const e=cocosConfig_1.cocosConfig.defaultGeneratePlatforms[this.getCurrentPlatform()];for(const t of e)await this.generatePlatform(t)}return!0}async generatePlatform(e){const t=this.getCurrentPlatform();e===default_1.PLATFORM_ENUM.IOSSIMULATOR&&(e=default_1.PLATFORM_ENUM.IOS,this.setPlatform(default_1.PLATFORM_ENUM.IOS),this.extendArgv(["--ios-simulator"]),this.args.ios.simulator=!0);const i=cocosConfig_1.cocosConfig.availableTargetPlatforms[t];i?i.indexOf(e)<0?console.error(`target platform "${e}" is not listed [${i.join(", ")}]`):e===default_1.PLATFORM_ENUM.MAC?await this.generateMac():e===default_1.PLATFORM_ENUM.IOS?await this.generateIos():e===default_1.PLATFORM_ENUM.WINDOWS?await this.generateWindows():e===default_1.PLATFORM_ENUM.ANDROID?await this.generateAndroid():e===default_1.PLATFORM_ENUM["HUAWEI-AGC"]&&await this.generateAndroid():console.error(`current host platform ${t} is not supported.`)}async generateAndroid(){console.log("generate android")}async generateIos(){await new IOSGenerateCMD(this).generate()}async generateMac(){await new MacGenerateCMD(this).generate()}async generateWindows(){await new WindowsGenerateCMD(this).generate()}}exports.CCPluginGENERATE=CCPluginGENERATE;class PlatformGenerateCmd{constructor(e){this.plugin=e}get projectSrcDir(){return path.join(this.plugin.projectDir,"..",`common-${this.plugin.args.templateName}`)}appendCmakeResDirArgs(e){e.push(`-DRES_DIR="${cocosCli_1.cchelper.fixPath(this.plugin.projectDir)}"`)}async xcodeDestroyZEROCHECK(){const e=this.plugin.getBuildDir(),t=require("../../static/xcode"),i=fs.readdirSync(e).filter(e=>e.endsWith(".xcodeproj")).map(t=>path.join(e,t));if(0===i.length)console.error(`can not find xcode project file in ${e}`);else try{for(const e of i){const i=path.join(e,"project.pbxproj");console.log(`parsing pbxfile ${i}`);const s=t.project(i);await new Promise((e,t)=>{s.parse(i=>{if(i)return t(i);e(s)})}),console.log(`  modifiy Xcode project file ${i}`);{const e=path.join(this.plugin.projectDir,"assets"),t=s.hash.project.objects,i="Resources",o=Object.entries(t.PBXGroup).filter(([,e])=>e.name===i);let r=o[0][0];if(o.length>1){console.log("   multiple Resources/ group found!");const e=e=>{const t=e[1].children.filter(e=>e.comment.endsWith(".xcassets")).length>0,i=e[1].children.filter(e=>e.comment.indexOf(`CMakeFiles/${this.plugin.args.projectName}`)>-1).length>0;return console.log(`   ${e[0]} hasImageAsset ${t}, is final target ${i}`),100*(i?1:0)+10*(t?1:0)+e[1].children.length};r=o.sort((t,i)=>e(i)-e(t))[0][0],console.log(`   select ${r}`)}const n=e=>"."!==e&&".."!==e&&"remote"!==e;fs.readdirSync(e,{encoding:"utf8"}).filter(n).forEach(o=>{const n=path.normalize(path.join(e,o)),a={};fs.statSync(n).isDirectory()&&(a.lastKnownFileType="folder");{const e={fileRef:s.addFile(n,r,a).fileRef,uuid:s.generateUuid(),isa:"PBXBuildFile",basename:`${o}`,group:i};s.addToPbxBuildFileSection(e);const[c]=Object.entries(t.PBXResourcesBuildPhase).find(([e,t])=>e.endsWith("_comment")&&t===i),l=c.split("_comment")[0];t.PBXResourcesBuildPhase[l].files.push({value:e.uuid,comment:n})}})}{const e=s.hash.project.objects.PBXShellScriptBuildPhase,t=Object.keys(e),i=[];for(const s of t){const t=e[s];t.name&&t.name.indexOf("ZERO_CHECK")>0&&i.push(t)}i.forEach(e=>e.shellScript="\"echo 'Skip Xcode Update'\"")}fs.writeFileSync(i,s.writeSync()),console.log(`  replace pbxfile: ${i}.`)}}catch(e){console.error("disable ZERO_CHECK, failed to update xcode."),console.error(e)}}}class IOSGenerateCMD extends PlatformGenerateCmd{async generate(){const e=this.plugin.getBuildDir();if(this.plugin.args.ios.skipUpdateXcodeProject&&fs.existsSync(path.join(e,"CMakeCache.txt")))return console.log("Skip xcode project update"),!0;const t=path.join(this.plugin.platformTemplatePath,"CMakeLists.txt");if(!fs.existsSync(t))throw new Error(`CMakeLists.txt not found in ${t}`);fs.existsSync(e)||cocosCli_1.cchelper.makeDirectoryRecursive(e);const i=["-DCMAKE_CXX_COMPILER=clang++","-DCMAKE_C_COMPILER=clang"],s=this.plugin.getAppTeamId();s&&i.push(`-DDEVELOPMENT_TEAM=${s}`),this.appendCmakeResDirArgs(i);const o=this.plugin.getXcodeMajorVerion()>=12?"12":"1";return await this.plugin.runCmake(["-S",`${this.plugin.platformTemplatePath}`,"-GXcode",`-B${e}`,"-T",`buildsystem=${o}`,"-DCMAKE_SYSTEM_NAME=iOS"].concat(i)),this.plugin.args.ios.skipUpdateXcodeProject&&await this.xcodeDestroyZEROCHECK(),!0}}class MacGenerateCMD extends PlatformGenerateCmd{async generate(){const e=this.plugin.getBuildDir();if(this.plugin.args.mac.skipUpdateXcodeProject&&fs.existsSync(path.join(e,"CMakeCache.txt")))return console.log("Skip xcode project update"),!0;const t=path.join(this.plugin.platformTemplatePath,"CMakeLists.txt");if(!fs.existsSync(t))throw new Error(`CMakeLists.txt not found in ${t}`);fs.existsSync(e)||cocosCli_1.cchelper.makeDirectoryRecursive(e);const i=this.plugin.getXcodeMajorVerion()>=12?"12":"1",s=["-S",`${this.plugin.platformTemplatePath}`,"-GXcode","-T",`buildsystem=${i}`,`-B${e}`,"-DCMAKE_SYSTEM_NAME=Darwin"];return this.appendCmakeResDirArgs(s),await this.plugin.runCmake(s),this.plugin.args.mac.skipUpdateXcodeProject&&await this.xcodeDestroyZEROCHECK(),!0}}class WindowsGenerateCMD extends PlatformGenerateCmd{async windowsSelectCmakeGeneratorArgs(){console.log("selecting visual studio generator ...");const e=cocosConfig_1.cocosConfig.cmake.windows.generators,t=await afs_1.afs.mkdtemp(path.join(os.tmpdir(),"cmakeTest_")),i=path.join(t,"CMakeLists.txt"),s=path.join(t,"test.cpp");{const e="\n            cmake_minimum_required(VERSION 3.8)\n            set(APP_NAME test-cmake)\n            project(${APP_NAME} CXX)\n            add_library(${APP_NAME} test.cpp)\n            ",t='\n            #include<iostream>\n            int main(int argc, char **argv)\n            {\n                std::cout << "Hello World" << std::endl;\n                return 0;\n            }\n            ';await afs_1.afs.writeFile(i,e),await afs_1.afs.writeFile(s,t)}const o=(e,t)=>new Promise((i,s)=>{childProcess.spawn(this.plugin.getCmakePath(),e,{cwd:t,env:process.env,shell:!0}).on("close",(e,t)=>{i(0===e)})}),r=[];for(const i of e){const e=path.join(t,`build_${i.G.replace(/ /g,"_")}`),s=[`-S"${t}"`,`-G"${i.G}"`,`-B"${e}"`];if(s.push("-A",this.plugin.args.win.targetPlatform),await afs_1.afs.mkdir(e),await o(s,e)){r.push(i.G);break}await cocosCli_1.cchelper.removeDirectoryRecursive(e)}await cocosCli_1.cchelper.removeDirectoryRecursive(t);const n=[];if(0===r.length)return[];const a=e.filter(e=>e.G===r[0])[0];return n.push("-A",this.plugin.args.win.targetPlatform),console.log(` using ${a.G}`),n}async generate(){const e=this.plugin.getBuildDir(),t=path.join(this.plugin.platformTemplatePath,"CMakeLists.txt");if(!fs.existsSync(t))throw new Error(`CMakeLists.txt not found in ${t}`);fs.existsSync(e)||cocosCli_1.cchelper.makeDirectoryRecursive(e);let i=[];if(!fs.existsSync(path.join(e,"CMakeCache.txt"))){const e=this.plugin.getCmakeGenerator();if(e){const t=cocosConfig_1.cocosConfig.cmake.windows.generators.filter(t=>t.G.toLowerCase()===e.toLowerCase());if(0===t.length)i.push(`-G"${e}"`);else{t[0];i.push("-A",this.plugin.args.win.targetPlatform)}}else i=i.concat(await this.windowsSelectCmakeGeneratorArgs());this.appendCmakeResDirArgs(i)}return await this.plugin.runCmake([`-S"${cocosCli_1.cchelper.fixPath(this.plugin.platformTemplatePath)}"`,`-B"${cocosCli_1.cchelper.fixPath(e)}"`].concat(i)),!0}}