"use strict";Object.defineProperty(exports,"__esModule",{value:!0});const fs_extra_1=require("fs-extra"),path_1=require("path"),out_path=(0,path_1.join)(Editor.App.path,"builtin/importer/creator/components");exports.ready=function(){},exports.close=function(){};const RENAME_COMPONENT={"cc.BoxCollider":"cc.BoxCollider2D","cc.BoxCollider3D":"cc.BoxCollider","cc.CircleCollider":"cc.CircleCollider2D","cc.Collider":"cc.Collider2D","cc.Collider3D":"cc.Collider","cc.DistanceJoint":"cc.DistanceJoint2D","cc.ClickEvent":"cc.EventHandler","cc.MouseJoint":"cc.MouseJoint2D","cc.WheelJoint":"cc.WheelJoint2D","cc.PolygonCollider":"cc.PolygonCollider2D","cc.ParticleSystem":"cc.ParticleSystem2D","cc.ParticleSystem3D":"cc.ParticleSystem","cc.Joint":"cc.Joint2D","cc.RenderComponent":"cc.RenderableComponent","cc.RigidBody":"cc.RigidBody2D","cc.RigidBody3D":"cc.RigidBody","cc.SphereCollider3D":"cc.SphereCollider"},CLASS=["AnimationCurve","Keyframe","GradientRange","Gradient","Burst","ShapeModule","ColorOvertimeModule","SizeOvertimeModule","TrailMode","VelocityOvertimeModule","ForceOvertimeModule","LimitVelocityOvertimeModule","RotationOvertimeModule","TextureAnimationModule","TrailModule","ColorKey","AlphaKey"];exports.methods={onSerializeComponent(){const e=new Map,n=[],c=require("cc");for(const o in c){const t=c[o];c.CCClass._isCCClass(t)&&!n.includes(t.name)&&(e.set(t.name,t),n.push(t.name))}for(const o of CLASS){const t=c.js.getClassByName(o);c.CCClass._isCCClass(t)&&!n.includes(t.name)?(e.set(t.name,t),n.push(t.name)):console.log(o)}n.sort();for(let c=0;c<n.length;++c){const o=n[c],t=e.get(o);try{const e=EditorExtends.serialize(new t),n=JSON.parse(e);delete n._id,Array.isArray(n)&&n.forEach(e=>{delete e._id});let c="'use strict';\n";const o=t.name.toUpperCase();c+=`export const ${o} = ${JSON.stringify(n,null,4)};\n\n`,c+=`export class ${t.name} {\n\n`,c+="    static create() {\n",c+=`        return JSON.parse(JSON.stringify(${o}));\n`,c+="    }\n\n",c+="    static async migrate(json2D: any) {\n",c+=`        const source = JSON.parse(JSON.stringify(${o}));\n`,c+="        for (const key in json2D) {\n",c+="            let value = json2D[key];\n",c+="            if (value === undefined || value === null) { continue; }\n",c+="            source[key] = value;\n",c+="        }\n",c+="        return source;\n",c+="    }\n\n",c+="    static async apply(index: number, json2D: any, json3D: any) {\n",c+=`        let source = await ${t.name}.migrate(json2D[index]);\n`,c+="        json3D.splice(index, 1, source);\n",c+="        return source;\n",c+="    }\n",c+="}\n";const r=(0,path_1.join)(out_path,t.name+".ts");(0,fs_extra_1.existsSync)(r)||((0,fs_extra_1.ensureDirSync)(out_path),(0,fs_extra_1.writeFileSync)(r,c))}catch(e){console.error(e)}}}};