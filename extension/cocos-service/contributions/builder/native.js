const _0x1544=["huawei-agc","createFileSync","forEach","join","match","fs-extra","defineProperty","insertServiceCmakeToCmakeList","existsSync","readFileSync","writeFileSync","android","replace","proj/service.cmake","engine/","shift","Post-service.cmake","push","__esModule","# Supported for Cocos Service!\n# insert source files\n#_SRC_\n# insert library files\nFunction(service_insert_library)\n    #_LIB_\nendfunction(service_insert_library)","path","/CMakeLists.txt","Pre-service.cmake","generatePostAndPreServiceCamke","dirname","use strict","ios"];!function(e,_){!function(_){for(;--_;)e.push(e.shift())}(++_)}(_0x1544,160);const _0x201b=function(e,_){return _0x1544[e-=359]},_0x3bf579=_0x201b,_0x17a9=[_0x3bf579(375),"huawei-agc","createFileSync",_0x3bf579(384),_0x3bf579(368),_0x3bf579(369),_0x3bf579(372),_0x3bf579(383),"utf8",_0x3bf579(363),"# Supported for Cocos Service!",_0x3bf579(370),_0x3bf579(377),_0x3bf579(366),_0x3bf579(364),_0x3bf579(373),_0x3bf579(371),_0x3bf579(365),_0x3bf579(380),"generateServiceCamke",_0x3bf579(381),_0x3bf579(385),_0x3bf579(374),_0x3bf579(367),"\n# -------------- SRART ---------------\n# USED BY COCOS SERVICE, DON'T REMOVE!\nif(COMMAND service_insert_library)\n    service_insert_library()\nendif()\n# --------------  END ----------------\n\n",_0x3bf579(382)];!function(e,_){!function(_){const t=_0x201b;for(;--_;)e[t(378)](e[t(376)]())}(++_)}(_0x17a9,409);const _0x4902=function(e,_){return _0x17a9[e-=490]},_0x4ac1df=_0x4902;_0x3bf579(359),Object[_0x4ac1df(494)](exports,_0x3bf579(379),{value:!0}),exports[_0x3bf579(368)]=exports[_0x4ac1df(500)]=exports[_0x4ac1df(490)]=void 0;const fs_extra_1=require(_0x4ac1df(510)),path_1=require(_0x4ac1df(491));function _insertCodeLine(e,_,t,r=!1){const n=_0x4ac1df;if(!fs_extra_1[_0x3bf579(369)](e))return;let i=fs_extra_1.readFileSync(e,n(505));null!==i[n(514)](_)&&fs_extra_1[n(513)](e,i[n(512)](_,r?t+"$1":"$1"+t))}function _replaceContent(e,_,t){const r=_0x3bf579,n=_0x4ac1df;if(!fs_extra_1.existsSync(e))return;let i=fs_extra_1[n(508)](e,n(505));null!==i[n(514)](_)&&fs_extra_1[n(513)](e,i[r(373)](_,t))}function _checkFileContent(e,_){const t=_0x3bf579,r=_0x4ac1df;if(fs_extra_1[r(502)](e))return null!==fs_extra_1[r(508)](e,"utf8")[t(365)](_)}function _insertServiceCmakeToCmakeList(e,_,t){const r=_0x3bf579,n=_0x4ac1df;do{if(!fs_extra_1[r(369)](e))break;_insertCodeLine(e,_,"\n# -------------- SRART ---------------\n# USED BY COCOS SERVICE, DON'T REMOVE!\nif(EXISTS ${RES_DIR}/proj/service.cmake)\n    set(SERVICE_NATIVE_DIR ${CMAKE_CURRENT_LIST_DIR})\n    include(${RES_DIR}/proj/service.cmake)\nendif()\n# --------------  END ----------------\n\n",!0),_insertCodeLine(e,t,n(495),!0)}while(0)}function generateServiceCamke(e){const _=_0x3bf579,t=_0x4ac1df;let r=path_1[_(364)](e,t(493));fs_extra_1[_(369)](path_1[t(492)](r))&&!fs_extra_1[t(502)](r)&&(fs_extra_1[t(499)](r),fs_extra_1[t(513)](r,t(515)))}function generatePostAndPreServiceCamke(e){const _=_0x4ac1df;[_(503),_(498),"ios"][_(506)](t=>{const r=_0x201b,n=_;let i=path_1[n(511)](e,r(375)+t),a=path_1[n(511)](i,n(504));if(!fs_extra_1[n(502)](path_1[n(492)](a))||fs_extra_1[n(502)](a))return;let f=n(507);fs_extra_1[n(499)](a),fs_extra_1[n(513)](a,f);let s=path_1[n(511)](i,n(509));fs_extra_1.existsSync(path_1[n(492)](s))&&!fs_extra_1[n(502)](s)&&(fs_extra_1[r(362)](s),fs_extra_1[n(513)](s,f))})}function insertServiceCmakeToCmakeList(e){const _=_0x3bf579,t=_0x4ac1df;[t(503),_(361),_(360)][_(363)](_=>{const r=t;let n=path_1[r(511)](e,r(497)+_+r(496));_checkFileContent(n,/proj\/service.cmake/)||_insertServiceCmakeToCmakeList(n,/(list\(APPEND PROJ_SOURCES|add_library)/,/(target_link_libraries\(\${LIB_NAME})/)})}exports[_0x4ac1df(490)]=generateServiceCamke,exports[_0x3bf579(384)]=generatePostAndPreServiceCamke,exports[_0x4ac1df(501)]=insertServiceCmakeToCmakeList;