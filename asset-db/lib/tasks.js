"use strict";const e=require("fire-fs"),t=require("fire-path"),i=require("async"),a=require("fast-glob"),r=require("minimatch"),n=require("del"),o=require("lodash"),{v4:s}=require("node-uuid"),{shell:u}=require("electron"),l=require("./meta"),d=require("os").cpus().length,h={onlyFiles:!1,absolute:!0},c="win32"===process.platform;let f={};function m(e){return c?Array.isArray(e)?e.map(e=>e.replace(/\\/g,"/")):e.replace(/\\/g,"/"):e}function p(e){return c?Array.isArray(e)?e.map(e=>e.replace(/\//g,"\\")):e.replace(/\//g,"\\"):e}async function y(e,r,o){let s=e._uuidToImportPathNoExt(r);try{s=s.replace(/\\/g,"/"),await n([s,s+".*"],{force:!0})}catch(e){return o(e)}i.series([e=>{let i=t.dirname(s),r=t.join(i,"**/*"),u=[];try{r=m(r),u=a.sync(r,h)}catch(e){return o&&o(e),void 0}0===(u=p(u)).length?n(i.replace(/\\/g,"/"),{force:!0}).then(t=>{e()},e):e()},t=>{let a=e.subAssetInfosByUuid(r);i.each(a,(t,i)=>{y(e,t.uuid,i)},i=>{i&&e.failed(`Fail to delete imported files for sub assets of ${r}: ${i.stack}`),t()})}],e=>{o&&o(e)})}function v(t,i){let a=t._metaToAssetPath(i);return!e.existsSync(a)&&(t.info(`remove unused meta: ${t._url(i)}`),e.unlinkSync(i),!0)}function g(i,a,r){if(!i.metaBackupPath)return null;if("boolean"!=typeof r&&(r=!1),r||!e.existsSync(i._metaToAssetPath(a))){let r=i.getRelativePath(a),n=t.normalize(t.join(i.metaBackupPath,r)),o=t.dirname(n);return e.ensureDirSync(o),e.copySync(a,n),e.unlinkSync(a),i.warn(`Backup unused meta file: ${i._url(a)}`),r}return null}function $(r,n){let o=/\S{8}-\S{4}-\S{4}-\S{4}-\S{12}/,s=[];try{const e=m(t.join(r._importPath,"**/*"));s=a.sync(e,h)}catch(e){return n&&n(e),void 0}i.each(s,(t,i)=>{if(t=p(t),e.isDirSync(t))return i(),void 0;let a=o.exec(t);return a?(a=a[0],void 0!==r._uuid2path[a]?(i(),void 0):(r.log(`remove unused import file ${a}`),y(r,a,e=>{e&&r.failed(`Failed to remove import file ${a}, message: ${e.stack}`),i()}),void 0)):(i(),void 0)},e=>{n&&n(e)})}function b(t,a){let r=Object.keys(t._uuid2mtime);i.each(r,(i,a)=>{let r=t.uuidToFspath(i);e.existsSync(r)||(delete t._uuid2mtime[i],t.log(`remove unused mtime info: ${i}`)),a()},e=>{a&&a(e)})}function _(i,r,n,o){"function"==typeof n&&(o=n,n=null),"boolean"!=typeof(n=n||{})["remove-unused-meta"]&&(n["remove-unused-meta"]=!0),"boolean"!=typeof n["filter-meta"]&&(n["filter-meta"]=!0);let s=r,u=[],l=[],d=!1;try{d=e.statSync(r).isDirectory()}catch(e){if(n["remove-unused-meta"])v(i,r);else{let e=g(i,r);e&&l.push(e)}return o&&(i._handleMetaBackupResults(l),o(null,[])),void 0}d&&(s=[t.join(r,"**/*")]);let c=[];try{s=m(s),c=a.sync(s,h)}catch(e){return o&&o(e),void 0}(c=p(c)).includes(r)||c.unshift(r);for(let e=0;e<c.length;e++){let a=c[e];if(!i._isMountPath(a))if(".meta"===t.extname(a)&&n["filter-meta"])if(n["remove-unused-meta"])v(i,a);else{let e=g(i,a);e&&l.push(e)}else u.push(a)}o&&(i._handleMetaBackupResults(l),o(null,u))}function S(t,i,a){if(t._isMountPath(i))return a&&a(null,!1),void 0;let r=t.fspathToUuid(i);if(!r)return a&&a(null,!0),void 0;let n,o=i+".meta";try{n=e.readJsonSync(o)}catch(e){return a&&a(null,!0),void 0}let s=l.load(t,o,n);if(s.ver!==s.constructor.version())return a(null,!0),void 0;let u=s.getSubMetas();for(let e in u){let t=u[e];if(t.ver!==t.constructor.version())return a(null,!0),void 0}let d=s.dests();for(let t=0;t<d.length;++t)if(!e.existsSync(d[t]))return a&&a(null,!0),void 0;let h=t._uuid2mtime[r];if(h){let r=e.statSync(i);if(h.asset!==r.mtime.getTime())return a&&a(null,!0),void 0;let n=e.statSync(i+".meta");if(h.meta!==n.mtime.getTime())return a&&a(null,!0),void 0;let o=t.getRelativePath(i);return h.relativePath!==o?(a&&a(null,!0),void 0):(a&&a(null,!1),void 0)}a&&a(null,!0)}function w(i,r,n,o,u){let d=r;e.isDirSync(r)&&(d=t.join(r,"**/*"),i._isMountPath(r)||(d=[r,d]));let c=[],f=[];try{d=m(d),f=a.sync(d,h)}catch(e){return u&&u(e),void 0}for(let a=0;a<f.length;a++){let r,u=p(f[a]);if(".meta"===t.extname(u)){o&&v(i,u);continue}let d,h=u+".meta";try{let a=e.readJsonSync(h);if(!(r=l.load(i,h,a)).uuid||i._uuid2path[r.uuid]){const e=s();i.warn(`uuid collision, the uuid(${r.uuid}) for ${u} is already used. A new uuid(${e}) will be assigned.`),r.uuid=e,l.save(i,h,r)}if(i._dbAdd(u,r.uuid),r){c.push({assetpath:u,meta:r});let e=r.getSubMetas();if(e)for(let a in e){let n=e[a],o=t.join(u,a);if(i._uuid2path[n.uuid]){const e=s();i.warn(`uuid collision, the uuid(${n.uuid}) for ${o} is already used. A new uuid(${e}) will be assigned.`),n.uuid=e,l.save(i,h,r)}i._dbAdd(o,n.uuid),c.push({assetpath:o,meta:n})}continue}}catch(e){}n&&(d=n[u]),r=l.create(i,h,d),i._dbAdd(u,r.uuid),l.save(i,h,r),c.push({assetpath:u,meta:r})}u&&u(null,c)}function P(a,r,n){let o,s=!1,u=r+".meta";try{o=e.readJsonSync(u)}catch(e){}let h=l.load(a,u,o);if(!h&&(h=l.create(a,u),s=!0,!h))return n&&n(new Error(`Can not create or load meta from ${r}`)),void 0;if(a.isSubAssetByPath(r))return n&&n(null,h),void 0;let c=h.constructor.version();h.ver!==c&&(h.ver=c,s=!0);let f=h.copySubMetas(),m={};i.series([e=>{if(h.import)try{a.log(`import asset ${r}...`),h.import(r,t=>{m=h.getSubMetas()||{},s=!0,e(t)})}catch(t){e(t)}else e()},e=>{let t=Object.keys(f);for(let e=0;e<t.length;++e){let i=t[e],r=f[i],n=a.uuidToFspath(r.uuid);a._dbDelete(n)}t=Object.keys(m);for(let e=0;e<t.length;++e){let i=t[e],a=m[i];f[i]&&(a.uuid=f[i].uuid)}e()},e=>{let n=Object.keys(m);i.eachLimit(n,d,(e,i)=>{let n=t.join(r,e),o=m[e],u=o.constructor.version();o.ver!==u&&(o.ver=u),o.import?o.import(n,function(e){if(e)return i(e),void 0;s=!0,a._dbAdd(n,o.uuid),i()}):(a._dbAdd(n,o.uuid),i())},t=>{e(t)})}],e=>{if(e)return n&&n(e),void 0;s&&l.save(a,u,h),n&&n(null,h)})}function M(e,a,r){a.path||r(new Error("Incomplete asset info: no path included"));let n=!1,o=a.path,s=o+".meta",u=a.meta||l.get(e,e.fspathToUuid(o)),h=a.isSubAsset||e.isSubAssetByPath(o);if(!u||h)return r&&r(null,u),void 0;i.series([t=>{if(u.postImport)try{e.log("post-import asset "+o+"..."),u.postImport(o,e=>{n=!0,t(e)})}catch(e){t(e)}else t()},e=>{let a=u.getSubMetas(),r=Object.keys(a);i.eachLimit(r,d,i.ensureAsync((e,i)=>{let r=t.join(o,e),s=a[e];s.postImport?s.postImport(r,function(){n=!0,i()}):i()}),t=>{e(t)})}],t=>{if(t)return r&&r(t),void 0;n&&l.save(e,s,u),r&&r(null,u)})}function T(e,i,a,r){let n=t.dirname(i),o=e.fspathToUuid(n),s=e.mountInfoByPath(i);r.push({uuid:a.uuid,parentUuid:o,url:e._url(i),path:i,type:a.assetType(),hidden:!!s.hidden,readonly:!!s.readonly});let u=a.getSubMetas();if(u)for(let n in u){let o=u[n],l=t.join(i,n);r.push({uuid:o.uuid,parentUuid:a.uuid,url:e._url(l),path:l,type:o.assetType(),isSubAsset:!0,hidden:!!s.hidden,readonly:!!s.readonly})}}function A(e,t,a,r){Array.isArray(t)||(t=[t]);let n=[];for(var o=0,s=t.length;o<s;o++)e.isSubAssetByPath(t[o])||n.push(t[o]);i.waterfall([t=>{let a=[];i.eachSeries(n,(t,i)=>{e.log(`scan ${t}...`),_(e,t,{"remove-unused-meta":!1},(e,t)=>{if(e)return i(),void 0;a=function(e,t){let i=e.concat(t),a=[],r={};for(let e of i)r[e]||(a.push(e),r[e]=1);return a}(a,t),i()})},()=>{t(null,a)})},(t,r)=>{if(a)return r(null,t),void 0;e.log("check if reimport...");let n=[];i.each(t,i.ensureAsync((t,i)=>{S(e,t,(a,r)=>{if(a)return e.failed(`Failed to check if reimport for ${t}, message: ${a.stack}`),i(),void 0;r&&n.push(t),i()})}),e=>{r(e,n)})},(t,a)=>{e.log("reimport assets...");let r=[];i.eachLimit(t,d,i.ensureAsync((t,i)=>{P(e,t,(a,n)=>{if(a)return e.failed(`Failed to import asset ${t}, message: ${a.stack}`),r.push({path:t,url:e._url(t),uuid:e.fspathToUuid(t),error:a}),i(),void 0;T(e,t,n,r),i()})}),e=>{a(e,r)})},(t,a)=>{e.log("post import assets..."),i.eachLimit(t,d,i.ensureAsync((t,i)=>{if(t.isSubAsset)return i(),void 0;M(e,t,(a,r)=>{if(a)return e.failed(`Failed to post import asset ${t.path}, message: ${a.stack}`),i(),void 0;r&&e.updateMtime(r.uuid),i()})}),e=>{a(e,t)})}],(e,t)=>{r&&r(e,t)})}function x(e,i,a){let r=i.getSubMetas()||{},n=e.uuidToFspath(i.uuid),o=[],s=[],u=[],l=Object.keys(a);for(let e=0;e<l.length;++e){let i=l[e],s=a[i];r[i]||o.push({uuid:s.uuid,path:t.join(n,i),type:s.assetType()})}l=Object.keys(r);for(let o=0;o<l.length;++o){let d=l[o],h=r[d],c=t.join(n,d);if(a[d])u.push({uuid:h.uuid,parentUuid:i.uuid,path:c,url:e.uuidToUrl(h.uuid),type:h.assetType(),isSubAsset:!0});else{let t=e.mountInfoByUuid(h.uuid);s.push({uuid:h.uuid,parentUuid:i.uuid,path:c,url:e.uuidToUrl(h.uuid),type:h.assetType(),isSubAsset:!0,hidden:!!t.hidden,readonly:!!t.readonly})}}return{deleted:o,added:s,remained:u}}module.exports=f,f.mount=function(i,a,r,n,s){if("string"!=typeof a)return s&&s(new Error("expect 1st param to be a string")),void 0;if(!e.isDirSync(a))return s&&s(new Error(`Failed to mount ${a}, path not found or it is not a directory!`)),void 0;if("string"!=typeof r)return s&&s(new Error("Expect 2nd param to be a string")),void 0;(function(e,i,a){/[\\/.]/.test(a)&&e.throw("normal",`Invalid character in ${a}, you can not contains '/', '\\' or '.'`),e._mounts[a]&&e.throw("normal",`Failed to mount ${i} to ${a}, already exists!`);for(let r in e._mounts){let n=e._mounts[r];t.contains(n.path,i)&&e.throw("normal",`Failed to mount ${i} to ${a}, the path or its parent ${n.path} already mounted to ${r}`),t.contains(i,n.path)&&e.throw("normal",`Failed to mount ${i} to ${a}, its child path ${n.path} already mounted to ${r}`)}})(i,a=t.resolve(a),r);let u={path:a,mountPath:r,attached:!1};o.assign(u,n),i._mounts[r]=u,i._dbAdd(a,i._mountIDByMountPath(r)),s&&s()},f.unmount=function(e,t,i){return"string"!=typeof t?(i&&i(new Error("expect 1st param to be a string")),void 0):e._mounts[t]?(e._dbDelete(e._mounts[t].path),delete e._mounts[t],i&&i(),void 0):(i&&i(new Error("can not find the mount "+t)),void 0)},f.init=function(e,t){let a=Object.keys(e._mounts),r=[];i.series([t=>{i.eachSeries(a,(t,i)=>{f.attachMountPath(e,t,(e,t)=>{r=r.concat(t),i()})},t)},t=>{$(e,i=>{i&&e.failed(`Failed to remove unused import files, message: ${i.stack}`),t()})},t=>{b(e,i=>{i&&e.failed(`Failed to remove unused mtime info, message: ${i.stack}`),e.updateMtime(),t()})}],e=>{t&&t(e,r)})},f.attachMountPath=function(e,t,a){var r=[],n=e._mounts[t];return n?n.attached?(e.log(`db://${t} already attached!`),a(null,r),void 0):(r.push({name:t,path:n.path,url:e._url(n.path),uuid:e._mountIDByMountPath(t),hidden:!!n.hidden,readonly:!!n.readonly,type:"mount"}),i.series([i=>{let a=e._mounts[t].path;e.log(`init meta files at db://${t}`),w(e,a,null,!1,(e,t)=>{i()})},i=>{let a=e._mounts[t].path;e.log(`refresh at db://${t}`),A(e,a,!1,(a,n)=>{if(a)return e.failed(`Failed to refresh db://${t}`),i(),void 0;e._handleErrorResults(n),r=r.concat(n),i()})}],i=>{r.forEach(e=>{e.command="create"}),e._mounts[t].attached=!0,a&&a(i,r)}),void 0):(e.failed(`db://${t} is not a mount path.`),a(new Error(`${t} is not a valid mount path. Please mount it first.`)),void 0)},f.unattachMountPath=function(e,a,r){var n=[],o=e._mounts[a];if(!o)return e.failed(`db://${a} is not a mount path.`),r(new Error(`${a} is not a valid mount path.`)),void 0;if(!o.attached)return e.log(`db://${a} has not been attached!`),r(null,n),void 0;var s=e._allPaths(),u=t.resolve(o.path);i.waterfall([t=>{i.eachLimit(s,3,(t,i)=>{0===t.indexOf(u)&&(n.push({path:t,url:e._url(t),uuid:e.fspathToUuid(t),command:"delete"}),e._dbDelete(t)),i()},t)},t=>{$(e,i=>{i&&e.failed(`Failed to remove unused import files, message: ${i.stack}`),t()})},t=>{b(e,i=>{i&&e.failed(`Failed to remove unused mtime info, message: ${i.stack}`),e.updateMtime(),t()})}],t=>{e._mounts[a].attached=!1,r&&r(t,n)})},f.refresh=function(a,r,n){let o=[],s={};for(let e in a._path2uuid)s[e]=a._path2uuid[e];Array.isArray(r)||(r=[r]),r=(r=r.map((e,i)=>{if(a._isAssetPath(e))return e;a.isSubAssetByPath(e)&&(e=t.dirname(e));let r=e,n=t.dirname(e);for(;n&&!a._path2uuid[n];)(r=n)===(n=t.dirname(n))&&(r=n=void 0,a.failed(`Failed to refresh path: ${e}`));return r})).filter(Boolean),i.waterfall([e=>{let t=[];i.eachSeries(r,(e,i)=>{if(!a.fspathToUuid(e))return i(),void 0;f.clearImports(a,e,s,(e,a)=>{if(e)return i(),void 0;t=t.concat(a),i()})},()=>{e(null,t)})},(t,i)=>{t.forEach(t=>{let i=t.path+".meta";e.existsSync(t.path)||(t.command="delete",o.push(t),e.existsSync(i)&&e.unlinkSync(i))}),i()},e=>{let t=[];i.eachSeries(r,(e,i)=>{if(t.includes(e))return i(),void 0;w(a,e,s,!1,(e,r)=>{r.forEach(e=>{t.push(e.assetpath);let i=a._path2uuid[e.assetpath],r=a._uuid2path[e.meta.uuid];!i||i!==e.meta.uuid||!r||r!==e.assetpath}),i()})},e)},e=>{A(a,r,!0,e)}],(e,t)=>{if(e)return n&&n(e),void 0;t.forEach(e=>{let t=s[e.path],i=a.fspathToUuid(e.path);for(let e=0;e<o.length;++e)if(i===o[e].uuid){o.splice(e,1);break}if(t)t!==i?(e.command="uuid-change",e.oldUuid=t):e.command="change";else{e.command="create";let t=a.mountInfoByUuid(i);e.hidden=!!t.hidden,e.readonly=!!t.readonly}}),o=o.concat(t),n&&n(null,o)})},f.deepQuery=function(e,i){let a=[],r=Object.keys(e._path2uuid);r.sort((e,t)=>e.length-t.length);for(let i=0;i<r.length;++i){let n,o,s,u=r[i],d=e._path2uuid[u],h=e._path2uuid[t.dirname(u)],c=e.isSubAssetByPath(u);o=t.extname(u);let f=e.mountInfoByPath(u);if(e.isMountByPath(u))n=t.basenameNoExt(f.mountPath),s="mount";else{"folder"===(s=l.get(e,e.fspathToUuid(u)).assetType())?(n=t.basename(u),o=""):n=t.basenameNoExt(u)}let m={uuid:d,parentUuid:h,name:n,extname:o,type:s,isSubAsset:c,hidden:!!f.hidden,readonly:!!f.readonly};a.push(m)}i&&i(null,a)},f.queryAssets=function(e,t,i,a){let n=[],o=Object.keys(e._path2uuid),s=o;t&&(s=r.match(o,t)),"string"==typeof(i=i||[])&&(i=[i]);for(let t=0;t<s.length;++t){let a=s[t],r=e._path2uuid[a],o=e.isSubAssetByPath(a),u=l.get(e,r);if(!u)continue;let d=u.assetType();if(i.length&&-1===i.indexOf(d))continue;let h=e.mountInfoByPath(a),c={url:e._url(a),path:a,uuid:r,type:d,readonly:!!h.readonly,hidden:!!h.hidden,isSubAsset:o,destPath:e._getDestPathByMeta(u)};n.push(c)}n.sort((e,t)=>e.path.localeCompare(t.path)),a&&a(null,n)},f.queryMetas=function(e,t,i,a){let n=[],o=Object.keys(e._path2uuid);t&&(o=r.match(o,t));for(let t=0;t<o.length;++t){let a=o[t],r=l.get(e,e.fspathToUuid(a));if(!r){e._isMountPath(a)||console.warn(`Meta ${a} is not exists`);continue}let s=r.assetType();i&&s!==i||n.push(r)}a&&a(null,n)},f.import=function(a,r,n,o){if(a.mountInfoByPath(n).readonly){let e=a.fspathToUrl(n);return o&&o(new Error(`${e} is readonly, CAN NOT import assets into it in Editor.`)),void 0}var s=null,u=[];i.waterfall([i=>{(function(i,a,r,n){if(!e.isDirSync(r))return n&&n(new Error("Invalid dest path, make sure it exists and it is a directory")),void 0;function o(a){return i._isAssetPath(a)?(i.failed(`Can not import file ${a}, already in the database`),-1):e.existsSync(t.join(r,t.basename(a)))?0:1}a.map(e=>t.basename(e)),a=i.arrayCmpFilter(a,(e,i)=>t.contains(e,i)?1:t.contains(i,e)?-1:0);for(var s=[],u=[],l=0;l<a.length;l++){let e=a[l];var d=o(e);d>0?s.push(e):0===d&&u.push(e)}n&&n(null,{importFiles:s,mergeFiles:u})})(a,r,n,(e,t)=>{s=t,i(e)})},r=>{let o={importFiles:[],mergeFiles:[]},u=s.importFiles.concat(s.mergeFiles);i.each(u,(i,r)=>{let u=t.basename(i);a.log(`copy file ${u}...`);let l=t.join(n,u),d=s.mergeFiles.indexOf(i)>=0;e.copy(i,l,e=>{if(e)return a.failed(`Failed to copy file ${i}. ${e}`),r(),void 0;d?o.mergeFiles.indexOf(l)<0&&o.mergeFiles.push(l):o.importFiles.indexOf(l)<0&&o.importFiles.push(l),r()})},e=>{r(e,o)})},(e,t)=>{if(0===e.mergeFiles.length)return t(null,e.importFiles),void 0;f.refresh(a,e.mergeFiles,(i,r)=>{if(i)return a.failed(`Failed to refresh assets ${e.mergeFiles}, message: ${i.stack}`),t(null,e.importFiles),void 0;u=u.concat(r),t(null,e.importFiles)})},(e,t)=>{let r=[];a.log("init metas..."),i.each(e,(e,t)=>{w(a,e,null,!0,(e,i)=>{i.forEach(e=>{a.isSubAssetByPath(e.assetpath)||r.push(e.assetpath)}),t()})},e=>{t(e,r)})},(e,t)=>{a.log("import assets...");let r=[];i.eachLimit(e,d,(e,t)=>{P(a,e,(i,n)=>{if(i)return a.failed(`Failed to import asset ${e}, message: ${i.stack}`),t(),void 0;T(a,e,n,r),t()})},e=>{t(e,r)})},(e,t)=>{a.log("post import assets..."),i.eachLimit(e,d,(e,t)=>{if(e.isSubAsset)return t(),void 0;M(a,e,(i,r)=>{if(i)return a.failed(`Failed to post import asset ${e.path}, message: ${i.stack}`),t(),void 0;t()})},i=>{t(i,e)})},(e,t)=>{e.forEach(e=>{a.updateMtime(e.uuid)}),e.sort((e,t)=>e.path.localeCompare(t.path)),t(null,e)}],(e,t)=>{u=u.concat(t),o&&o(e,u)})},f.postImport=function(e,t,a){i.waterfall([i=>{M(e,{path:t},(a,r)=>{a?(e.failed(`Failed to post import asset ${t}, message: ${a.stack}`),i(a)):i(null,r)})},(t,i)=>{t&&e.updateMtime(t.uuid),i(null,t)}],(e,t)=>{a&&a(e,t)})},f.assetMove=function(a,r,n,o){let s,u,h,c,f=e.isDirSync(r),m=t.basename(r)!==t.basename(n),p=[];i.series([e=>{(function(e,i,a,r){_(e,i,null,(e,n)=>{let o=n.map(e=>t.join(a,t.relative(i,e)));r&&r(null,n,o)})})(a,r,n,(t,i,r)=>{if(t)return e(t),void 0;u=r,h=(s=i).map(e=>a.fspathToUuid(e)),c=s.map(e=>{return l.get(a,a.fspathToUuid(e)).copySubMetas()}),e()})},e=>{if(f||!m)return e(),void 0;(function(e,t,a){i.eachSeries(t,(t,i)=>{y(e,t,i)},e=>{a&&a(e)})})(a,h,e)},t=>{(function(t,a,r,n){i.series([t=>{e.rename(a,r,t)},i=>{let n=a+".meta",o=r+".meta";if(!e.existsSync(n))return i(),void 0;e.rename(n,o,n=>{n&&e.rename(r,a,e=>{t.error(e)}),i(n)})}],n)})(a,r,n,t)},e=>{for(let e=0;e<s.length;e++){if(f||!m){let t=a.subAssetInfosByPath(s[e]),i=s[e],r=u[e];for(let e=0;e<t.length;++e){let n=t[e].path,o=n.replace(i,r);a._dbMove(n,o)}}a._dbMove(s[e],u[e])}e()},e=>{if(f||!m)return e(),void 0;i.eachLimit(u,d,(e,t)=>{P(a,n,(e,i)=>{e&&a.failed(`Failed to import asset ${n}, message: ${e.stack}`),p.push(i),t()})},()=>{e()})},e=>{if(f||!m)return e(),void 0;i.eachLimit(u,d,(e,t)=>{M(a,{path:n},(e,i)=>{e&&a.failed(`Failed to post import asset ${n}, message: ${e.stack}`),t()})},()=>{e()})},e=>{h.forEach(e=>{a.updateMtime(e)}),e()}],e=>{if(!o)return;if(e)return o(e),void 0;let i=[];for(let e=0;e<u.length;++e){let r=t.dirname(u[e]),n=null;p[e]&&(n=x(a,p[e],c[e]));let o=a.mountInfoByUuid(h[e]),d=l.get(a,h[e]);i.push({uuid:h[e],type:d.assetType(),url:a.uuidToUrl(h[e]),parentUuid:a.fspathToUuid(r),srcPath:s[e],destPath:u[e],subMetas:n,hidden:!!o.hidden,readonly:!!o.readonly})}o(null,i)})},f.delete=function(a,r,n){Array.isArray(r)||(r=[r]);let o=a.arrayCmpFilter(r,(e,i)=>t.contains(e,i)?1:t.contains(i,e)?-1:0).map(e=>a._fspath(e)),s=[];i.each(o,(t,i)=>{(async function(t,i,a){if(!e.existsSync(i))return a&&a(new Error(`Asset ${i} is not exists`)),void 0;if(t.mountInfoByPath(i).readonly){if(a){let e=t.fspathToUrl(i);a(new Error(`${e} is readonly, CAN NOT delete it in Editor.`))}}else{try{u?(u.moveItemToTrash(i,!0),u.moveItemToTrash(i+".meta",!0)):(e.removeSync(i),e.removeSync(i+".meta"))}catch(e){return a&&a(e),void 0}f.clearImports(t,i,null,(e,t)=>{if(e)return a&&a(e),void 0;a&&a(null,t)})}})(a,t,(e,r)=>{if(e){let r=a.fspathToUuid(t);return a.error(`Failed to delete asset ${r}, messages: ${e.stack}`),i(e),void 0}s=s.concat(r),i()})},e=>{n(e,s)})},f.create=function(a,r,n,o){if(!r)return o&&o(new Error(`Invalid path: ${r}`)),void 0;if(a.mountInfoByPath(r).readonly){if(o){let e=a.fspathToUrl(t.dirname(r));o(new Error(`${e} is readonly, CAN NOT create it in Editor.`))}return}let s=r,u=0;for(;e.existsSync(s);)u+=1,s=t.join(t.dirname(r),t.basenameNoExt(r)+" - "+a.padLeft(u,3,"0")+t.extname(r));r=s;let l=t.dirname(r);if(!e.existsSync(l))return o&&o(new Error(`Parent path ${l} is not exists`)),void 0;let d=a._ensureDirSync(t.dirname(r));i.waterfall([i=>{a.log(`write ${r}...`);let o=t.extname(r),s=e.existsSync(r);if(!o&&!1===s)return e.mkdir(r,i),void 0;e.writeFile(r,n,i)},e=>{P(a,r,e)},(e,t)=>{M(a,{path:r,meta:e},t)},(e,t)=>{a._dbAdd(r,e.uuid),a.updateMtime(e.uuid),t(null,e)}],(e,i)=>{if(e)return o&&o(e),void 0;let n=[];d.forEach(e=>{let i=a.uuidToFspath(e.uuid),r=t.dirname(i),o=a.fspathToUuid(r),s=a.mountInfoByPath(i);n.push({uuid:e.uuid,parentUuid:o,url:a._url(i),path:i,type:e.assetType(),hidden:!!s.hidden,readonly:!!s.readonly})}),T(a,r,i,n),o&&o(e,n)})},f.saveExists=function(a,r,n,o){if(!a.existsByPath(r))return o&&o(new Error(r+" is not exists")),void 0;if(a.mountInfoByPath(r).readonly){if(o){let e=a.fspathToUrl(r);o(new Error(`${e} is readonly, CAN NOT save the changes in Editor.`))}return}let s=a.loadMetaByPath(r).copySubMetas(),u=a.fspathToUuid(r);i.waterfall([i=>{(function(i,a){if(!i.assetBackupPath||!e.existsSync(a))return;let r=i.getAssetBackupPath(a);if(!r)return;let n=t.dirname(r);e.ensureDirSync(n),e.copySync(a,r)})(a,r),i()},t=>{e.writeFile(r,n,t)},e=>{y(a,u,t=>{t&&a.failed(`Failed to delete imported assets of ${u} during save, message: ${t.stack}`),e()})},e=>{P(a,r,e)},(e,t)=>{M(a,{path:r,meta:e},t)},(e,t)=>{a.updateMtime(u),t(null,e)}],(e,t)=>{if(e){if(o){let t={path:r,url:a._url(r),uuid:u,error:e};o(e,t)}}else if(o){let i=x(a,t,s);o(e,{meta:t,subMetas:i})}})},f.saveMeta=function(e,a,r,n){let o,s=e.uuidToFspath(a);if(e.mountInfoByPath(s).readonly){if(n){let t=e.fspathToUrl(s);n(new Error(`${t} is readonly, CAN NOT save the changes in Editor.`))}return}try{o=JSON.parse(r)}catch(e){return n&&n(new Error(`Failed to pase json string, message : ${e.message}`)),void 0}if(a!==o.uuid)return n&&n(new Error("Uuid is not equal to json uuid")),void 0;let u=s+".meta",d=e.loadMetaByPath(s);if(!d)return n&&n(new Error(`Can't load meta for : ${a}`)),void 0;let h=d.copySubMetas();if(d.deserialize(o),e.isSubAssetByPath(s)){let i=t.basename(s);u=(s=t.dirname(s))+".meta";let r=e.loadMetaByPath(s);a=r.uuid,h=r.copySubMetas(),r.getSubMetas()[i]=d,d=r}l.save(e,u,d),i.waterfall([t=>{y(e,a,i=>{i&&e.failed(`Failed to delete imported assets of ${a} during saveMeta, message: ${i.stack}`),t()})},t=>{P(e,s,t)},(t,i)=>{M(e,{path:s,meta:t},i)},(t,i)=>{let r=x(e,t,h);for(let t=0;t<r.added.length;++t){let i=r.added[t];e.existsByUuid(i.uuid)||(e._dbAdd(i.path,i.uuid),e.updateMtime(i.uuid))}for(let t=0;t<r.deleted.length;++t){let i=r.deleted[t];e.existsByUuid(i.uuid)&&e._dbDelete(i.path)}e.updateMtime(a),i(null,{meta:t,subMetas:r})}],(e,t)=>{if(e)return n&&n(e),void 0;n&&n(null,t)})},f.clearImports=function(a,r,n,o){if(!a.fspathToUuid(r))return o&&o(new Error(`path-2-uuid does not contian: ${r}`)),void 0;a.log(`clear imports ${r}`);let s=[];for(let e in a._path2uuid)t.contains(r,e)&&(a._isMountPath(e)||s.push(e));let u=[];i.eachSeries(s,(t,r)=>{let o=a.assetInfoByPath(t),s=o.uuid;u.push(o),i.series([i=>{let r,o=t+".meta",u=e.existsSync(o);if(u)r=l.load(a,o);else{r=new(l.findCtor(a,t))(a)}if(r&&r.delete)return u||a.warn(`Try to delete imported files from an un-exists path : ${o}.\n              This is not 100% work, please check them manually.`),r.uuid=n&&n[t]||s,a.log(`do meta.delete ${o}...`),r.delete(t,i),void 0;i()},e=>{y(a,s,t=>{t&&a.failed(`Failed to delete imported assets of ${s} during clearImports, message: ${t.stack}`),e()})},e=>{a._dbDelete(t),a.updateMtime(s),e()}],r)},e=>{o&&o(e,u)})},f.copy=function(r,o,s,u,l){i.series([t=>{e.copy(o,s,t)},t=>{if(!u)return t(),void 0;let i=o+".meta",a=s+".meta";e.existsSync(i)&&e.copy(i,a,t)},i=>{if(!e.isDirSync(s)||u)return i(),void 0;let r=[t.join(s,"**/*.meta")],o=[];try{r=m(r),o=a.sync(r,h)}catch(e){return l&&l(e),void 0}Promise.all(o.map(e=>(e=t.resolve(e),n(e.replace(/\\/g,"/"),{force:!0})))).then(e=>{i()},i)}],e=>{l&&l(e)})},f.move=function(e,t,a,r){if(e.mountInfoByPath(t).readonly){let i=e.fspathToUrl(t);return r&&r(new Error(`${i} is readonly, CAN NOT move it in Editor.`)),void 0}if(e.mountInfoByPath(a).readonly){let t=e.fspathToUrl(a);return r&&r(new Error(`${t} is readonly, CAN NOT move asset into it in Editor.`)),void 0}i.waterfall([i=>{f._checkMoveInput(e,t,a,i)},i=>{f.assetMove(e,t,a,i)}],(e,t)=>{if(e)return r&&r(e),void 0;r&&r(null,t)})},f.exchangeUuid=function(e,t,a,r){let n=e.loadMetaByPath(t);if(!n)return r&&r(new Error(`Can't load meta for : ${t}`)),void 0;let o=e.loadMetaByPath(a);if(!o)return r&&r(new Error(`Can't load meta for : ${a}`)),void 0;let s=n.uuid;n.uuid=o.uuid,o.uuid=s,e._uuid2meta[n.uuid]=n,e._path2uuid[t]=n.uuid,e._uuid2path[n.uuid]=t,e._uuid2meta[o.uuid]=o,e._path2uuid[a]=o.uuid,e._uuid2path[o.uuid]=a,i.series([t=>{f.saveMeta(e,n.uuid,JSON.stringify(n.serialize(),null,2),t)},t=>{f.saveMeta(e,o.uuid,JSON.stringify(o.serialize(),null,2),t)}],r)},f._backupUnusedMeta=g,f._scan=_,f._checkIfReimport=S,f._initMetas=w,f._refresh=A,f._importAsset=P,f._checkMoveInput=function(i,a,r,n){let o=t.dirname(r),s=e.existsSync(a),u=e.existsSync(r),l=e.isDirSync(a),d=e.isDirSync(r),h=t.basename(a);return s?e.existsSync(o)?u&&a.toLowerCase()!==r.toLowerCase()?(n&&n(new Error(`Dest asset ${r} already exists`)),void 0):d&&l&&e.existsSync(t.join(r,h))?(n&&n(new Error(`Dest normal asset ${r} already exists`)),void 0):(n&&n(),void 0):(n&&n(new Error(`Dest parent path ${o} is not exists`)),void 0):(n&&n(new Error(`Src asset ${a} is not exists`)),void 0)};