"use strict";"use stirct";var __importDefault=this&&this.__importDefault||function(t){return t&&t.__esModule?t:{default:t}};Object.defineProperty(exports,"__esModule",{value:!0}),exports.AssetDB=exports.version=exports.map=void 0;const fs_extra_1=require("fs-extra"),path_1=require("path"),events_1=require("events"),node_uuid_1=require("node-uuid"),importer_1=require("./importer"),asset_1=require("./asset"),utils_1=require("./utils"),meta_1=require("./meta"),info_1=require("./info"),task_1=require("./task"),dependency_1=require("./dependency"),event_manager_1=require("./event-manager"),workflow_extra_1=require("workflow-extra"),fast_glob_1=__importDefault(require("fast-glob"));function getAsset(t){for(let e in exports.map){const s=exports.map[e].uuid2asset.get(t);if(s)return s}}exports.map={},exports.version="2.0.0";class AssetDB extends events_1.EventEmitter{constructor(t){super(),this.flag={starting:!1,started:!1},this.path2asset=new Map,this.uuid2asset=new Map,this.importerManager=new importer_1.ImporterManager(this),this._lock=!1,this._waitLockHandler=[],t.target&&t.library?(t.target=utils_1.absolutePath(t.target),t.library=utils_1.absolutePath(t.library),t.temp||(t.temp=path_1.join(t.library,".temp")),t.temp=utils_1.absolutePath(t.temp)):console.error("The database cannot be created because there is no target or library definition"),(!("level"in t)||t.level>4||t.level<0)&&(t.level=4),t.ignoreFiles&&Array.isArray(t.ignoreFiles)||(t.ignoreFiles=[]),this.options=t,this.taskManager=new workflow_extra_1.ParallelQueue(async t=>{const e=await this.importerManager.find(t);if(!e)return this.options.level>=1&&console.error(`Unable to import data, no suitable importer was found. {asset[${t instanceof asset_1.Asset?t.basename:""}](${t.uuid})}`),!1;switch(t.action){case asset_1.AssetActionEnum.add:case asset_1.AssetActionEnum.change:if(await task_1.TASK_MAP.import.exec(this,t,e,!0)&&await t.save(),t instanceof asset_1.Asset){const e=fs_extra_1.statSync(t.source);this.infoManager.add(t.source,e.mtimeMs,t.uuid)}event_manager_1.importAssociatedAssets(this,t);break;case asset_1.AssetActionEnum.delete:await task_1.TASK_MAP.destroy.exec(this,t),this.metaManager.remove(t.source+path_1.sep+".meta"),t instanceof asset_1.Asset&&this.infoManager.remove(t.source),event_manager_1.importAssociatedAssets(this,t);break;case asset_1.AssetActionEnum.none:await task_1.TASK_MAP.import.exec(this,t,e,!1)&&await t.save()}return t.init=!0,t.action=asset_1.AssetActionEnum.none,!0},5),this.eventManager=new event_manager_1.EventManager(this),this.metaManager=new meta_1.MetaManager,this.infoManager=new info_1.InfoManager,this.dependencyManager=new dependency_1.DependencyManager,this.importerManager.add(importer_1.DefaultImporter,["*"])}async lock(){return this._lock?await new Promise((t,e)=>{this._waitLockHandler.push(()=>{t()})}):this._lock=!0}unlock(){const t=this._waitLockHandler.shift();t?t():this._lock=!1}async start(){if(!this.options.target||!this.options.library||!this.options.temp)return void(this.options.level>=1&&console.error("Parameter error, unable to start."));if(this.flag.started&&this.options.level>=2)return void console.warn(`The ${this.options.name} database is already started.`);this.flag.started=!0,this.flag.starting=!0,await this.metaManager.setBackupPath(path_1.join(this.options.temp,"meta")),await this.metaManager.setRecordJSON(path_1.join(this.options.library,`.${this.options.name}-meta.json`)),await this.infoManager.setRecordJSON(path_1.join(this.options.library,`.${this.options.name}-info.json`)),await this.dependencyManager.setRecordJSON(path_1.join(this.options.library,`.${this.options.name}-dependency.json`)),exports.map[this.options.name]=this;let t=await this.refresh(this.options.target,{ignoreSelf:!0}),e=!1;for(let t in this.infoManager.map)if(!this.path2asset.has(t)&&this.infoManager.map[t].uuid&&!this.infoManager.map[t].missing)try{const s=this.infoManager.map[t].uuid;if(getAsset(s))continue;const a=`${this.options.library}${path_1.sep}${s.substr(0,2)}`;if(fs_extra_1.existsSync(a)){const t=await fs_extra_1.readdir(a);for(let e of t)e.startsWith(s)&&await fs_extra_1.remove(path_1.join(a,e))}this.infoManager.map[t].missing=!0,e=!0}catch(t){console.warn(t)}return e&&this.infoManager.save(),new Promise(e=>{const s=()=>{setTimeout(()=>{if(!this.taskManager.busy())return e(t);this.taskManager.waitQueue().then(()=>{s()})},10)};s()})}async stop(){this.uuid2asset.clear(),this.path2asset.clear(),this.flag.started=!1,this.metaManager.saveImmediate(),this.infoManager.saveImmediate(),this.dependencyManager.saveImmediate(),this.metaManager.destroy(),this.infoManager.destroy(),this.dependencyManager.destroy(),exports.map[this.options.name]===this&&delete exports.map[this.options.name]}pathToUuid(t){let e=this.path2asset.get(t);return e?e.uuid:null}uuidToPath(t){let e=this.uuid2asset.get(t);return e?e.source:null}getAsset(t){if(!t||"string"!=typeof t)return null;let e=t.split("@"),s=e.shift()||"",a=this.uuid2asset.get(s);if(!a)return null;for(let t=0;t<e.length;t++){let s=e[t];if(!(a=a.subAssets[s]))return null}return a||null}async reimport(t){const e=this.path2asset.get(t)||this.getAsset(t);if(!e)return!0;if(await this.lock(),e instanceof asset_1.Asset&&(this.metaManager.read(e.source+".meta"),e.meta.importer="*"),!await this.importerManager.find(e))throw new Error(`Unable to import data, no suitable importer was found.\n  path: ${e.source}\n  uuid: ${e.uuid}`);try{if(!e.init)return this.unlock(),!1;e.action=asset_1.AssetActionEnum.change,e.task=this.taskManager.addTask(e)}catch(t){console.error(t)}this.unlock(),await this.taskManager.waitQueue()}async refresh(t,e={}){if(!utils_1.absolutePath(t))return 0;(t=path_1.normalize(t))===this.options.target&&(e.ignoreSelf=!0);let s,a=path_1.dirname(t);for(;utils_1.isSubPath(a,this.options.target)&&!this.path2asset.has(a);)t=a,a=path_1.dirname(a);if(!utils_1.isSubPath(t,this.options.target)&&t!==this.options.target)return 0;try{if(fs_extra_1.statSync(t).isFile())s=[t];else{const e="win32"===process.platform?t.replace(/\\/g,"/"):t,a=[`${e}/**/*`,`!${e}/**/*.meta`];this.options.ignoreGlob&&a.push(this.options.ignoreGlob),s=fast_glob_1.default.sync(a,{onlyFiles:!1}),"win32"===process.platform&&s.forEach((t,e)=>{s[e]=t.replace(/\//g,"\\")}),t!==this.options.target&&s.splice(0,0,t)}}catch(t){s=[]}const i=new Set,n=new Set,r=new Set;try{const e=[],a=[];for(let t of s)this.path2asset.has(t)||(e.push(t),r.add(t)),i.add(t);this.path2asset.forEach((e,r)=>{0!==s.length&&i.has(r)||(r===t||utils_1.isSubPath(r,t)?(a.push(r),n.add(r)):n.add(r))}),this.taskManager.stop(),this._checkAssetsStatSync(e,a,n),this.emit("refresh-uuid-ready",t),await this.lock();const o=[];for(let t of s)if(!r.has(t)&&!n.has(t)){const e=this.path2asset.get(t);e&&o.push(this._checkAssetStat(e))}await Promise.all(o)}catch(t){return console.error(t),this.unlock(),0}this.taskManager.start();try{await this.taskManager.waitQueue()}catch(t){console.error(t)}this.unlock();const o=this.taskManager.total();return this.taskManager.clear(),o}_replaceUUID(t,e){if(e!==t){const s=node_uuid_1.v4();if(this.options.level>=2){let a=JSON.stringify([t.source,e.source],null,2);console.warn(`The uuid is already pointing to another resource.\n${a}\nThe file uuid has been updated: ${t.source}\n    ${t.uuid} -> ${s}`)}t.meta.uuid=s}}_checkAssetsStatSync(t,e,s){for(let e of t){const t=this.metaManager.get(e+".meta"),a=getAsset(t.json.uuid);if(a)if(s.has(a.source)){const s=a;this.path2asset.delete(s.source),s._source=e,s.meta=t.json,this.path2asset.set(s.source,s),s.action=asset_1.AssetActionEnum.change,s.task=this.taskManager.addTask(s)}else{const s=new asset_1.Asset(e,t.json,this);this._replaceUUID(s,a),s.save(),s.action=asset_1.AssetActionEnum.add,s.task=this.taskManager.addTask(s),this.uuid2asset.set(s.uuid,s),this.path2asset.set(s.source,s)}else if(this.flag.starting){const s=fs_extra_1.statSync(e),a=new asset_1.Asset(e,t.json,this);if(this.infoManager.compare(e,s.mtimeMs)){const t=e+".meta",s=fs_extra_1.statSync(t);if(this.infoManager.compare(t,s.mtimeMs))a.action=asset_1.AssetActionEnum.none,a.task=this.taskManager.addTask(a);else{const e=a.uuid;this.metaManager.read(t),a.uuid!==e&&(this.uuid2asset.delete(e),this.uuid2asset.has(a.uuid)&&this._replaceUUID(a,getAsset(a.uuid)),this.uuid2asset.set(a.uuid,a)),this.infoManager.add(t,s.mtimeMs),a.action=asset_1.AssetActionEnum.change,a.task=this.taskManager.addTask(a)}}else a.action=asset_1.AssetActionEnum.add,this.infoManager.add(e,s.mtimeMs),a.task=this.taskManager.addTask(a);this.uuid2asset.set(a.uuid,a),this.path2asset.set(a.source,a)}else{const s=getAsset(t.json.uuid),a=new asset_1.Asset(e,t.json,this);s&&(this._replaceUUID(a,s),a.save()),a.action=asset_1.AssetActionEnum.add,a.task=this.taskManager.addTask(a),this.uuid2asset.set(a.uuid,a),this.path2asset.set(a.source,a)}}for(let t of e){const e=this.path2asset.get(t);e&&(e.action=asset_1.AssetActionEnum.delete,e.task=this.taskManager.addTask(e),this.uuid2asset.delete(e.uuid),this.path2asset.delete(e.source))}}async _checkAssetStat(t){const e=t.source,s=e+".meta",a=await fs_extra_1.stat(s);if(await this.infoManager.compare(s,a.mtimeMs)){const s=await fs_extra_1.stat(e);await this.infoManager.compare(e,s.mtimeMs)?(t.action=asset_1.AssetActionEnum.none,t.task=this.taskManager.addTask(t)):(this.infoManager.add(e,s.mtimeMs,t.uuid),t.action=asset_1.AssetActionEnum.change,t.task=this.taskManager.addTask(t))}else{const e=t.uuid;this.metaManager.read(s),t.uuid!==e&&(this.uuid2asset.delete(e),this.uuid2asset.has(t.uuid)&&this._replaceUUID(t,getAsset(t.uuid)),this.uuid2asset.set(t.uuid,t)),this.infoManager.add(s,a.mtimeMs),t.action=asset_1.AssetActionEnum.change,t.task=this.taskManager.addTask(t)}}}exports.AssetDB=AssetDB;