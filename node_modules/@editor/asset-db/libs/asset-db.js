"use strict";"use stirct";Object.defineProperty(exports,"__esModule",{value:!0}),exports.AssetDB=exports.version=void 0;const fs_extra_1=require("fs-extra"),path_1=require("path"),events_1=require("events"),node_uuid_1=require("node-uuid"),importer_1=require("./importer"),asset_1=require("./asset"),utils_1=require("./utils"),meta_1=require("./meta"),info_1=require("./info"),task_1=require("./task"),dependency_1=require("./dependency"),event_manager_1=require("./event-manager");exports.version="2.0.0";class AssetDB extends events_1.EventEmitter{constructor(e){super(),this.flag={starting:!1,started:!1},this.path2asset={},this.uuid2asset={},this.importerManager=new importer_1.ImporterManager(this),this._lock=!1,this._waitLockHandler=[],this._refresh=!1,this._refreshQueue=[],e.target&&e.library?(e.target=utils_1.absolutePath(e.target),e.library=utils_1.absolutePath(e.library),e.temp||(e.temp=path_1.join(e.library,".temp")),e.temp=utils_1.absolutePath(e.temp)):console.error("The database cannot be created because there is no target or library definition"),(!("level"in e)||e.level>4||e.level<0)&&(e.level=4),e.ignoreFiles&&Array.isArray(e.ignoreFiles)||(e.ignoreFiles=[]),this.options=e,this.taskManager=new task_1.TaskManager(this),this.eventManager=new event_manager_1.EventManager(this),this.metaManager=new meta_1.MetaManager,this.infoManager=new info_1.InfoManager,this.dependencyManager=new dependency_1.DependencyManager,this.importerManager.add(importer_1.DefaultImporter,["*"])}async lock(){return this._lock?await new Promise((e,t)=>{this._waitLockHandler.push(()=>{e()})}):this._lock=!0}unlock(){const e=this._waitLockHandler.shift();e?e():this._lock=!1}async start(){if(!this.options.target||!this.options.library||!this.options.temp)return void(this.options.level>=1&&console.error("Parameter error, unable to start."));if(this.flag.started&&this.options.level>=2)return void console.warn(`The ${this.options.name} database is already started.`);this.flag.started=!0,await this.metaManager.setBackupPath(path_1.join(this.options.temp,"meta")),await this.metaManager.setRecordJSON(path_1.join(this.options.library,`.${this.options.name}-meta.json`)),await this.infoManager.setRecordJSON(path_1.join(this.options.library,`.${this.options.name}-info.json`)),await this.dependencyManager.setRecordJSON(path_1.join(this.options.library,`.${this.options.name}-dependency.json`));const e=await this.refresh(this.options.target,{ignoreSelf:!0});let t=!1;for(let e in this.infoManager.map)if(!this.path2asset[e]&&this.infoManager.map[e].uuid&&!this.infoManager.map[e].missing)try{const s=this.infoManager.map[e].uuid;if(this.uuid2asset[s])continue;const a=path_1.join(this.options.library,s.substr(0,2));if(fs_extra_1.existsSync(a)){const e=await fs_extra_1.readdir(a);for(let t of e)t.startsWith(s)&&await fs_extra_1.remove(path_1.join(a,t))}this.infoManager.map[e].missing=!0,t=!0}catch(e){console.warn(e)}return t&&this.infoManager.save(),new Promise(t=>{const s=()=>{setTimeout(()=>{if(this.taskManager.finish===this.taskManager.total)return t(e);this.taskManager.once("idle",s)},10)};s()})}async stop(){this.uuid2asset={},this.path2asset={},this.flag.started=!1,this.metaManager.saveImmediate(),this.infoManager.saveImmediate(),this.dependencyManager.saveImmediate(),this.metaManager.destroy(),this.infoManager.destroy(),this.dependencyManager.destroy()}pathToUuid(e){let t=this.path2asset[e];return t?t.uuid:null}uuidToPath(e){let t=this.uuid2asset[e];return t?t.source:null}getAsset(e){if(!e||"string"!=typeof e)return null;let t=e.split("@"),s=t.shift()||"",a=this.uuid2asset[s];if(!a)return null;for(let e=0;e<t.length;e++){let s=t[e];if(!(a=a.subAssets[s]))return null}return a||null}async reimport(e){const t=this.path2asset[e]||this.getAsset(e);if(!t)return!0;await this.lock(),t instanceof asset_1.Asset&&(this.metaManager.read(t.source+".meta"),t.meta.importer="*");const s=await this.importerManager.find(t);if(!s)throw new Error(`Unable to import data, no suitable importer was found.\n  path: ${t.source}\n  uuid: ${t.uuid}`);try{if(!t.init)return this.unlock(),!1;const e=this.taskManager.createQueue();this.taskManager.add(e);const a={source:t.source,uuid:t.uuid};await Promise.all([e.destroy(t),e.import(t,s,!0)]),t instanceof asset_1.Asset&&(t.source!==a.source&&(delete this.path2asset[a.source],this.path2asset[t.source]=t),t.uuid!==a.uuid&&(delete this.uuid2asset[a.uuid],this.uuid2asset[t.uuid]=t)),await t.save(),t instanceof asset_1.Asset&&this.eventManager.change(t),this.taskManager.remove(e)}catch(e){console.error(e)}this.unlock()}async _waitRefresh(){if(this._refresh)return new Promise(e=>{this._refreshQueue.push(e)})}async refresh(e,t={}){if(!utils_1.absolutePath(e))return 0;await this._waitRefresh(),this._refresh=!0,e=path_1.normalize(e);const s=path_1.dirname(e),a=path_1.basename(e);if(!utils_1.isSubPath(e,this.options.target)&&e!==this.options.target)return 0;await this.lock();let i=0;try{e===this.options.target&&(t.ignoreSelf=!0);const r=[];let n=s;for(;utils_1.isSubPath(n,this.options.target)&&!this.path2asset[n];){const e=fs_extra_1.statSync(n),t=this.metaManager.get(n+".meta"),s=this.path2asset[n]||new asset_1.Asset(n,t.json,this),a=this.mountAsset(s);this.path2asset[n]=s,this.uuid2asset[s.uuid]=s,r.splice(0,0,{stat:e,asset:s,covered:a}),n=path_1.dirname(n)}utils_1.recursiveSync(s,a,(e,s,a)=>{if(t.ignoreSelf)return void(t.ignoreSelf=!1);if(this.options.ignoreFiles.includes(a))return;if(this.options.ignoreRegular&&this.options.ignoreRegular.test(e))return;if(".meta"===path_1.extname(e))return;const i=this.metaManager.get(e+".meta"),n=this.path2asset[e]||new asset_1.Asset(e,i.json,this),o=this.mountAsset(n);this.path2asset[e]=n,this.uuid2asset[n.uuid]=n,r.push({stat:s,asset:n,covered:o})},(e,s,a)=>{if(t.ignoreSelf)return void(t.ignoreSelf=!1);const i=this.metaManager.get(e+".meta"),n=this.path2asset[e]||new asset_1.Asset(e,i.json,this),o=this.mountAsset(n);this.path2asset[e]=n,this.uuid2asset[n.uuid]=n,r.push({stat:s,asset:n,covered:o})});const o=this.taskManager.createQueue();this.taskManager.add(o),await Promise.all(r.map(async(e,t)=>{i++;let s=e.asset.uuid;const a=await this.importerManager.find(e.asset);if(!a)return this.options.level>=1&&console.error(`Unable to import data, no suitable importer was found. {asset[${e.asset.basename}](${s})}`),!1;if(!await this.checkDirty(e.asset,a)){const t=e.covered&&e.covered.source!==e.asset.source;return t&&(this.metaManager.remove(e.covered.source+".meta"),this.infoManager.remove(e.covered.source)),await o.import(e.asset,a,!1)&&await e.asset.save(),e.asset.init=!0,t&&this.eventManager.change(e.asset),!1}e.asset.uuid!==s&&(delete this.uuid2asset[s],s=e.asset.uuid,this.uuid2asset[s]=e.asset),e.covered?(e.covered.source!==e.asset.source&&(this.metaManager.remove(e.covered.source+".meta"),this.infoManager.remove(e.covered.source)),await Promise.all([o.destroy(e.covered),o.import(e.asset,a,!0)]),await e.asset.save(),e.asset.init=!0,this.eventManager.change(e.asset)):(await o.import(e.asset,a,!0),await e.asset.save(),e.asset.init=!0,this.eventManager.add(e.asset))}));for(let t in this.path2asset)if((t===e||utils_1.isSubPath(t,e))&&(0===r.length||!fs_extra_1.existsSync(t))){i++;const e=this.path2asset[t];await o.destroy(e),delete this.path2asset[e.source],delete this.uuid2asset[e.uuid],this.infoManager.remove(e.source),this.metaManager.remove(e.source+".meta"),await e.save(),e.init=!1,this.eventManager.delete(e)}this.taskManager.remove(o)}catch(e){console.error(e)}this.unlock(),this._refresh=!1;const r=this._refreshQueue.shift();return r&&r(),i}mountAsset(e){const t=e.source+".meta";if(!fs_extra_1.existsSync(t)){this.metaManager.write(t);const s=fs_extra_1.statSync(t);this.infoManager.add(e.source+".meta",s.mtimeMs)}const s=this.uuid2asset[e.uuid];if(s&&s!==e){if(fs_extra_1.existsSync(s.source)){const t=node_uuid_1.v4();return this.options.level>=2&&console.warn(`The uuid is already pointing to another resource.\n${JSON.stringify([e.source,s.source],null,2)}\nThe file uuid has been updated: ${e.source}\n    ${e.uuid} -> ${t}`),void(e.meta.uuid=t)}return delete this.uuid2asset[s.uuid],delete this.path2asset[s.source],s}return s}async checkDirty(e,t){const s=e.source+".meta",a=fs_extra_1.statSync(e.source),i=fs_extra_1.statSync(s);if(this.infoManager.map[s]){if(!await this.infoManager.compare(s,i.mtimeMs))return await this.metaManager.read(s),!0}else this.infoManager.add(s,i.mtimeMs);return!await this.infoManager.compare(e.source,a.mtimeMs)||(!!e.meta.files.some(t=>!e.existsInLibrary(t))||!e.init&&-1===utils_1.compareVersion(e.meta.ver,t.version))}}exports.AssetDB=AssetDB;