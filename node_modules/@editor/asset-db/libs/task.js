"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.TaskManager=exports.TaskQueue=exports.DestroyTask=exports.ImportTask=exports.Task=void 0;const fs_extra_1=require("fs-extra"),events_1=require("events"),asset_1=require("./asset"),utils_1=require("./utils");class Task{constructor(){this.event={}}on(e,t){this.event[e]=t}emit(e,...t){this.event[e]&&this.event[e].call(this,...t)}}exports.Task=Task;class ImportTask extends Task{async exec(e,t,s,r){try{r=t instanceof asset_1.Asset?await this.importAsset(e,t,s,r):await this.importVirtualAsset(e,t,s,r)}catch(e){console.error(e)}let a=r;for(let s in t.subAssets){const o=t.subAssets[s];try{const t=await e.importerManager.find(o);if(!t)throw new Error(`Unable to import data, no suitable importer was found.\n asset: {asset[${o.source}](${o.uuid})}`);await this.exec(e,o,t,a)&&(r=!0)}catch(t){e.options.level>=1&&(console.error(`Importer exec failed: {asset[${o.source}](${o.uuid})}`),console.error(t))}}if(t instanceof asset_1.Asset)try{const s=fs_extra_1.statSync(t.source);e.infoManager.add(t.source,s.mtimeMs,t.uuid)}catch(e){console.error(e)}return r}async importAsset(e,t,s,r){if(r||s.version!==t.meta.ver||!1===t.meta.imported&&!0!==t.invalid||await s.force(t)||t.meta.files.some(e=>!t.existsInLibrary(e))){t.meta.importer!==s.name&&(t.meta.ver="0.0.0");const a=utils_1.compareVersion(t.meta.ver,s.version);if(1===a){if(t.init)return!1;console.warn(`Importer exec warning: {asset[${t.source}](${t.uuid})}: The importer version is lower than asset`)}if(r=!0,await t.reset(),t.imported=!1,s.name===t.meta.importer&&"0.0.0"!==t.meta.ver&&-1===a)try{await this.migrateAsset(s,e,t)}catch(s){return e.options.level>=1&&console.error(s),t.imported=!1,t.invalid=!0,!1}console.debug(`%cImport%c: ${t.source}`,"background: #aaff85; color: #000;","color: #000;");try{t.meta.ver=s.version,t.meta.importer=s.name,!1===await s.import(t)?t.invalid=!0:t.imported=!0}catch(s){e.options.level>=1&&(console.error(`Importer exec failed: {asset[${t.source}](${t.uuid})}`),console.error(s)),t.invalid=!0}}return r}async importVirtualAsset(e,t,s,r){if(r||s.version!==t.meta.ver||!1===t.meta.imported&&!0!==t.invalid||await s.force(t)||t.meta.files.some(e=>!t.existsInLibrary(e))){const a=utils_1.compareVersion(t.meta.ver,s.version);if(1===a)return!t.init&&(t.invalid=!0,console.warn(`Importer exec warning: {asset[${t.source}](${t.uuid})}: The importer version is lower than asset`),!1);if(r=!0,t.imported=!1,s.name===t.meta.importer&&"0.0.0"!==t.meta.ver&&-1===a)try{await this.migrateAsset(s,e,t)}catch(s){return e.options.level>=1&&console.error(s),t.imported=!1,t.invalid=!0,e.eventManager.add(t),!1}console.debug(`%cImport%c: ${t.source}`,"background: #aaff85; color: #000;","color: #000;");try{t.meta.ver=s.version,t.meta.importer=s.name,!1===await s.import(t)?t.invalid=!0:t.imported=!0}catch(s){e.options.level>=1&&(console.error(`Importer exec failed: {asset[${t.source}](${t.uuid})}`),console.error(s)),t.invalid=!0}e.eventManager.add(t)}return r}async migrateAsset(e,t,s){let r=null;e.migrationHook&&e.migrationHook.pre&&await e.migrationHook.pre(s);let a=0,o=0;for(;o<e.migrations.length;o++){const i=e.migrations[o];if(utils_1.compareVersion(s.meta.ver,i.version)<0)try{console.debug(`%cMigrate%c: ${s.source}(${i.version})`,"background: #fbe5b5; color: #000;","color: #000;"),i.migrate&&await i.migrate(s),a++,s.meta.ver=i.version}catch(e){t.options.level>=1&&console.error(`Migrate error:  {asset[${s.source}](${s.uuid})} - ${i.version}`),r=e;break}}if(e.migrationHook&&e.migrationHook.post&&await e.migrationHook.post(s,a),r)throw r}}exports.ImportTask=ImportTask;class DestroyTask extends Task{async exec(e,t){for(let s in t.subAssets){const r=t.subAssets[s];try{await this.exec(e,r)}catch(t){e.options.level>=1&&(console.error(`Destroy exec failed: {asset[${r.source}](${r.uuid})}`),console.error(t))}}let s=void 0;try{s=await this.destroyAsset(e,t)}catch(e){console.error(e)}return s}async destroyAsset(e,t){console.debug(`%cDestroy%c: ${t.source}`,"background: #ffb8b8; color: #000;","color: #000;"),asset_1.Asset,await t.reset(),t.imported=!1,t.invalid=!1;const s=t.library;if(await fs_extra_1.pathExists(s)){0===fs_extra_1.readdirSync(s).length&&fs_extra_1.removeSync(s)}t instanceof asset_1.Asset||e.eventManager.delete(t)}}exports.DestroyTask=DestroyTask;const TASK_MAP={import:new ImportTask,destroy:new DestroyTask};class TaskQueue{constructor(e){this.total=0,this.finish=0,this.waitQueue=[],this.manager=e}async waitTask(e,t){const s=this.manager.execID++;return await new Promise(r=>{this.waitQueue.push({type:e,id:s,source:t.source,exec:r}),this.manager.next()}),s}async import(e,t,s){this.total++;const r=await this.waitTask("import",e);let a;await e.lock(),e.task=r;try{a=await TASK_MAP.import.exec(this.manager.database,e,t,s)}catch(e){console.error(e)}return await e.unlock(),e.task=void 0,this.finish++,this.manager.complete(r),this.manager.next(),a}async destroy(e){this.total++;const t=await this.waitTask("destroy",e);let s;await e.lock(),e.task=t;try{s=await TASK_MAP.destroy.exec(this.manager.database,e)}catch(e){console.error(e)}return e.task=void 0,await e.unlock(),this.finish++,this.manager.complete(t),this.manager.next(),s}}exports.TaskQueue=TaskQueue;class TaskManager extends events_1.EventEmitter{constructor(e){super(),this.queue=[],this.thread=5,this.taskID=1,this.execNum=0,this.execID=1,this.execMap={},this.database=e}pause(e){void 0!==e&&this.execMap[e]&&(this.execNum--,this.next())}resume(e){void 0!==e&&this.execMap[e]&&this.execNum++}complete(e){void 0!==e&&this.execMap[e]&&(delete this.execMap[e],this.execNum--)}async next(){if(this.execNum>=this.thread)return;let e;for(let t of this.queue)if(0!==t.waitQueue.length){e=t;break}if(!e)return;const t=e.waitQueue.shift();t&&(this.execNum++,this.execMap[t.id]=t,t.exec())}get total(){let e=0;return this.queue.some(t=>(e+=t.total,!1)),e}get finish(){let e=0;return this.queue.some(t=>(e+=t.finish,!1)),e}add(e){this.emit("busy"),this.queue.push(e)}remove(e){const t=this.queue.indexOf(e);-1!==t&&this.queue.splice(t,1),0===this.queue.length&&this.emit("idle")}createQueue(){return new TaskQueue(this)}}exports.TaskManager=TaskManager;