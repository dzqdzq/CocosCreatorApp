"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.TASK_MAP=exports.DestroyTask=exports.ImportTask=exports.Task=void 0;const fs_extra_1=require("fs-extra"),asset_1=require("./asset"),utils_1=require("./utils"),default_meta_1=require("./default-meta"),manager_1=require("./manager");class Task{constructor(){this.event={}}on(e,t){this.event[e]=t}emit(e,...t){this.event[e]&&this.event[e].call(this,...t)}}exports.Task=Task;class ImportTask extends Task{async exec(e,t,s,r){const o=new Map;for(let e in t.subAssets)o.set(e,t.subAssets[e]);try{r=t instanceof asset_1.Asset?await this.importAsset(e,t,s,r):await this.importVirtualAsset(e,t,s,r)}catch(e){console.error(e)}let a=r;for(let s in t.subAssets){const i=t.subAssets[s];try{const t=await e.importerManager.find(i);if(!t)throw new Error(`Unable to import data, no suitable importer was found.\n asset: {asset[${i.source}](${i.uuid})}`);o.has(s)?i.action=asset_1.AssetActionEnum.change:i.action=asset_1.AssetActionEnum.add,await this.exec(e,i,t,a)&&(r=!0),i.action=asset_1.AssetActionEnum.none}catch(t){r=!0,e.options.level>=1&&(console.error(`Importer exec failed: {asset[${i.source}](${i.uuid})}`),console.error(t))}}return o.forEach((s,r)=>{t.subAssets[r]||e.emit("delete",s)}),r&&(t.action===asset_1.AssetActionEnum.add?e.emit("added",t):t.action===asset_1.AssetActionEnum.change&&e.emit("changed",t)),t.action=asset_1.AssetActionEnum.none,r}async importAsset(e,t,s,r){if(r||s.version!==t.meta.ver&&!0!==t.invalid||!1===t.meta.imported&&!0!==t.invalid||await s.force(t)||t.meta.files.some(e=>!t.existsInLibrary(e))){t.meta.importer!==s.name&&(t.meta.ver="0.0.0");const o=(0,utils_1.compareVersion)(t.meta.ver,s.version);if(1===o){if(t.init)return!1;console.warn(`Importer exec warning: {asset[${t.source}](${t.uuid})}: The importer version is lower than asset`)}if(r=!0,await t.reset(),t.imported=!1,s.name===t.meta.importer&&"0.0.0"!==t.meta.ver&&-1===o)try{await this.migrateAsset(s,e,t)}catch(s){return e.options.level>=1&&console.error(s),t.imported=!1,t.invalid=!0,r}e.options.level>=4&&console.debug(`%cImport%c: ${t.source}`,"background: #aaff85; color: #000;","color: #000;");try{t.meta.ver=s.version,"*"===t.meta.importer&&(t.meta.userData=t.meta.userData||{},(0,default_meta_1.fillUserData)(s.name,t.meta.userData)),t.meta.importer=s.name,!1===await s.import(t)?t.invalid=!0:(t.invalid=!1,t.imported=!0)}catch(s){e.options.level>=1&&(console.error(`Importer exec failed: {asset[${t.source}](${t.uuid})}`),console.error(s)),t.invalid=!0}}return r}async importVirtualAsset(e,t,s,r){if(r||s.version!==t.meta.ver||!1===t.meta.imported&&!0!==t.invalid||await s.force(t)||t.meta.files.some(e=>!t.existsInLibrary(e))){const o=(0,utils_1.compareVersion)(t.meta.ver,s.version);if(1===o)return!t.init&&(t.invalid=!0,console.warn(`Importer exec warning: {asset[${t.source}](${t.uuid})}: The importer version is lower than asset`),!1);if(r=!0,t.imported=!1,s.name===t.meta.importer&&"0.0.0"!==t.meta.ver&&-1===o)try{await this.migrateAsset(s,e,t)}catch(s){return e.options.level>=1&&console.error(s),t.imported=!1,t.invalid=!0,!1}e.options.level>=4&&(t.action===asset_1.AssetActionEnum.add?console.debug(`%cImport%c: ${t.source}`,"background: #aaff85; color: #000;","color: #000;"):console.debug(`%cReImport%c: ${t.source}`,"background: #aaff85; color: #000;","color: #000;"));try{t.meta.ver=s.version,"*"===t.meta.importer&&(t.meta.userData=t.meta.userData||{},(0,default_meta_1.fillUserData)(s.name,t.meta.userData)),t.meta.importer=s.name,!1===await s.import(t)?t.invalid=!0:(t.invalid=!1,t.imported=!0)}catch(s){e.options.level>=1&&(console.error(`Importer exec failed: {asset[${t.source}](${t.uuid})}`),console.error(s)),t.invalid=!0}(0,manager_1.importAssociatedAssets)(e,t)}return r}async migrateAsset(e,t,s){let r=null;e.migrationHook&&e.migrationHook.pre&&await e.migrationHook.pre(s);let o=0,a=0;for(;a<e.migrations.length;a++){const i=e.migrations[a];if((0,utils_1.compareVersion)(s.meta.ver,i.version)<0)try{t.options.level>=4&&console.debug(`%cMigrate%c: ${s.source}(${i.version})`,"background: #fbe5b5; color: #000;","color: #000;"),i.migrate&&await i.migrate(s),o++,s.meta.ver=i.version}catch(e){t.options.level>=1&&console.error(`Migrate error:  {asset[${s.source}](${s.uuid})} - ${i.version}`),r=e;break}}if(e.migrationHook&&e.migrationHook.post&&await e.migrationHook.post(s,o),r)throw r}}exports.ImportTask=ImportTask;class DestroyTask extends Task{async exec(e,t){for(let s in t.subAssets){const r=t.subAssets[s];try{r.action=asset_1.AssetActionEnum.delete,await this.exec(e,r),r.action=asset_1.AssetActionEnum.none}catch(t){e.options.level>=1&&(console.error(`Destroy exec failed: {asset[${r.source}](${r.uuid})}`),console.error(t))}}let s=void 0;try{s=await this.destroyAsset(e,t)}catch(e){console.error(e)}return t.action===asset_1.AssetActionEnum.delete&&e.emit("deleted",t),s}async destroyAsset(e,t){e.options.level>=4&&console.debug(`%cDestroy%c: ${t.source}`,"background: #ffb8b8; color: #000;","color: #000;"),asset_1.Asset,await t.reset(),t.imported=!1,t.invalid=!1;const s=t.library;if((0,fs_extra_1.existsSync)(s)){0===(0,fs_extra_1.readdirSync)(s).length&&(0,fs_extra_1.removeSync)(s)}}}exports.DestroyTask=DestroyTask,exports.TASK_MAP={import:new ImportTask,destroy:new DestroyTask};