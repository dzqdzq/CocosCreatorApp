{"version":3,"file":"target.js","sourceRoot":"","sources":["../src/target.ts"],"names":[],"mappings":";;;AAGA,yCAA8E;AAmBvE,KAAK,UAAU,kBAAkB,CAAC,EACrC,OAAO,EACP,OAAO,EACP,YAAY,EACZ,OAAO,EACP,OAAO,GAOV;IACG,MAAM,mBAAmB,GAAG,OAAO,CAAC,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,YAAY,CAAC,KAAK,CAAC,CAAC,CAAC;IAE5E,MAAM,YAAY,GAAiB,IAAI,GAAG,EAAE,CAAC;IAC7C,MAAM,OAAO,CAAC,GAAG,CAAC,mBAAmB,CAAC,GAAG,CAAC,KAAK,EAAE,WAAoB,EAAE,EAAE;QACrE,MAAM,aAAa,GAAG,GAAG,EAAE,CAAC,OAAO,YAAY,CAAC,KAAK,CAAC,WAAW,CAAC,CAAC;QAEnE,IAAI,CAAC,IAAA,2BAAgB,EAAC,WAAW,CAAC,EAAE;YAChC,IAAI,CAAC,CAAC,MAAM,OAAO,CAAC,UAAU,CAAC,WAAW,CAAC,CAAC,EAAE;gBAC1C,aAAa,EAAE,CAAC;gBAChB,OAAO;aACV;YAED,MAAM,QAAQ,GAAG,MAAM,OAAO,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC;YACjD,MAAM,QAAQ,GAAG,QAAQ,CAAC,OAAO,CAAC;YAClC,IAAI,CAAC,CAAC,WAAW,IAAI,YAAY,CAAC,KAAK,CAAC;gBACpC,YAAY,CAAC,KAAK,CAAC,WAAW,CAAC,CAAC,QAAQ,KAAK,QAAQ;gBACrD,MAAM,CAAC,MAAM,CAAC,YAAY,CAAC,KAAK,CAAC,WAAW,CAAC,CAAC,YAAY,CAAC,CAAC,IAAI,CAAC,CAAC,aAAa,EAAE,EAAE,CAAC,CAAC,aAAa,CAAC,QAAQ,CAAC,EAAE;gBAC9G,YAAY,CAAC,GAAG,CAAC,WAAW,CAAC,CAAC;gBAC9B,aAAa,EAAE,CAAC;gBAChB,OAAO;aACV;SACJ;QAED,IAAI,CAAC,CAAC,MAAM,OAAO,CAAC,cAAc,CAAC,WAAW,CAAC,CAAC,EAAE;YAC9C,YAAY,CAAC,GAAG,CAAC,WAAW,CAAC,CAAC;YAC9B,aAAa,EAAE,CAAC;YAChB,OAAO;SACV;IACL,CAAC,CAAC,CAAC,CAAC;IACJ,OAAO,KAAK,CAAC,IAAI,CAAC,YAAY,CAAC,CAAC;AACpC,CAAC;AA3CD,gDA2CC","sourcesContent":["import ps from 'path';\r\nimport type { IBundler } from './bundler';\r\nimport type { FileRecord } from './file-record';\r\nimport { decodeRegularFilePath, FileUid, isVirtualFileUid } from './file-uid';\r\nimport { FsCache } from './fs-cache';\r\n\r\nexport interface TargetRecord {\r\n    files: Record<FileUid, FileRecord>;\r\n    /**\r\n     * 键值是依赖文件 Id。\r\n     */\r\n    externalDependencies: Record<string, string>;\r\n\r\n    /**\r\n     * 外部依赖所牵扯到的所有文件以及它们的时间戳。\r\n     * 键是依赖文件 Id。\r\n     */\r\n    externalDependencyWatchFiles: Record<string, number>;\r\n\r\n    externalDependencyImportMap: Record<string, string>;\r\n}\r\n\r\nexport async function detectChangedFiles({\r\n    rootDir,\r\n    entries,\r\n    targetRecord,\r\n    bundler,\r\n    fsCache,\r\n}: {\r\n    rootDir: string;\r\n    entries: FileUid[];\r\n    targetRecord: TargetRecord;\r\n    bundler: IBundler;\r\n    fsCache: FsCache;\r\n}) {\r\n    const startupFilesToAudit = entries.concat(Object.keys(targetRecord.files));\r\n\r\n    const filesToAudit: Set<FileUid> = new Set();\r\n    await Promise.all(startupFilesToAudit.map(async (startupFile: FileUid) => {\r\n        const delFromRecord = () => delete targetRecord.files[startupFile];\r\n\r\n        if (!isVirtualFileUid(startupFile)) {\r\n            if (!(await fsCache.pathExists(startupFile))) {\r\n                delFromRecord();\r\n                return;\r\n            }\r\n\r\n            const fileStat = await fsCache.stat(startupFile);\r\n            const fileTime = fileStat.mtimeMs;\r\n            if (!(startupFile in targetRecord.files) ||\r\n                targetRecord.files[startupFile].fileTime !== fileTime ||\r\n                Object.values(targetRecord.files[startupFile].dependencies).some((resolveRecord) => !resolveRecord.resolved)) {\r\n                filesToAudit.add(startupFile);\r\n                delFromRecord();\r\n                return;\r\n            }\r\n        }\r\n\r\n        if (!(await bundler.isOutFileValid(startupFile))) {\r\n            filesToAudit.add(startupFile);\r\n            delFromRecord();\r\n            return;\r\n        }\r\n    }));\r\n    return Array.from(filesToAudit);\r\n}\r\n"]}