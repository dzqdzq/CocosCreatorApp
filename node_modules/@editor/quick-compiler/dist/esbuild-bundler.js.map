{"version":3,"file":"esbuild-bundler.js","sourceRoot":"","sources":["../src/esbuild-bundler.ts"],"names":[],"mappings":";;AAMA,6EAA6E;AAC7E,2BAA2B;AAC3B,kBAAkB;AAClB,6CAA6C;AAC7C,wCAAwC;AACxC,+DAA+D;AAC/D,uEAAuE;AACvE,iEAAiE;AACjE,qFAAqF;AAErF,4FAA4F;AAC5F,sHAAsH;AACtH,mEAAmE;AACnE,wDAAwD;AACxD,2CAA2C;AAC3C,oDAAoD;AACpD,eAAe;AACf,sBAAsB;AACtB,8BAA8B;AAC9B,aAAa;AACb,QAAQ;AACR,MAAM;AACN,cAAc;AACd,iDAAiD;AAEjD,8CAA8C;AAC9C,gBAAgB;AAChB,YAAY;AAEZ,0DAA0D;AAC1D,wDAAwD;AACxD,mCAAmC;AACnC,qEAAqE;AACrE,sDAAsD;AACtD,4BAA4B;AAC5B,oCAAoC;AACpC,iDAAiD;AACjD,+BAA+B;AAC/B,6BAA6B;AAC7B,mCAAmC;AACnC,uCAAuC;AACvC,4BAA4B;AAC5B,0DAA0D;AAC1D,2BAA2B;AAC3B,cAAc;AACd,sCAAsC;AACtC,0DAA0D;AAC1D,wDAAwD;AACxD,8CAA8C;AAC9C,4DAA4D;AAC5D,YAAY;AACZ,4CAA4C;AAC5C,mFAAmF;AACnF,qDAAqD;AACrD,oDAAoD;AACpD,+DAA+D;AAC/D,sDAAsD;AACtD,uBAAuB;AACvB,6DAA6D;AAE7D,4EAA4E;AAC5E,uCAAuC;AACvC,8CAA8C;AAC9C,kEAAkE;AAClE,uHAAuH;AACvH,wHAAwH;AACxH,uHAAuH;AACvH,oFAAoF;AACpF,2GAA2G;AAC3G,4FAA4F;AAC5F,8BAA8B;AAC9B,wCAAwC;AACxC,uBAAuB;AACvB,gFAAgF;AAChF,oEAAoE;AACpE,yCAAyC;AACzC,yBAAyB;AACzB,6CAA6C;AAC7C,oFAAoF;AACpF,8BAA8B;AAC9B,mEAAmE;AACnE,wGAAwG;AACxG,mDAAmD;AACnD,6CAA6C;AAC7C,sEAAsE;AACtE,0IAA0I;AAC1I,6BAA6B;AAC7B,uBAAuB;AACvB,gBAAgB;AAChB,eAAe;AACf,+CAA+C;AAC/C,6EAA6E;AAC7E,qGAAqG;AAErG,kBAAkB;AAClB,QAAQ;AACR,IAAI","sourcesContent":["import fs from 'fs-extra';\r\nimport ps from 'path';\r\nimport { IBundler } from './bundler';\r\nimport { CacheTransformed } from './cache-transformed';\r\nimport esBuild, { Metadata } from 'esbuild';\r\n\r\n// export class EsBuildBundler extends CacheTransformed implements IBundler {\r\n//     public async build({\r\n//         outDir,\r\n//     }: Parameters<IBundler['build']>[0]) {\r\n//         const entries: string[] = [];\r\n//         const entryHome = ps.join(this.cacheDir, 'exports');\r\n//         for (const entryFileName of (await fs.readdir(entryHome))) {\r\n//             if (entryFileName.toLowerCase().endsWith('.js')) {\r\n//                 const entryFile = ps.normalize(ps.join(entryHome, entryFileName));\r\n\r\n//                 const systemProxyFile = ps.join(this.cacheDir, '__proxy', entryFileName);\r\n//                 const relativeUrl = `./${ps.relative(ps.dirname(systemProxyFile), entryFile).replace(/\\\\/g, '/')}`;\r\n//                 await fs.ensureDir(ps.dirname(systemProxyFile));\r\n//                 await fs.writeFile(systemProxyFile, `\r\n// import * as esExp from '${relativeUrl}';\r\n// System.register([], function(_context, _export) {\r\n//     return {\r\n//         execute() {\r\n//             _export(esExp);\r\n//         },\r\n//     }\r\n// });\r\n// `, 'utf8');\r\n//                 entries.push(systemProxyFile);\r\n\r\n//                 // entries.push(entryFile);\r\n//             }\r\n//         }\r\n\r\n//         const bundleOutDir = ps.join(outDir, 'bundle');\r\n//         await fs.ensureDir(ps.dirname(bundleOutDir));\r\n//         console.time('esbuild');\r\n//         const buildMetaFile = ps.join(outDir, 'bundle-meta.json');\r\n//         const esBuildResult = await esBuild.build({\r\n//             bundle: true,\r\n//             entryPoints: entries,\r\n//             outdir: ps.join(outDir, 'bundle'),\r\n//             splitting: true,\r\n//             format: 'esm',\r\n//             sourcemap: 'inline',\r\n//             metafile: buildMetaFile,\r\n//             write: false,\r\n//             external: ['@cocos/ammo', '@cocos/cannon'],\r\n//             color: true,\r\n//         });\r\n//         console.timeEnd('esbuild');\r\n//         for (const warning of esBuildResult.warnings) {\r\n//             const location = !warning.location ? '' :\r\n//                 `${warning.location.file}`;\r\n//             console.warn(`${location}: ${warning.text}`);\r\n//         }\r\n//         console.time(`Transform trunks`);\r\n//         await Promise.all(esBuildResult.outputFiles!.map(async (outputFile) => {\r\n//             const { path, contents } = outputFile;\r\n//             await fs.ensureDir(ps.dirname(path));\r\n//             if (!path.toLocaleLowerCase().endsWith('.js')) {\r\n//                 await fs.writeFile(path, contents);\r\n//             } else {\r\n//                 return await fs.writeFile(path, contents);\r\n\r\n//                 // const source = Buffer.from(contents).toString('utf8');\r\n//                 // let code: string;\r\n//                 // let inputSourceMap: any;\r\n//                 // // Note: . would not match the last new line\r\n//                 // // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/dotAll\r\n//                 // // See https://stackoverflow.com/questions/1979884/how-to-use-javascript-regex-over-multiple-lines\r\n//                 // const sourceMapMatch = /\\/\\/# sourceMappingURL=data:application\\/json;base64,(.*)/s.exec(source);\r\n//                 // if (sourceMapMatch && typeof sourceMapMatch[1] === 'string') {\r\n//                 //     inputSourceMap = JSON.parse(Buffer.from(sourceMapMatch[1], 'base64').toString());\r\n//                 //     code = source.substr(0, source.length - sourceMapMatch[0].length);\r\n//                 // } else {\r\n//                 //     code = source;\r\n//                 // }\r\n//                 // const transformResult = await babel.transformAsync(code, {\r\n//                 //     plugins: [babelPluginTransformModulesUmd],\r\n//                 //     inputSourceMap,\r\n//                 // });\r\n//                 // if (!transformResult) {\r\n//                 //     console.error(`Failed to transform bundle chunk to UMD!`);\r\n//                 // } else {\r\n//                 //     const codeWithMap = transformResult.map ?\r\n//                 //         `${transformResult.code}\\n//# sourceMappingURL=${ps.basename(path)}.map` :\r\n//                 //         transformResult.code;\r\n//                 //     await Promise.all([\r\n//                 //         fs.writeFile(path, codeWithMap, 'utf8'),\r\n//                 //         !transformResult.map ? undefined : fs.writeFile(`${path}.map`, JSON.stringify(transformResult.map), 'utf8'),\r\n//                 //     ]);\r\n//                 // }\r\n//             }\r\n//         }));\r\n//         console.timeEnd(`Transform trunks`);\r\n//         // const buildMeta = await fs.readJson(buildMetaFile) as Metadata;\r\n//         // await Promise.all(Object.entries(buildMeta.outputs).map(async ([path, outputInfo]) => {\r\n\r\n//         // }));\r\n//     }\r\n// }\r\n"]}