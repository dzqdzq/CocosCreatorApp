"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.core = void 0;
const fs_extra_1 = __importDefault(require("fs-extra"));
const path_1 = __importDefault(require("path"));
const module_resolve_1 = require("@editor/transform-utilities/dist/module-resolve");
const path_url_interop_1 = require("@editor/transform-utilities/dist/path-url-interop");
const url_1 = require("url");
const babel = __importStar(require("@babel/core"));
const babel_preset_cc_1 = __importDefault(require("@cocos/babel-preset-cc"));
const preset_env_1 = __importDefault(require("@babel/preset-env"));
// @ts-ignore
const babel_plugin_const_enum_1 = __importDefault(require("babel-plugin-const-enum"));
// @ts-ignore
const plugin_transform_modules_umd_1 = __importDefault(require("@babel/plugin-transform-modules-umd"));
// @ts-ignore
const plugin_transform_modules_systemjs_1 = __importDefault(require("@babel/plugin-transform-modules-systemjs"));
// @ts-ignore
const plugin_transform_modules_commonjs_1 = __importDefault(require("@babel/plugin-transform-modules-commonjs"));
// @ts-ignore
const plugin_proposal_dynamic_import_1 = __importDefault(require("@babel/plugin-proposal-dynamic-import"));
const babel_plugin_dynamic_import_vars_1 = __importDefault(require("@cocos/babel-plugin-dynamic-import-vars"));
const jss = __importStar(require("javascript-stringify"));
const file_uid_1 = require("./file-uid");
const virtual_modules_1 = require("./virtual-modules");
const module_specifier_visitor_1 = require("./module-specifier-visitor");
const bundle_externals_1 = require("./bundle-externals");
const bundler_1 = require("./bundler");
const progress_1 = require("./progress");
const seq_1 = require("./seq");
const relateurl_1 = __importDefault(require("relateurl"));
async function core({ rootDir, entries, targetOptions, targetRecord, bundler, chunkDir, fsCache, vm, logger, onProgress, }) {
    const rootDirUrl = url_1.pathToFileURL(rootDir);
    const babelHelpersModuleName = 'quick-compiler.babel-helpers';
    const babelHelpersModuleUid = file_uid_1.encodeVirtualFileUid(babelHelpersModuleName);
    const virtualModules = vm !== null && vm !== void 0 ? vm : new virtual_modules_1.VirtualModules();
    await setupVirtualModules();
    const moduleResolver = new module_resolve_1.ModuleResolver({
        rootDir,
    });
    // Do audition.
    const audition = { audited: new Set() };
    const transformProgress = {
        stage: progress_1.Stage.transform,
        total: 0,
        progress: 0,
        file: '',
    };
    const updateTransformProgress = onProgress
        ? () => onProgress(transformProgress)
        : undefined;
    await main();
    async function main() {
        await Promise.all(entries.concat([babelHelpersModuleUid]).map((fileUid) => audit(fileUid)));
        if (await rebuildExternalDependenciesIsNeeded()) {
            onProgress === null || onProgress === void 0 ? void 0 : onProgress({
                stage: progress_1.Stage.external,
            });
            await createExternalDependenciesStuffs();
        }
    }
    async function setupVirtualModules() {
        virtualModules.set('internal:constants', () => `export * from "${path_1.default.join(rootDir, 'cocos', 'core', 'default-constants.ts').replace(/\\/g, '/')}";\n`);
        virtualModules.set(babelHelpersModuleName, () => {
            // @ts-ignore
            return babel.buildExternalHelpers(null, 'module');
        });
    }
    /**
     * @param fileUid
     */
    async function audit(fileUid) {
        if (audition.audited.has(fileUid)) {
            return;
        }
        audition.audited.add(fileUid);
        if (fileUid in targetRecord.files) {
            return;
        }
        let source;
        let fileTime = 0;
        const isVirtual = file_uid_1.isVirtualFileUid(fileUid);
        if (isVirtual) {
            const name = file_uid_1.decodeVirtualFileUid(fileUid);
            if (!virtualModules.has(name)) {
                logger.error(`Can not find module(virtual): ${name}`);
                return;
            }
            source = virtualModules.get(name);
        }
        else {
            fileTime = (await fsCache.stat(fileUid)).mtimeMs;
            source = await fsCache.readFile(fileUid);
            if (fileUid.toLowerCase().endsWith('.json')) {
                // Because AMD (which is our engine code format, in editor or previewer)
                // is not able to import a json module, in [SystemJS](https://github.com/systemjs/systemjs/issues/2045).
                // We should transform the json module here.
                source = `export default ${jss.stringify(JSON.parse(source), undefined, 2)}`;
            }
        }
        // Update total
        ++transformProgress.total;
        transformProgress.file = fileUid;
        updateTransformProgress === null || updateTransformProgress === void 0 ? void 0 : updateTransformProgress();
        transformProgress.file = '';
        logger.debug(`[QuickCompiler] Transforming ${fileUid}...`);
        const newFileRecord = {
            fileTime,
            dependencies: [],
            externalDependencies: {},
            status: false,
        };
        targetRecord.files[fileUid] = newFileRecord;
        const transformResult = await (async () => {
            try {
                return await compileFile(source, fileUid, newFileRecord, bundler);
            }
            catch (err) {
                logger.error(err);
                return;
            }
        })();
        newFileRecord.status = !!transformResult;
        // Update progress
        ++transformProgress.progress;
        updateTransformProgress === null || updateTransformProgress === void 0 ? void 0 : updateTransformProgress();
        const store = !transformResult ? undefined :
            bundler.store(fileUid, transformResult.code, transformResult.map);
        await store;
        await seq_1.sequenceDiscarding(newFileRecord.dependencies, async (dependency) => await audit(dependency));
    }
    /**
     * @param source
     * @param fileUid
     * @param record
     */
    async function compileFile(source, fileUid, record, bundler) {
        var _a, _b, _c, _d;
        const outFileURL = bundler.getOutFileUrl(fileUid);
        const resolveRelativeFromOutFile = new relateurl_1.default(outFileURL);
        let fileName;
        let sourceFileName;
        let isFile = false;
        if (file_uid_1.isVirtualFileUid(fileUid)) {
            sourceFileName = `virtual:///${file_uid_1.decodeVirtualFileUid(fileUid)}`;
        }
        else {
            fileName = path_1.default.resolve(rootDir, file_uid_1.decodeRegularFilePath(fileUid));
            isFile = true;
            const fileURL = url_1.pathToFileURL(fileName);
            if (targetOptions.usedInElectron509) {
                sourceFileName = fileURL.href;
            }
            else {
                sourceFileName = resolveRelativeFromOutFile.relate(fileURL.href);
            }
        }
        const sourceMaps = !!sourceFileName;
        const targetModule = (_a = bundler.targetMode) !== null && _a !== void 0 ? _a : bundler_1.TransformTargetModule.esm;
        const babelOptionsBase = {
            moduleIds: targetModule === bundler_1.TransformTargetModule.systemJsNamed,
            moduleId: (_c = (_b = bundler.getModuleId) === null || _b === void 0 ? void 0 : _b.call(bundler, fileUid)) !== null && _c !== void 0 ? _c : fileUid,
            filename: fileName,
            sourceMaps,
            sourceFileName,
            configFile: false,
            babelrc: false,
        };
        const addTransformModulesPlugin = (plugins) => {
            if (targetModule === bundler_1.TransformTargetModule.umd) {
                plugins.push([plugin_transform_modules_umd_1.default]);
            }
            else if (targetModule === bundler_1.TransformTargetModule.commonJs) {
                plugins.push([plugin_transform_modules_commonjs_1.default]);
            }
            else if (targetModule === bundler_1.TransformTargetModule.systemJs || targetModule === bundler_1.TransformTargetModule.systemJsNamed) {
                plugins.push([plugin_transform_modules_systemjs_1.default]);
            }
            return plugins;
        };
        if (fileUid === babelHelpersModuleUid) {
            const babelFileResult = await babel.transformAsync(source, Object.assign(Object.assign({}, babelOptionsBase), { plugins: [
                    [babel_plugin_const_enum_1.default, { transform: 'constObject' }]
                ].concat(addTransformModulesPlugin([])) }));
            if (!babelFileResult) {
                return;
            }
            else {
                return {
                    code: babelFileResult.code,
                };
            }
        }
        const getModuleRequestTo = (targetFileUid) => path_url_interop_1.moduleSpecifierURLRelative(outFileURL, bundler.getOutFileUrl(targetFileUid));
        const helperModuleRequest = getModuleRequestTo(babelHelpersModuleUid);
        // Resolves them and record the useful information.
        const moduleSpecifierResolveMap = {};
        const processModuleSpecifier = (moduleSpecifier) => {
            let resolvedModule;
            if (virtualModules.has(moduleSpecifier)) {
                resolvedModule = {
                    file: moduleSpecifier,
                    isExternal: false,
                };
            }
            else if (!fileName) { // isVirtualFileUid(fileUid)
                resolvedModule = {
                    file: moduleSpecifier,
                    isExternal: false,
                };
            }
            else {
                resolvedModule = moduleResolver.resolveSync(moduleSpecifier, fileName);
                if (resolvedModule && !resolvedModule.isExternal) {
                    const lower = resolvedModule.file.toLowerCase();
                    if (lower.endsWith('.d.ts')) {
                        // If a module is resolved to a declaration file.
                        // We are trying to figure out the real code file.
                        const baseName = resolvedModule.file.substr(0, resolvedModule.file.length - 5);
                        for (const extension of ['.js', '.json']) {
                            const name = `${baseName}${extension}`;
                            if (fs_extra_1.default.pathExistsSync(name)) {
                                resolvedModule.file = name;
                            }
                        }
                    }
                }
            }
            if (!resolvedModule) {
                return;
            }
            let replacement = null;
            if (resolvedModule.isExternal) {
                record.externalDependencies[moduleSpecifier] = getDependencyFileId(resolvedModule.file);
            }
            else {
                const depFileId = getFileUidFromResolved(resolvedModule.file);
                if (!depFileId) {
                    logger.error(`File ${resolvedModule.file} referenced from ${fileName !== null && fileName !== void 0 ? fileName : fileUid} is not under source root.`);
                    return;
                }
                replacement = module_resolve_1.replaceWithOutputExtension(getModuleRequestTo(depFileId));
                if (!(depFileId in record.dependencies)) {
                    record.dependencies.push(depFileId);
                }
            }
            if (replacement) {
                moduleSpecifierResolveMap[moduleSpecifier] = replacement;
            }
        };
        const resolveModuleSpecifier = {
            visitor: module_specifier_visitor_1.makeVisitorOnModuleSpecifiers((moduleSpecifierPath) => {
                const moduleSpecifier = moduleSpecifierPath.node.value;
                processModuleSpecifier(moduleSpecifier);
                // An in-place babel plugin which apply the resolve result.
                if (moduleSpecifier in moduleSpecifierResolveMap) {
                    moduleSpecifierPath.replaceWith(babel.types.stringLiteral(moduleSpecifierResolveMap[moduleSpecifier]));
                }
            }),
        };
        // 2020.10.10: esbuild will treat empty files(not using es6 features) as commonjs modules.
        // 1. for commonjs modules, esbuild will generate strange _commonjs wrapper to handle.
        // 2. If a module (transitively) export star from commonjs modules, the module is
        // treated as commonjs module and will only export a default binding.
        const injectEmptyExportStmt = {
            visitor: { Program: { exit: (path) => {
                        if (path.node.body.length === 0) {
                            path.node.body.push(babel.types.exportNamedDeclaration(undefined, []));
                        }
                    } } },
        };
        const transformCodePassResult = await babel.transformAsync(source, Object.assign(Object.assign({}, babelOptionsBase), { presets: [
                [{ plugins: [
                            [babel_plugin_const_enum_1.default, { transform: 'constObject' }],
                            [plugin_proposal_dynamic_import_1.default],
                        ] }],
                [preset_env_1.default, {
                        modules: false,
                        targets: targetOptions.targets,
                        loose: targetOptions.loose,
                    }],
                [{ plugins: [
                            [injectEmptyExportStmt],
                            [babel_plugin_dynamic_import_vars_1.default],
                            [resolveModuleSpecifier],
                            ...addTransformModulesPlugin([]),
                        ] }],
                [babel_preset_cc_1.default, {
                        allowDeclareFields: true,
                    }],
                [{ plugins: [
                        // [importHelperPlugin, { helperModuleName: helperModuleRequest }],
                        ] }],
            ] }));
        if (!transformCodePassResult || !transformCodePassResult.code) {
            return;
        }
        if ((_d = transformCodePassResult.map) === null || _d === void 0 ? void 0 : _d.sourcesContent) {
            if (isFile) {
                delete transformCodePassResult.map.sourcesContent;
            }
        }
        return {
            code: transformCodePassResult.code,
            map: transformCodePassResult.map ? JSON.stringify(transformCodePassResult.map) : undefined,
        };
    }
    /**
     *
     */
    function countExternalDependencies() {
        const dependenciesMap = {};
        for (const fileRecord of Object.values(targetRecord.files)) {
            Object.assign(dependenciesMap, fileRecord.externalDependencies);
        }
        return dependenciesMap;
    }
    /**
     *
     */
    async function rebuildExternalDependenciesIsNeeded() {
        //// TODO!!!!! remove
        // return true;
        if (true) {
            const old = targetRecord.externalDependencies;
            const now = countExternalDependencies();
            const keysOld = Object.keys(old);
            const keysNew = Object.keys(now);
            if (keysOld.length !== keysNew.length ||
                !keysOld.every((keyOld) => keysNew.includes(keyOld) && old[keyOld] === now[keyOld]) ||
                !keysNew.every((keyNew) => keysOld.includes(keyNew))) {
                logger.debug(`Dependencies changed from ${JSON.stringify(old, undefined, 2)} to ${JSON.stringify(now, undefined, 2)}`);
                return true;
            }
        }
        // 任何外部依赖文件更新了，都需要重新构建。
        for (const file of Object.keys(targetRecord.externalDependencyWatchFiles)) {
            const stamp = targetRecord.externalDependencyWatchFiles[file];
            try {
                const stat = await fs_extra_1.default.stat(getDependencyFile(file));
                if (stat.mtimeMs !== stamp) {
                    logger.debug(`[QuickCompiler] External dependency "${file}" changed.`);
                    return true;
                }
            }
            catch (_a) {
                logger.debug(`[QuickCompiler] Miss external dependency "${file}".`);
                return true;
            }
        }
        return false;
    }
    /**
     * @param chunkDir
     * @param importMapFile
     */
    async function createExternalDependenciesStuffs() {
        targetRecord.externalDependencyWatchFiles = {};
        targetRecord.externalDependencyImportMap = {};
        const dependenciesMap = countExternalDependencies();
        const dependenciesMapResolved = {};
        for (const key of Object.keys(dependenciesMap)) {
            dependenciesMapResolved[key] = getDependencyFile(dependenciesMap[key]);
        }
        const dependencyEntries = Object.entries(dependenciesMapResolved).map(([k, v]) => [v, k]);
        logger.debug(`Bundling external dependencies: ${JSON.stringify(dependenciesMapResolved, undefined, 2)}`);
        const bundleResult = await bundle_externals_1.bundleExternals(dependencyEntries, {
            rootDir,
            perf: targetOptions.perf,
        });
        if (await fs_extra_1.default.pathExists(chunkDir)) {
            await fs_extra_1.default.emptyDir(chunkDir);
        }
        await bundleResult.write({
            format: targetOptions.format,
            sourceMap: true,
            chunkDir,
        });
        for (const moduleSpecifier of Object.keys(dependenciesMapResolved)) {
            const entry = dependenciesMapResolved[moduleSpecifier];
            const chunkRelativeURL = bundleResult.entryMap[entry].split(/[\\/]/g).map((part) => encodeURIComponent(part)).join('/');
            targetRecord.externalDependencyImportMap[moduleSpecifier] = chunkRelativeURL;
        }
        const watchFiles = {};
        for (const watchFile of bundleResult.watchFiles) {
            try {
                const stat = await fs_extra_1.default.stat(watchFile);
                watchFiles[getDependencyFileId(watchFile)] = stat.mtimeMs;
            }
            catch (_a) {
            }
        }
        targetRecord.externalDependencies = dependenciesMap;
        targetRecord.externalDependencyWatchFiles = watchFiles;
    }
    /**
     * @param moduleNameOrFile
     */
    function getFileUidFromResolved(moduleNameOrFile) {
        if (virtualModules.has(moduleNameOrFile)) {
            return file_uid_1.encodeVirtualFileUid(moduleNameOrFile);
        }
        const relativeFromRoot = path_1.default.relative(path_1.default.join(rootDir), moduleNameOrFile);
        if (relativeFromRoot.length === 0 ||
            relativeFromRoot.startsWith('..') ||
            path_1.default.isAbsolute(relativeFromRoot)) {
            return null;
        }
        else {
            return relativeFromRoot;
        }
    }
    /**
     * @param dependencyFile
     */
    function getDependencyFileId(dependencyFile) {
        return path_1.default.relative(rootDir, dependencyFile);
    }
    /**
     * @param dependencyFileId
     */
    function getDependencyFile(dependencyFileId) {
        return path_1.default.resolve(rootDir, dependencyFileId);
    }
}
exports.core = core;
//# sourceMappingURL=core.js.map