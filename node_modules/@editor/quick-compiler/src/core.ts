
import fs from 'fs-extra';
import ps from 'path';
import { ModuleResolver, replaceWithOutputExtension } from '@editor/transform-utilities/dist/module-resolve';
import { urlRelative, moduleSpecifierURLRelative } from '@editor/transform-utilities/dist/path-url-interop';
import { pathToFileURL } from 'url';
import * as babel from '@babel/core';
import babelPresetCC from '@cocos/babel-preset-cc';
import babelPresetEnv from '@babel/preset-env';
// @ts-ignore
import babelPluginConstEnum from 'babel-plugin-const-enum';
// @ts-ignore
import babelPluginTransformModulesUmd from '@babel/plugin-transform-modules-umd';
// @ts-ignore
import babelPluginTransformModulesSystemJs from '@babel/plugin-transform-modules-systemjs';
// @ts-ignore
import babelPluginTransformModulesCommonJs from '@babel/plugin-transform-modules-commonjs';
// @ts-ignore
import babelPluginProposalDynamicImport from '@babel/plugin-proposal-dynamic-import';
import babelPluginDynamicVars from '@cocos/babel-plugin-dynamic-import-vars';
import * as jss from 'javascript-stringify';
import type { FileUid } from './file-uid';
import { decodeVirtualFileUid, isVirtualFileUid, encodeVirtualFileUid, decodeRegularFilePath } from './file-uid';
import { VirtualModules } from './virtual-modules';
import { makeVisitorOnModuleSpecifiers } from './module-specifier-visitor';
import { FileRecord } from './file-record';
import { SourceMapOptions } from './source-map-options';
import { bundleExternals } from './bundle-externals';
import { importHelperPlugin } from './bundled-helpers-plugin';
import { IBundler, TransformTargetModule } from './bundler';
import { TargetRecord } from './target';
import { FsCache } from './fs-cache';
import { ProgressMessage, Stage, TransformStageMessage } from './progress';
import { sequenceDiscarding } from './seq';
import winston from 'winston';
import RelateURl from 'relateurl';

type FileId = FileUid;

export interface TargetOptions extends SourceMapOptions {
    /**
     * 加到功能模块的前缀。
     */
    featureUnitPrefix?: string;

    /**
     * 是否包含引擎 `editor/exports` 下的模块。
     */
    includeEditorExports?: boolean;

    /**
     * `'cc'` 模块的内容。
     */
    includeIndex?: {
        features: string[];
    };

    /**
     * 输出目录。
     */
    dir: string;

    /**
     * 输出格式。
     */
    format: 'commonjs' | 'systemjs';

    /**
     * 宽松模式.
     */
    loose?: boolean;

    /**
     * BrowsersList targets.
     */
    targets?: string | string[] | Record<string, string>;
    perf?: boolean;
}

export interface OutputProfile {
    importMap: ImportMap & { imports: NonNullable<ImportMap['imports']> };
    importMapFile: string;
    chunkDir: string;
}

export async function core({
    rootDir,
    entries,
    targetOptions,
    targetRecord,
    bundler,
    chunkDir,
    fsCache,
    vm,
    logger,
    onProgress,
}: {
    rootDir: string;
    entries: FileUid[];
    targetOptions: TargetOptions;
    targetRecord: TargetRecord;
    bundler: IBundler;
    chunkDir: string;
    fsCache: FsCache;
    vm?: VirtualModules;
    logger: winston.Logger,
    onProgress?: (message: Readonly<ProgressMessage>) => void;
}) {
    const rootDirUrl = pathToFileURL(rootDir);

    const babelHelpersModuleName = 'quick-compiler.babel-helpers';
    const babelHelpersModuleUid = encodeVirtualFileUid(babelHelpersModuleName);

    const virtualModules = vm ?? new VirtualModules();
    await setupVirtualModules();

    const moduleResolver = new ModuleResolver({
        rootDir,
    });

    // Do audition.
    const audition: {
        audited: Set<string>;
    } = { audited: new Set() };

    const transformProgress: TransformStageMessage = {
        stage: Stage.transform,
        total: 0,
        progress: 0,
        file: '',
    };

    const updateTransformProgress = onProgress
        ? () => onProgress(transformProgress)
        : undefined;

    await main();

    async function main() {
        await Promise.all(entries.concat(
            [babelHelpersModuleUid],
        ).map(
            (fileUid) => audit(fileUid),
        ));
    
        if (await rebuildExternalDependenciesIsNeeded()) {
            onProgress?.({
                stage: Stage.external,
            });
            await createExternalDependenciesStuffs();
        }
    }

    async function setupVirtualModules() {
        virtualModules.set(
            'internal:constants',
            () => `export * from "${ps.join(rootDir, 'cocos', 'core', 'default-constants.ts').replace(/\\/g, '/')}";\n`,
        );

        virtualModules.set(
            babelHelpersModuleName,
            () => {
                // @ts-ignore
                return babel.buildExternalHelpers(null, 'module');
            },
        );

    }

    /**
     * @param fileUid
     */
    async function audit(fileUid: FileId) {
        if (audition.audited.has(fileUid)) {
            return;
        }
        audition.audited.add(fileUid);

        if (fileUid in targetRecord.files) {
            return;
        }

        let source: string;
        let fileTime = 0;
        const isVirtual = isVirtualFileUid(fileUid);
        if (isVirtual) {
            const name = decodeVirtualFileUid(fileUid);
            if (!virtualModules.has(name)) {
                logger.error(`Can not find module(virtual): ${name}`);
                return;
            }
            source = virtualModules.get(name);
        } else {
            fileTime = (await fsCache.stat(fileUid)).mtimeMs;
            source = await fsCache.readFile(fileUid);
            if (fileUid.toLowerCase().endsWith('.json')) {
                // Because AMD (which is our engine code format, in editor or previewer)
                // is not able to import a json module, in [SystemJS](https://github.com/systemjs/systemjs/issues/2045).
                // We should transform the json module here.
                source = `export default ${jss.stringify(JSON.parse(source), undefined, 2)}`;
            }
        }

        // Update total
        ++transformProgress.total;
        transformProgress.file = fileUid;
        updateTransformProgress?.();
        transformProgress.file = '';
        logger.debug(`[QuickCompiler] Transforming ${fileUid}...`);

        const newFileRecord: FileRecord = {
            fileTime,
            dependencies: [],
            externalDependencies: {},
            status: false,
        };
        targetRecord.files[fileUid] = newFileRecord;

        const transformResult = await (async () => {
            try {
                return await compileFile(source, fileUid, newFileRecord, bundler);
            } catch (err) {
                logger.error(err);
                return;
            }
        })();
        newFileRecord.status = !!transformResult;

        // Update progress
        ++transformProgress.progress;
        updateTransformProgress?.();

        const store = !transformResult ? undefined : 
            bundler.store(fileUid, transformResult.code, transformResult.map);

        await store;
        await sequenceDiscarding(
            newFileRecord.dependencies,
            async (dependency) => await audit(dependency),
        );
    }

    /**
     * @param source
     * @param fileUid
     * @param record
     */
    async function compileFile(source: string, fileUid: string, record: FileRecord, bundler: IBundler) {
        const outFileURL = bundler.getOutFileUrl(fileUid);
        const resolveRelativeFromOutFile = new RelateURl(outFileURL);

        let fileName: string | undefined;
        let sourceFileName: string | undefined;
        let isFile = false;
        if (isVirtualFileUid(fileUid)) {
            sourceFileName = `virtual:///${decodeVirtualFileUid(fileUid)}`;
        } else {
            fileName = ps.resolve(rootDir, decodeRegularFilePath(fileUid));
            isFile = true;
            const fileURL = pathToFileURL(fileName);
            if (targetOptions.usedInElectron509) {
                sourceFileName = fileURL.href;
            } else {
                sourceFileName = resolveRelativeFromOutFile.relate(fileURL.href);
            }
        }

        const sourceMaps = !!sourceFileName;

        const targetModule = bundler.targetMode ?? TransformTargetModule.esm;
        const babelOptionsBase: babel.TransformOptions = {
            moduleIds: targetModule === TransformTargetModule.systemJsNamed,
            moduleId: bundler.getModuleId?.(fileUid) ?? fileUid,
            filename: fileName,
            sourceMaps,
            sourceFileName,

            configFile: false,
            babelrc: false,
        };
        const addTransformModulesPlugin = (plugins: any[]) => {
            if (targetModule === TransformTargetModule.umd) {
                plugins.push([babelPluginTransformModulesUmd]);
            } else if (targetModule === TransformTargetModule.commonJs) {
                plugins.push([babelPluginTransformModulesCommonJs]);
            } else if (targetModule === TransformTargetModule.systemJs || targetModule === TransformTargetModule.systemJsNamed) {
                plugins.push([babelPluginTransformModulesSystemJs]);
            }
            return plugins;
        };

        if (fileUid === babelHelpersModuleUid) {
            const babelFileResult = await babel.transformAsync(source, {
                ...babelOptionsBase,
                plugins: [
                    [babelPluginConstEnum, { transform: 'constObject' }]
                ].concat(addTransformModulesPlugin([])),
            });
            if (!babelFileResult) {
                return;
            } else {
                return {
                    code: babelFileResult.code!,
                };
            }
        }

        const getModuleRequestTo = (targetFileUid: string) => moduleSpecifierURLRelative(
            outFileURL,
            bundler.getOutFileUrl(targetFileUid),
        );

        const helperModuleRequest = getModuleRequestTo(babelHelpersModuleUid);

        // Resolves them and record the useful information.
        const moduleSpecifierResolveMap: Record<string, string> = {};
        const processModuleSpecifier = (moduleSpecifier: string) => {
            let resolvedModule: {
                file: string;
                isExternal: boolean;
            } | null;

            if (virtualModules.has(moduleSpecifier)) {
                resolvedModule = {
                    file: moduleSpecifier,
                    isExternal: false,
                };
            } else if (!fileName) { // isVirtualFileUid(fileUid)
                resolvedModule = {
                    file: moduleSpecifier,
                    isExternal: false,
                };
            } else {
                resolvedModule = moduleResolver.resolveSync(moduleSpecifier, fileName);
                if (resolvedModule && !resolvedModule.isExternal) {
                    const lower = resolvedModule.file.toLowerCase();
                    if (lower.endsWith('.d.ts')) {
                        // If a module is resolved to a declaration file.
                        // We are trying to figure out the real code file.
                        const baseName = resolvedModule.file.substr(0, resolvedModule.file.length - 5);
                        for (const extension of ['.js', '.json']) {
                            const name = `${baseName}${extension}`;
                            if (fs.pathExistsSync(name)) {
                                resolvedModule.file = name;
                            }
                        }
                    }
                }
            }

            if (!resolvedModule) {
                return;
            }

            let replacement: string | null = null;
            if (resolvedModule.isExternal) {
                record.externalDependencies[moduleSpecifier] = getDependencyFileId(resolvedModule.file);
            } else {
                const depFileId = getFileUidFromResolved(resolvedModule.file);
                if (!depFileId) {
                    logger.error(`File ${resolvedModule.file} referenced from ${fileName ?? fileUid} is not under source root.`);
                    return;
                }
                replacement = replaceWithOutputExtension(getModuleRequestTo(depFileId));
                if (!(depFileId in record.dependencies)) {
                    record.dependencies.push(depFileId);
                }
            }

            if (replacement) {
                moduleSpecifierResolveMap[moduleSpecifier] = replacement;
            }
        };
        const resolveModuleSpecifier: babel.PluginObj = {
            visitor: makeVisitorOnModuleSpecifiers((moduleSpecifierPath) => {
                const moduleSpecifier = moduleSpecifierPath.node.value;
                processModuleSpecifier(moduleSpecifier);
                // An in-place babel plugin which apply the resolve result.
                if (moduleSpecifier in moduleSpecifierResolveMap) {
                    moduleSpecifierPath.replaceWith(babel.types.stringLiteral(moduleSpecifierResolveMap[moduleSpecifier]));
                }
            }),
        };

        // 2020.10.10: esbuild will treat empty files(not using es6 features) as commonjs modules.
        // 1. for commonjs modules, esbuild will generate strange _commonjs wrapper to handle.
        // 2. If a module (transitively) export star from commonjs modules, the module is
        // treated as commonjs module and will only export a default binding.
        const injectEmptyExportStmt: babel.PluginObj = {
            visitor: { Program: { exit: (path) => {
                if (path.node.body.length === 0) {
                    path.node.body.push(
                        babel.types.exportNamedDeclaration(
                            undefined,
                            [],
                        ));
                }
            } } },
        };

        const transformCodePassResult = await babel.transformAsync(source, {
            ...babelOptionsBase,
            presets: [
                [{ plugins: [
                    [babelPluginConstEnum, { transform: 'constObject' }],
                    [babelPluginProposalDynamicImport],
                ] }],
                [babelPresetEnv, {
                    modules: false,
                    targets: targetOptions.targets,
                    loose: targetOptions.loose,
                } as babelPresetEnv.Options],
                [{ plugins: [
                    [injectEmptyExportStmt],
                    [babelPluginDynamicVars],
                    [resolveModuleSpecifier], // Resolve module specifiers
                    ...addTransformModulesPlugin([]),
                ] }],
                [babelPresetCC, {
                    allowDeclareFields: true,
                } as babelPresetCC.Options],
                [{ plugins: [
                    // [importHelperPlugin, { helperModuleName: helperModuleRequest }],
                ] }],
            ],
        });

        if (!transformCodePassResult || !transformCodePassResult.code) {
            return;
        }

        if (transformCodePassResult.map?.sourcesContent) {
            if (isFile) {
                delete transformCodePassResult.map.sourcesContent;
            }
        }

        return {
            code: transformCodePassResult.code!,
            map: transformCodePassResult.map? JSON.stringify(transformCodePassResult.map) : undefined,
        };
    }

    /**
     *
     */
    function countExternalDependencies() {
        const dependenciesMap: Record<string, string> = {};
        for (const fileRecord of Object.values(targetRecord.files)) {
            Object.assign(dependenciesMap, fileRecord.externalDependencies);
        }
        return dependenciesMap;
    }

    /**
     *
     */
    async function rebuildExternalDependenciesIsNeeded() {
        //// TODO!!!!! remove
        // return true;

        if (true) {
            const old = targetRecord.externalDependencies;
            const now = countExternalDependencies();
            const keysOld = Object.keys(old);
            const keysNew = Object.keys(now);
            if (keysOld.length !== keysNew.length ||
                !keysOld.every((keyOld) => keysNew.includes(keyOld) && old[keyOld] === now[keyOld]) ||
                !keysNew.every((keyNew) => keysOld.includes(keyNew))
            ) {
                logger.debug(`Dependencies changed from ${JSON.stringify(old, undefined, 2)} to ${JSON.stringify(now, undefined, 2)}`);
                return true;
            }
        }

        // 任何外部依赖文件更新了，都需要重新构建。
        for (const file of Object.keys(targetRecord.externalDependencyWatchFiles)) {
            const stamp = targetRecord.externalDependencyWatchFiles[file];
            try {
                const stat = await fs.stat(getDependencyFile(file));
                if (stat.mtimeMs !== stamp) {
                    logger.debug(`[QuickCompiler] External dependency "${file}" changed.`);
                    return true;
                }
            } catch {
                logger.debug(`[QuickCompiler] Miss external dependency "${file}".`);
                return true;
            }
        }

        return false;
    }

    /**
     * @param chunkDir
     * @param importMapFile
     */
    async function createExternalDependenciesStuffs() {
        targetRecord.externalDependencyWatchFiles = {};
        targetRecord.externalDependencyImportMap = {};

        const dependenciesMap = countExternalDependencies();

        const dependenciesMapResolved: typeof dependenciesMap = {};
        for (const key of Object.keys(dependenciesMap)) {
            dependenciesMapResolved[key] = getDependencyFile(dependenciesMap[key]);
        }

        const dependencyEntries = Object.entries(dependenciesMapResolved).map(([k, v]): [string, string] => [v, k]);
        logger.debug(`Bundling external dependencies: ${JSON.stringify(dependenciesMapResolved, undefined, 2)}`);

        const bundleResult = await bundleExternals(dependencyEntries, {
            rootDir,
            perf: targetOptions.perf,
        });

        if (await fs.pathExists(chunkDir)) {
            await fs.emptyDir(chunkDir);
        }

        await bundleResult.write({
            format: targetOptions.format,
            sourceMap: true,
            chunkDir,
        });

        for (const moduleSpecifier of Object.keys(dependenciesMapResolved)) {
            const entry = dependenciesMapResolved[moduleSpecifier];
            const chunkRelativeURL = bundleResult.entryMap[entry].split(/[\\/]/g).map((part) => encodeURIComponent(part)).join('/');
            targetRecord.externalDependencyImportMap[moduleSpecifier] = chunkRelativeURL;
        }

        const watchFiles: Record<string, number> = {};
        for (const watchFile of bundleResult.watchFiles) {
            try {
                const stat = await fs.stat(watchFile);
                watchFiles[getDependencyFileId(watchFile)] = stat.mtimeMs;
            } catch {

            }
        }

        targetRecord.externalDependencies = dependenciesMap;
        targetRecord.externalDependencyWatchFiles = watchFiles;
    }

    /**
     * @param moduleNameOrFile
     */
    function getFileUidFromResolved(moduleNameOrFile: string) {
        if (virtualModules.has(moduleNameOrFile)) {
            return encodeVirtualFileUid(moduleNameOrFile);
        }
        const relativeFromRoot = ps.relative(ps.join(rootDir), moduleNameOrFile);
        if (relativeFromRoot.length === 0 ||
            relativeFromRoot.startsWith('..') ||
            ps.isAbsolute(relativeFromRoot)) {
            return null;
        } else {
            return relativeFromRoot;
        }
    }

    /**
     * @param dependencyFile
     */
    function getDependencyFileId(dependencyFile: string) {
        return ps.relative(rootDir, dependencyFile);
    }

    /**
     * @param dependencyFileId
     */
    function getDependencyFile(dependencyFileId: string) {
        return ps.resolve(rootDir, dependencyFileId);
    }
}
