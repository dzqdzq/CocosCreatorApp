'use stirct';

const Resize = require('../renderer/element/dock-resize');

/**
 * 插入新的布局
 * @param elem 放置面板的布局元素
 * @param layout 需要插入的面板的布局信息
 * @param direction 放到的指定布局元素上的上下左右哪个位置
 * @param options 需要插入的面板的附加数据
 */
let addLayout = function (elem, layout, direction, options) {

    const $element = elem;
    const $layout = document.createElement('dock-layout');
    const $resize = document.createElement('dock-resize');
    const $parent = elem.parentElement;

    // 如果没有 $parent，则判断 elem 是最顶级的布局元素
    if ($parent === null) {
        // 创建一个临时的布局元素，将原先布局内的元素都放进去
        const $tmp = document.createElement('dock-layout');
        $tmp.direction = $element.direction;

        while ($element.children.length) {
            let $child = $element.children[0];
            $element.removeChild($child);
            $tmp.appendChild($child);
        }

        if (direction === 'left' || direction === 'right') {
            $element.direction = 'row';

            if (options.width) {
                layout.percent = options.width / ($element.clientWidth - ($element.children.length / 2 | 0) * Resize.line);
                layout.percent *= 1 + layout.percent;
            }
        } else {
            $element.direction = 'column';

            if (options.height) {
                layout.percent = options.height / ($element.clientHeight - ($element.children.length / 2 | 0) * Resize.line);
                layout.percent *= 1 + layout.percent;
            }
        }

        if (direction === 'left' || direction === 'top') {
            $element.appendChild($layout);
            $element.appendChild($resize);
            $element.appendChild($tmp);
        } else {
            $element.appendChild($tmp);
            $element.appendChild($resize);
            $element.appendChild($layout);
        }

        $layout.layout(layout);
        return;
    }

    // 布局对象是最终显示的对象
    if ($element.direction === 'none') {

        if ( // 与父节点同一方向，这时候需要插入上一级的 layout 内的指定位置
            ($parent.direction === 'row' && (direction === 'left' || direction === 'right')) ||
            ($parent.direction === 'column' && (direction === 'top' || direction === 'bottom'))
        ) {
            if ($parent.direction === 'row') {

                if (options.width) {
                    layout.percent = options.width / ($parent.clientWidth - ($parent.children.length / 2 | 0) * Resize.line);
                    layout.percent *= 1 + layout.percent;
                }
            } else {

                if (options.height) {
                    layout.percent = options.height / ($parent.clientHeight - ($parent.children.length / 2 | 0) * Resize.line);
                    layout.percent *= 1 + layout.percent;
                }
            }

            if (direction === 'left' || direction === 'top') {
                $parent.insertBefore($layout, $element);
                $parent.insertBefore($resize, $element);
            } else {
                let $e = $element.nextElementSibling;
                if ($e) {
                    $parent.insertBefore($resize, $e);
                    $parent.insertBefore($layout, $e);
                } else {
                    $parent.appendChild($resize);
                    $parent.appendChild($layout);
                }
            }
        } else { // 与父节点方向不一致，这时候需要新建一个 layout
            let $tmp = document.createElement('dock-layout');

            if ($parent.direction === 'row') {
                $tmp.direction = 'column';

                if (options.width) {
                    layout.percent = options.width / ($tmp.clientWidth - ($tmp.children.length / 2 | 0) * Resize.line);
                    layout.percent *= 1 + layout.percent;
                }
            } else {
                $tmp.direction = 'row';

                if (options.height) {
                    layout.percent = options.height / ($tmp.clientHeight - ($tmp.children.length / 2 | 0) * Resize.line);
                    layout.percent *= 1 + layout.percent;
                }
            }

            // 复制之前的占用百分比
            $tmp.data._percent = $element.data._percent;
            $layout.data._percent = $element.data._percent = 0.5;

            $parent.insertBefore($tmp, $element);
            $parent.removeChild($element);
            if (direction === 'left' || direction === 'top') {
                $tmp.appendChild($layout);
                $tmp.appendChild($resize);
                $tmp.appendChild($element);
            } else {
                $tmp.appendChild($element);
                $tmp.appendChild($resize);
                $tmp.appendChild($layout);
            }
        }

        $layout.layout(layout);
        return;
    }

    // 布局对象不是最终显示的 layout

    if ( // 对象和自己同向，插入自身内部
        ($element.direction === 'row' && (direction === 'left' || direction === 'right')) ||
        ($element.direction === 'column' && (direction === 'top' || direction === 'bottom'))
    ) {
        if ($element.direction === 'row') {

            if (options.width) {
                layout.percent = options.width / ($element.clientWidth - ($element.children.length / 2 | 0) * Resize.line);
                layout.percent *= 1 + layout.percent;
            }
        } else {

            if (options.height) {
                layout.percent = options.height / ($element.clientHeight - ($element.children.length / 2 | 0) * Resize.line);
                layout.percent *= 1 + layout.percent;
            }
        }

        if (direction === 'left' || direction === 'top') {
            $element.insertBefore($resize, $element.firstElementChild);
            $element.insertBefore($layout, $element.firstElementChild);
        } else {
            $element.appendChild($resize);
            $element.appendChild($layout);
        }
    } else { // 和自身不同方向

        if ($parent.direction === 'row') {

            if (options.width) {
                layout.percent = options.width / ($parent.clientWidth - ($parent.children.length / 2 | 0) * Resize.line);
                layout.percent *= 1 + layout.percent;
            }
        } else {

            if (options.height) {
                layout.percent = options.height / ($parent.clientHeight - ($parent.children.length / 2 | 0) * Resize.line);
                layout.percent *= 1 + layout.percent;
            }
        }

        if (direction === 'left' || direction === 'top') {
            $parent.insertBefore($layout, $element);
            $parent.insertBefore($resize, $element);
        } else {
            let $e = $element.nextElementSibling;
            if ($e) {
                $parent.insertBefore($resize, $e);
                $parent.insertBefore($layout, $e);
            } else {
                $parent.appendChild($resize);
                $parent.appendChild($layout);
            }
        }
    }

    $layout.layout(layout);
};

/**
 * 插入新的 panel
 * @param elem 
 * @param name 
 * @param index 
 */
let addPanel = function (elem, name, index) {
    elem.parentElement.parentElement.parentElement.addPanel(name, index);
};

/**
 * 刷新单个 layout
 * @param $elem 
 */
let refreshLayout = function ($elem) {
    $elem.data.minWidth = 0;
    $elem.data.minHeight = 0;
    for (let i = 0; i < $elem.children.length; i++) {
        let $child = $elem.children[i];
        switch ($child.tagName) {
            case 'DOCK-GROUPS':
                $elem.data.minWidth = $child.minWidth || 200;
                $elem.data.minHeight = $child.minHeight || 150;
                if ($child.panels.length === 0) {
                    $elem.removeChild($child);
                    i--;
                }
                continue;
            case 'DOCK-RESIZE':
                continue;
            case 'DOCK-LAYOUT':
                refreshLayout($child);

                // 如果整理完数据，发现当前的 layout 为空，则直接删除当前的 layout 节点
                if ($child.children.length === 0) {
                    if ($child.nextElementSibling && $child.nextElementSibling.tagName === 'DOCK-RESIZE') {
                        $elem.removeChild($child.nextElementSibling);
                    } else if ($child.previousElementSibling) {
                        $elem.removeChild($child.previousElementSibling);
                        i--;
                    }
                    $elem.removeChild($child);
                    i--;
                    continue;
                }

                if ($elem.direction === 'row') {
                    $elem.data.minWidth += $child.data.minWidth;
                    if (i !== 0) {
                        $elem.data.minWidth += Resize.line;
                    }
                    $elem.data.minHeight = Math.max($elem.data.minHeight, $child.data.minHeight);
                } else if ($elem.direction === 'column') {
                    $elem.data.minWidth = Math.max($elem.data.minWidth, $child.data.minWidth);
                    $elem.data.minHeight += $child.data.minHeight;
                    if (i !== 0) {
                        $elem.data.minHeight += Resize.line;
                    }
                } else {
                    $elem.data.minWidth = Math.max($elem.data.minWidth, $child.data.minWidth);
                    $elem.data.minHeight = Math.max($elem.data.minHeight, $child.data.minHeight);
                }

                continue;
        }
    }

    // 如果子元素只有 1 个，并且是 layout，应该将子元素删除，并将所有数据放到自己身上
    if ($elem.children.length === 1 && $elem.children[0].tagName === 'DOCK-LAYOUT') {
        let $child = $elem.children[0];
        $elem.removeChild($child);
        while ($child.children.length) {
            let $tmp = $child.children[0];
            $child.removeChild($tmp);
            $elem.appendChild($tmp);
        }
        $elem.direction = $child.direction;
    }

    // 检查 percent 总和是否超出 1
    let total = 0;
    // 记录没有 percent 数据的节点
    let nothings = [];
    // 记录正常的节点
    let normals = [];
    for (let i = 0; i < $elem.children.length; i++) {
        let $child = $elem.children[i];
        if ($child.tagName === 'DOCK-LAYOUT') {
            if ($child.data.percent) {
                total += $child.data.percent;
                normals.push($child);
            } else if($child.data.minimize !== true) {
                nothings.push($child);
            }
        }
    }

    if (total < 1) {
        if (nothings.length > 0) {
            // 将剩余的显示百分比，平均分配给 nothings 的布局元素
            let num = (1 - total) / nothings.length;
            nothings.forEach(($child) => {
                $child.data.percent = num;

                let event = document.createEvent('HTMLEvents');
                event.initEvent('resize', false, false);
                $child.dispatchEvent(event);
            });
        } else if (normals.length > 0) {
            // 如果 nothings 没有分配，则平均分给 normals 的布局元素
            let num = (1 - total) / normals.length;
            normals.forEach(($child) => {
                $child.data.percent += num;

                let event = document.createEvent('HTMLEvents');
                event.initEvent('resize', false, false);
                $child.dispatchEvent(event);
            });
        }
    } else {
        for (let i = 0; i < $elem.children.length; i++) {
            let $child = $elem.children[i];
            if ($child.tagName === 'DOCK-LAYOUT' && $child.data.minimize !== true) {
                $child.data.percent /= total;

                let event = document.createEvent('HTMLEvents');
                event.initEvent('resize', false, false);
                $child.dispatchEvent(event);
            }
        }
    }
};

/**
 * 刷新一个 layout 节点以及内部的所有节点的数据
 * @param elem 
 */
let refresh = function (elem) {
    // 拿到根节点
    let $root = elem;
    while ($root.parentElement) {
        $root = $root.parentElement;
    }

    if ($root.tagName !== 'DOCK-LAYOUT') {
        return;
    }

    refreshLayout($root);
    emit($root);
};

let emit = function ($elem) {
    // 拿到根节点
    let $root = $elem;
    while ($root.parentElement) {
        $root = $root.parentElement;
    }

    if ($root.$parent) {
        // 触发 dock-frame 的 layout 事件
        let event = document.createEvent("HTMLEvents");
        event.initEvent('layout', false, false);
        $root.$parent.dispatchEvent(event);
    }
};

let recursiveFindPanel = function ($layout, name, result = []) {
    Array.prototype.forEach.call($layout.children, ($child) => {
        switch ($child.tagName) {
            case 'DOCK-LAYOUT':
                recursiveFindPanel($child, name, result);
                break;
            case 'DOCK-GROUPS':
                if ($child.panels.includes(name)) {
                    result.push($child);
                }
                break
        }
    });
    return result;
}

let appendPanel = function ($elem, existsPanel, name) {
    const $layout = Array.prototype.find.call($elem.shadowRoot.children, ($child) => {
        return $child.tagName === 'DOCK-LAYOUT';
    });

    const results = recursiveFindPanel($layout, existsPanel);
    if (!results[0]) {
        return ;
    }
    results[0].addPanel(name);
    results[0].active = name;
}

exports.addLayout = addLayout;
exports.addPanel = addPanel;
exports.refresh = refresh;
exports.emit = emit;
exports.appendPanel = appendPanel;

