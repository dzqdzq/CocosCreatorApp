"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseImportMap = void 0;
const url_1 = require("url");
const resolve_error_1 = require("./resolve-error");
function parseImportMap(json, baseUrl) {
    if (typeof json !== 'object') {
        throw new resolve_error_1.ImportMapParseError(`The top-level value needs to be a JSON object.`);
    }
    const parsed = { imports: [], scopes: [] };
    let nValidKeys = 0;
    if (('imports' in json)) {
        ++nValidKeys;
        const imports = json.imports;
        if (typeof imports !== 'object') {
            throw new resolve_error_1.ImportMapParseError(`The "imports" top-level key needs to be a JSON object.`);
        }
        parsed.imports = sortAndNormalizeSpecifierMap(imports, baseUrl);
    }
    if (('scopes' in json)) {
        ++nValidKeys;
        const scopes = json.scopes;
        if (typeof scopes !== 'object') {
            throw new resolve_error_1.ImportMapParseError(`The "scopes" top-level key needs to be a JSON object.`);
        }
        parsed.scopes = sortAndNormalizeScopes(scopes, baseUrl);
    }
    for (const key of Object.keys(json)) {
        if (key !== 'imports' && key !== 'scopes') {
            console.warn(`An invalid top-level key ${key} was present in the import map.`);
        }
    }
    return parsed;
}
exports.parseImportMap = parseImportMap;
function sortAndNormalizeSpecifierMap(originalMap, baseUrl) {
    const normalized = [];
    for (const specifierKey in originalMap) {
        const normalizedSpecifierKey = normalizeSpecifierKey(specifierKey, baseUrl);
        if (normalizedSpecifierKey === null) {
            continue;
        }
        const value = originalMap[specifierKey];
        if (typeof value !== 'string') {
            console.warn(`The address need to be strings.`);
            normalized.push([normalizedSpecifierKey, null]);
            continue;
        }
        const addressUrl = parseUrlLikeImportSpecifier(value, baseUrl);
        if (addressUrl === null) {
            console.warn(`The address was invalid.`);
            normalized.push([normalizedSpecifierKey, null]);
            continue;
        }
        if (specifierKey.endsWith('/') && !serializeUrl(addressUrl).endsWith('/')) {
            console.warn(`an invalid address was given for the specifier key ${specifierKey}; ` +
                `since ${specifierKey} ended in a slash, the address needs to as well.`);
            normalized.push([normalizedSpecifierKey, null]);
            continue;
        }
        normalized.push([normalizedSpecifierKey, addressUrl]);
    }
    sortMap(normalized);
    return normalized;
}
function sortAndNormalizeScopes(originalMap, baseUrl) {
    const normalized = [];
    for (const scopePrefix in originalMap) {
        const potentialSpecifierMap = originalMap[scopePrefix];
        if (typeof potentialSpecifierMap !== 'object') {
            throw new resolve_error_1.ImportMapParseError(`The value of the scope with prefix ${scopePrefix} needs to be a JSON object.`);
        }
        const scopePrefixUrl = parseUrl(scopePrefix, baseUrl);
        if (!scopePrefixUrl) {
            console.warn(`The scope prefix URL ${scopePrefixUrl} was not parsable.`);
            continue;
        }
        const normalizedScopePrefix = serializeUrl(scopePrefixUrl);
        normalized.push([
            normalizedScopePrefix,
            sortAndNormalizeSpecifierMap(potentialSpecifierMap, baseUrl),
        ]);
    }
    sortMapReverse(normalized);
    return normalized;
}
function sortMap(map) {
    return map.sort(([a], [b]) => a > b ? 1 : (a < b ? -1 : 0));
}
function sortMapReverse(map) {
    return map.sort(([b], [a]) => a > b ? 1 : (a < b ? -1 : 0));
}
function normalizeSpecifierKey(key, baseUrl) {
    if (key.length === 0) {
        console.warn(`Specifier keys cannot be the empty string.`);
        return null;
    }
    const url = parseUrlLikeImportSpecifier(key, baseUrl);
    if (url) {
        return serializeUrl(url);
    }
    return key;
}
function parseUrlLikeImportSpecifier(specifier, baseUrl) {
    if (specifier.startsWith('/') ||
        specifier.startsWith('./') ||
        specifier.startsWith('../')) {
        return parseUrl(specifier, baseUrl);
    }
    return parseUrl(specifier);
}
function parseUrl(url, base) {
    try {
        return new url_1.URL(url, base);
    }
    catch (_a) {
        return null;
    }
}
function serializeUrl(url) {
    return url.href;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicGFyc2UtaW1wb3J0LW1hcC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9tb2QtYXNzZW1ibGluZy9tb2QtbG8vcmVzb2x2ZXIvcGFyc2UtaW1wb3J0LW1hcC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFBQSw2QkFBMEI7QUFFMUIsbURBQXNEO0FBRXRELFNBQWdCLGNBQWMsQ0FBQyxJQUFTLEVBQUUsT0FBWTtJQUNsRCxJQUFJLE9BQU8sSUFBSSxLQUFLLFFBQVEsRUFBRTtRQUMxQixNQUFNLElBQUksbUNBQW1CLENBQUMsZ0RBQWdELENBQUMsQ0FBQztLQUNuRjtJQUNELE1BQU0sTUFBTSxHQUFvQixFQUFFLE9BQU8sRUFBRSxFQUFFLEVBQUUsTUFBTSxFQUFFLEVBQUUsRUFBRSxDQUFDO0lBQzVELElBQUksVUFBVSxHQUFHLENBQUMsQ0FBQztJQUNuQixJQUFJLENBQUMsU0FBUyxJQUFJLElBQUksQ0FBQyxFQUFFO1FBQ3JCLEVBQUUsVUFBVSxDQUFDO1FBQ2IsTUFBTSxPQUFPLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQztRQUM3QixJQUFJLE9BQU8sT0FBTyxLQUFLLFFBQVEsRUFBRTtZQUM3QixNQUFNLElBQUksbUNBQW1CLENBQUMsd0RBQXdELENBQUMsQ0FBQztTQUMzRjtRQUNELE1BQU0sQ0FBQyxPQUFPLEdBQUcsNEJBQTRCLENBQUMsT0FBTyxFQUFFLE9BQU8sQ0FBQyxDQUFDO0tBQ25FO0lBQ0QsSUFBSSxDQUFDLFFBQVEsSUFBSSxJQUFJLENBQUMsRUFBRTtRQUNwQixFQUFFLFVBQVUsQ0FBQztRQUNiLE1BQU0sTUFBTSxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUM7UUFDM0IsSUFBSSxPQUFPLE1BQU0sS0FBSyxRQUFRLEVBQUU7WUFDNUIsTUFBTSxJQUFJLG1DQUFtQixDQUFDLHVEQUF1RCxDQUFDLENBQUM7U0FDMUY7UUFDRCxNQUFNLENBQUMsTUFBTSxHQUFHLHNCQUFzQixDQUFDLE1B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QUMsU0FBaUIsRUFBRSxPQUFZO0lBQ2hFLElBQUksU0FBUyxDQUFDLFVBQVUsQ0FBQyxHQUFHLENBQUM7UUFDekIsU0FBUyxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUM7UUFDMUIsU0FBUyxDQUFDLFVBQVUsQ0FBQyxLQUFLLENBQUMsRUFBRTtRQUM3QixPQUFPLFFBQVEsQ0FBQyxTQUFTLEVBQUUsT0FBTyxDQUFDLENBQUM7S0FDdkM7SUFDRCxPQUFPLFFBQVEsQ0FBQyxTQUFTLENBQUMsQ0FBQztBQUMvQixDQUFDO0FBRUQsU0FBUyxRQUFRLENBQUMsR0FBVyxFQUFFLElBQVU7SUFDckMsSUFBSTtRQUNBLE9BQU8sSUFBSSxTQUFHLENBQUMsR0FBRyxFQUFFLElBQUksQ0FBQyxDQUFDO0tBQzdCO0lBQUMsV0FBTTtRQUNKLE9BQU8sSUFBSSxDQUFDO0tBQ2Y7QUFDTCxDQUFDO0FBRUQsU0FBUyxZQUFZLENBQUMsR0FBUTtJQUMxQixPQUFPLEdBQUcsQ0FBQyxJQUFJLENBQUM7QUFDcEIsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFVSTCB9IGZyb20gJ3VybCc7XG5pbXBvcnQgeyBQYXJzZWRJbXBvcnRNYXAsIFBhcnNlZFNjb3BlTWFwLCBQYXJzZWRTcGVjaWZpZXJNYXAgfSBmcm9tICcuL3BhcnNlZC1pbXBvcnQtbWFwJztcbmltcG9ydCB7IEltcG9ydE1hcFBhcnNlRXJyb3IgfSBmcm9tICcuL3Jlc29sdmUtZXJyb3InO1xuXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VJbXBvcnRNYXAoanNvbjogYW55LCBiYXNlVXJsOiBVUkwpIHtcbiAgICBpZiAodHlwZW9mIGpzb24gIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHRocm93IG5ldyBJbXBvcnRNYXBQYXJzZUVycm9yKGBUaGUgdG9wLWxldmVsIHZhbHVlIG5lZWRzIHRvIGJlIGEgSlNPTiBvYmplY3QuYCk7XG4gICAgfVxuICAgIGNvbnN0IHBhcnNlZDogUGFyc2VkSW1wb3J0TWFwID0geyBpbXBvcnRzOiBbXSwgc2NvcGVzOiBbXSB9O1xuICAgIGxldCBuVmFsaWRLZXlzID0gMDtcbiAgICBpZiAoKCdpbXBvcnRzJyBpbiBqc29uKSkge1xuICAgICAgICArK25WYWxpZEtleXM7XG4gICAgICAgIGNvbnN0IGltcG9ydHMgPSBqc29uLmltcG9ydHM7XG4gICAgICAgIGlmICh0eXBlb2YgaW1wb3J0cyAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBJbXBvcnRNYXBQYXJzZUVycm9yKGBUaGUgXCJpbXBvcnRzXCIgdG9wLWxldmVsIGtleSBuZWVkcyB0byBiZSBhIEpTT04gb2JqZWN0LmApO1xuICAgICAgICB9XG4gICAgICAgIHBhcnNlZC5pbXBvcnRzID0gc29ydEFuZE5vcm1hbGl6ZVNwZWNpZmllck1hcChpbXBvcnRzLCBiYXNlVXJsKTtcbiAgICB9XG4gICAgaWYgKCgnc2NvcGVzJyBpbiBqc29uKSkge1xuICAgICAgICArK25WYWxpZEtleXM7XG4gICAgICAgIGNvbnN0IHNjb3BlcyA9IGpzb24uc2NvcGVzO1xuICAgICAgICBpZiAodHlwZW9mIHNjb3BlcyAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBJbXBvcnRNYXBQYXJzZUVycm9yKGBUaGUgXCJzY29wZXNcIiB0b3AtbGV2ZWwga2V5IG5lZWRzIHRvIGJlIGEgSlNPTiBvYmplY3QuYCk7XG4gICAgICAgIH1cbiAgICAgICAgcGFyc2VkLnNjb3BlcyA9IHNvcnRBbmROb3JtYWxpemVTY29wZXMoc2NvcGVzLCBiYXNlVXJsKTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMoanNvbikpIHtcbiAgICAgICAgaWYgKGtleSAhPT0gJ2ltcG9ydHMnICYmIGtleSAhPT0gJ3Njb3BlcycpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgQW4gaW52YWxpZCB0b3AtbGV2ZWwga2V5ICR7a2V5fSB3YXMgcHJlc2VudCBpbiB0aGUgaW1wb3J0IG1hcC5gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcGFyc2VkO1xufVxuXG5mdW5jdGlvbiBzb3J0QW5kTm9ybWFsaXplU3BlY2lmaWVyTWFwKG9yaWdpbmFsTWFwOiBSZWNvcmQ8c3RyaW5nLCBhbnk+LCBiYXNlVXJsOiBVUkwpIHtcbiAgICBjb25zdCBub3JtYWxpemVkOiBQYXJzZWRTcGVjaWZpZXJNYXAgPSBbXTtcbiAgICBmb3IgKGNvbnN0IHNwZWNpZmllcktleSBpbiBvcmlnaW5hbE1hcCkge1xuICAgICAgICBjb25zdCBub3JtYWxpemVkU3BlY2lmaWVyS2V5ID0gbm9ybWFsaXplU3BlY2lmaWVyS2V5KHNwZWNpZmllcktleSwgYmFzZVVybCk7XG4gICAgICAgIGlmIChub3JtYWxpemVkU3BlY2lmaWVyS2V5ID09PSBudWxsKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB2YWx1ZSA9IG9yaWdpbmFsTWFwW3NwZWNpZmllcktleV07XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYFRoZSBhZGRyZXNzIG5lZWQgdG8gYmUgc3RyaW5ncy5gKTtcbiAgICAgICAgICAgIG5vcm1hbGl6ZWQucHVzaChbbm9ybWFsaXplZFNwZWNpZmllcktleSwgbnVsbF0pO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYWRkcmVzc1VybCA9IHBhcnNlVXJsTGlrZUltcG9ydFNwZWNpZmllcih2YWx1ZSwgYmFzZVVybCk7XG4gICAgICAgIGlmIChhZGRyZXNzVXJsID09PSBudWxsKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYFRoZSBhZGRyZXNzIHdhcyBpbnZhbGlkLmApO1xuICAgICAgICAgICAgbm9ybWFsaXplZC5wdXNoKFtub3JtYWxpemVkU3BlY2lmaWVyS2V5LCBudWxsXSk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3BlY2lmaWVyS2V5LmVuZHNXaXRoKCcvJykgJiYgIXNlcmlhbGl6ZVVybChhZGRyZXNzVXJsKS5lbmRzV2l0aCgnLycpKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICAgICAgYGFuIGludmFsaWQgYWRkcmVzcyB3YXMgZ2l2ZW4gZm9yIHRoZSBzcGVjaWZpZXIga2V5ICR7c3BlY2lmaWVyS2V5fTsgYCArXG4gICAgICAgICAgICAgICAgYHNpbmNlICR7c3BlY2lmaWVyS2V5fSBlbmRlZCBpbiBhIHNsYXNoLCB0aGUgYWRkcmVzcyBuZWVkcyB0byBhcyB3ZWxsLmApO1xuICAgICAgICAgICAgbm9ybWFsaXplZC5wdXNoKFtub3JtYWxpemVkU3BlY2lmaWVyS2V5LCBudWxsXSk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBub3JtYWxpemVkLnB1c2goW25vcm1hbGl6ZWRTcGVjaWZpZXJLZXksIGFkZHJlc3NVcmxdKTtcbiAgICB9XG4gICAgc29ydE1hcChub3JtYWxpemVkKTtcbiAgICByZXR1cm4gbm9ybWFsaXplZDtcbn1cblxuZnVuY3Rpb24gc29ydEFuZE5vcm1hbGl6ZVNjb3BlcyhvcmlnaW5hbE1hcDogUmVjb3JkPHN0cmluZywgYW55PiwgYmFzZVVybDogVVJMKSB7XG4gICAgY29uc3Qgbm9ybWFsaXplZDogUGFyc2VkU2NvcGVNYXAgPSBbXTtcbiAgICBmb3IgKGNvbnN0IHNjb3BlUHJlZml4IGluIG9yaWdpbmFsTWFwKSB7XG4gICAgICAgIGNvbnN0IHBvdGVudGlhbFNwZWNpZmllck1hcCA9IG9yaWdpbmFsTWFwW3Njb3BlUHJlZml4XTtcbiAgICAgICAgaWYgKHR5cGVvZiBwb3RlbnRpYWxTcGVjaWZpZXJNYXAgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgSW1wb3J0TWFwUGFyc2VFcnJvcihgVGhlIHZhbHVlIG9mIHRoZSBzY29wZSB3aXRoIHByZWZpeCAke3Njb3BlUHJlZml4fSBuZWVkcyB0byBiZSBhIEpTT04gb2JqZWN0LmApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNjb3BlUHJlZml4VXJsID0gcGFyc2VVcmwoc2NvcGVQcmVmaXgsIGJhc2VVcmwpO1xuICAgICAgICBpZiAoIXNjb3BlUHJlZml4VXJsKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYFRoZSBzY29wZSBwcmVmaXggVVJMICR7c2NvcGVQcmVmaXhVcmx9IHdhcyBub3QgcGFyc2FibGUuYCk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBub3JtYWxpemVkU2NvcGVQcmVmaXggPSBzZXJpYWxpemVVcmwoc2NvcGVQcmVmaXhVcmwpO1xuICAgICAgICBub3JtYWxpemVkLnB1c2goW1xuICAgICAgICAgICAgbm9ybWFsaXplZFNjb3BlUHJlZml4LFxuICAgICAgICAgICAgc29ydEFuZE5vcm1hbGl6ZVNwZWNpZmllck1hcChwb3RlbnRpYWxTcGVjaWZpZXJNYXAsIGJhc2VVcmwpLFxuICAgICAgICBdKTtcbiAgICB9XG4gICAgc29ydE1hcFJldmVyc2Uobm9ybWFsaXplZCk7XG4gICAgcmV0dXJuIG5vcm1hbGl6ZWQ7XG59XG5cbmZ1bmN0aW9uIHNvcnRNYXA8VD4obWFwOiBbc3RyaW5nLCBUXVtdKSB7XG4gICAgcmV0dXJuIG1hcC5zb3J0KChbYV0sIFtiXSkgPT4gYSA+IGIgPyAxIDogKGEgPCBiID8gLTEgOiAwKSk7XG59XG5cbmZ1bmN0aW9uIHNvcnRNYXBSZXZlcnNlPFQ+KG1hcDogW3N0cmluZywgVF1bXSkge1xuICAgIHJldHVybiBtYXAuc29ydCgoW2JdLCBbYV0pID0+IGEgPiBiID8gMSA6IChhIDwgYiA/IC0xIDogMCkpO1xufVxuXG5mdW5jdGlvbiBub3JtYWxpemVTcGVjaWZpZXJLZXkoa2V5OiBzdHJpbmcsIGJhc2VVcmw6IFVSTCk6IHN0cmluZyB8IG51bGwge1xuICAgIGlmIChrZXkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihgU3BlY2lmaWVyIGtleXMgY2Fubm90IGJlIHRoZSBlbXB0eSBzdHJpbmcuYCk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCB1cmwgPSBwYXJzZVVybExpa2VJbXBvcnRTcGVjaWZpZXIoa2V5LCBiYXNlVXJsKTtcbiAgICBpZiAodXJsKSB7XG4gICAgICAgIHJldHVybiBzZXJpYWxpemVVcmwodXJsKTtcbiAgICB9XG4gICAgcmV0dXJuIGtleTtcbn1cblxuZnVuY3Rpb24gcGFyc2VVcmxMaWtlSW1wb3J0U3BlY2lmaWVyKHNwZWNpZmllcjogc3RyaW5nLCBiYXNlVXJsOiBVUkwpOiBVUkwgfCBudWxsIHtcbiAgICBpZiAoc3BlY2lmaWVyLnN0YXJ0c1dpdGgoJy8nKSB8fFxuICAgICAgICBzcGVjaWZpZXIuc3RhcnRzV2l0aCgnLi8nKSB8fFxuICAgICAgICBzcGVjaWZpZXIuc3RhcnRzV2l0aCgnLi4vJykpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlVXJsKHNwZWNpZmllciwgYmFzZVVybCk7XG4gICAgfVxuICAgIHJldHVybiBwYXJzZVVybChzcGVjaWZpZXIpO1xufVxuXG5mdW5jdGlvbiBwYXJzZVVybCh1cmw6IHN0cmluZywgYmFzZT86IFVSTCk6IFVSTCB8IG51bGwge1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBuZXcgVVJMKHVybCwgYmFzZSk7XG4gICAgfSBjYXRjaCB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gc2VyaWFsaXplVXJsKHVybDogVVJMKSB7XG4gICAgcmV0dXJuIHVybC5ocmVmO1xufVxuIl19