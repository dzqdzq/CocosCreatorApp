"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ChunkWriter = void 0;
const base_1 = require("./base");
const path_1 = __importDefault(require("path"));
const fs_extra_1 = __importDefault(require("fs-extra"));
const chunk_id_1 = require("../chunk-id");
const asserts_1 = require("../../../../utils/asserts");
const url_1 = require("url");
const relateurl_1 = __importDefault(require("relateurl"));
class ChunkWriter extends base_1.ChunkIOBase {
    constructor({ origin, chunkRecordFile, sourceCacheDir, importMapFile, logger, }) {
        super({ chunkRecordFile, sourceCacheDir });
        this._origin = origin;
        this._logger = logger;
        this._importMapFile = importMapFile;
    }
    async loadCache() {
        await this._loadChunkRecord();
    }
    async clear() {
        const importMapFile = this._importMapFile;
        try {
            await fs_extra_1.default.unlink(importMapFile);
        }
        catch (err) {
            this._logger.debug(`Failed to delete module record file ${importMapFile}: ${err}`);
        }
        await super.clear();
    }
    getChunkId(url) {
        return chunk_id_1.calculateChunkId(url, this._origin);
    }
    async getChunk(id) {
        return this._chunks[id];
    }
    async addChunk(id, code, map) {
        const physicalLocation = chunk_id_1.calculatePhysicalLocation(id);
        const mTimestamp = Date.now();
        this._chunks[id] = {
            imports: {},
            physicalLocation,
            mTimestamp,
        };
        const sourceCacheFile = this._getChunkSourceFile(physicalLocation);
        // const metadataCacheFile = this._getMetadataCacheFile(qpLocation);
        let sourceMappingURL;
        let serializedMap;
        if (map) {
            serializedMap = typeof map === 'string'
                ? map
                : JSON.stringify(map);
            sourceMappingURL = `${path_1.default.basename(sourceCacheFile)}.map`;
        }
        const codeWithMap = sourceMappingURL
            ? `${code}\n//# sourceMappingURL=${sourceMappingURL}`
            : code;
        await Promise.all([
            // Write metadata
            // fs.outputFile(metadataCacheFile, JSON.stringify(metadata, undefined, 2), { encoding: 'utf8' }),
            // Write code
            fs_extra_1.default.outputFile(sourceCacheFile, codeWithMap, { encoding: 'utf8' }),
            // Write map
            serializedMap
                ? fs_extra_1.default.outputFile(`${sourceCacheFile}.map`, serializedMap, { encoding: 'utf8' })
                : undefined,
        ]);
    }
    async removeChunk(id) {
        delete this._chunks[id];
    }
    async syncChunk(chunkAlias) {
        await this._writeChunkRecord();
        await this._writeImportMap(this._importMapFile, chunkAlias);
    }
    async _writeImportMap(outFile, chunkAlias) {
        const importMapURL = url_1.pathToFileURL(outFile);
        const importMapRelate = new relateurl_1.default(importMapURL.href);
        const getChunkRelativePathFromImportMap = (chunkId) => {
            // Can happen when reload A -> B
            // A is unchanged, but can not load B(since `forceAll: true`)
            // A's dep records are not clear
            asserts_1.asserts(chunkId in this._chunks, 'Something went wrong: module A depends on B, but B is not correctly generated.');
            const chunkSourceFile = this._getChunkSourceFile(this._chunks[chunkId].physicalLocation);
            const relativePath = importMapRelate.relate(url_1.pathToFileURL(chunkSourceFile).href);
            return `./${relativePath}`;
        };
        const importMap = {};
        importMap.imports = {};
        const imports = importMap.imports;
        for (const [alias, chunkId] of Object.entries(chunkAlias)) {
            imports[alias] = getChunkRelativePathFromImportMap(chunkId);
        }
        importMap.scopes = {};
        const scopes = importMap.scopes;
        for (const [chunkId, chunk] of Object.entries(this._chunks)) {
            const importsEntries = Object.entries(chunk.imports);
            if (importsEntries.length === 0) {
                continue;
            }
            const chunkPath = getChunkRelativePathFromImportMap(chunkId);
            const specifierMap = scopes[chunkPath] = {};
            for (const [specifier, resolvedChunkId] of importsEntries) {
                if (typeof resolvedChunkId === 'string') {
                    specifierMap[specifier] = getChunkRelativePathFromImportMap(resolvedChunkId);
                }
                else {
                    specifierMap[specifier] = resolvedChunkId.url;
                }
            }
        }
        await fs_extra_1.default.outputJson(outFile, importMap, { spaces: 2, });
    }
}
exports.ChunkWriter = ChunkWriter;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoid3JpdGVyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vc3JjL21vZC1hc3NlbWJsaW5nL3F1aWNrLXBhY2svdXRpbHMvY2h1bmstaW8vd3JpdGVyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7OztBQUNBLGlDQUFxQztBQUNyQyxnREFBc0I7QUFDdEIsd0RBQTBCO0FBQzFCLDBDQUFtRjtBQUVuRix1REFBb0Q7QUFDcEQsNkJBQW9DO0FBQ3BDLDBEQUFrQztBQUdsQyxNQUFhLFdBQVksU0FBUSxrQkFBVztJQUN4QyxZQUFZLEVBQ1IsTUFBTSxFQUNOLGVBQWUsRUFDZixjQUFjLEVBQ2QsYUFBYSxFQUNiLE1BQU0sR0FPVDtRQUNHLEtBQUssQ0FBQyxFQUFFLGVBQWUsRUFBRSxjQUFjLEVBQUUsQ0FBQyxDQUFDO1FBQzNDLElBQUksQ0FBQyxPQUFPLEdBQUcsTUFBTSxDQUFDO1FBQ3RCLElBQUksQ0FBQyxPQUFPLEdBQUcsTUFBTSxDQUFDO1FBQ3RCLElBQUksQ0FBQyxjQUFjLEdBQUcsYUFBYSxDQUFDO0lBQ3hDLENBQUM7SUFFTSxLQUFLLENBQUMsU0FBUztRQUNsQixNQUFNLElBQUksQ0FBQyxnQkFBZ0IsRUFBRSxDQUFDO0lBQ2xDLENBQUM7SUFFTSxLQUFLLENBQUMsS0FBSztRQUNkLE1BQU0sYUFBYSxHQUFHLElBQUksQ0FBQyxjQUFjLENBQUM7UUFDMUMsSUFBSTtZQUNBLE1BQU0sa0JBQUUsQ0FBQyxNQUFNLENBQUMsYUFBYSxDQUFDLENBQUM7U0FDbEM7UUFBQyxPQUFPLEdBQUcsRUFBRTtZQUNWLElBQUksQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLHVDQUF1QyxhQUFhLEtBQUssR0FBRyxFQUFFLENBQUMsQ0FBQztTQUN0RjtRQUNELE1BQU0sS0FBSyxDQUFDLEtBQUssRUFBRSxDQUFDO0lBQ3hCLENBQUM7SUFFTSxVQUFVLENBQUMsR0FBUTtRQUN0QixPQUFPLDJCQUFnQixDQUFDLEdBQUcsRUFB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QztpQkFDakQ7YUFDSjtTQUNKO1FBQ0QsTUFBTSxrQkFBRSxDQUFDLFVBQVUsQ0FBQyxPQUFPLEVBQUUsU0FBUyxFQUFFLEVBQUUsTUFBTSxFQUFFLENBQUMsR0FBRyxDQUFDLENBQUM7SUFDNUQsQ0FBQztDQUNKO0FBOUhELGtDQThIQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFNvdXJjZU1hcCB9IGZyb20gJy4uLy4uLy4uL21vZC1sby9tb2QtbG8nO1xuaW1wb3J0IHsgQ2h1bmtJT0Jhc2UgfSBmcm9tICcuL2Jhc2UnO1xuaW1wb3J0IHBzIGZyb20gJ3BhdGgnO1xuaW1wb3J0IGZzIGZyb20gJ2ZzLWV4dHJhJztcbmltcG9ydCB7IENodW5rSWQsIGNhbGN1bGF0ZUNodW5rSWQsIGNhbGN1bGF0ZVBoeXNpY2FsTG9jYXRpb24gfSBmcm9tICcuLi9jaHVuay1pZCc7XG5pbXBvcnQgeyBJbXBvcnRNYXAgfSBmcm9tICcuLi8uLi9sb2FkZXInO1xuaW1wb3J0IHsgYXNzZXJ0cyB9IGZyb20gJy4uLy4uLy4uLy4uL3V0aWxzL2Fzc2VydHMnO1xuaW1wb3J0IHsgcGF0aFRvRmlsZVVSTCB9IGZyb20gJ3VybCc7XG5pbXBvcnQgUmVsYXRlVXJsIGZyb20gJ3JlbGF0ZXVybCc7XG5pbXBvcnQgeyBMb2dnZXIgfSBmcm9tICcuLi8uLi8uLi91dGlscy9sb2dnZXInO1xuXG5leHBvcnQgY2xhc3MgQ2h1bmtXcml0ZXIgZXh0ZW5kcyBDaHVua0lPQmFzZSB7XG4gICAgY29uc3RydWN0b3Ioe1xuICAgICAgICBvcmlnaW4sXG4gICAgICAgIGNodW5rUmVjb3JkRmlsZSxcbiAgICAgICAgc291cmNlQ2FjaGVEaXIsXG4gICAgICAgIGltcG9ydE1hcEZpbGUsXG4gICAgICAgIGxvZ2dlcixcbiAgICB9OiB7XG4gICAgICAgIG9yaWdpbjogc3RyaW5nO1xuICAgICAgICBjaHVua1JlY29yZEZpbGU6IHN0cmluZztcbiAgICAgICAgc291cmNlQ2FjaGVEaXI6IHN0cmluZztcbiAgICAgICAgaW1wb3J0TWFwRmlsZTogc3RyaW5nO1xuICAgICAgICBsb2dnZXI6IExvZ2dlcixcbiAgICB9KSB7XG4gICAgICAgIHN1cGVyKHsgY2h1bmtSZWNvcmRGaWxlLCBzb3VyY2VDYWNoZURpciB9KTtcbiAgICAgICAgdGhpcy5fb3JpZ2luID0gb3JpZ2luO1xuICAgICAgICB0aGlzLl9sb2dnZXIgPSBsb2dnZXI7XG4gICAgICAgIHRoaXMuX2ltcG9ydE1hcEZpbGUgPSBpbXBvcnRNYXBGaWxlO1xuICAgIH1cblxuICAgIHB1YmxpYyBhc3luYyBsb2FkQ2FjaGUoKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuX2xvYWRDaHVua1JlY29yZCgpO1xuICAgIH1cblxuICAgIHB1YmxpYyBhc3luYyBjbGVhcigpIHtcbiAgICAgICAgY29uc3QgaW1wb3J0TWFwRmlsZSA9IHRoaXMuX2ltcG9ydE1hcEZpbGU7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBhd2FpdCBmcy51bmxpbmsoaW1wb3J0TWFwRmlsZSk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgdGhpcy5fbG9nZ2VyLmRlYnVnKGBGYWlsZWQgdG8gZGVsZXRlIG1vZHVsZSByZWNvcmQgZmlsZSAke2ltcG9ydE1hcEZpbGV9OiAke2Vycn1gKTtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCBzdXBlci5jbGVhcigpO1xuICAgIH1cblxuICAgIHB1YmxpYyBnZXRDaHVua0lkKHVybDogVVJMKSB7XG4gICAgICAgIHJldHVybiBjYWxjdWxhdGVDaHVua0lkKHVybCwgdGhpcy5fb3JpZ2luKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgYXN5bmMgZ2V0Q2h1bmsoaWQ6IENodW5rSWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NodW5rc1tpZF07XG4gICAgfVxuXG4gICAgcHVibGljIGFzeW5jIGFkZENodW5rKGlkOiBDaHVua0lkLCBjb2RlOiBzdHJpbmcsIG1hcD86IFNvdXJjZU1hcCkge1xuICAgICAgICBjb25zdCBwaHlzaWNhbExvY2F0aW9uID0gY2FsY3VsYXRlUGh5c2ljYWxMb2NhdGlvbihpZCk7XG4gICAgICAgIGNvbnN0IG1UaW1lc3RhbXAgPSBEYXRlLm5vdygpO1xuICAgICAgICB0aGlzLl9jaHVua3NbaWRdID0ge1xuICAgICAgICAgICAgaW1wb3J0czoge30sXG4gICAgICAgICAgICBwaHlzaWNhbExvY2F0aW9uLFxuICAgICAgICAgICAgbVRpbWVzdGFtcCxcbiAgICAgICAgfTtcblxuICAgICAgICBjb25zdCBzb3VyY2VDYWNoZUZpbGUgPSB0aGlzLl9nZXRDaHVua1NvdXJjZUZpbGUocGh5c2ljYWxMb2NhdGlvbik7XG4gICAgICAgIC8vIGNvbnN0IG1ldGFkYXRhQ2FjaGVGaWxlID0gdGhpcy5fZ2V0TWV0YWRhdGFDYWNoZUZpbGUocXBMb2NhdGlvbik7XG4gICAgICAgIGxldCBzb3VyY2VNYXBwaW5nVVJMOiBzdHJpbmcgfCB1bmRlZmluZWQ7XG4gICAgICAgIGxldCBzZXJpYWxpemVkTWFwOiBzdHJpbmcgfCB1bmRlZmluZWQ7XG4gICAgICAgIGlmIChtYXApIHtcbiAgICAgICAgICAgIHNlcmlhbGl6ZWRNYXAgPSB0eXBlb2YgbWFwID09PSAnc3RyaW5nJ1xuICAgICAgICAgICAgICAgID8gbWFwXG4gICAgICAgICAgICAgICAgOiBKU09OLnN0cmluZ2lmeShtYXApO1xuICAgICAgICAgICAgc291cmNlTWFwcGluZ1VSTCA9IGAke3BzLmJhc2VuYW1lKHNvdXJjZUNhY2hlRmlsZSl9Lm1hcGA7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29kZVdpdGhNYXAgPSBzb3VyY2VNYXBwaW5nVVJMXG4gICAgICAgICAgICA/IGAke2NvZGV9XFxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9JHtzb3VyY2VNYXBwaW5nVVJMfWBcbiAgICAgICAgICAgIDogY29kZTtcbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgICAgICAgLy8gV3JpdGUgbWV0YWRhdGFcbiAgICAgICAgICAgIC8vIGZzLm91dHB1dEZpbGUobWV0YWRhdGFDYWNoZUZpbGUsIEpTT04uc3RyaW5naWZ5KG1ldGFkYXRhLCB1bmRlZmluZWQsIDIpLCB7IGVuY29kaW5nOiAndXRmOCcgfSksXG4gICAgICAgICAgICAvLyBXcml0ZSBjb2RlXG4gICAgICAgICAgICBmcy5vdXRwdXRGaWxlKHNvdXJjZUNhY2hlRmlsZSwgY29kZVdpdGhNYXAsIHsgZW5jb2Rpbmc6ICd1dGY4JyB9KSxcbiAgICAgICAgICAgIC8vIFdyaXRlIG1hcFxuICAgICAgICAgICAgc2VyaWFsaXplZE1hcFxuICAgICAgICAgICAgICAgID8gZnMub3V0cHV0RmlsZShgJHtzb3VyY2VDYWNoZUZpbGV9Lm1hcGAsIHNlcmlhbGl6ZWRNYXAsIHsgZW5jb2Rpbmc6ICd1dGY4JyB9KVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICBdKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgYXN5bmMgcmVtb3ZlQ2h1bmsoaWQ6IENodW5rSWQpIHtcbiAgICAgICAgZGVsZXRlIHRoaXMuX2NodW5rc1tpZF07XG4gICAgfVxuXG4gICAgcHVibGljIGFzeW5jIHN5bmNDaHVuayhjaHVua0FsaWFzOiBSZWNvcmQ8Q2h1bmtJZCwgc3RyaW5nPikge1xuICAgICAgICBhd2FpdCB0aGlzLl93cml0ZUNodW5rUmVjb3JkKCk7XG4gICAgICAgIGF3YWl0IHRoaXMuX3dyaXRlSW1wb3J0TWFwKHRoaXMuX2ltcG9ydE1hcEZpbGUsIGNodW5rQWxpYXMpO1xuICAgIH1cblxuICAgIHByaXZhdGUgX29yaWdpbjogc3RyaW5nO1xuICAgIHByaXZhdGUgX2xvZ2dlcjogTG9nZ2VyO1xuICAgIHByaXZhdGUgX2ltcG9ydE1hcEZpbGU6IHN0cmluZztcblxuICAgIHByaXZhdGUgYXN5bmMgX3dyaXRlSW1wb3J0TWFwKG91dEZpbGU6IHN0cmluZywgY2h1bmtBbGlhczogUmVjb3JkPHN0cmluZywgQ2h1bmtJZD4pIHtcbiAgICAgICAgY29uc3QgaW1wb3J0TWFwVVJMID0gcGF0aFRvRmlsZVVSTChvdXRGaWxlKTtcbiAgICAgICAgY29uc3QgaW1wb3J0TWFwUmVsYXRlID0gbmV3IFJlbGF0ZVVybChpbXBvcnRNYXBVUkwuaHJlZik7XG4gICAgICAgIGNvbnN0IGdldENodW5rUmVsYXRpdmVQYXRoRnJvbUltcG9ydE1hcCA9IChjaHVua0lkOiBzdHJpbmcpOiBzdHJpbmcgPT4ge1xuICAgICAgICAgICAgLy8gQ2FuIGhhcHBlbiB3aGVuIHJlbG9hZCBBIC0+IEJcbiAgICAgICAgICAgIC8vIEEgaXMgdW5jaGFuZ2VkLCBidXQgY2FuIG5vdCBsb2FkIEIoc2luY2UgYGZvcmNlQWxsOiB0cnVlYClcbiAgICAgICAgICAgIC8vIEEncyBkZXAgcmVjb3JkcyBhcmUgbm90IGNsZWFyXG4gICAgICAgICAgICBhc3NlcnRzKGNodW5rSWQgaW4gdGhpcy5fY2h1bmtzLCAnU29tZXRoaW5nIHdlbnQgd3Jvbmc6IG1vZHVsZSBBIGRlcGVuZHMgb24gQiwgYnV0IEIgaXMgbm90IGNvcnJlY3RseSBnZW5lcmF0ZWQuJyk7XG4gICAgICAgICAgICBjb25zdCBjaHVua1NvdXJjZUZpbGUgPSB0aGlzLl9nZXRDaHVua1NvdXJjZUZpbGUodGhpcy5fY2h1bmtzW2NodW5rSWRdLnBoeXNpY2FsTG9jYXRpb24pO1xuICAgICAgICAgICAgY29uc3QgcmVsYXRpdmVQYXRoID0gaW1wb3J0TWFwUmVsYXRlLnJlbGF0ZShwYXRoVG9GaWxlVVJMKGNodW5rU291cmNlRmlsZSkuaHJlZik7XG4gICAgICAgICAgICByZXR1cm4gYC4vJHtyZWxhdGl2ZVBhdGh9YDtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgaW1wb3J0TWFwOiBJbXBvcnRNYXAgPSB7fTtcbiAgICAgICAgaW1wb3J0TWFwLmltcG9ydHMgPSB7fTtcbiAgICAgICAgY29uc3QgaW1wb3J0cyA9IGltcG9ydE1hcC5pbXBvcnRzO1xuICAgICAgICBmb3IgKGNvbnN0IFthbGlhcywgY2h1bmtJZF0gb2YgT2JqZWN0LmVudHJpZXMoY2h1bmtBbGlhcykpIHtcbiAgICAgICAgICAgIGltcG9ydHNbYWxpYXNdID0gZ2V0Q2h1bmtSZWxhdGl2ZVBhdGhGcm9tSW1wb3J0TWFwKGNodW5rSWQpO1xuICAgICAgICB9XG4gICAgICAgIGltcG9ydE1hcC5zY29wZXMgPSB7fTtcbiAgICAgICAgY29uc3Qgc2NvcGVzID0gaW1wb3J0TWFwLnNjb3BlcztcbiAgICAgICAgZm9yIChjb25zdCBbY2h1bmtJZCwgY2h1bmtdIG9mIE9iamVjdC5lbnRyaWVzKHRoaXMuX2NodW5rcykpIHtcbiAgICAgICAgICAgIGNvbnN0IGltcG9ydHNFbnRyaWVzID0gT2JqZWN0LmVudHJpZXMoY2h1bmsuaW1wb3J0cyk7XG4gICAgICAgICAgICBpZiAoaW1wb3J0c0VudHJpZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBjaHVua1BhdGggPSBnZXRDaHVua1JlbGF0aXZlUGF0aEZyb21JbXBvcnRNYXAoY2h1bmtJZCk7XG4gICAgICAgICAgICBjb25zdCBzcGVjaWZpZXJNYXA6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gPSBzY29wZXNbY2h1bmtQYXRoXSA9IHt9O1xuICAgICAgICAgICAgZm9yIChjb25zdCBbc3BlY2lmaWVyLCByZXNvbHZlZENodW5rSWRdIG9mIGltcG9ydHNFbnRyaWVzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiByZXNvbHZlZENodW5rSWQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIHNwZWNpZmllck1hcFtzcGVjaWZpZXJdID0gZ2V0Q2h1bmtSZWxhdGl2ZVBhdGhGcm9tSW1wb3J0TWFwKHJlc29sdmVkQ2h1bmtJZCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc3BlY2lmaWVyTWFwW3NwZWNpZmllcl0gPSByZXNvbHZlZENodW5rSWQudXJsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBhd2FpdCBmcy5vdXRwdXRKc29uKG91dEZpbGUsIGltcG9ydE1hcCwgeyBzcGFjZXM6IDIsIH0pO1xuICAgIH1cbn1cbiJdfQ==