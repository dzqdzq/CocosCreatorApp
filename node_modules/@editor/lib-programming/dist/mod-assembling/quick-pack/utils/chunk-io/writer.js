"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ChunkWriter = void 0;
const base_1 = require("./base");
const path_1 = __importDefault(require("path"));
const fs_extra_1 = __importDefault(require("fs-extra"));
const chunk_id_1 = require("../chunk-id");
const asserts_1 = require("../../../../utils/asserts");
const url_1 = require("url");
const relateurl_1 = __importDefault(require("relateurl"));
class ChunkWriter extends base_1.ChunkIOBase {
    constructor({ origin, chunkRecordFile, sourceCacheDir, importMapFile, logger, }) {
        super({ chunkRecordFile, sourceCacheDir });
        this._origin = origin;
        this._logger = logger;
        this._importMapFile = importMapFile;
    }
    async loadCache() {
        await this._loadChunkRecord();
    }
    async clear() {
        const importMapFile = this._importMapFile;
        try {
            await fs_extra_1.default.unlink(importMapFile);
        }
        catch (err) {
            this._logger.debug(`Failed to delete module record file ${importMapFile}: ${err}`);
        }
        await super.clear();
    }
    getChunkId(url) {
        return chunk_id_1.calculateChunkId(url, this._origin);
    }
    async getChunk(id) {
        return this._chunks[id];
    }
    async addChunk(id, code, map) {
        const physicalLocation = chunk_id_1.calculatePhysicalLocation(id);
        const mTimestamp = Date.now();
        this._chunks[id] = {
            imports: {},
            physicalLocation,
            mTimestamp,
        };
        const sourceCacheFile = this._getChunkSourceFile(physicalLocation);
        // const metadataCacheFile = this._getMetadataCacheFile(qpLocation);
        let sourceMappingURL;
        let serializedMap;
        if (map) {
            serializedMap = typeof map === 'string'
                ? map
                : JSON.stringify(map);
            sourceMappingURL = `${path_1.default.basename(sourceCacheFile)}.map`;
        }
        const codeWithMap = sourceMappingURL
            ? `${code}\n//# sourceMappingURL=${sourceMappingURL}`
            : code;
        await Promise.all([
            // Write metadata
            // fs.outputFile(metadataCacheFile, JSON.stringify(metadata, undefined, 2), { encoding: 'utf8' }),
            // Write code
            fs_extra_1.default.outputFile(sourceCacheFile, codeWithMap, { encoding: 'utf8' }),
            // Write map
            serializedMap
                ? fs_extra_1.default.outputFile(`${sourceCacheFile}.map`, serializedMap, { encoding: 'utf8' })
                : undefined,
        ]);
    }
    async removeChunk(id) {
        delete this._chunks[id];
    }
    async syncChunk(chunkAlias) {
        await this._writeChunkRecord();
        await this._writeImportMap(this._importMapFile, chunkAlias);
    }
    async _writeImportMap(outFile, chunkAlias) {
        const importMapURL = url_1.pathToFileURL(outFile);
        const importMapRelate = new relateurl_1.default(importMapURL.href);
        const getChunkRelativePathFromImportMap = (chunkId) => {
            // Can happen when reload A -> B
            // A is unchanged, but can not load B(since `forceAll: true`)
            // A's dep records are not clear
            asserts_1.asserts(chunkId in this._chunks, 'Something went wrong: module A depends on B, but B is not correctly generated.');
            const chunkSourceFile = this._getChunkSourceFile(this._chunks[chunkId].physicalLocation);
            const relativePath = importMapRelate.relate(url_1.pathToFileURL(chunkSourceFile).href);
            return `./${relativePath}`;
        };
        const importMap = {};
        importMap.imports = {};
        const imports = importMap.imports;
        for (const [alias, chunkId] of Object.entries(chunkAlias)) {
            imports[alias] = getChunkRelativePathFromImportMap(chunkId);
        }
        importMap.scopes = {};
        const scopes = importMap.scopes;
        for (const [chunkId, chunk] of Object.entries(this._chunks)) {
            const importsEntries = Object.entries(chunk.imports);
            if (importsEntries.length === 0) {
                continue;
            }
            const chunkPath = getChunkRelativePathFromImportMap(chunkId);
            const specifierMap = scopes[chunkPath] = {};
            for (const [specifier, resolvedChunkId] of importsEntries) {
                if (typeof resolvedChunkId === 'string') {
                    specifierMap[specifier] = getChunkRelativePathFromImportMap(resolvedChunkId);
                }
                else {
                    specifierMap[specifier] = resolvedChunkId.url;
                }
            }
        }
        await fs_extra_1.default.outputJson(outFile, importMap, { spaces: 2, });
    }
}
exports.ChunkWriter = ChunkWriter;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoid3JpdGVyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vc3JjL21vZC1hc3NlbWJsaW5nL3F1aWNrLXBhY2svdXRpbHMvY2h1bmstaW8vd3JpdGVyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7OztBQUNBLGlDQUFxQztBQUNyQyxnREFBc0I7QUFDdEIsd0RBQTBCO0FBQzFCLDBDQUFtRjtBQUVuRix1REFBb0Q7QUFDcEQsNkJBQW9DO0FBQ3BDLDBEQUFrQztBQUdsQyxNQUFhLFdBQVksU0FBUSxrQkFBVztJQUN4QyxZQUFZLEVBQ1IsTUFBTSxFQUNOLGVBQWUsRUFDZixjQUFjLEVBQ2QsYUFBYSxFQUNiLE1BQU0sR0FPVDtRQUNHLEtBQUssQ0FBQyxFQUFFLGVBQWUsRUFBRSxjQUFjLEVBQUUsQ0FBQyxDQUFDO1FBQzNDLElBQUksQ0FBQyxPQUFPLEdBQUcsTUFBTSxDQUFDO1FBQ3RCLElBQUksQ0FBQyxPQUFPLEdBQUcsTUFBTSxDQUFDO1FBQ3RCLElBQUksQ0FBQyxjQUFjLEdBQUcsYUFBYSxDQUFDO0lBQ3hDLENBQUM7SUFFTSxLQUFLLENBQUMsU0FBUztRQUNsQixNQUFNLElBQUksQ0FBQyxnQkFBZ0IsRUFBRSxDQUFDO0lBQ2xDLENBQUM7SUFFTSxLQUFLLENBQUMsS0FBSztRQUNkLE1BQU0sYUFBYSxHQUFHLElBQUksQ0FBQyxjQUFjLENBQUM7UUFDMUMsSUFBSTtZQUNBLE1BQU0sa0JBQUUsQ0FBQyxNQUFNLENBQUMsYUFBYSxDQUFDLENBQUM7U0FDbEM7UUFBQyxPQUFPLEdBQUcsRUFBRTtZQUNWLElBQUksQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLHVDQUF1QyxhQUFhLEtBQUssR0FBRyxFQUFFLENBQUMsQ0FBQztTQUN0RjtRQUNELE1BQU0sS0FBSyxDQUFDLEtBQUssRUFBRSxDQUFDO0lBQ3hCLENBQUM7SUFFTSxVQUFVLENBQUMsR0FBUTtRQUN0QixPQUFPLDJCQUFnQixDQUFDLEdBQUcsRUFB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QztpQkFDakQ7YUFDSjtTQUNKO1FBQ0QsTUFBTSxrQkFBRSxDQUFDLFVBQVUsQ0FBQyxPQUFPLEVBQUUsU0FBUyxFQUFFLEVBQUUsTUFBTSxFQUFFLENBQUMsR0FBRyxDQUFDLENBQUM7SUFDNUQsQ0FBQztDQUNKO0FBOUhELGtDQThIQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFNvdXJjZU1hcCB9IGZyb20gJy4uLy4uLy4uL21vZC1sby9tb2QtbG8nO1xyXG5pbXBvcnQgeyBDaHVua0lPQmFzZSB9IGZyb20gJy4vYmFzZSc7XHJcbmltcG9ydCBwcyBmcm9tICdwYXRoJztcclxuaW1wb3J0IGZzIGZyb20gJ2ZzLWV4dHJhJztcclxuaW1wb3J0IHsgQ2h1bmtJZCwgY2FsY3VsYXRlQ2h1bmtJZCwgY2FsY3VsYXRlUGh5c2ljYWxMb2NhdGlvbiB9IGZyb20gJy4uL2NodW5rLWlkJztcclxuaW1wb3J0IHsgSW1wb3J0TWFwIH0gZnJvbSAnLi4vLi4vbG9hZGVyJztcclxuaW1wb3J0IHsgYXNzZXJ0cyB9IGZyb20gJy4uLy4uLy4uLy4uL3V0aWxzL2Fzc2VydHMnO1xyXG5pbXBvcnQgeyBwYXRoVG9GaWxlVVJMIH0gZnJvbSAndXJsJztcclxuaW1wb3J0IFJlbGF0ZVVybCBmcm9tICdyZWxhdGV1cmwnO1xyXG5pbXBvcnQgeyBMb2dnZXIgfSBmcm9tICcuLi8uLi8uLi91dGlscy9sb2dnZXInO1xyXG5cclxuZXhwb3J0IGNsYXNzIENodW5rV3JpdGVyIGV4dGVuZHMgQ2h1bmtJT0Jhc2Uge1xyXG4gICAgY29uc3RydWN0b3Ioe1xyXG4gICAgICAgIG9yaWdpbixcclxuICAgICAgICBjaHVua1JlY29yZEZpbGUsXHJcbiAgICAgICAgc291cmNlQ2FjaGVEaXIsXHJcbiAgICAgICAgaW1wb3J0TWFwRmlsZSxcclxuICAgICAgICBsb2dnZXIsXHJcbiAgICB9OiB7XHJcbiAgICAgICAgb3JpZ2luOiBzdHJpbmc7XHJcbiAgICAgICAgY2h1bmtSZWNvcmRGaWxlOiBzdHJpbmc7XHJcbiAgICAgICAgc291cmNlQ2FjaGVEaXI6IHN0cmluZztcclxuICAgICAgICBpbXBvcnRNYXBGaWxlOiBzdHJpbmc7XHJcbiAgICAgICAgbG9nZ2VyOiBMb2dnZXIsXHJcbiAgICB9KSB7XHJcbiAgICAgICAgc3VwZXIoeyBjaHVua1JlY29yZEZpbGUsIHNvdXJjZUNhY2hlRGlyIH0pO1xyXG4gICAgICAgIHRoaXMuX29yaWdpbiA9IG9yaWdpbjtcclxuICAgICAgICB0aGlzLl9sb2dnZXIgPSBsb2dnZXI7XHJcbiAgICAgICAgdGhpcy5faW1wb3J0TWFwRmlsZSA9IGltcG9ydE1hcEZpbGU7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGFzeW5jIGxvYWRDYWNoZSgpIHtcclxuICAgICAgICBhd2FpdCB0aGlzLl9sb2FkQ2h1bmtSZWNvcmQoKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgYXN5bmMgY2xlYXIoKSB7XHJcbiAgICAgICAgY29uc3QgaW1wb3J0TWFwRmlsZSA9IHRoaXMuX2ltcG9ydE1hcEZpbGU7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgYXdhaXQgZnMudW5saW5rKGltcG9ydE1hcEZpbGUpO1xyXG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xyXG4gICAgICAgICAgICB0aGlzLl9sb2dnZXIuZGVidWcoYEZhaWxlZCB0byBkZWxldGUgbW9kdWxlIHJlY29yZCBmaWxlICR7aW1wb3J0TWFwRmlsZX06ICR7ZXJyfWApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBhd2FpdCBzdXBlci5jbGVhcigpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXRDaHVua0lkKHVybDogVVJMKSB7XHJcbiAgICAgICAgcmV0dXJuIGNhbGN1bGF0ZUNodW5rSWQodXJsLCB0aGlzLl9vcmlnaW4pO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBhc3luYyBnZXRDaHVuayhpZDogQ2h1bmtJZCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9jaHVua3NbaWRdO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBhc3luYyBhZGRDaHVuayhpZDogQ2h1bmtJZCwgY29kZTogc3RyaW5nLCBtYXA/OiBTb3VyY2VNYXApIHtcclxuICAgICAgICBjb25zdCBwaHlzaWNhbExvY2F0aW9uID0gY2FsY3VsYXRlUGh5c2ljYWxMb2NhdGlvbihpZCk7XHJcbiAgICAgICAgY29uc3QgbVRpbWVzdGFtcCA9IERhdGUubm93KCk7XHJcbiAgICAgICAgdGhpcy5fY2h1bmtzW2lkXSA9IHtcclxuICAgICAgICAgICAgaW1wb3J0czoge30sXHJcbiAgICAgICAgICAgIHBoeXNpY2FsTG9jYXRpb24sXHJcbiAgICAgICAgICAgIG1UaW1lc3RhbXAsXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgY29uc3Qgc291cmNlQ2FjaGVGaWxlID0gdGhpcy5fZ2V0Q2h1bmtTb3VyY2VGaWxlKHBoeXNpY2FsTG9jYXRpb24pO1xyXG4gICAgICAgIC8vIGNvbnN0IG1ldGFkYXRhQ2FjaGVGaWxlID0gdGhpcy5fZ2V0TWV0YWRhdGFDYWNoZUZpbGUocXBMb2NhdGlvbik7XHJcbiAgICAgICAgbGV0IHNvdXJjZU1hcHBpbmdVUkw6IHN0cmluZyB8IHVuZGVmaW5lZDtcclxuICAgICAgICBsZXQgc2VyaWFsaXplZE1hcDogc3RyaW5nIHwgdW5kZWZpbmVkO1xyXG4gICAgICAgIGlmIChtYXApIHtcclxuICAgICAgICAgICAgc2VyaWFsaXplZE1hcCA9IHR5cGVvZiBtYXAgPT09ICdzdHJpbmcnXHJcbiAgICAgICAgICAgICAgICA/IG1hcFxyXG4gICAgICAgICAgICAgICAgOiBKU09OLnN0cmluZ2lmeShtYXApO1xyXG4gICAgICAgICAgICBzb3VyY2VNYXBwaW5nVVJMID0gYCR7cHMuYmFzZW5hbWUoc291cmNlQ2FjaGVGaWxlKX0ubWFwYDtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgY29kZVdpdGhNYXAgPSBzb3VyY2VNYXBwaW5nVVJMXHJcbiAgICAgICAgICAgID8gYCR7Y29kZX1cXG4vLyMgc291cmNlTWFwcGluZ1VSTD0ke3NvdXJjZU1hcHBpbmdVUkx9YFxyXG4gICAgICAgICAgICA6IGNvZGU7XHJcbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoW1xyXG4gICAgICAgICAgICAvLyBXcml0ZSBtZXRhZGF0YVxyXG4gICAgICAgICAgICAvLyBmcy5vdXRwdXRGaWxlKG1ldGFkYXRhQ2FjaGVGaWxlLCBKU09OLnN0cmluZ2lmeShtZXRhZGF0YSwgdW5kZWZpbmVkLCAyKSwgeyBlbmNvZGluZzogJ3V0ZjgnIH0pLFxyXG4gICAgICAgICAgICAvLyBXcml0ZSBjb2RlXHJcbiAgICAgICAgICAgIGZzLm91dHB1dEZpbGUoc291cmNlQ2FjaGVGaWxlLCBjb2RlV2l0aE1hcCwgeyBlbmNvZGluZzogJ3V0ZjgnIH0pLFxyXG4gICAgICAgICAgICAvLyBXcml0ZSBtYXBcclxuICAgICAgICAgICAgc2VyaWFsaXplZE1hcFxyXG4gICAgICAgICAgICAgICAgPyBmcy5vdXRwdXRGaWxlKGAke3NvdXJjZUNhY2hlRmlsZX0ubWFwYCwgc2VyaWFsaXplZE1hcCwgeyBlbmNvZGluZzogJ3V0ZjgnIH0pXHJcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcclxuICAgICAgICBdKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgYXN5bmMgcmVtb3ZlQ2h1bmsoaWQ6IENodW5rSWQpIHtcclxuICAgICAgICBkZWxldGUgdGhpcy5fY2h1bmtzW2lkXTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgYXN5bmMgc3luY0NodW5rKGNodW5rQWxpYXM6IFJlY29yZDxDaHVua0lkLCBzdHJpbmc+KSB7XHJcbiAgICAgICAgYXdhaXQgdGhpcy5fd3JpdGVDaHVua1JlY29yZCgpO1xyXG4gICAgICAgIGF3YWl0IHRoaXMuX3dyaXRlSW1wb3J0TWFwKHRoaXMuX2ltcG9ydE1hcEZpbGUsIGNodW5rQWxpYXMpO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgX29yaWdpbjogc3RyaW5nO1xyXG4gICAgcHJpdmF0ZSBfbG9nZ2VyOiBMb2dnZXI7XHJcbiAgICBwcml2YXRlIF9pbXBvcnRNYXBGaWxlOiBzdHJpbmc7XHJcblxyXG4gICAgcHJpdmF0ZSBhc3luYyBfd3JpdGVJbXBvcnRNYXAob3V0RmlsZTogc3RyaW5nLCBjaHVua0FsaWFzOiBSZWNvcmQ8c3RyaW5nLCBDaHVua0lkPikge1xyXG4gICAgICAgIGNvbnN0IGltcG9ydE1hcFVSTCA9IHBhdGhUb0ZpbGVVUkwob3V0RmlsZSk7XHJcbiAgICAgICAgY29uc3QgaW1wb3J0TWFwUmVsYXRlID0gbmV3IFJlbGF0ZVVybChpbXBvcnRNYXBVUkwuaHJlZik7XHJcbiAgICAgICAgY29uc3QgZ2V0Q2h1bmtSZWxhdGl2ZVBhdGhGcm9tSW1wb3J0TWFwID0gKGNodW5rSWQ6IHN0cmluZyk6IHN0cmluZyA9PiB7XHJcbiAgICAgICAgICAgIC8vIENhbiBoYXBwZW4gd2hlbiByZWxvYWQgQSAtPiBCXHJcbiAgICAgICAgICAgIC8vIEEgaXMgdW5jaGFuZ2VkLCBidXQgY2FuIG5vdCBsb2FkIEIoc2luY2UgYGZvcmNlQWxsOiB0cnVlYClcclxuICAgICAgICAgICAgLy8gQSdzIGRlcCByZWNvcmRzIGFyZSBub3QgY2xlYXJcclxuICAgICAgICAgICAgYXNzZXJ0cyhjaHVua0lkIGluIHRoaXMuX2NodW5rcywgJ1NvbWV0aGluZyB3ZW50IHdyb25nOiBtb2R1bGUgQSBkZXBlbmRzIG9uIEIsIGJ1dCBCIGlzIG5vdCBjb3JyZWN0bHkgZ2VuZXJhdGVkLicpO1xyXG4gICAgICAgICAgICBjb25zdCBjaHVua1NvdXJjZUZpbGUgPSB0aGlzLl9nZXRDaHVua1NvdXJjZUZpbGUodGhpcy5fY2h1bmtzW2NodW5rSWRdLnBoeXNpY2FsTG9jYXRpb24pO1xyXG4gICAgICAgICAgICBjb25zdCByZWxhdGl2ZVBhdGggPSBpbXBvcnRNYXBSZWxhdGUucmVsYXRlKHBhdGhUb0ZpbGVVUkwoY2h1bmtTb3VyY2VGaWxlKS5ocmVmKTtcclxuICAgICAgICAgICAgcmV0dXJuIGAuLyR7cmVsYXRpdmVQYXRofWA7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBjb25zdCBpbXBvcnRNYXA6IEltcG9ydE1hcCA9IHt9O1xyXG4gICAgICAgIGltcG9ydE1hcC5pbXBvcnRzID0ge307XHJcbiAgICAgICAgY29uc3QgaW1wb3J0cyA9IGltcG9ydE1hcC5pbXBvcnRzO1xyXG4gICAgICAgIGZvciAoY29uc3QgW2FsaWFzLCBjaHVua0lkXSBvZiBPYmplY3QuZW50cmllcyhjaHVua0FsaWFzKSkge1xyXG4gICAgICAgICAgICBpbXBvcnRzW2FsaWFzXSA9IGdldENodW5rUmVsYXRpdmVQYXRoRnJvbUltcG9ydE1hcChjaHVua0lkKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaW1wb3J0TWFwLnNjb3BlcyA9IHt9O1xyXG4gICAgICAgIGNvbnN0IHNjb3BlcyA9IGltcG9ydE1hcC5zY29wZXM7XHJcbiAgICAgICAgZm9yIChjb25zdCBbY2h1bmtJZCwgY2h1bmtdIG9mIE9iamVjdC5lbnRyaWVzKHRoaXMuX2NodW5rcykpIHtcclxuICAgICAgICAgICAgY29uc3QgaW1wb3J0c0VudHJpZXMgPSBPYmplY3QuZW50cmllcyhjaHVuay5pbXBvcnRzKTtcclxuICAgICAgICAgICAgaWYgKGltcG9ydHNFbnRyaWVzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgY2h1bmtQYXRoID0gZ2V0Q2h1bmtSZWxhdGl2ZVBhdGhGcm9tSW1wb3J0TWFwKGNodW5rSWQpO1xyXG4gICAgICAgICAgICBjb25zdCBzcGVjaWZpZXJNYXA6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gPSBzY29wZXNbY2h1bmtQYXRoXSA9IHt9O1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtzcGVjaWZpZXIsIHJlc29sdmVkQ2h1bmtJZF0gb2YgaW1wb3J0c0VudHJpZXMpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcmVzb2x2ZWRDaHVua0lkID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICAgICAgICAgIHNwZWNpZmllck1hcFtzcGVjaWZpZXJdID0gZ2V0Q2h1bmtSZWxhdGl2ZVBhdGhGcm9tSW1wb3J0TWFwKHJlc29sdmVkQ2h1bmtJZCk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHNwZWNpZmllck1hcFtzcGVjaWZpZXJdID0gcmVzb2x2ZWRDaHVua0lkLnVybDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBhd2FpdCBmcy5vdXRwdXRKc29uKG91dEZpbGUsIGltcG9ydE1hcCwgeyBzcGFjZXM6IDIsIH0pO1xyXG4gICAgfVxyXG59XHJcbiJdfQ==