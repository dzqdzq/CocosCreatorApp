"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.detectImports = void 0;
const babel = __importStar(require("@babel/core"));
async function detectImports(ast) {
    const result = [];
    const add = (specifier, loc) => {
        result.push({
            value: specifier,
            loc: loc ? {
                start: { line: loc.start.line, column: loc.start.column },
                end: { line: loc.end.line, column: loc.end.column },
            } : undefined,
        });
    };
    const addStringLiteralSpecifier = (specifier) => {
        add(specifier.value, specifier.loc);
    };
    babel.traverse(ast, {
        ImportDeclaration: (path) => addStringLiteralSpecifier(path.node.source),
        ExportAllDeclaration: (path) => addStringLiteralSpecifier(path.node.source),
        ExportNamedDeclaration: (path) => {
            if (path.node.source) {
                addStringLiteralSpecifier(path.node.source);
            }
        },
        CallExpression: (path) => {
            const { callee, arguments: args } = path.node;
            if (callee.type === 'Import' && args.length === 1) {
                const specifierNode = args[0];
                if (specifierNode.type === 'StringLiteral') {
                    addStringLiteralSpecifier(specifierNode);
                }
                else if (specifierNode.type === 'TemplateLiteral' &&
                    specifierNode.expressions.length === 0 &&
                    specifierNode.quasis.length === 1) {
                    add(specifierNode.quasis[0].value.raw, specifierNode.quasis[0].loc);
                }
            }
        },
    });
    return result;
}
exports.detectImports = detectImports;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGV0ZWN0LWltcG9ydHMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi9zcmMvbW9kLWFzc2VtYmxpbmcvcXVpY2stcGFjay91dGlscy9kZXRlY3QtaW1wb3J0cy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQ0EsbURBQXFDO0FBa0I5QixLQUFLLFVBQVUsYUFBYSxDQUFDLEdBQVE7SUFDeEMsTUFBTSxNQUFNLEdBQWdCLEVBQUUsQ0FBQztJQUMvQixNQUFNLEdBQUcsR0FBRyxDQUFDLFNBQWlCLEVBQUUsR0FBdUMsRUFBRSxFQUFFO1FBQ3ZFLE1BQU0sQ0FBQyxJQUFJLENBQUM7WUFDUixLQUFLLEVBQUUsU0FBUztZQUNoQixHQUFHLEVBQUUsR0FBRyxDQUFDLENBQUMsQ0FBQztnQkFDUCxLQUFLLEVBQUUsRUFBRSxJQUFJLEVBQUUsR0FBRyxDQUFDLEtBQUssQ0FBQyxJQUFJLEVBQUUsTUFBTSxFQUFFLEdBQUcsQ0FBQyxLQUFLLENBQUMsTUFBTSxFQUFFO2dCQUN6RCxHQUFHLEVBQUUsRUFBRSxJQUFJLEVBQUUsR0FBRyxDQUFDLEdBQUcsQ0FBQyxJQUFJLEVBQUUsTUFBTSxFQUFFLEdBQUcsQ0FBQyxHQUFHLENBQUMsTUFBTSxFQUFFO2FBQ3RELENBQUMsQ0FBQyxDQUFDLFNBQVM7U0FDaEIsQ0FBQyxDQUFDO0lBQ1AsQ0FBQyxDQUFDO0lBQ0YsTUFBTSx5QkFBeUIsR0FBRyxDQUFDLFNBQW9DLEVBQUUsRUFBRTtRQUN2RSxHQUFHLENBQUMsU0FBUyxDQUFDLEtBQUssRUFBRSxTQUFTLENBQUMsR0FBRyxDQUFDLENBQUM7SUFDeEMsQ0FBQyxDQUFDO0lBQ0YsS0FBSyxDQUFDLFFBQVEsQ0FBQyxHQUFHLEVBQUU7UUFDaEIsaUJBQWlCLEVBQUUsQ0FBQyxJQUFJLEVBQUUsRUFBRSxDQUFDLHlCQUF5QixDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDO1FBQ3hFLG9CQUFvQixFQUFFLENBQUMsSUFBSSxFQUFFLEVBQUUsQ0FBQyx5QkFBeUIsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQztRQUMzRSxzQkFBc0IsRUFBRSxDQUFDLElBQUksRUFBRSxFQUFFO1lBQzdCLElBQUksSUFBSSxDQUFDLElBQUksQ0FBQyxNQUFNLEVBQUU7Z0JBQ2xCLHlCQUF5QixDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUM7YUFDL0M7UUFDTCxDQUFDO1FBQ0QsY0FBYyxFQUFFLENBQUMsSUFBSSxFQUFFLEVBQUU7WUFDckIsTUFBTSxFQUFFLE1BQU0sRUFBRSxTQUFTLEVBQUUsSUFBSSxFQUFFLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQztZQUM5QyxJQUFJLE1BQU0sQ0FBQyxJQUFJLEtBQUssUUFBUSxJQUFJLElBQUksQ0FBQyxNQUFNLEtBQUssQ0FBQyxFQUFFO2dCQUMvQyxNQUFNLGFBQWEsR0FBRyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUM7Z0JBQzlCLElBQUksYUFBYSxDQUFDLElBQUksS0FBSyxlQUFlLEVBQUU7b0JBQ3hDLHlCQUF5QixDQUFDLGFBQWEsQ0FBQyxDQUFDO2lCQUM1QztxQkFBTSxJQUNILGFBQWEsQ0FBQyxJQUFJLEtBQUssaUJBQWlCO29CQUN4QyxhQUFhLENBQUMsV0FBVyxDQUFDLE1BQU0sS0FBSyxDQUFDO29CQUN0QyxhQUFhLENBQUMsTUFBTSxDQUFDLE1BQU0sS0FBSyxDQUFDLEVBQUU7b0JBQ25DLEdBQUcsQ0FBQyxhQUFhLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxHQUFHLEVBQUUsYUFBYSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQztpQkFDdkU7YUFDSjtRQUNMLENBQUM7S0FDSixDQUFDLENBQUM7SUFDSCxPQUFPLE1BQU0sQ0FBQztBQUNsQixDQUFDO0FBdENELHNDQXNDQyIsInNvdXJjZXNDb250ZW50IjpbIlxuaW1wb3J0ICogYXMgYmFiZWwgZnJvbSAnQGJhYmVsL2NvcmUnO1xuaW1wb3J0IHsgQXN0IH0gZnJvbSAnLi4vLi4vbW9kLWxvL21vZC1sbyc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgU3BlY2lmaWVyIHtcbiAgICB2YWx1ZTogc3RyaW5nO1xuICAgIGxvYz86IFNvdXJjZUxvY2F0aW9uO1xufVxuXG5pbnRlcmZhY2UgTGluZUNvbHVtbiB7XG4gICAgbGluZTogbnVtYmVyO1xuICAgIGNvbHVtbjogbnVtYmVyO1xufVxuXG5pbnRlcmZhY2UgU291cmNlTG9jYXRpb24ge1xuICAgIHN0YXJ0OiBMaW5lQ29sdW1uO1xuICAgIGVuZDogTGluZUNvbHVtbjtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGRldGVjdEltcG9ydHMoYXN0OiBBc3QpOiBQcm9taXNlPFNwZWNpZmllcltdPiB7XG4gICAgY29uc3QgcmVzdWx0OiBTcGVjaWZpZXJbXSA9IFtdO1xuICAgIGNvbnN0IGFkZCA9IChzcGVjaWZpZXI6IHN0cmluZywgbG9jPzogYmFiZWwudHlwZXMuU291cmNlTG9jYXRpb24gfCBudWxsKSA9PiB7XG4gICAgICAgIHJlc3VsdC5wdXNoKHtcbiAgICAgICAgICAgIHZhbHVlOiBzcGVjaWZpZXIsXG4gICAgICAgICAgICBsb2M6IGxvYyA/IHtcbiAgICAgICAgICAgICAgICBzdGFydDogeyBsaW5lOiBsb2Muc3RhcnQubGluZSwgY29sdW1uOiBsb2Muc3RhcnQuY29sdW1uIH0sXG4gICAgICAgICAgICAgICAgZW5kOiB7IGxpbmU6IGxvYy5lbmQubGluZSwgY29sdW1uOiBsb2MuZW5kLmNvbHVtbiB9LFxuICAgICAgICAgICAgfSA6IHVuZGVmaW5lZCxcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCBhZGRTdHJpbmdMaXRlcmFsU3BlY2lmaWVyID0gKHNwZWNpZmllcjogYmFiZWwudHlwZXMuU3RyaW5nTGl0ZXJhbCkgPT4ge1xuICAgICAgICBhZGQoc3BlY2lmaWVyLnZhbHVlLCBzcGVjaWZpZXIubG9jKTtcbiAgICB9O1xuICAgIGJhYmVsLnRyYXZlcnNlKGFzdCwge1xuICAgICAgICBJbXBvcnREZWNsYXJhdGlvbjogKHBhdGgpID0+IGFkZFN0cmluZ0xpdGVyYWxTcGVjaWZpZXIocGF0aC5ub2RlLnNvdXJjZSksXG4gICAgICAgIEV4cG9ydEFsbERlY2xhcmF0aW9uOiAocGF0aCkgPT4gYWRkU3RyaW5nTGl0ZXJhbFNwZWNpZmllcihwYXRoLm5vZGUuc291cmNlKSxcbiAgICAgICAgRXhwb3J0TmFtZWREZWNsYXJhdGlvbjogKHBhdGgpID0+IHtcbiAgICAgICAgICAgIGlmIChwYXRoLm5vZGUuc291cmNlKSB7XG4gICAgICAgICAgICAgICAgYWRkU3RyaW5nTGl0ZXJhbFNwZWNpZmllcihwYXRoLm5vZGUuc291cmNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgQ2FsbEV4cHJlc3Npb246IChwYXRoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IGNhbGxlZSwgYXJndW1lbnRzOiBhcmdzIH0gPSBwYXRoLm5vZGU7XG4gICAgICAgICAgICBpZiAoY2FsbGVlLnR5cGUgPT09ICdJbXBvcnQnICYmIGFyZ3MubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3BlY2lmaWVyTm9kZSA9IGFyZ3NbMF07XG4gICAgICAgICAgICAgICAgaWYgKHNwZWNpZmllck5vZGUudHlwZSA9PT0gJ1N0cmluZ0xpdGVyYWwnKSB7XG4gICAgICAgICAgICAgICAgICAgIGFkZFN0cmluZ0xpdGVyYWxTcGVjaWZpZXIoc3BlY2lmaWVyTm9kZSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAgICAgICAgICAgc3BlY2lmaWVyTm9kZS50eXBlID09PSAnVGVtcGxhdGVMaXRlcmFsJyAmJlxuICAgICAgICAgICAgICAgICAgICBzcGVjaWZpZXJOb2RlLmV4cHJlc3Npb25zLmxlbmd0aCA9PT0gMCAmJlxuICAgICAgICAgICAgICAgICAgICBzcGVjaWZpZXJOb2RlLnF1YXNpcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgYWRkKHNwZWNpZmllck5vZGUucXVhc2lzWzBdLnZhbHVlLnJhdywgc3BlY2lmaWVyTm9kZS5xdWFzaXNbMF0ubG9jKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbiJdfQ==