"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.QuickPackLoaderContext = exports.QuickPackLoader = exports.ResourceNotFoundError = void 0;
const loader_context_1 = require("./utils/loader-context");
Object.defineProperty(exports, "QuickPackLoaderContext", { enumerable: true, get: function () { return loader_context_1.LoaderContext; } });
const base_1 = require("./utils/chunk-io/base");
const asserts_1 = require("../../utils/asserts");
const chunk_url_1 = require("./utils/chunk-url");
const url_1 = require("url");
const path_1 = __importDefault(require("path"));
const specifier_1 = require("../utils/specifier");
const url_2 = require("../utils/url");
const i18n_1 = require("../../utils/i18n");
class ResourceNotFoundError extends Error {
    constructor(id) {
        super(i18n_1.i18nTranslate('quick_pack_loader_resource_not_found_error', { id }));
    }
}
exports.ResourceNotFoundError = ResourceNotFoundError;
class QuickPackLoader extends base_1.ChunkIOBase {
    constructor(context, options) {
        super({ chunkRecordFile: context.chunkRecordFile, sourceCacheDir: context.sourceCacheDir });
        this._importMap = {};
        this._entries = [];
        this._origin = context.origin;
        this._options = options;
        const realFsRoot = url_1.pathToFileURL(this._origin).pathname;
        this._fsLocator = new chunk_url_1.FsLocator(realFsRoot);
    }
    async getImportMap() {
        return this._importMap;
    }
    getEntries() {
        return this._entries;
    }
    async getResource(link) {
        const resourceId = this.getResourceId(link);
        return await this.getResourceFromId(resourceId);
    }
    getResourceId(link) {
        const normalizedLink = this._normalizeLink(link);
        const quickPackURL = linkToQuickPackURL(normalizedLink);
        const chunkId = this._fsLocator.toChunkId(quickPackURL);
        return chunkId;
    }
    async getResourceFromId(resourceId) {
        let chunkId;
        let isMap;
        if (resourceId.endsWith('.map')) {
            isMap = true;
            chunkId = resourceId.substr(0, resourceId.length - 4);
        }
        else {
            isMap = false;
            chunkId = resourceId;
        }
        const chunk = this._chunks[chunkId];
        if (!chunk) {
            throw new ResourceNotFoundError(resourceId);
        }
        const physicalLocation = chunk.physicalLocation;
        const file = this._getChunkSourceFile(physicalLocation);
        return {
            type: 'file',
            path: isMap ? `${file}.map` : file,
        };
    }
    /**
     * 获取指定资源的 mtime 时间戳。若不存在则返回负值。
     */
    async getResourceMTimestamp(resource) {
        var _a, _b;
        return (_b = (_a = this._chunks[this._getChunkId(resource)]) === null || _a === void 0 ? void 0 : _a.mTimestamp) !== null && _b !== void 0 ? _b : -1;
    }
    /**
     * 获取指定所有资源的 mtime 时间戳。不存在的资源将返回负值。
     */
    async getResourceMTimestamps(resources) {
        return resources.map((resourceId) => { var _a, _b; return (_b = (_a = this._chunks[this._getChunkId(resourceId)]) === null || _a === void 0 ? void 0 : _a.mTimestamp) !== null && _b !== void 0 ? _b : -1; });
    }
    async reload() {
        await this._loadChunkRecord();
        ({
            importMap: this._importMap,
            entries: this._entries,
        } = await this._createImportMap(this._origin, this._options.importMapBasedRoot));
    }
    async _createImportMap(origin, importMapBasedRoot) {
        var _a, _b, _c;
        asserts_1.asserts(importMapBasedRoot.endsWith('/'));
        const fsLocator = this._fsLocator;
        const entries = [];
        const imports = {};
        const scopes = {};
        const getImportMapBasedUrl = (url) => {
            if (chunk_url_1.isQuickPackURL(url)) {
                return `${importMapBasedRoot}${quickPackURLToExternalLink(url)}`;
            }
            else {
                // All other urls are not import map arrived.
                return url.href;
            }
        };
        const normalizeSpecifier = (specifier, baseUrl) => {
            var _a;
            // https://wicg.github.io/import-maps/#resolve-an-imports-match
            if (specifier_1.isRelativeSpecifier(specifier)) {
                return url_2.tryParseURL(specifier, baseUrl);
            }
            else {
                return (_a = url_2.tryParseURL(specifier)) !== null && _a !== void 0 ? _a : specifier;
            }
        };
        const originDirUrl = url_1.pathToFileURL(`${origin}${path_1.default.sep}`);
        const originNpURL = new url_1.URL(fsLocator.getOrigin().href);
        if (!originNpURL.pathname.endsWith('/')) {
            originNpURL.pathname += '/';
        }
        imports[originDirUrl.href] = getImportMapBasedUrl(originNpURL);
        const urlResolves = {};
        for (const [chunkId, chunk] of Object.entries(this._chunks)) {
            const chunkURL = fsLocator.toQuickPackURL(chunkId);
            const myUrlImportMapBased = getImportMapBasedUrl(chunkURL);
            if (chunk.isEntry) {
                entries.push(myUrlImportMapBased);
            }
            if (chunk.exposeAs) {
                imports[chunk.exposeAs] = myUrlImportMapBased;
            }
            const scopeCurMod = myUrlImportMapBased;
            for (const [specifier, resolvedChunkId] of Object.entries(chunk.imports)) {
                const resolvedUrl = fsLocator.toQuickPackURL(resolvedChunkId);
                const normalizedSpecifier = normalizeSpecifier(specifier, chunkURL);
                // If the specifier is erroneous, continue.
                // Otherwise, the normalized specifier is an URL or bare specifier.
                if (!normalizedSpecifier) {
                    continue;
                }
                const isNormal = typeof normalizedSpecifier !== 'string' &&
                    normalizedSpecifier.href === resolvedUrl.href;
                const resolveKey = typeof normalizedSpecifier === 'string'
                    ? normalizedSpecifier
                    : getImportMapBasedUrl(normalizedSpecifier);
                const resolves = (_a = urlResolves[resolveKey]) !== null && _a !== void 0 ? _a : (urlResolves[resolveKey] = { normal: false });
                if (isNormal) {
                    resolves.normal = true;
                }
                else {
                    const specialResolves = (_b = resolves.specialResolves) !== null && _b !== void 0 ? _b : (resolves.specialResolves = {});
                    specialResolves[scopeCurMod] = resolvedUrl;
                }
            }
        }
        const scopeThis = scopes[getImportMapBasedUrl(chunk_url_1.quickPackRootURL)] = {};
        for (const [specifier, { normal, specialResolves }] of Object.entries(urlResolves)) {
            if (!specialResolves) {
                // If there is no special match, do nothing
                continue;
            }
            if (normal) {
                scopeThis[specifier] = specifier;
            }
            const allResolves = Object.entries(specialResolves);
            if (!normal && allResolves.every(([, resolved], _index, [[, firstResolved]]) => resolved.href === firstResolved.href)) {
                const [, resolved] = allResolves[0];
                scopeThis[specifier] = getImportMapBasedUrl(resolved);
            }
            else {
                for (const [importer, resolved] of allResolves) {
                    ((_c = scopes[importer]) !== null && _c !== void 0 ? _c : (scopes[importer] = {}))[specifier] = getImportMapBasedUrl(resolved);
                }
            }
        }
        const sortObject = (o, fn = (v) => v) => Object.keys(o).sort().reduce((r, k) => (r[k] = fn(o[k]), r), {});
        const importMap = {
            imports: sortObject(imports),
            scopes: sortObject(scopes, (map) => sortObject(map)),
        };
        return {
            entries,
            importMap,
        };
    }
    _normalizeLink(link) {
        return link.startsWith('/') ? link : `/${link}`;
    }
    _getChunkId(resourceId) {
        return resourceId.endsWith('.map')
            ? resourceId.substr(0, resourceId.length - 4)
            : resourceId;
    }
}
exports.QuickPackLoader = QuickPackLoader;
function quickPackURLToExternalLink(url) {
    return `${url.pathname.substr(1)}${url.search}`;
}
function linkToQuickPackURL(link) {
    return new url_1.URL(link, chunk_url_1.quickPackRootURL);
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibG9hZGVyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vc3JjL21vZC1hc3NlbWJsaW5nL3F1aWNrLXBhY2svbG9hZGVyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFBLDJEQUF1RDtBQXdPN0IsdUdBeE9qQiw4QkFBYSxPQXdPMEI7QUF2T2hELGdEQUFvRDtBQUNwRCxpREFBOEM7QUFDOUMsaURBQWdGO0FBQ2hGLDZCQUF5QztBQUN6QyxnREFBc0I7QUFHdEIsa0RBQXlEO0FBQ3pELHNDQUEyQztBQUMzQywyQ0FBaUQ7QUFNakQsTUFBYSxxQkFBc0IsU0FBUSxLQUFLO0lBQzVDLFlBQVksRUFBVTtRQUNsQixLQUFLLENBQUMsb0JBQWEsQ0FBQyw0Q0FBNEMsRUFBRSxFQUFFLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQztJQUMvRSxDQUFDO0NBQ0o7QUFKRCxzREFJQztBQUVELE1BQWEsZUFBZ0IsU0FBUSxrQkFBVztJQUM1QyxZQUNJLE9BQXNCLEVBQ3RCLE9BQWdCO1FBRWhCLEtBQUssQ0FBQyxFQUFFLGVBQWUsRUFBRSxPQUFPLENBQUMsZUFBZSxFQUFFLGNBQWMsRUFBRSxPQUFPLENBQUMsY0FBYyxFQUFFLENBQUMsQ0FBQztRQTBFeEYsZUFBVSxHQUFjLEVBQUUsQ0FBQztRQUMzQixhQUFRLEdBQWEsRUFBRSxDQUFDO1FBMUU1QixJQUFJLENBQUMsT0FBTyxHQUFHLE9BQU8sQ0FBQyxNQUFNLENBQUM7UUFDOUIsSUFBSSxDQUFDLFFBQVEsR0FBRyxPQUFPLENBQUM7UUFDeEIsTUFBTSxVQUFVLEdBQUcsbUJBQWEsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUMsUUFBUSxDQUFDO1FBQ3hELElBQUksQ0FBQyxVQUFVLEdBQUcsSUFBSSxxQkFBUyxDQUFDLFVBQVUsQ0FBQyxDQUFDO0lBQ2hELENBQUM7SUFFTSxLQUFLLENBQUMsWUFBWTtRQUNyQixPQUFPLElBQUksQ0FBQyxVQUFVLENBQUM7SUFDM0IsQ0FBQztJQUVNLFVBQVU7UUFDYixPQUFPLElBQUksQ0FBQyxRQUFRLENBQUM7SUFDekIsQ0FBQztJQUVNLEtBQUssQ0FBQyxXQUFXLENBQUMsSUFBWTtRQUNqQyxNQUFNLFVBQVUsR0FBRyxJQUFJLENBQUMsYUFBYSxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQzVDLE9BQU8sTUFBTSxJQUFJLENBQUMsaUJBQWlCLENBQUMsVUFBVSxDQUFDLENBQUM7SUFDcEQsQ0FBQztJQUVNLGFBQWEsQ0FBQyxJQUFZO1FBQzdCLE1BQU0sY0FBYyxHQUFHLElBQUksQ0FBQyxjQUFjLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDakQsTUFBTSxZQUFZLEdBQUcsa0JBQWtCLENBQUMsY0FBYyxDQUFDLENBQUM7UUFDeEQsTUFBTSxPQUFPLEdBQUcsSUFBSSxDQUFDLFVBQVUsQ0FBQyxTQUFTLENBQUMsWUFBWSxDQUFDLENBQUM7UUFDeEQsT0FBTyxPQUFPLENBQUM7SUFDbkIsQ0FBQztJQUVNLEtBQUssQ0FBQyxpQkFBaUIsQ0FBQyxVQUFzQjtRQUNqRCxJQUFJLE9BQWUsQ0FBQztRQUNwQixJQUFJLEtBQWMsQ0FBQztRQUNuQixJQUFJLFVBQVUsQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDLEVBQUU7WUFDN0IsS0FBSyxHQUFHLElBQUksQ0FBQztZQUNiLE9BQU8sR0FBRyxVQUFVLENBQUMsTUFBTSxDQUFDLENBQUMsRUFBRSxVQUFVLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQyxDQUFDO1NBQ3pEO2FBQU07WUFDSCxLQUFLLEdBQUcsS0FBSyxDQUFDO1lBQ2QsT0FBTyxHQUFHLFVBQVUsQ0FBQztTQUN4QjtRQUNELE1BQU0sS0FBSyxHQUFHLElBQUksQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDLENBQUM7UUFDcEMsSUFBSSxDQUFDLEtBQUssRUFBRTtZQUNSLE1BQU0sSUFBSSxxQkFBcUIsQ0FBQyxVQUFVLENBQUMsQ0FBQztTQUMvQztRQUNELE1BQU0sZ0JBQWdCLEdBQUcsS0FBSyxDQUFDLGdCQUFnQixDQUFDO1FBQ2hELE1BQU0sSUFBSSxHQUFHLElBQUksQ0FBQyxtQkFBbUIsQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDO1FBQ3hELE9BQU87WUFDSCxJQUFJLEVBQUUsTUFBTTtZQUNaLElBQUksRUFBRSxLQUFLLENBQUMsQ0FBQyxDQUFDLEdBQUcsSUFBSSxNQUFNLENBQUMsQ0FBQyxDQUFDLElBQUk7U0FDNUIsQ0FBQztJQUNmLENBQUM7SUFFRDs7T0FFRztJQUNJLEtBQUssQ0FBQyxxQkFBcUIsQ0FBQyxRQUFvQjs7UUFDbkQsbUJBQU8sSUFBSSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLFFBQVEsQ0FBQyxDQUFDLDBDQUFFLFVBQVUsbUNBQUksQ0FBQyxDQUFDLENBQUM7SUFDdEUsQ0FBQztJQUVEOztPQUVHO0lBQ0ksS0FBSyxDQUFDLHNCQUFzQixDQUFDLFNBQXVCO1FBQ3ZELE9BQU8sU0FBUyxDQUFDLEdBQUcsQ0FBQyxDQUFDLFVBQVUsRUFBRSxFQUFFLGtDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxVQUFVLENBQUMsQ0FBQywwQ0FBRSxVQUFVLG1DQUFJLENBQUMsQ0FBQyxHQUFBLENBQUMsQ0FBQztJQUN2RyxDQUFDO0lBRU0sS0FBSyxDQUFDLE1BQU07UUFDZixNQUFNLElBQUksQ0FBQyxnQkFBZ0IsRUFBRSxDQUFDO1FBQzlCLENBQUM7WUFDRyxTQUFTLEVBQUUsSUFBSSxDQUFDLFVBQVU7WUFDMUIsT0FBTyxFQUFFLElBQUksQ0FBQyxRQUFRO1NBQ3pCLEdBQUcsTUFBTSxJQUFJLENBQUMsZ0JBQWdCLENBQUMsSUFBSSxDQUFDLE9BQU8sRUFBRSxJQUFJLENBQUMsUUFBUSxDQUFDLGtCQUFrQixDQUFDLENBQUMsQ0FBQztJQUNyRixDQUFDO0lBUU8sS0FBSyxDQUFDLGdCQUFnQixDQUMxQixNQUFjLEVBQ2Qsa0JBQTBCOztRQUUxQixpQkFBTyxDQUFDLGtCQUFrQixDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1FBRTFDLE1BQU0sU0FBUyxHQUFHLElBQUksQ0FBQyxVQUFVLENBQUM7UUFFbEMsTUFBTSxPQUFPLEdBQWEsRUFBRSxDQUFDO1FBRTdCLE1BQU0sT0FBTyxHQUEyQixFQUFFLENBQUM7UUFFM0MsTUFBTSxNQUFNLEdBQXFDLEVBQUUsQ0FBQztRQUVwRCxNQUFNLG9CQUFvQixHQUFHLENBQUMsR0FBUSxFQUFFLEVBQUU7WUFDdEMsSUFBSSwwQkFBYyxDQUFDLEdBQUcsQ0FBQyxFQUFFO2dCQUNyQixPQUFPLEdBQUcsa0JBQWtCLEdBQUcsMEJBQTBCLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQzthQUNwRTtpQkFBTTtnQkFDSCw2Q0FBNkM7Z0JBQzdDLE9BQU8sR0FBRyxDQUFDLElBQUksQ0FBQzthQUNuQjtRQUNMLENBQUMsQ0FBQztRQUVGLE1BQU0sa0JBQWtCLEdBQUcsQ0FBQyxTQUFpQixFQUFFLE9BQVksRUFBNEIsRUFBRTs7WUFDckYsK0RBQStEO1lBQy9ELElBQUksK0JBQW1CLENBQUMsU0FBUyxDQUFDLEVBQUU7Z0JBQ2hDLE9BQU8saUJBQVcsQ0FBQyxTQUFTLEVBQUUsT0FBTyxDQUFDLENBQUM7YUFDMUM7aUJBQU07Z0JBQ0gsYUFBTyxpQkFBVyxDQUFDLFNBQVMsQ0FBQyxtQ0FBSSxTQUFTLENBQUM7YUFDOUM7UUFDTCxDQUFDLENBQUM7UUFFRixNQUFNLFlBQVksR0FBRyxtQkFBYSxDQUFDLEdBQUcsTUFBTSxHQUFHLGNBQUUsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxDQUFDO1FBQ3pELE1BQU0sV0FBVyxHQUFHLElBQUksU0FBRyxDQUFDLFNBQVMsQ0FBQyxTQUFTLEVBQUUsQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUN4RCxJQUFJLENBQUMsV0FBVyxDQUFDLFFBQVEsQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLEVBQUU7WUFDckMsV0FBVyxDQUFDLFFBQVEsSUFBSSxHQUFHLENBQUM7U0FDL0I7UUFDRCxPQUFPLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQyxHQUFHLG9CQUFvQixDQUFDLFdBQVcsQ0FBQyxDQUFDO1FBRS9ELE1BQU0sV0FBVyxHQUdaLEVBQUUsQ0FBQztRQUVSLEtBQUssTUFBTSxDQUFDLE9BQU8sRUFBRSxLQUFLLENBQUMsSUFBSSxNQUFNLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsRUFBRTtZQUN6RCxNQUFNLFFBQVEsR0FBRyxTQUFTLENBQUMsY0FBYyxDQUFDLE9BQU8sQ0FBQyxDQUFDO1lBRW5ELE1BQU0sbUJBQW1CLEdBQUcsb0JBQW9CLENBQUMsUUFBUSxDQUFDLENBQUM7WUFDM0QsSUFBSSxLQUFLLENBQUMsT0FBTyxFQUFFO2dCQUNmLE9BQU8sQ0FBQyxJQUFJLENBQUMsbUJBQW1CLENBQUMsQ0FBQzthQUNyQztZQUNELElBQUksS0FBSyxDQUFDLFFBQVEsRUFBRTtnQkFDaEIsT0FBTyxDQUFDLEtBQUssQ0FBQyxRQUFRLENBQUMsR0FBRyxtQkFBbUIsQ0FBQzthQUNqRDtZQUVELE1BQU0sV0FBVyxHQUFHLG1CQUFtQixDQUFDO1lBQ3hDLEtBQUssTUFBTSxDQUFDLFNBQVMsRUFBRSxlQUFlLENBQUMsSUFBSSxNQUFNLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsRUFBRTtnQkFDdEUsTUFBTSxXQUFXLEdBQUcsU0FBUyxDQUFDLGNBQWMsQ0FBQyxlQUFlLENBQUMsQ0FBQztnQkFFOUQsTUFBTSxtQkFBbUIsR0FBRyxrQkFBa0IsQ0FBQyxTQUFTLEVBQUUsUUFBUSxDQUFDLENBQUM7Z0JBQ3BFLDJDQUEyQztnQkFDM0MsbUVBQW1FO2dCQUNuRSxJQUFJLENBQUMsbUJBQW1CLEVBQUU7b0JBQ3RCLFNBQVM7aUJBQ1o7Z0JBRUQsTUFBTSxRQUFRLEdBQUcsT0FBTyxtQkFBbUIsS0FBSyxRQUFRO29CQUNwRCxtQkFBbUIsQ0FBQyxJQUFJLEtBQUssV0FBVyxDQUFDLElBQUksQ0FBQztnQkFFbEQsTUFBTSxVQUFVLEdBQUcsT0FBTyxtQkFBbUIsS0FBSyxRQUFRO29CQUN0RCxDQUFDLENBQUMsbUJBQW1CO29CQUNyQixDQUFDLENBQUMsb0JBQW9CLENBQUMsbUJBQW1CLENBQUMsQ0FBQztnQkFDaEQsTUFBTSxRQUFRLFNBQUcsV0FBVyxDQUFDLFVBQVUscUNBQXRCLFdBQVcsQ0FBQyxVQUFVLElBQU0sRUFBRSxNQUFNLEVBQUUsS0FBSyxFQUFFLENBQUEsQ0FBQztnQkFDL0QsSUFBSSxRQUFRLEVBQUU7b0JBQ1YsUUFBUSxDQUFDLE1BQU0sR0FBRyxJQUFJLENBQUM7aUJBQzFCO3FCQUFNO29CQUNILE1BQU0sZUFBZSxTQUFHLFFBQVEsQ0FBQyxlQUFlLG9DQUF4QixRQUFRLENBQUMsZUFBZSxHQUFLLEVBQUUsQ0FBQSxDQUFDO29CQUN4RCxlQUFlLENBQUMsV0FBVyxDQUFDLEdBQUcsV0FBVyxDQUFDO2lCQUM5QzthQUNKO1NBQ0o7UUFFRCxNQUFNLFNBQVMsR0FBRyxNQUFNLENBQUMsb0JBQW9CLENBQUMsNEJBQWdCLENBQUMsQ0FBQyxHQUFHLEVBQTRCLENBQUM7UUFFaEcsS0FBSyxNQUFNLENBQUMsU0FBUyxFQUFFLEVBQUUsTUFBTSxFQUFFLGVBQWUsRUFBRSxDQUFDLElBQUksTUFBTSxDQUFDLE9BQU8sQ0FBQyxXQUFXLENBQUMsRUFBRTtZQUNoRixJQUFJLENBQUMsZUFBZSxFQUFFO2dCQUNsQiwyQ0FBMkM7Z0JBQzNDLFNBQVM7YUFDWjtZQUNELElBQUksTUFBTSxFQUFFO2dCQUNSLFNBQVMsQ0FBQyxTQUFTLENBQUMsR0FBRyxTQUFTLENBQUM7YUFDcEM7WUFDRCxNQUFNLFdBQVcsR0FBRyxNQUFNLENBQUMsT0FBTyxDQUFDLGVBQWUsQ0FBQyxDQUFDO1lBQ3BELElBQUksQ0FBQyxNQUFNLElBQUksV0FBVyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsRUFBRSxRQUFRLENBQUMsRUFBRSxNQUFNLEVBQUUsQ0FBQyxDQUFDLEVBQUUsYUFBYSxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsUUFBUSxDQUFDLElBQUksS0FBSyxhQUFhLENBQUMsSUFBSSxDQUFDLEVBQUU7Z0JBQ25ILE1BQU0sQ0FBQyxFQUFFLFFBQVEsQ0FBQyxHQUFHLFdBQVcsQ0FBQyxDQUFDLENBQUMsQ0FBQztnQkFDcEMsU0FBUyxDQUFDLFNBQVMsQ0FBQyxHQUFHLG9CQUFvQixDQUFDLFFBQVEsQ0FBQyxDQUFDO2FBQ3pEO2lCQUFNO2dCQUNILEtBQUssTUFBTSxDQUFDLFFBQVEsRUFBRSxRQUFRLENBQUMsSUFBSSxXQUFXLEVBQUU7b0JBQzVDLE9BQUMsTUFBTSxDQUFDLFFBQVEscUNBQWYsTUFBTSxDQUFDLFFBQVEsSUFBTSxFQUFFLEVBQUMsQ0FBQyxTQUFTLENBQUMsR0FBRyxvQkFBb0IsQ0FBQyxRQUFRLENBQUMsQ0FBQztpQkFDekU7YUFDSjtTQUNKO1FBRUQsTUFBTSxVQUFVLEdBQUcsQ0FBSSxDQUFvQixFQUFFLEtBQUssQ0FBQyxDQUFJLEVBQUUsRUFBRSxDQUFDLENBQUMsRUFBRSxFQUFFLENBQzdELE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxFQUFFLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLEVBQXVCLENBQUMsQ0FBQztRQUUxRixNQUFNLFNBQVMsR0FBYztZQUN6QixPQUFPLEVBQUUsVUFBVSxDQUFDLE9BQU8sQ0FBQztZQUM1QixNQUFNLEVBQUUsVUFBVSxDQUFDLE1BQU0sRUFBRSxDQUFDLEdBQUcsRUFBRSxFQUFFLENBQUMsVUFBVSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1NBQ3ZELENBQUM7UUFFRixPQUFPO1lBQ0gsT0FBTztZQUNQLFNBQVM7U0FDWixDQUFDO0lBQ04sQ0FBQztJQUVPLGNBQWMsQ0FBQyxJQUFZO1FBQy9CLE9BQU8sSUFBSSxDQUFDLFVBQVUsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxJQUFJLElBQUksRUFBRSxDQUFDO0lBQ3BELENBQUM7SUFFTyxXQUFXLENBQUMsVUFBa0I7UUFDbEMsT0FBTyxVQUFVLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQztZQUM5QixDQUFDLENBQUMsVUFBVSxDQUFDLE1BQU0sQ0FBQyxDQUFDLEVBQUUsVUFBVSxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUM7WUFDN0MsQ0FBQyxDQUFDLFVBQVUsQ0FBQztJQUNyQixDQUFDO0NBQ0o7QUFoTkQsMENBZ05DO0FBa0JELFNBQVMsMEJBQTBCLENBQUMsR0FBUTtJQUN4QyxPQUFPLEdBQUcsR0FBRyxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEdBQUcsR0FBRyxDQUFDLE1BQU0sRUFBRSxDQUFDO0FBQ3BELENBQUM7QUFFRCxTQUFTLGtCQUFrQixDQUFDLElBQVk7SUFDcEMsT0FBTyxJQUFJLFNBQUcsQ0FBQyxJQUFJLEVBQUUsNEJBQWdCLENBQUMsQ0FBQztBQUMzQyxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgTG9hZGVyQ29udGV4dCB9IGZyb20gXCIuL3V0aWxzL2xvYWRlci1jb250ZXh0XCI7XG5pbXBvcnQgeyBDaHVua0lPQmFzZSB9IGZyb20gJy4vdXRpbHMvY2h1bmstaW8vYmFzZSc7XG5pbXBvcnQgeyBhc3NlcnRzIH0gZnJvbSAnLi4vLi4vdXRpbHMvYXNzZXJ0cyc7XG5pbXBvcnQgeyBGc0xvY2F0b3IsIGlzUXVpY2tQYWNrVVJMLCBxdWlja1BhY2tSb290VVJMIH0gZnJvbSAnLi91dGlscy9jaHVuay11cmwnO1xuaW1wb3J0IHsgcGF0aFRvRmlsZVVSTCwgVVJMIH0gZnJvbSAndXJsJztcbmltcG9ydCBwcyBmcm9tICdwYXRoJztcbmltcG9ydCB7IENodW5rSWQgfSBmcm9tICcuL3V0aWxzL2NodW5rLWlkJztcbmltcG9ydCB7IENodW5rTVRpbWVzdGFtcCB9IGZyb20gJy4vdXRpbHMvY2h1bmsnO1xuaW1wb3J0IHsgaXNSZWxhdGl2ZVNwZWNpZmllciB9IGZyb20gJy4uL3V0aWxzL3NwZWNpZmllcic7XG5pbXBvcnQgeyB0cnlQYXJzZVVSTCB9IGZyb20gJy4uL3V0aWxzL3VybCc7XG5pbXBvcnQgeyBpMThuVHJhbnNsYXRlIH0gZnJvbSAnLi4vLi4vdXRpbHMvaTE4bic7XG5cbmludGVyZmFjZSBPcHRpb25zIHtcbiAgICBpbXBvcnRNYXBCYXNlZFJvb3Q6IHN0cmluZztcbn1cblxuZXhwb3J0IGNsYXNzIFJlc291cmNlTm90Rm91bmRFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihpZDogc3RyaW5nKSB7XG4gICAgICAgIHN1cGVyKGkxOG5UcmFuc2xhdGUoJ3F1aWNrX3BhY2tfbG9hZGVyX3Jlc291cmNlX25vdF9mb3VuZF9lcnJvcicsIHsgaWQgfSkpO1xuICAgIH1cbn1cblxuZXhwb3J0IGNsYXNzIFF1aWNrUGFja0xvYWRlciBleHRlbmRzIENodW5rSU9CYXNlIHtcbiAgICBwdWJsaWMgY29uc3RydWN0b3IoXG4gICAgICAgIGNvbnRleHQ6IExvYWRlckNvbnRleHQsXG4gICAgICAgIG9wdGlvbnM6IE9wdGlvbnMsXG4gICAgKSB7XG4gICAgICAgIHN1cGVyKHsgY2h1bmtSZWNvcmRGaWxlOiBjb250ZXh0LmNodW5rUmVjb3JkRmlsZSwgc291cmNlQ2FjaGVEaXI6IGNvbnRleHQuc291cmNlQ2FjaGVEaXIgfSk7XG4gICAgICAgIHRoaXMuX29yaWdpbiA9IGNvbnRleHQub3JpZ2luO1xuICAgICAgICB0aGlzLl9vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgY29uc3QgcmVhbEZzUm9vdCA9IHBhdGhUb0ZpbGVVUkwodGhpcy5fb3JpZ2luKS5wYXRobmFtZTtcbiAgICAgICAgdGhpcy5fZnNMb2NhdG9yID0gbmV3IEZzTG9jYXRvcihyZWFsRnNSb290KTtcbiAgICB9XG5cbiAgICBwdWJsaWMgYXN5bmMgZ2V0SW1wb3J0TWFwKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faW1wb3J0TWFwO1xuICAgIH1cblxuICAgIHB1YmxpYyBnZXRFbnRyaWVzKCk6IHJlYWRvbmx5IHN0cmluZ1tdIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2VudHJpZXM7XG4gICAgfVxuXG4gICAgcHVibGljIGFzeW5jIGdldFJlc291cmNlKGxpbms6IHN0cmluZyk6IFByb21pc2U8TW9kdWxlUmVzb3VyY2U+IHtcbiAgICAgICAgY29uc3QgcmVzb3VyY2VJZCA9IHRoaXMuZ2V0UmVzb3VyY2VJZChsaW5rKTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuZ2V0UmVzb3VyY2VGcm9tSWQocmVzb3VyY2VJZCk7XG4gICAgfVxuXG4gICAgcHVibGljIGdldFJlc291cmNlSWQobGluazogc3RyaW5nKSB7XG4gICAgICAgIGNvbnN0IG5vcm1hbGl6ZWRMaW5rID0gdGhpcy5fbm9ybWFsaXplTGluayhsaW5rKTtcbiAgICAgICAgY29uc3QgcXVpY2tQYWNrVVJMID0gbGlua1RvUXVpY2tQYWNrVVJMKG5vcm1hbGl6ZWRMaW5rKTtcbiAgICAgICAgY29uc3QgY2h1bmtJZCA9IHRoaXMuX2ZzTG9jYXRvci50b0NodW5rSWQocXVpY2tQYWNrVVJMKTtcbiAgICAgICAgcmV0dXJuIGNodW5rSWQ7XG4gICAgfVxuXG4gICAgcHVibGljIGFzeW5jIGdldFJlc291cmNlRnJvbUlkKHJlc291cmNlSWQ6IFJlc291cmNlSWQpIHtcbiAgICAgICAgbGV0IGNodW5rSWQ6IHN0cmluZztcbiAgICAgICAgbGV0IGlzTWFwOiBib29sZWFuO1xuICAgICAgICBpZiAocmVzb3VyY2VJZC5lbmRzV2l0aCgnLm1hcCcpKSB7XG4gICAgICAgICAgICBpc01hcCA9IHRydWU7XG4gICAgICAgICAgICBjaHVua0lkID0gcmVzb3VyY2VJZC5zdWJzdHIoMCwgcmVzb3VyY2VJZC5sZW5ndGggLSA0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlzTWFwID0gZmFsc2U7XG4gICAgICAgICAgICBjaHVua0lkID0gcmVzb3VyY2VJZDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjaHVuayA9IHRoaXMuX2NodW5rc1tjaHVua0lkXTtcbiAgICAgICAgaWYgKCFjaHVuaykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFJlc291cmNlTm90Rm91bmRFcnJvcihyZXNvdXJjZUlkKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwaHlzaWNhbExvY2F0aW9uID0gY2h1bmsucGh5c2ljYWxMb2NhdGlvbjtcbiAgICAgICAgY29uc3QgZmlsZSA9IHRoaXMuX2dldENodW5rU291cmNlRmlsZShwaHlzaWNhbExvY2F0aW9uKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6ICdmaWxlJyxcbiAgICAgICAgICAgIHBhdGg6IGlzTWFwID8gYCR7ZmlsZX0ubWFwYCA6IGZpbGUsXG4gICAgICAgIH0gYXMgY29uc3Q7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICog6I635Y+W5oyH5a6a6LWE5rqQ55qEIG10aW1lIOaXtumXtOaIs+OAguiLpeS4jeWtmOWcqOWImei/lOWbnui0n+WAvOOAglxuICAgICAqL1xuICAgIHB1YmxpYyBhc3luYyBnZXRSZXNvdXJjZU1UaW1lc3RhbXAocmVzb3VyY2U6IFJlc291cmNlSWQpOiBQcm9taXNlPFJlc291cmNlTVRpbWVzdGFtcD4ge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2h1bmtzW3RoaXMuX2dldENodW5rSWQocmVzb3VyY2UpXT8ubVRpbWVzdGFtcCA/PyAtMTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiDojrflj5bmjIflrprmiYDmnInotYTmupDnmoQgbXRpbWUg5pe26Ze05oiz44CC5LiN5a2Y5Zyo55qE6LWE5rqQ5bCG6L+U5Zue6LSf5YC844CCXG4gICAgICovXG4gICAgcHVibGljIGFzeW5jIGdldFJlc291cmNlTVRpbWVzdGFtcHMocmVzb3VyY2VzOiBSZXNvdXJjZUlkW10pOiBQcm9taXNlPFJlc291cmNlTVRpbWVzdGFtcFtdPiB7XG4gICAgICAgIHJldHVybiByZXNvdXJjZXMubWFwKChyZXNvdXJjZUlkKSA9PiB0aGlzLl9jaHVua3NbdGhpcy5fZ2V0Q2h1bmtJZChyZXNvdXJjZUlkKV0/Lm1UaW1lc3RhbXAgPz8gLTEpO1xuICAgIH1cblxuICAgIHB1YmxpYyBhc3luYyByZWxvYWQoKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuX2xvYWRDaHVua1JlY29yZCgpO1xuICAgICAgICAoe1xuICAgICAgICAgICAgaW1wb3J0TWFwOiB0aGlzLl9pbXBvcnRNYXAsXG4gICAgICAgICAgICBlbnRyaWVzOiB0aGlzLl9lbnRyaWVzLFxuICAgICAgICB9ID0gYXdhaXQgdGhpcy5fY3JlYXRlSW1wb3J0TWFwKHRoaXMuX29yaWdpbiwgdGhpcy5fb3B0aW9ucy5pbXBvcnRNYXBCYXNlZFJvb3QpKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIF9vcmlnaW46IHN0cmluZztcbiAgICBwcml2YXRlIF9vcHRpb25zOiBPcHRpb25zO1xuICAgIHByaXZhdGUgX2ZzTG9jYXRvcjogRnNMb2NhdG9yO1xuICAgIHByaXZhdGUgX2ltcG9ydE1hcDogSW1wb3J0TWFwID0ge307XG4gICAgcHJpdmF0ZSBfZW50cmllczogc3RyaW5nW10gPSBbXTtcblxuICAgIHByaXZhdGUgYXN5bmMgX2NyZWF0ZUltcG9ydE1hcChcbiAgICAgICAgb3JpZ2luOiBzdHJpbmcsXG4gICAgICAgIGltcG9ydE1hcEJhc2VkUm9vdDogc3RyaW5nLFxuICAgICkge1xuICAgICAgICBhc3NlcnRzKGltcG9ydE1hcEJhc2VkUm9vdC5lbmRzV2l0aCgnLycpKTtcblxuICAgICAgICBjb25zdCBmc0xvY2F0b3IgPSB0aGlzLl9mc0xvY2F0b3I7XG5cbiAgICAgICAgY29uc3QgZW50cmllczogc3RyaW5nW10gPSBbXTtcblxuICAgICAgICBjb25zdCBpbXBvcnRzOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+ID0ge307XG5cbiAgICAgICAgY29uc3Qgc2NvcGVzOiBOb25OdWxsYWJsZTxJbXBvcnRNYXBbJ3Njb3BlcyddPiA9IHt9O1xuXG4gICAgICAgIGNvbnN0IGdldEltcG9ydE1hcEJhc2VkVXJsID0gKHVybDogVVJMKSA9PiB7XG4gICAgICAgICAgICBpZiAoaXNRdWlja1BhY2tVUkwodXJsKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBgJHtpbXBvcnRNYXBCYXNlZFJvb3R9JHtxdWlja1BhY2tVUkxUb0V4dGVybmFsTGluayh1cmwpfWA7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIEFsbCBvdGhlciB1cmxzIGFyZSBub3QgaW1wb3J0IG1hcCBhcnJpdmVkLlxuICAgICAgICAgICAgICAgIHJldHVybiB1cmwuaHJlZjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBjb25zdCBub3JtYWxpemVTcGVjaWZpZXIgPSAoc3BlY2lmaWVyOiBzdHJpbmcsIGJhc2VVcmw6IFVSTCk6IHN0cmluZyB8IFVSTCB8IHVuZGVmaW5lZCA9PiB7XG4gICAgICAgICAgICAvLyBodHRwczovL3dpY2cuZ2l0aHViLmlvL2ltcG9ydC1tYXBzLyNyZXNvbHZlLWFuLWltcG9ydHMtbWF0Y2hcbiAgICAgICAgICAgIGlmIChpc1JlbGF0aXZlU3BlY2lmaWVyKHNwZWNpZmllcikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ5UGFyc2VVUkwoc3BlY2lmaWVyLCBiYXNlVXJsKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRyeVBhcnNlVVJMKHNwZWNpZmllcikgPz8gc3BlY2lmaWVyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IG9yaWdpbkRpclVybCA9IHBhdGhUb0ZpbGVVUkwoYCR7b3JpZ2lufSR7cHMuc2VwfWApO1xuICAgICAgICBjb25zdCBvcmlnaW5OcFVSTCA9IG5ldyBVUkwoZnNMb2NhdG9yLmdldE9yaWdpbigpLmhyZWYpO1xuICAgICAgICBpZiAoIW9yaWdpbk5wVVJMLnBhdGhuYW1lLmVuZHNXaXRoKCcvJykpIHtcbiAgICAgICAgICAgIG9yaWdpbk5wVVJMLnBhdGhuYW1lICs9ICcvJztcbiAgICAgICAgfVxuICAgICAgICBpbXBvcnRzW29yaWdpbkRpclVybC5ocmVmXSA9IGdldEltcG9ydE1hcEJhc2VkVXJsKG9yaWdpbk5wVVJMKTtcblxuICAgICAgICBjb25zdCB1cmxSZXNvbHZlczogUmVjb3JkPHN0cmluZywge1xuICAgICAgICAgICAgbm9ybWFsOiBib29sZWFuO1xuICAgICAgICAgICAgc3BlY2lhbFJlc29sdmVzPzogUmVjb3JkPHN0cmluZywgVVJMPjtcbiAgICAgICAgfT4gPSB7fTtcblxuICAgICAgICBmb3IgKGNvbnN0IFtjaHVua0lkLCBjaHVua10gb2YgT2JqZWN0LmVudHJpZXModGhpcy5fY2h1bmtzKSkge1xuICAgICAgICAgICAgY29uc3QgY2h1bmtVUkwgPSBmc0xvY2F0b3IudG9RdWlja1BhY2tVUkwoY2h1bmtJZCk7XG5cbiAgICAgICAgICAgIGNvbnN0IG15VXJsSW1wb3J0TWFwQmFzZWQgPSBnZXRJbXBvcnRNYXBCYXNlZFVybChjaHVua1VSTCk7XG4gICAgICAgICAgICBpZiAoY2h1bmsuaXNFbnRyeSkge1xuICAgICAgICAgICAgICAgIGVudHJpZXMucHVzaChteVVybEltcG9ydE1hcEJhc2VkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjaHVuay5leHBvc2VBcykge1xuICAgICAgICAgICAgICAgIGltcG9ydHNbY2h1bmsuZXhwb3NlQXNdID0gbXlVcmxJbXBvcnRNYXBCYXNlZDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3Qgc2NvcGVDdXJNb2QgPSBteVVybEltcG9ydE1hcEJhc2VkO1xuICAgICAgICAgICAgZm9yIChjb25zdCBbc3BlY2lmaWVyLCByZXNvbHZlZENodW5rSWRdIG9mIE9iamVjdC5lbnRyaWVzKGNodW5rLmltcG9ydHMpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzb2x2ZWRVcmwgPSBmc0xvY2F0b3IudG9RdWlja1BhY2tVUkwocmVzb2x2ZWRDaHVua0lkKTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IG5vcm1hbGl6ZWRTcGVjaWZpZXIgPSBub3JtYWxpemVTcGVjaWZpZXIoc3BlY2lmaWVyLCBjaHVua1VSTCk7XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIHNwZWNpZmllciBpcyBlcnJvbmVvdXMsIGNvbnRpbnVlLlxuICAgICAgICAgICAgICAgIC8vIE90aGVyd2lzZSwgdGhlIG5vcm1hbGl6ZWQgc3BlY2lmaWVyIGlzIGFuIFVSTCBvciBiYXJlIHNwZWNpZmllci5cbiAgICAgICAgICAgICAgICBpZiAoIW5vcm1hbGl6ZWRTcGVjaWZpZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY29uc3QgaXNOb3JtYWwgPSB0eXBlb2Ygbm9ybWFsaXplZFNwZWNpZmllciAhPT0gJ3N0cmluZycgJiZcbiAgICAgICAgICAgICAgICAgICAgbm9ybWFsaXplZFNwZWNpZmllci5ocmVmID09PSByZXNvbHZlZFVybC5ocmVmO1xuXG4gICAgICAgICAgICAgICAgY29uc3QgcmVzb2x2ZUtleSA9IHR5cGVvZiBub3JtYWxpemVkU3BlY2lmaWVyID09PSAnc3RyaW5nJ1xuICAgICAgICAgICAgICAgICAgICA/IG5vcm1hbGl6ZWRTcGVjaWZpZXJcbiAgICAgICAgICAgICAgICAgICAgOiBnZXRJbXBvcnRNYXBCYXNlZFVybChub3JtYWxpemVkU3BlY2lmaWVyKTtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNvbHZlcyA9IHVybFJlc29sdmVzW3Jlc29sdmVLZXldID8/PSB7IG5vcm1hbDogZmFsc2UgfTtcbiAgICAgICAgICAgICAgICBpZiAoaXNOb3JtYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZXMubm9ybWFsID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzcGVjaWFsUmVzb2x2ZXMgPSByZXNvbHZlcy5zcGVjaWFsUmVzb2x2ZXMgPz89IHt9O1xuICAgICAgICAgICAgICAgICAgICBzcGVjaWFsUmVzb2x2ZXNbc2NvcGVDdXJNb2RdID0gcmVzb2x2ZWRVcmw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgc2NvcGVUaGlzID0gc2NvcGVzW2dldEltcG9ydE1hcEJhc2VkVXJsKHF1aWNrUGFja1Jvb3RVUkwpXSA9IHt9IGFzIFJlY29yZDxzdHJpbmcsIHN0cmluZz47XG5cbiAgICAgICAgZm9yIChjb25zdCBbc3BlY2lmaWVyLCB7IG5vcm1hbCwgc3BlY2lhbFJlc29sdmVzIH1dIG9mIE9iamVjdC5lbnRyaWVzKHVybFJlc29sdmVzKSkge1xuICAgICAgICAgICAgaWYgKCFzcGVjaWFsUmVzb2x2ZXMpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGVyZSBpcyBubyBzcGVjaWFsIG1hdGNoLCBkbyBub3RoaW5nXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobm9ybWFsKSB7XG4gICAgICAgICAgICAgICAgc2NvcGVUaGlzW3NwZWNpZmllcl0gPSBzcGVjaWZpZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBhbGxSZXNvbHZlcyA9IE9iamVjdC5lbnRyaWVzKHNwZWNpYWxSZXNvbHZlcyk7XG4gICAgICAgICAgICBpZiAoIW5vcm1hbCAmJiBhbGxSZXNvbHZlcy5ldmVyeSgoWywgcmVzb2x2ZWRdLCBfaW5kZXgsIFtbLCBmaXJzdFJlc29sdmVkXV0pID0+IHJlc29sdmVkLmhyZWYgPT09IGZpcnN0UmVzb2x2ZWQuaHJlZikpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBbLCByZXNvbHZlZF0gPSBhbGxSZXNvbHZlc1swXTtcbiAgICAgICAgICAgICAgICBzY29wZVRoaXNbc3BlY2lmaWVyXSA9IGdldEltcG9ydE1hcEJhc2VkVXJsKHJlc29sdmVkKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBbaW1wb3J0ZXIsIHJlc29sdmVkXSBvZiBhbGxSZXNvbHZlcykge1xuICAgICAgICAgICAgICAgICAgICAoc2NvcGVzW2ltcG9ydGVyXSA/Pz0ge30pW3NwZWNpZmllcl0gPSBnZXRJbXBvcnRNYXBCYXNlZFVybChyZXNvbHZlZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgc29ydE9iamVjdCA9IDxUPihvOiBSZWNvcmQ8c3RyaW5nLCBUPiwgZm4gPSAodjogVCkgPT4gdikgPT5cbiAgICAgICAgICAgIE9iamVjdC5rZXlzKG8pLnNvcnQoKS5yZWR1Y2UoKHIsIGspID0+IChyW2tdID0gZm4ob1trXSksIHIpLCB7fSBhcyBSZWNvcmQ8c3RyaW5nLCBUPik7XG5cbiAgICAgICAgY29uc3QgaW1wb3J0TWFwOiBJbXBvcnRNYXAgPSB7XG4gICAgICAgICAgICBpbXBvcnRzOiBzb3J0T2JqZWN0KGltcG9ydHMpLFxuICAgICAgICAgICAgc2NvcGVzOiBzb3J0T2JqZWN0KHNjb3BlcywgKG1hcCkgPT4gc29ydE9iamVjdChtYXApKSxcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZW50cmllcyxcbiAgICAgICAgICAgIGltcG9ydE1hcCxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBwcml2YXRlIF9ub3JtYWxpemVMaW5rKGxpbms6IHN0cmluZykge1xuICAgICAgICByZXR1cm4gbGluay5zdGFydHNXaXRoKCcvJykgPyBsaW5rIDogYC8ke2xpbmt9YDtcbiAgICB9XG5cbiAgICBwcml2YXRlIF9nZXRDaHVua0lkKHJlc291cmNlSWQ6IHN0cmluZyk6IENodW5rSWQge1xuICAgICAgICByZXR1cm4gcmVzb3VyY2VJZC5lbmRzV2l0aCgnLm1hcCcpXG4gICAgICAgICAgICA/IHJlc291cmNlSWQuc3Vic3RyKDAsIHJlc291cmNlSWQubGVuZ3RoIC0gNClcbiAgICAgICAgICAgIDogcmVzb3VyY2VJZDtcbiAgICB9XG59XG5cbmV4cG9ydCB7IExvYWRlckNvbnRleHQgYXMgUXVpY2tQYWNrTG9hZGVyQ29udGV4dCB9O1xuXG5leHBvcnQgdHlwZSBSZXNvdXJjZUlkID0gc3RyaW5nO1xuXG5leHBvcnQgdHlwZSBSZXNvdXJjZU1UaW1lc3RhbXAgPSBDaHVua01UaW1lc3RhbXA7XG5cbmV4cG9ydCBpbnRlcmZhY2UgTW9kdWxlUmVzb3VyY2Uge1xuICAgIHR5cGU6ICdmaWxlJztcbiAgICBwYXRoOiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSW1wb3J0TWFwIHtcbiAgICBpbXBvcnRzPzogUmVjb3JkPHN0cmluZywgc3RyaW5nPjtcbiAgICBzY29wZXM/OiBSZWNvcmQ8c3RyaW5nLCBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+Pjtcbn1cblxuZnVuY3Rpb24gcXVpY2tQYWNrVVJMVG9FeHRlcm5hbExpbmsodXJsOiBVUkwpIHtcbiAgICByZXR1cm4gYCR7dXJsLnBhdGhuYW1lLnN1YnN0cigxKX0ke3VybC5zZWFyY2h9YDtcbn1cblxuZnVuY3Rpb24gbGlua1RvUXVpY2tQYWNrVVJMKGxpbms6IHN0cmluZykge1xuICAgIHJldHVybiBuZXcgVVJMKGxpbmssIHF1aWNrUGFja1Jvb3RVUkwpO1xufVxuIl19