"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.QuickPack = void 0;
const path_1 = __importDefault(require("path"));
const fs_extra_1 = __importDefault(require("fs-extra"));
const url_1 = require("url");
const writer_1 = require("./utils/chunk-io/writer");
const loader_context_1 = require("./utils/loader-context");
const url_2 = require("../utils/url");
const logger_1 = require("../utils/logger");
const babel = __importStar(require("@babel/core"));
// @ts-expect-error
const plugin_transform_modules_systemjs_1 = __importDefault(require("@babel/plugin-transform-modules-systemjs"));
// @ts-expect-error
const plugin_proposal_dynamic_import_1 = __importDefault(require("@babel/plugin-proposal-dynamic-import"));
const asserts_1 = require("../../utils/asserts");
const detect_imports_1 = require("./utils/detect-imports");
const launch_policy_1 = require("../utils/launch-policy");
const i18n_1 = require("../../utils/i18n");
const specifier_1 = require("../utils/specifier");
const getLauncher = (par) => par ? launch_policy_1.parallelDiscarding : launch_policy_1.sequenceDiscarding;
const resolveLauncher = getLauncher(true);
class QuickPack {
    constructor({ modLo, sourceMaps, origin, workspace, verbose, logger, }) {
        this._moduleRecords = {};
        this._extensionMapping = [
            ['.ts', '.js'],
            ['.mjs', '.js'],
        ];
        this._verbose = verbose !== null && verbose !== void 0 ? verbose : false;
        this._origin = origin;
        this._modLo = modLo;
        this._sourceMaps = sourceMaps !== null && sourceMaps !== void 0 ? sourceMaps : true;
        this._moduleRecordFile = path_1.default.join(workspace, 'modules.json');
        this._chunkRecordFile = path_1.default.join(workspace, 'chunks.json');
        this._sourceCacheDir = path_1.default.join(workspace, 'mods');
        const importMapFile = path_1.default.join(workspace, 'import-map.json');
        this._importMapFile = importMapFile;
        const theLogger = logger !== null && logger !== void 0 ? logger : logger_1.createLogger({});
        this._chunkWriter = new writer_1.ChunkWriter({
            origin,
            chunkRecordFile: this._chunkRecordFile,
            sourceCacheDir: this._sourceCacheDir,
            importMapFile,
            logger: theLogger,
        });
        this._logger = theLogger;
    }
    async build(specifiers, options) {
        var _a;
        const context = {
            modules: new Map(),
            retryResolutionOnUnchangedModule: (_a = options === null || options === void 0 ? void 0 : options.retryResolutionOnUnchangedModule) !== null && _a !== void 0 ? _a : false,
        };
        const entryModuleRecords = [];
        for (const specifier of specifiers) {
            const url = typeof specifier === 'string'
                ? await this._resolveEntry(specifier)
                : specifier;
            if (!url) {
                continue;
            }
            const inspectRecord = await this._getOrCreateInspectRecord(url, context);
            await this._instantiateAll(inspectRecord, new Set());
            const moduleRecord = this._moduleRecords[url.href];
            if (!moduleRecord) {
                this._logger.debug(`Entry ${url} did not library a chunk.`);
                continue;
            }
            entryModuleRecords.push([url, moduleRecord]);
            const chunk = await this._chunkWriter.getChunk(moduleRecord.chunkId);
            asserts_1.asserts(chunk);
            chunk.isEntry = true;
            chunk.exposeAs = url.href;
        }
        await fs_extra_1.default.outputJson(this._moduleRecordFile, this._moduleRecords, { encoding: 'utf8', spaces: 2 });
        const chunkAlias = {};
        for (const [entryURL, entryModuleRecord] of entryModuleRecords) {
            const chunkId = entryModuleRecord.chunkId;
            chunkAlias[entryURL.href] = chunkId;
        }
        await this._chunkWriter.syncChunk(chunkAlias);
    }
    async createLoaderContext() {
        return new loader_context_1.LoaderContext(this._origin, this._chunkRecordFile, this._sourceCacheDir, this._importMapFile);
    }
    async clear() {
        this._moduleRecords = {};
        const moduleRecordFile = this._moduleRecordFile;
        try {
            await fs_extra_1.default.unlink(moduleRecordFile);
        }
        catch (err) {
            this._logger.debug(`Failed to delete module record file ${moduleRecordFile}: ${err}`);
        }
        await this._chunkWriter.clear();
    }
    async loadCache() {
        try {
            const serializedModuleRecords = await fs_extra_1.default.readJson(this._moduleRecordFile);
            for (const moduleRecord of Object.values(serializedModuleRecords)) {
                if (moduleRecord.resolvedImports) {
                    for (const resolveResult of moduleRecord.resolvedImports) {
                        if (resolveResult && !resolveResult.isExternal) {
                            resolveResult.url = new url_1.URL(resolveResult.url);
                        }
                    }
                }
            }
            this._moduleRecords = serializedModuleRecords;
        }
        catch (err) {
            this._logger.debug(`Module record file loaded failed with error: ${err}`);
        }
        await this._chunkWriter.loadCache();
    }
    async _resolveEntry(specifier) {
        try {
            return new url_1.URL(specifier);
        }
        catch (err) {
            this._logger.error(i18n_1.i18nTranslate('quick_pack_could_not_resolve_entry', { specifier }));
            return;
        }
    }
    async _getOrCreateInspectRecord(url, context) {
        const existedInspectRecord = context.modules.get(url.href);
        if (existedInspectRecord) {
            return existedInspectRecord;
        }
        // eslint-disable-next-line prefer-const
        let inspectRecord;
        const inspectPromise = this._inspectWithCache(url);
        const linkPromise = inspectPromise.then(async (moduleInspectInfo) => {
            if (moduleInspectInfo) {
                const dependencies = await this._link(url, moduleInspectInfo.moduleRecord, context);
                inspectRecord.dependencies = dependencies;
            }
        });
        inspectRecord = {
            inspect: inspectPromise,
            link: linkPromise,
            dependencies: undefined,
        };
        context.modules.set(url.href, inspectRecord);
        return inspectRecord;
    }
    async _instantiateAll(inspectRecord, visited) {
        if (visited.has(inspectRecord)) {
            return;
        }
        visited.add(inspectRecord);
        await inspectRecord.link;
        if (inspectRecord.dependencies) {
            await Promise.all(inspectRecord.dependencies.map(async (dependency) => {
                if (dependency) {
                    await this._instantiateAll(dependency, visited);
                }
            }));
        }
    }
    async _inspectWithCache(url) {
        const mTimestamp = await this._modLo.getMTimestamp(url);
        const oldModuleRecord = this._moduleRecords[url.href];
        if (oldModuleRecord) {
            if (mTimestamp === oldModuleRecord.mTimestamp) {
                return { moduleRecord: oldModuleRecord, updated: false };
            }
            this._logger.debug(`Detected change: ${url}. Last mtime: ${new Date(oldModuleRecord.mTimestamp)}, Current mtime: ${new Date(mTimestamp)}`);
            this._moduleRecords[url.href] = null;
            await this._chunkWriter.removeChunk(oldModuleRecord.chunkId);
        }
        if (this._verbose) {
            this._logger.debug(`Inspect ${url}`);
        }
        const moduleRecord = await this._inspect(url, mTimestamp).catch((err) => {
            this._logger.error(err);
        });
        if (!moduleRecord) {
            // Module record is invalid or cache is valid
            return undefined;
        }
        return { moduleRecord, updated: true };
    }
    async _link(url, moduleRecord, context) {
        const chunkImports = {};
        let forceResolve = false;
        if (!moduleRecord.resolvedImports) {
            forceResolve = true;
            moduleRecord.resolvedImports = new Array(moduleRecord.imports.length).fill(null);
        }
        const resolvedImports = moduleRecord.resolvedImports;
        const depRecords = await Promise.all(moduleRecord.imports.map(async (specifier, iImport) => {
            var _a, _b;
            let resolved = resolvedImports[iImport];
            if (forceResolve || // Not resolved before
                resolved === null && context.retryResolutionOnUnchangedModule // Resolved but failed
            ) {
                resolved = await this._resolve(specifier, url, moduleRecord.modLoMetadata);
                resolvedImports[iImport] = resolved;
            }
            if (!resolved) {
                return;
            }
            const chunkImportKey = (_a = specifier.rewritten) !== null && _a !== void 0 ? _a : specifier.value;
            if (resolved.isExternal) {
                const isResolvedToBare = !url_2.tryParseURL(resolved.specifierOrURL);
                if (isResolvedToBare) {
                    // Only bare specifier may resolved to bare
                    asserts_1.asserts(!specifier.rewritten, `Something wrong with rewriting and resolve ${specifier.value}`);
                    return;
                }
                chunkImports[chunkImportKey] = {
                    external: true,
                    url: resolved.specifierOrURL,
                };
                return;
            }
            const { url: resolvedURL } = resolved;
            const inspectRecord = await this._getOrCreateInspectRecord(resolvedURL, context);
            await inspectRecord.inspect;
            const resolvedChunk = (_b = this._moduleRecords[resolvedURL.href]) === null || _b === void 0 ? void 0 : _b.chunkId;
            if (resolvedChunk) {
                chunkImports[chunkImportKey] = resolvedChunk;
            }
            else {
                this._logger.debug(`We're missing the chunk ${resolvedURL.href}, referenced as '${specifier}'.`);
            }
            return inspectRecord;
        }));
        const chunk = await this._chunkWriter.getChunk(moduleRecord.chunkId);
        asserts_1.asserts(chunk);
        chunk.imports = chunkImports;
        return depRecords;
    }
    async _inspect(url, mTimestamp) {
        let mod;
        try {
            mod = await this._modLo.load(url);
        }
        catch (err) {
            this._logger.error(i18n_1.i18nTranslate('quick_pack_failed_to_load', { url: url.href, cause: err }));
            if (url.protocol === 'node:') {
                this._logger.warn(i18n_1.i18nTranslate('load_error_hint_node_builtin'));
            }
            return;
        }
        const { originalSource, code, modLoMetadata, } = mod;
        let { map, } = mod;
        let ast;
        if (typeof code === 'string') {
            // TODO: input source map
            ast = await this._modLo.parse(code, map);
        }
        else {
            ast = code;
        }
        const chunkURL = this._getChunkURL(url);
        const chunkId = this._chunkWriter.getChunkId(chunkURL);
        let specifiers = [];
        ({ transformResult: { ast, map }, specifiers } = await this._rewriteImports(url, ast, typeof map === 'string' ? JSON.parse(map) : map !== null && map !== void 0 ? map : undefined, originalSource));
        await this._transformAndAdd(chunkId, url, ast, typeof map === 'string' ? JSON.parse(map) : map !== null && map !== void 0 ? map : undefined, originalSource);
        const moduleRecord = {
            mTimestamp,
            chunkId,
            imports: specifiers,
            modLoMetadata,
        };
        this._moduleRecords[url.href] = moduleRecord;
        return moduleRecord;
    }
    async _transformAndAdd(chunkId, url, ast, map, originalSource) {
        const transformed = await this._transform(url, ast, map, originalSource);
        await this._chunkWriter.addChunk(chunkId, transformed.code, transformed.map);
    }
    async _rewriteImports(url, ast, map, originalSource) {
        var _a;
        const specifiers = [];
        let nSpecifier = 0;
        const transformResult = await babel.transformFromAstAsync(ast, originalSource, {
            ast: true,
            code: false,
            sourceFileName: url.href,
            cloneInputAst: false,
            configFile: false,
            sourceType: 'module',
            sourceMaps: this._sourceMaps,
            inputSourceMap: map,
            plugins: [
                [detect_imports_1.createBabelPluginDetectAndRewriteImports({
                        specifiers,
                        rewrite: (specifier) => {
                            if (specifier_1.isBareSpecifier(specifier)) {
                                // If it's bare specifier, we do not rewrite it.
                                return undefined;
                            }
                            const rewritten = `__unresolved_${nSpecifier}`;
                            ++nSpecifier;
                            return rewritten;
                        },
                    })],
            ],
        });
        asserts_1.asserts(transformResult);
        asserts_1.asserts(transformResult.ast);
        return {
            transformResult: {
                ast: transformResult.ast,
                map: (_a = transformResult.map) !== null && _a !== void 0 ? _a : undefined,
            },
            specifiers,
        };
    }
    async _transform(url, ast, map, originalSource) {
        const babelResult = await babel.transformFromAstAsync(ast, originalSource, {
            sourceFileName: url.href,
            // cloneInputAst: false,
            configFile: false,
            sourceType: 'module',
            sourceMaps: this._sourceMaps,
            inputSourceMap: map,
            plugins: [
                [plugin_transform_modules_systemjs_1.default],
                // Dynamic import() transformation must be enabled using the
                // @babel/plugin-proposal-dynamic-import plugin. Babel 8 will
                // no longer transform import() without using that plugin.
                [plugin_proposal_dynamic_import_1.default],
            ],
        });
        asserts_1.asserts(babelResult);
        asserts_1.asserts(babelResult.code);
        return {
            code: babelResult.code,
            map: babelResult.map,
        };
    }
    async _resolve(specifier, parentURL, modLoMetadata) {
        const specifierValue = specifier.value;
        try {
            const resolved = await this._modLo.resolve(specifierValue, parentURL, modLoMetadata);
            if (this._verbose) {
                if (resolved.isExternal) {
                    this._logger.debug(`Resolve ${specifierValue} from ${parentURL.href} as external dependency ${resolved.specifierOrURL}.`);
                }
                else {
                    this._logger.debug(`Resolve ${specifierValue} from ${parentURL.href} as ${resolved.url}.`);
                }
            }
            return resolved;
        }
        catch (err) {
            this._logger.error(i18n_1.i18nTranslate('quick_pack_failed_to_resolve', { specifier: specifierValue, parentURL: parentURL.href, cause: err }));
            if (specifierValue.includes('/')) {
                const lastPortion = specifierValue.split('/').pop();
                if (lastPortion && !lastPortion.includes('.')) {
                    this._logger.warn(i18n_1.i18nTranslate('resolve_error_hint_extension'));
                }
            }
            return null;
        }
    }
    /**
     * Map the module URL to chunk URL.
     * @param url
     */
    _getChunkURL(_url) {
        // TODO: do it better
        let url;
        if (!_url.search) {
            url = _url;
        }
        else {
            const u = new url_1.URL(_url.href);
            const extensionName = url_2.parseExtensionName(u.pathname);
            url_2.replaceExtension(u, `.proxy${extensionName}`);
            url = u;
        }
        // 见：https://gist.github.com/shrinktofit/50f2380782b6219ed6a4cb3a210a75f7
        for (const [from, to] of this._extensionMapping) {
            if (url.pathname.endsWith(from)) {
                return url_2.assignPathname(new url_1.URL(url.href), `${url.pathname.substr(0, url.pathname.length - from.length)}${to}`);
            }
        }
        if (!url_2.parseExtensionName(url.pathname)) {
            // URLs with no extension are store as .js
            return url_2.assignPathname(new url_1.URL(url.href), `${url.pathname}.js`);
        }
        return url;
    }
}
exports.QuickPack = QuickPack;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicXVpY2stcGFjay5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9tb2QtYXNzZW1ibGluZy9xdWljay1wYWNrL3F1aWNrLXBhY2sudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLGdEQUFzQjtBQUN0Qix3REFBMEI7QUFDMUIsNkJBQXlDO0FBR3pDLG9EQUFzRDtBQUV0RCwyREFBdUQ7QUFDdkQsc0NBQWlHO0FBQ2pHLDRDQUF1RDtBQUN2RCxtREFBcUM7QUFDckMsbUJBQW1CO0FBQ25CLGlIQUFvRjtBQUNwRixtQkFBbUI7QUFDbkIsMkdBQXFGO0FBQ3JGLGlEQUE4QztBQUM5QywyREFBNEc7QUFDNUcsMERBQWdGO0FBRWhGLDJDQUFpRDtBQUVqRCxrREFBcUQ7QUFFckQsTUFBTSxXQUFXLEdBQUcsQ0FBQyxHQUFZLEVBQUUsRUFBRSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsa0NBQWtCLENBQUMsQ0FBQyxDQUFDLGtDQUFrQixDQUFDO0FBRXBGLE1BQU0sZUFBZSxHQUFHLFdBQVcsQ0FBQyxJQUFJLENBQUMsQ0FBQztBQUUxQyxNQUFhLFNBQVM7SUFDbEIsWUFBWSxFQUNSLEtBQUssRUFDTCxVQUFVLEVBQ1YsTUFBTSxFQUNOLFNBQVMsRUFDVCxPQUFPLEVBQ1AsTUFBTSxHQVFUO1FBMEdPLG1CQUFjLEdBQXdDLEVBQUUsQ0FBQztRQUV6RCxzQkFBaUIsR0FBNEI7WUFDakQsQ0FBQyxLQUFLLEVBQUUsS0FBSyxDQUFDO1lBQ2QsQ0FBQyxNQUFNLEVBQUUsS0FBSyxDQUFDO1NBQ2xCLENBQUM7UUE5R0UsSUFBSSxDQUFDLFFBQVEsR0FBRyxPQUFPLGFBQVAsT0FBTyxjQUFQLE9BQU8sR0FBSSxLQUFLLENBQUM7UUFDakMsSUFBSSxDQUFDLE9BQU8sR0FBRyxNQUFNLENBQUM7UUFDdEIsSUFBSSxDQUFDLE1BQU0sR0FBRyxLQUFLLENBQUM7UUFDcEIsSUFBSSxDQUFDLFdB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Q3pFLEtBQUssTUFBTSxDQUFDLElBQUksRUFBRSxFQUFFLENBQUMsSUFBSSxJQUFJLENBQUMsaUJBQWlCLEVBQUU7WUFDN0MsSUFBSSxHQUFHLENBQUMsUUFBUSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsRUFBRTtnQkFDN0IsT0FBTyxvQkFBYyxDQUNqQixJQUFJLFNBQUcsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLEVBQ2pCLEdBQUcsR0FBRyxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsQ0FBQyxFQUFFLEdBQUcsQ0FBQyxRQUFRLENBQUMsTUFBTSxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsR0FBRyxFQUFFLEVBQUUsQ0FDdEUsQ0FBQzthQUNMO1NBQ0o7UUFDRCxJQUFJLENBQUMsd0JBQWtCLENBQUMsR0FBRyxDQUFDLFFBQVEsQ0FBQyxFQUFFO1lBQ25DLDBDQUEwQztZQUMxQyxPQUFPLG9CQUFjLENBQ2pCLElBQUksU0FBRyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsRUFDakIsR0FBRyxHQUFHLENBQUMsUUFBUSxLQUFLLENBQ3ZCLENBQUM7U0FDTDtRQUNELE9BQU8sR0FBRyxDQUFDO0lBQ2YsQ0FBQztDQUNKO0FBNWRELDhCQTRkQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBwcyBmcm9tICdwYXRoJztcclxuaW1wb3J0IGZzIGZyb20gJ2ZzLWV4dHJhJztcclxuaW1wb3J0IHsgcGF0aFRvRmlsZVVSTCwgVVJMIH0gZnJvbSAndXJsJztcclxuaW1wb3J0IHsgTW9kTG9NZXRhZGF0YSwgTW9kTG8sIFJlc29sdmVSZXN1bHQsIFNvdXJjZSwgQXN0LCBTb3VyY2VNYXAsIE1vZCB9IGZyb20gJy4uL21vZC1sby9tb2QtbG8nO1xyXG5pbXBvcnQgeyBNb2R1bGVSZWNvcmQgfSBmcm9tICcuL3V0aWxzL21vZC1yZWNvcmQnO1xyXG5pbXBvcnQgeyBDaHVua1dyaXRlciB9IGZyb20gJy4vdXRpbHMvY2h1bmstaW8vd3JpdGVyJztcclxuaW1wb3J0IHsgQ2h1bmtJZCB9IGZyb20gJy4vdXRpbHMvY2h1bmstaWQnO1xyXG5pbXBvcnQgeyBMb2FkZXJDb250ZXh0IH0gZnJvbSAnLi91dGlscy9sb2FkZXItY29udGV4dCc7XHJcbmltcG9ydCB7IGFzc2lnblBhdGhuYW1lLCBwYXJzZUV4dGVuc2lvbk5hbWUsIHJlcGxhY2VFeHRlbnNpb24sIHRyeVBhcnNlVVJMIH0gZnJvbSAnLi4vdXRpbHMvdXJsJztcclxuaW1wb3J0IHsgY3JlYXRlTG9nZ2VyLCBMb2dnZXIgfSBmcm9tICcuLi91dGlscy9sb2dnZXInO1xyXG5pbXBvcnQgKiBhcyBiYWJlbCBmcm9tICdAYmFiZWwvY29yZSc7XHJcbi8vIEB0cy1leHBlY3QtZXJyb3JcclxuaW1wb3J0IGJhYmVsUGx1Z2luVHJhbnNmb3JtU3lzdGVtSnMgZnJvbSAnQGJhYmVsL3BsdWdpbi10cmFuc2Zvcm0tbW9kdWxlcy1zeXN0ZW1qcyc7XHJcbi8vIEB0cy1leHBlY3QtZXJyb3JcclxuaW1wb3J0IGJhYmVsUGx1Z2luUHJvcG9zYWxEeW5hbWljSW1wb3J0IGZyb20gJ0BiYWJlbC9wbHVnaW4tcHJvcG9zYWwtZHluYW1pYy1pbXBvcnQnO1xyXG5pbXBvcnQgeyBhc3NlcnRzIH0gZnJvbSAnLi4vLi4vdXRpbHMvYXNzZXJ0cyc7XHJcbmltcG9ydCB7IGNyZWF0ZUJhYmVsUGx1Z2luRGV0ZWN0QW5kUmV3cml0ZUltcG9ydHMsIGRldGVjdEltcG9ydHMsIFNwZWNpZmllciB9IGZyb20gJy4vdXRpbHMvZGV0ZWN0LWltcG9ydHMnO1xyXG5pbXBvcnQgeyBwYXJhbGxlbERpc2NhcmRpbmcsIHNlcXVlbmNlRGlzY2FyZGluZyB9IGZyb20gJy4uL3V0aWxzL2xhdW5jaC1wb2xpY3knO1xyXG5pbXBvcnQgeyBSYXdTb3VyY2VNYXAgfSBmcm9tICdzb3VyY2UtbWFwJztcclxuaW1wb3J0IHsgaTE4blRyYW5zbGF0ZSB9IGZyb20gJy4uLy4uL3V0aWxzL2kxOG4nO1xyXG5pbXBvcnQgeyBDaHVuayB9IGZyb20gJy4vdXRpbHMvY2h1bmsnO1xyXG5pbXBvcnQgeyBpc0JhcmVTcGVjaWZpZXIgfSBmcm9tICcuLi91dGlscy9zcGVjaWZpZXInO1xyXG5cclxuY29uc3QgZ2V0TGF1bmNoZXIgPSAocGFyOiBib29sZWFuKSA9PiBwYXIgPyBwYXJhbGxlbERpc2NhcmRpbmcgOiBzZXF1ZW5jZURpc2NhcmRpbmc7XHJcblxyXG5jb25zdCByZXNvbHZlTGF1bmNoZXIgPSBnZXRMYXVuY2hlcih0cnVlKTtcclxuXHJcbmV4cG9ydCBjbGFzcyBRdWlja1BhY2sge1xyXG4gICAgY29uc3RydWN0b3Ioe1xyXG4gICAgICAgIG1vZExvLFxyXG4gICAgICAgIHNvdXJjZU1hcHMsXHJcbiAgICAgICAgb3JpZ2luLFxyXG4gICAgICAgIHdvcmtzcGFjZSxcclxuICAgICAgICB2ZXJib3NlLFxyXG4gICAgICAgIGxvZ2dlcixcclxuICAgIH06IHtcclxuICAgICAgICBtb2RMbzogTW9kTG87XHJcbiAgICAgICAgc291cmNlTWFwcz86IGJvb2xlYW4gfCAnaW5saW5lJztcclxuICAgICAgICBvcmlnaW46IHN0cmluZztcclxuICAgICAgICB3b3Jrc3BhY2U6IHN0cmluZztcclxuICAgICAgICB2ZXJib3NlPzogYm9vbGVhbjtcclxuICAgICAgICBsb2dnZXI/OiBMb2dnZXI7XHJcbiAgICB9KSB7XHJcbiAgICAgICAgdGhpcy5fdmVyYm9zZSA9IHZlcmJvc2UgPz8gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5fb3JpZ2luID0gb3JpZ2luO1xyXG4gICAgICAgIHRoaXMuX21vZExvID0gbW9kTG87XHJcbiAgICAgICAgdGhpcy5fc291cmNlTWFwcyA9IHNvdXJjZU1hcHMgPz8gdHJ1ZTtcclxuICAgICAgICB0aGlzLl9tb2R1bGVSZWNvcmRGaWxlID0gcHMuam9pbih3b3Jrc3BhY2UsICdtb2R1bGVzLmpzb24nKTtcclxuICAgICAgICB0aGlzLl9jaHVua1JlY29yZEZpbGUgPSBwcy5qb2luKHdvcmtzcGFjZSwgJ2NodW5rcy5qc29uJyk7XHJcbiAgICAgICAgdGhpcy5fc291cmNlQ2FjaGVEaXIgPSBwcy5qb2luKHdvcmtzcGFjZSwgJ21vZHMnKTtcclxuICAgICAgICBjb25zdCBpbXBvcnRNYXBGaWxlID0gcHMuam9pbih3b3Jrc3BhY2UsICdpbXBvcnQtbWFwLmpzb24nKTtcclxuICAgICAgICB0aGlzLl9pbXBvcnRNYXBGaWxlID0gaW1wb3J0TWFwRmlsZTtcclxuICAgICAgICBjb25zdCB0aGVMb2dnZXIgPSBsb2dnZXIgPz8gY3JlYXRlTG9nZ2VyKHt9KTtcclxuICAgICAgICB0aGlzLl9jaHVua1dyaXRlciA9IG5ldyBDaHVua1dyaXRlcih7XHJcbiAgICAgICAgICAgIG9yaWdpbixcclxuICAgICAgICAgICAgY2h1bmtSZWNvcmRGaWxlOiB0aGlzLl9jaHVua1JlY29yZEZpbGUsXHJcbiAgICAgICAgICAgIHNvdXJjZUNhY2hlRGlyOiB0aGlzLl9zb3VyY2VDYWNoZURpcixcclxuICAgICAgICAgICAgaW1wb3J0TWFwRmlsZSxcclxuICAgICAgICAgICAgbG9nZ2VyOiB0aGVMb2dnZXIsXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5fbG9nZ2VyID0gdGhlTG9nZ2VyO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBhc3luYyBidWlsZChzcGVjaWZpZXJzOiBJdGVyYWJsZTxzdHJpbmcgfCBVUkw+LCBvcHRpb25zPzoge1xyXG4gICAgICAgIHJldHJ5UmVzb2x1dGlvbk9uVW5jaGFuZ2VkTW9kdWxlPzogYm9vbGVhbjtcclxuICAgIH0pIHtcclxuICAgICAgICBjb25zdCBjb250ZXh0OiBJbnNwZWN0Q29udGV4dCA9IHtcclxuICAgICAgICAgICAgbW9kdWxlczogbmV3IE1hcCgpLFxyXG4gICAgICAgICAgICByZXRyeVJlc29sdXRpb25PblVuY2hhbmdlZE1vZHVsZTogb3B0aW9ucz8ucmV0cnlSZXNvbHV0aW9uT25VbmNoYW5nZWRNb2R1bGUgPz8gZmFsc2UsXHJcbiAgICAgICAgfTtcclxuICAgICAgICBjb25zdCBlbnRyeU1vZHVsZVJlY29yZHM6IEFycmF5PFtVUkwsIE1vZHVsZVJlY29yZF0+ID0gW107XHJcbiAgICAgICAgZm9yIChjb25zdCBzcGVjaWZpZXIgb2Ygc3BlY2lmaWVycykge1xyXG4gICAgICAgICAgICBjb25zdCB1cmwgPSB0eXBlb2Ygc3BlY2lmaWVyID09PSAnc3RyaW5nJ1xyXG4gICAgICAgICAgICAgICAgPyBhd2FpdCB0aGlzLl9yZXNvbHZlRW50cnkoc3BlY2lmaWVyKVxyXG4gICAgICAgICAgICAgICAgOiBzcGVjaWZpZXI7XHJcbiAgICAgICAgICAgIGlmICghdXJsKSB7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBpbnNwZWN0UmVjb3JkID0gYXdhaXQgdGhpcy5fZ2V0T3JDcmVhdGVJbnNwZWN0UmVjb3JkKHVybCwgY29udGV4dCk7XHJcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX2luc3RhbnRpYXRlQWxsKGluc3BlY3RSZWNvcmQsIG5ldyBTZXQoKSk7XHJcbiAgICAgICAgICAgIGNvbnN0IG1vZHVsZVJlY29yZCA9IHRoaXMuX21vZHVsZVJlY29yZHNbdXJsLmhyZWZdO1xyXG4gICAgICAgICAgICBpZiAoIW1vZHVsZVJlY29yZCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbG9nZ2VyLmRlYnVnKGBFbnRyeSAke3VybH0gZGlkIG5vdCBsaWJyYXJ5IGEgY2h1bmsuYCk7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbnRyeU1vZHVsZVJlY29yZHMucHVzaChbdXJsLCBtb2R1bGVSZWNvcmRdKTtcclxuICAgICAgICAgICAgY29uc3QgY2h1bmsgPSBhd2FpdCB0aGlzLl9jaHVua1dyaXRlci5nZXRDaHVuayhtb2R1bGVSZWNvcmQuY2h1bmtJZCk7XHJcbiAgICAgICAgICAgIGFzc2VydHMoY2h1bmspO1xyXG4gICAgICAgICAgICBjaHVuay5pc0VudHJ5ID0gdHJ1ZTtcclxuICAgICAgICAgICAgY2h1bmsuZXhwb3NlQXMgPSB1cmwuaHJlZjtcclxuICAgICAgICB9XHJcbiAgICAgICAgYXdhaXQgZnMub3V0cHV0SnNvbih0aGlzLl9tb2R1bGVSZWNvcmRGaWxlLCB0aGlzLl9tb2R1bGVSZWNvcmRzLCB7IGVuY29kaW5nOiAndXRmOCcsIHNwYWNlczogMiB9KTtcclxuXHJcbiAgICAgICAgY29uc3QgY2h1bmtBbGlhczogUmVjb3JkPHN0cmluZywgQ2h1bmtJZD4gPSB7fTtcclxuICAgICAgICBmb3IgKGNvbnN0IFtlbnRyeVVSTCwgZW50cnlNb2R1bGVSZWNvcmRdIG9mIGVudHJ5TW9kdWxlUmVjb3Jkcykge1xyXG4gICAgICAgICAgICBjb25zdCBjaHVua0lkID0gZW50cnlNb2R1bGVSZWNvcmQuY2h1bmtJZDtcclxuICAgICAgICAgICAgY2h1bmtBbGlhc1tlbnRyeVVSTC5ocmVmXSA9IGNodW5rSWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGF3YWl0IHRoaXMuX2NodW5rV3JpdGVyLnN5bmNDaHVuayhjaHVua0FsaWFzKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgYXN5bmMgY3JlYXRlTG9hZGVyQ29udGV4dCgpIHtcclxuICAgICAgICByZXR1cm4gbmV3IExvYWRlckNvbnRleHQoXHJcbiAgICAgICAgICAgIHRoaXMuX29yaWdpbixcclxuICAgICAgICAgICAgdGhpcy5fY2h1bmtSZWNvcmRGaWxlLFxyXG4gICAgICAgICAgICB0aGlzLl9zb3VyY2VDYWNoZURpcixcclxuICAgICAgICAgICAgdGhpcy5faW1wb3J0TWFwRmlsZSxcclxuICAgICAgICApO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBhc3luYyBjbGVhcigpIHtcclxuICAgICAgICB0aGlzLl9tb2R1bGVSZWNvcmRzID0ge307XHJcbiAgICAgICAgY29uc3QgbW9kdWxlUmVjb3JkRmlsZSA9IHRoaXMuX21vZHVsZVJlY29yZEZpbGU7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgYXdhaXQgZnMudW5saW5rKG1vZHVsZVJlY29yZEZpbGUpO1xyXG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xyXG4gICAgICAgICAgICB0aGlzLl9sb2dnZXIuZGVidWcoYEZhaWxlZCB0byBkZWxldGUgbW9kdWxlIHJlY29yZCBmaWxlICR7bW9kdWxlUmVjb3JkRmlsZX06ICR7ZXJyfWApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBhd2FpdCB0aGlzLl9jaHVua1dyaXRlci5jbGVhcigpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBhc3luYyBsb2FkQ2FjaGUoKSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgY29uc3Qgc2VyaWFsaXplZE1vZHVsZVJlY29yZHM6IFJlY29yZDxzdHJpbmcsIE1vZHVsZVJlY29yZD4gPSBhd2FpdCBmcy5yZWFkSnNvbih0aGlzLl9tb2R1bGVSZWNvcmRGaWxlKTtcclxuICAgICAgICAgICAgZm9yIChjb25zdCBtb2R1bGVSZWNvcmQgb2YgT2JqZWN0LnZhbHVlcyhzZXJpYWxpemVkTW9kdWxlUmVjb3JkcykpIHtcclxuICAgICAgICAgICAgICAgIGlmIChtb2R1bGVSZWNvcmQucmVzb2x2ZWRJbXBvcnRzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCByZXNvbHZlUmVzdWx0IG9mIG1vZHVsZVJlY29yZC5yZXNvbHZlZEltcG9ydHMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc29sdmVSZXN1bHQgJiYgIXJlc29sdmVSZXN1bHQuaXNFeHRlcm5hbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZVJlc3VsdC51cmwgPSBuZXcgVVJMKHJlc29sdmVSZXN1bHQudXJsIGFzIHVua25vd24gYXMgc3RyaW5nKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl9tb2R1bGVSZWNvcmRzID0gc2VyaWFsaXplZE1vZHVsZVJlY29yZHM7XHJcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2xvZ2dlci5kZWJ1ZyhgTW9kdWxlIHJlY29yZCBmaWxlIGxvYWRlZCBmYWlsZWQgd2l0aCBlcnJvcjogJHtlcnJ9YCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGF3YWl0IHRoaXMuX2NodW5rV3JpdGVyLmxvYWRDYWNoZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgX3ZlcmJvc2U6IGJvb2xlYW47XHJcbiAgICBwcml2YXRlIF9vcmlnaW46IHN0cmluZztcclxuICAgIHByaXZhdGUgX21vZHVsZVJlY29yZEZpbGU6IHN0cmluZztcclxuICAgIHByaXZhdGUgX2NodW5rUmVjb3JkRmlsZTogc3RyaW5nO1xyXG4gICAgcHJpdmF0ZSBfc291cmNlQ2FjaGVEaXI6IHN0cmluZztcclxuICAgIHByaXZhdGUgX2ltcG9ydE1hcEZpbGU6IHN0cmluZztcclxuICAgIHByaXZhdGUgX21vZExvOiBNb2RMbztcclxuICAgIHByaXZhdGUgX3NvdXJjZU1hcHM6IGJvb2xlYW4gfCAnaW5saW5lJztcclxuICAgIHByaXZhdGUgX21vZHVsZVJlY29yZHM6IFJlY29yZDxzdHJpbmcsIE1vZHVsZVJlY29yZCB8IG51bGw+ID0ge307XHJcbiAgICBwcml2YXRlIF9jaHVua1dyaXRlcjogQ2h1bmtXcml0ZXI7XHJcbiAgICBwcml2YXRlIF9leHRlbnNpb25NYXBwaW5nOiBBcnJheTxbc3RyaW5nLCBzdHJpbmddPiA9IFtcclxuICAgICAgICBbJy50cycsICcuanMnXSxcclxuICAgICAgICBbJy5tanMnLCAnLmpzJ10sXHJcbiAgICBdO1xyXG4gICAgcHJpdmF0ZSBfbG9nZ2VyOiBMb2dnZXI7XHJcblxyXG4gICAgcHJpdmF0ZSBhc3luYyBfcmVzb2x2ZUVudHJ5KHNwZWNpZmllcjogc3RyaW5nKSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBVUkwoc3BlY2lmaWVyKTtcclxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgICAgICAgdGhpcy5fbG9nZ2VyLmVycm9yKGkxOG5UcmFuc2xhdGUoJ3F1aWNrX3BhY2tfY291bGRfbm90X3Jlc29sdmVfZW50cnknLCB7IHNwZWNpZmllciB9KSk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBhc3luYyBfZ2V0T3JDcmVhdGVJbnNwZWN0UmVjb3JkKHVybDogVVJMLCBjb250ZXh0OiBJbnNwZWN0Q29udGV4dCkge1xyXG4gICAgICAgIGNvbnN0IGV4aXN0ZWRJbnNwZWN0UmVjb3JkID0gY29udGV4dC5tb2R1bGVzLmdldCh1cmwuaHJlZik7XHJcbiAgICAgICAgaWYgKGV4aXN0ZWRJbnNwZWN0UmVjb3JkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBleGlzdGVkSW5zcGVjdFJlY29yZDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItY29uc3RcclxuICAgICAgICBsZXQgaW5zcGVjdFJlY29yZDogSW5zcGVjdFJlY29yZDtcclxuXHJcbiAgICAgICAgY29uc3QgaW5zcGVjdFByb21pc2UgPSB0aGlzLl9pbnNwZWN0V2l0aENhY2hlKHVybCk7XHJcbiAgICAgICAgY29uc3QgbGlua1Byb21pc2UgPSBpbnNwZWN0UHJvbWlzZS50aGVuKGFzeW5jIChtb2R1bGVJbnNwZWN0SW5mbykgPT4ge1xyXG4gICAgICAgICAgICBpZiAobW9kdWxlSW5zcGVjdEluZm8pIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGRlcGVuZGVuY2llcyA9IGF3YWl0IHRoaXMuX2xpbmsodXJsLCBtb2R1bGVJbnNwZWN0SW5mby5tb2R1bGVSZWNvcmQsIGNvbnRleHQpO1xyXG4gICAgICAgICAgICAgICAgaW5zcGVjdFJlY29yZC5kZXBlbmRlbmNpZXMgPSBkZXBlbmRlbmNpZXM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgaW5zcGVjdFJlY29yZCA9IHtcclxuICAgICAgICAgICAgaW5zcGVjdDogaW5zcGVjdFByb21pc2UsXHJcbiAgICAgICAgICAgIGxpbms6IGxpbmtQcm9taXNlLFxyXG4gICAgICAgICAgICBkZXBlbmRlbmNpZXM6IHVuZGVmaW5lZCxcclxuICAgICAgICB9O1xyXG4gICAgICAgIGNvbnRleHQubW9kdWxlcy5zZXQodXJsLmhyZWYsIGluc3BlY3RSZWNvcmQpO1xyXG4gICAgICAgIHJldHVybiBpbnNwZWN0UmVjb3JkO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgYXN5bmMgX2luc3RhbnRpYXRlQWxsKGluc3BlY3RSZWNvcmQ6IEluc3BlY3RSZWNvcmQsIHZpc2l0ZWQ6IFNldDxJbnNwZWN0UmVjb3JkPikge1xyXG4gICAgICAgIGlmICh2aXNpdGVkLmhhcyhpbnNwZWN0UmVjb3JkKSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZpc2l0ZWQuYWRkKGluc3BlY3RSZWNvcmQpO1xyXG4gICAgICAgIGF3YWl0IGluc3BlY3RSZWNvcmQubGluaztcclxuICAgICAgICBpZiAoaW5zcGVjdFJlY29yZC5kZXBlbmRlbmNpZXMpIHtcclxuICAgICAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoaW5zcGVjdFJlY29yZC5kZXBlbmRlbmNpZXMubWFwKGFzeW5jIChkZXBlbmRlbmN5KSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZGVwZW5kZW5jeSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX2luc3RhbnRpYXRlQWxsKGRlcGVuZGVuY3ksIHZpc2l0ZWQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgYXN5bmMgX2luc3BlY3RXaXRoQ2FjaGUodXJsOiBVUkwpIHtcclxuICAgICAgICBjb25zdCBtVGltZXN0YW1wID0gYXdhaXQgdGhpcy5fbW9kTG8uZ2V0TVRpbWVzdGFtcCh1cmwpO1xyXG4gICAgICAgIGNvbnN0IG9sZE1vZHVsZVJlY29yZCA9IHRoaXMuX21vZHVsZVJlY29yZHNbdXJsLmhyZWZdO1xyXG4gICAgICAgIGlmIChvbGRNb2R1bGVSZWNvcmQpIHtcclxuICAgICAgICAgICAgaWYgKG1UaW1lc3RhbXAgPT09IG9sZE1vZHVsZVJlY29yZC5tVGltZXN0YW1wKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4geyBtb2R1bGVSZWNvcmQ6IG9sZE1vZHVsZVJlY29yZCwgdXBkYXRlZDogZmFsc2UgfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl9sb2dnZXIuZGVidWcoYERldGVjdGVkIGNoYW5nZTogJHt1cmx9LiBMYXN0IG10aW1lOiAke25ldyBEYXRlKG9sZE1vZHVsZVJlY29yZC5tVGltZXN0YW1wKX0sIEN1cnJlbnQgbXRpbWU6ICR7bmV3IERhdGUobVRpbWVzdGFtcCl9YCk7XHJcbiAgICAgICAgICAgIHRoaXMuX21vZHVsZVJlY29yZHNbdXJsLmhyZWZdID0gbnVsbDtcclxuICAgICAgICAgICAgYXdhaXQgdGhpcy5fY2h1bmtXcml0ZXIucmVtb3ZlQ2h1bmsob2xkTW9kdWxlUmVjb3JkLmNodW5rSWQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHRoaXMuX3ZlcmJvc2UpIHtcclxuICAgICAgICAgICAgdGhpcy5fbG9nZ2VyLmRlYnVnKGBJbnNwZWN0ICR7dXJsfWApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc3QgbW9kdWxlUmVjb3JkID0gYXdhaXQgdGhpcy5faW5zcGVjdCh1cmwsIG1UaW1lc3RhbXApLmNhdGNoKChlcnIpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5fbG9nZ2VyLmVycm9yKGVycik7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaWYgKCFtb2R1bGVSZWNvcmQpIHtcclxuICAgICAgICAgICAgLy8gTW9kdWxlIHJlY29yZCBpcyBpbnZhbGlkIG9yIGNhY2hlIGlzIHZhbGlkXHJcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4geyBtb2R1bGVSZWNvcmQsIHVwZGF0ZWQ6IHRydWUgfTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIGFzeW5jIF9saW5rKHVybDogVVJMLCBtb2R1bGVSZWNvcmQ6IE1vZHVsZVJlY29yZCwgY29udGV4dDogSW5zcGVjdENvbnRleHQpIHtcclxuICAgICAgICBjb25zdCBjaHVua0ltcG9ydHM6IENodW5rWydpbXBvcnRzJ10gPSB7fTtcclxuXHJcbiAgICAgICAgbGV0IGZvcmNlUmVzb2x2ZSA9IGZhbHNlO1xyXG4gICAgICAgIGlmICghbW9kdWxlUmVjb3JkLnJlc29sdmVkSW1wb3J0cykge1xyXG4gICAgICAgICAgICBmb3JjZVJlc29sdmUgPSB0cnVlO1xyXG4gICAgICAgICAgICBtb2R1bGVSZWNvcmQucmVzb2x2ZWRJbXBvcnRzID0gbmV3IEFycmF5KG1vZHVsZVJlY29yZC5pbXBvcnRzLmxlbmd0aCkuZmlsbChudWxsKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IHJlc29sdmVkSW1wb3J0cyA9IG1vZHVsZVJlY29yZC5yZXNvbHZlZEltcG9ydHM7XHJcblxyXG4gICAgICAgIGNvbnN0IGRlcFJlY29yZHMgPSBhd2FpdCBQcm9taXNlLmFsbChtb2R1bGVSZWNvcmQuaW1wb3J0cy5tYXAoYXN5bmMgKHNwZWNpZmllciwgaUltcG9ydCk6IFByb21pc2U8dW5kZWZpbmVkIHwgSW5zcGVjdFJlY29yZD4gPT4ge1xyXG4gICAgICAgICAgICBsZXQgcmVzb2x2ZWQgPSByZXNvbHZlZEltcG9ydHNbaUltcG9ydF07XHJcbiAgICAgICAgICAgIGlmIChmb3JjZVJlc29sdmUgfHwgLy8gTm90IHJlc29sdmVkIGJlZm9yZVxyXG4gICAgICAgICAgICAgICAgcmVzb2x2ZWQgPT09IG51bGwgJiYgY29udGV4dC5yZXRyeVJlc29sdXRpb25PblVuY2hhbmdlZE1vZHVsZSAvLyBSZXNvbHZlZCBidXQgZmFpbGVkXHJcbiAgICAgICAgICAgICkge1xyXG4gICAgICAgICAgICAgICAgcmVzb2x2ZWQgPSBhd2FpdCB0aGlzLl9yZXNvbHZlKHNwZWNpZmllciwgdXJsLCBtb2R1bGVSZWNvcmQubW9kTG9NZXRhZGF0YSk7XHJcbiAgICAgICAgICAgICAgICByZXNvbHZlZEltcG9ydHNbaUltcG9ydF0gPSByZXNvbHZlZDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKCFyZXNvbHZlZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBjb25zdCBjaHVua0ltcG9ydEtleSA9IHNwZWNpZmllci5yZXdyaXR0ZW4gPz8gc3BlY2lmaWVyLnZhbHVlO1xyXG5cclxuICAgICAgICAgICAgaWYgKHJlc29sdmVkLmlzRXh0ZXJuYWwpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGlzUmVzb2x2ZWRUb0JhcmUgPSAhdHJ5UGFyc2VVUkwocmVzb2x2ZWQuc3BlY2lmaWVyT3JVUkwpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzUmVzb2x2ZWRUb0JhcmUpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBPbmx5IGJhcmUgc3BlY2lmaWVyIG1heSByZXNvbHZlZCB0byBiYXJlXHJcbiAgICAgICAgICAgICAgICAgICAgYXNzZXJ0cyghc3BlY2lmaWVyLnJld3JpdHRlbiwgYFNvbWV0aGluZyB3cm9uZyB3aXRoIHJld3JpdGluZyBhbmQgcmVzb2x2ZSAke3NwZWNpZmllci52YWx1ZX1gKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjaHVua0ltcG9ydHNbY2h1bmtJbXBvcnRLZXldID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIGV4dGVybmFsOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgICAgIHVybDogcmVzb2x2ZWQuc3BlY2lmaWVyT3JVUkwsXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBjb25zdCB7IHVybDogcmVzb2x2ZWRVUkwgfSA9IHJlc29sdmVkO1xyXG5cclxuICAgICAgICAgICAgY29uc3QgaW5zcGVjdFJlY29yZCA9IGF3YWl0IHRoaXMuX2dldE9yQ3JlYXRlSW5zcGVjdFJlY29yZChyZXNvbHZlZFVSTCwgY29udGV4dCk7XHJcbiAgICAgICAgICAgIGF3YWl0IGluc3BlY3RSZWNvcmQuaW5zcGVjdDtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IHJlc29sdmVkQ2h1bmsgPSB0aGlzLl9tb2R1bGVSZWNvcmRzW3Jlc29sdmVkVVJMLmhyZWZdPy5jaHVua0lkO1xyXG4gICAgICAgICAgICBpZiAocmVzb2x2ZWRDaHVuaykge1xyXG4gICAgICAgICAgICAgICAgY2h1bmtJbXBvcnRzW2NodW5rSW1wb3J0S2V5XSA9IHJlc29sdmVkQ2h1bms7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9sb2dnZXIuZGVidWcoYFdlJ3JlIG1pc3NpbmcgdGhlIGNodW5rICR7cmVzb2x2ZWRVUkwuaHJlZn0sIHJlZmVyZW5jZWQgYXMgJyR7c3BlY2lmaWVyfScuYCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBpbnNwZWN0UmVjb3JkO1xyXG4gICAgICAgIH0pKTtcclxuXHJcbiAgICAgICAgY29uc3QgY2h1bmsgPSBhd2FpdCB0aGlzLl9jaHVua1dyaXRlci5nZXRDaHVuayhtb2R1bGVSZWNvcmQuY2h1bmtJZCk7XHJcbiAgICAgICAgYXNzZXJ0cyhjaHVuayk7XHJcbiAgICAgICAgY2h1bmsuaW1wb3J0cyA9IGNodW5rSW1wb3J0cztcclxuXHJcbiAgICAgICAgcmV0dXJuIGRlcFJlY29yZHM7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBhc3luYyBfaW5zcGVjdCh1cmw6IFVSTCwgbVRpbWVzdGFtcDogbnVtYmVyKSB7XHJcbiAgICAgICAgbGV0IG1vZDogTW9kO1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIG1vZCA9IGF3YWl0IHRoaXMuX21vZExvLmxvYWQodXJsKTtcclxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgICAgICAgdGhpcy5fbG9nZ2VyLmVycm9yKGkxOG5UcmFuc2xhdGUoJ3F1aWNrX3BhY2tfZmFpbGVkX3RvX2xvYWQnLCB7IHVybDogdXJsLmhyZWYsIGNhdXNlOiBlcnIgfSkpO1xyXG4gICAgICAgICAgICBpZiAodXJsLnByb3RvY29sID09PSAnbm9kZTonKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9sb2dnZXIud2FybihpMThuVHJhbnNsYXRlKCdsb2FkX2Vycm9yX2hpbnRfbm9kZV9idWlsdGluJykpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IHtcclxuICAgICAgICAgICAgb3JpZ2luYWxTb3VyY2UsXHJcbiAgICAgICAgICAgIGNvZGUsXHJcbiAgICAgICAgICAgIG1vZExvTWV0YWRhdGEsXHJcbiAgICAgICAgfSA9IG1vZDtcclxuXHJcbiAgICAgICAgbGV0IHtcclxuICAgICAgICAgICAgbWFwLFxyXG4gICAgICAgIH0gPSBtb2Q7XHJcblxyXG4gICAgICAgIGxldCBhc3Q6IEFzdDtcclxuICAgICAgICBpZiAodHlwZW9mIGNvZGUgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgIC8vIFRPRE86IGlucHV0IHNvdXJjZSBtYXBcclxuICAgICAgICAgICAgYXN0ID0gYXdhaXQgdGhpcy5fbW9kTG8ucGFyc2UoY29kZSwgbWFwKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBhc3QgPSBjb2RlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc3QgY2h1bmtVUkwgPSB0aGlzLl9nZXRDaHVua1VSTCh1cmwpO1xyXG5cclxuICAgICAgICBjb25zdCBjaHVua0lkID0gdGhpcy5fY2h1bmtXcml0ZXIuZ2V0Q2h1bmtJZChjaHVua1VSTCk7XHJcblxyXG4gICAgICAgIGxldCBzcGVjaWZpZXJzOiBTcGVjaWZpZXJbXSA9IFtdO1xyXG4gICAgICAgICh7IHRyYW5zZm9ybVJlc3VsdDogeyBhc3QsIG1hcCB9LCBzcGVjaWZpZXJzIH0gPSBhd2FpdCB0aGlzLl9yZXdyaXRlSW1wb3J0cyhcclxuICAgICAgICAgICAgdXJsLFxyXG4gICAgICAgICAgICBhc3QsXHJcbiAgICAgICAgICAgIHR5cGVvZiBtYXAgPT09ICdzdHJpbmcnID8gSlNPTi5wYXJzZShtYXApIDogbWFwID8/IHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgb3JpZ2luYWxTb3VyY2UsXHJcbiAgICAgICAgKSk7XHJcblxyXG4gICAgICAgIGF3YWl0IHRoaXMuX3RyYW5zZm9ybUFuZEFkZChcclxuICAgICAgICAgICAgY2h1bmtJZCxcclxuICAgICAgICAgICAgdXJsLFxyXG4gICAgICAgICAgICBhc3QsXHJcbiAgICAgICAgICAgIHR5cGVvZiBtYXAgPT09ICdzdHJpbmcnID8gSlNPTi5wYXJzZShtYXApIDogbWFwID8/IHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgb3JpZ2luYWxTb3VyY2UsXHJcbiAgICAgICAgKTtcclxuXHJcbiAgICAgICAgY29uc3QgbW9kdWxlUmVjb3JkOiBNb2R1bGVSZWNvcmQgPSB7XHJcbiAgICAgICAgICAgIG1UaW1lc3RhbXAsXHJcbiAgICAgICAgICAgIGNodW5rSWQsXHJcbiAgICAgICAgICAgIGltcG9ydHM6IHNwZWNpZmllcnMsXHJcbiAgICAgICAgICAgIG1vZExvTWV0YWRhdGEsXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgdGhpcy5fbW9kdWxlUmVjb3Jkc1t1cmwuaHJlZl0gPSBtb2R1bGVSZWNvcmQ7XHJcblxyXG4gICAgICAgIHJldHVybiBtb2R1bGVSZWNvcmQ7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBhc3luYyBfdHJhbnNmb3JtQW5kQWRkKGNodW5rSWQ6IHN0cmluZywgdXJsOiBVUkwsIGFzdDogQXN0LCBtYXA6IFJhd1NvdXJjZU1hcCB8IHVuZGVmaW5lZCwgb3JpZ2luYWxTb3VyY2U6IHN0cmluZykge1xyXG4gICAgICAgIGNvbnN0IHRyYW5zZm9ybWVkID0gYXdhaXQgdGhpcy5fdHJhbnNmb3JtKHVybCwgYXN0LCBtYXAsIG9yaWdpbmFsU291cmNlKTtcclxuXHJcbiAgICAgICAgYXdhaXQgdGhpcy5fY2h1bmtXcml0ZXIuYWRkQ2h1bmsoXHJcbiAgICAgICAgICAgIGNodW5rSWQsXHJcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkLmNvZGUsXHJcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkLm1hcCxcclxuICAgICAgICApO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgYXN5bmMgX3Jld3JpdGVJbXBvcnRzKHVybDogVVJMLCBhc3Q6IEFzdCwgbWFwOiBSYXdTb3VyY2VNYXAgfCB1bmRlZmluZWQsIG9yaWdpbmFsU291cmNlOiBzdHJpbmcpIHtcclxuICAgICAgICBjb25zdCBzcGVjaWZpZXJzOiBTcGVjaWZpZXJbXSA9IFtdO1xyXG5cclxuICAgICAgICBsZXQgblNwZWNpZmllciA9IDA7XHJcblxyXG4gICAgICAgIGNvbnN0IHRyYW5zZm9ybVJlc3VsdCA9IGF3YWl0IGJhYmVsLnRyYW5zZm9ybUZyb21Bc3RBc3luYyhcclxuICAgICAgICAgICAgYXN0LCBvcmlnaW5hbFNvdXJjZSwge1xyXG4gICAgICAgICAgICAgICAgYXN0OiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgY29kZTogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICBzb3VyY2VGaWxlTmFtZTogdXJsLmhyZWYsXHJcbiAgICAgICAgICAgICAgICBjbG9uZUlucHV0QXN0OiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIGNvbmZpZ0ZpbGU6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgc291cmNlVHlwZTogJ21vZHVsZScsXHJcbiAgICAgICAgICAgICAgICBzb3VyY2VNYXBzOiB0aGlzLl9zb3VyY2VNYXBzLFxyXG4gICAgICAgICAgICAgICAgaW5wdXRTb3VyY2VNYXA6IG1hcCxcclxuICAgICAgICAgICAgICAgIHBsdWdpbnM6IFtcclxuICAgICAgICAgICAgICAgICAgICBbY3JlYXRlQmFiZWxQbHVnaW5EZXRlY3RBbmRSZXdyaXRlSW1wb3J0cyh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNwZWNpZmllcnMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJld3JpdGU6IChzcGVjaWZpZXIpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc0JhcmVTcGVjaWZpZXIoc3BlY2lmaWVyKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIGl0J3MgYmFyZSBzcGVjaWZpZXIsIHdlIGRvIG5vdCByZXdyaXRlIGl0LlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZXdyaXR0ZW4gPSBgX191bnJlc29sdmVkXyR7blNwZWNpZmllcn1gO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKytuU3BlY2lmaWVyO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJld3JpdHRlbjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICB9KV0sXHJcbiAgICAgICAgICAgICAgICBdLFxyXG4gICAgICAgICAgICB9IGFzIGJhYmVsLlRyYW5zZm9ybU9wdGlvbnMgJiB7XHJcbiAgICAgICAgICAgICAgICBjbG9uZUlucHV0QXN0PzogYm9vbGVhbjtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICApO1xyXG5cclxuICAgICAgICBhc3NlcnRzKHRyYW5zZm9ybVJlc3VsdCk7XHJcbiAgICAgICAgYXNzZXJ0cyh0cmFuc2Zvcm1SZXN1bHQuYXN0KTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgdHJhbnNmb3JtUmVzdWx0OiB7XHJcbiAgICAgICAgICAgICAgICBhc3Q6IHRyYW5zZm9ybVJlc3VsdC5hc3QsXHJcbiAgICAgICAgICAgICAgICBtYXA6ICh0cmFuc2Zvcm1SZXN1bHQubWFwIGFzIFNvdXJjZU1hcCB8IHVuZGVmaW5lZCkgPz8gdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBzcGVjaWZpZXJzLFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBhc3luYyBfdHJhbnNmb3JtKHVybDogVVJMLCBhc3Q6IEFzdCwgbWFwOiBSYXdTb3VyY2VNYXAgfCB1bmRlZmluZWQsIG9yaWdpbmFsU291cmNlOiBzdHJpbmcpIHtcclxuICAgICAgICBjb25zdCBiYWJlbFJlc3VsdCA9IGF3YWl0IGJhYmVsLnRyYW5zZm9ybUZyb21Bc3RBc3luYyhcclxuICAgICAgICAgICAgYXN0LFxyXG4gICAgICAgICAgICBvcmlnaW5hbFNvdXJjZSwge1xyXG4gICAgICAgICAgICAgICAgc291cmNlRmlsZU5hbWU6IHVybC5ocmVmLFxyXG4gICAgICAgICAgICAgICAgLy8gY2xvbmVJbnB1dEFzdDogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICBjb25maWdGaWxlOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIHNvdXJjZVR5cGU6ICdtb2R1bGUnLFxyXG4gICAgICAgICAgICAgICAgc291cmNlTWFwczogdGhpcy5fc291cmNlTWFwcyxcclxuICAgICAgICAgICAgICAgIGlucHV0U291cmNlTWFwOiBtYXAsXHJcbiAgICAgICAgICAgICAgICBwbHVnaW5zOiBbXHJcbiAgICAgICAgICAgICAgICAgICAgW2JhYmVsUGx1Z2luVHJhbnNmb3JtU3lzdGVtSnNdLFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIER5bmFtaWMgaW1wb3J0KCkgdHJhbnNmb3JtYXRpb24gbXVzdCBiZSBlbmFibGVkIHVzaW5nIHRoZVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIEBiYWJlbC9wbHVnaW4tcHJvcG9zYWwtZHluYW1pYy1pbXBvcnQgcGx1Z2luLiBCYWJlbCA4IHdpbGxcclxuICAgICAgICAgICAgICAgICAgICAvLyBubyBsb25nZXIgdHJhbnNmb3JtIGltcG9ydCgpIHdpdGhvdXQgdXNpbmcgdGhhdCBwbHVnaW4uXHJcbiAgICAgICAgICAgICAgICAgICAgW2JhYmVsUGx1Z2luUHJvcG9zYWxEeW5hbWljSW1wb3J0XSxcclxuICAgICAgICAgICAgICAgIF0sXHJcbiAgICAgICAgICAgIH0gYXMgYmFiZWwuVHJhbnNmb3JtT3B0aW9ucyAmIHtcclxuICAgICAgICAgICAgICAgIGNsb25lSW5wdXRBc3Q/OiBib29sZWFuO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICk7XHJcbiAgICAgICAgYXNzZXJ0cyhiYWJlbFJlc3VsdCk7XHJcbiAgICAgICAgYXNzZXJ0cyhiYWJlbFJlc3VsdC5jb2RlKTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBjb2RlOiBiYWJlbFJlc3VsdC5jb2RlLFxyXG4gICAgICAgICAgICBtYXA6IGJhYmVsUmVzdWx0Lm1hcCBhcyB1bmtub3duIGFzIFNvdXJjZU1hcCxcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgYXN5bmMgX3Jlc29sdmUoc3BlY2lmaWVyOiBTcGVjaWZpZXIsIHBhcmVudFVSTDogVVJMLCBtb2RMb01ldGFkYXRhOiBNb2RMb01ldGFkYXRhKSB7XHJcbiAgICAgICAgY29uc3Qgc3BlY2lmaWVyVmFsdWUgPSBzcGVjaWZpZXIudmFsdWU7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgY29uc3QgcmVzb2x2ZWQgPSBhd2FpdCB0aGlzLl9tb2RMby5yZXNvbHZlKHNwZWNpZmllclZhbHVlLCBwYXJlbnRVUkwsIG1vZExvTWV0YWRhdGEpO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5fdmVyYm9zZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHJlc29sdmVkLmlzRXh0ZXJuYWwpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9sb2dnZXIuZGVidWcoYFJlc29sdmUgJHtzcGVjaWZpZXJWYWx1ZX0gZnJvbSAke3BhcmVudFVSTC5ocmVmfSBhcyBleHRlcm5hbCBkZXBlbmRlbmN5ICR7cmVzb2x2ZWQuc3BlY2lmaWVyT3JVUkx9LmApO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9sb2dnZXIuZGVidWcoYFJlc29sdmUgJHtzcGVjaWZpZXJWYWx1ZX0gZnJvbSAke3BhcmVudFVSTC5ocmVmfSBhcyAke3Jlc29sdmVkLnVybH0uYCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHJlc29sdmVkO1xyXG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xyXG4gICAgICAgICAgICB0aGlzLl9sb2dnZXIuZXJyb3IoaTE4blRyYW5zbGF0ZShcclxuICAgICAgICAgICAgICAgICdxdWlja19wYWNrX2ZhaWxlZF90b19yZXNvbHZlJyxcclxuICAgICAgICAgICAgICAgIHsgc3BlY2lmaWVyOiBzcGVjaWZpZXJWYWx1ZSwgcGFyZW50VVJMOiBwYXJlbnRVUkwuaHJlZiwgY2F1c2U6IGVyciB9LFxyXG4gICAgICAgICAgICApKTtcclxuICAgICAgICAgICAgaWYgKHNwZWNpZmllclZhbHVlLmluY2x1ZGVzKCcvJykpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGxhc3RQb3J0aW9uID0gc3BlY2lmaWVyVmFsdWUuc3BsaXQoJy8nKS5wb3AoKTtcclxuICAgICAgICAgICAgICAgIGlmIChsYXN0UG9ydGlvbiAmJiAhbGFzdFBvcnRpb24uaW5jbHVkZXMoJy4nKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2xvZ2dlci53YXJuKGkxOG5UcmFuc2xhdGUoJ3Jlc29sdmVfZXJyb3JfaGludF9leHRlbnNpb24nKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogTWFwIHRoZSBtb2R1bGUgVVJMIHRvIGNodW5rIFVSTC5cclxuICAgICAqIEBwYXJhbSB1cmwgXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgX2dldENodW5rVVJMKF91cmw6IFJlYWRvbmx5PFVSTD4pOiBSZWFkb25seTxVUkw+IHtcclxuICAgICAgICAvLyBUT0RPOiBkbyBpdCBiZXR0ZXJcclxuICAgICAgICBsZXQgdXJsOiBSZWFkb25seTxVUkw+O1xyXG4gICAgICAgIGlmICghX3VybC5zZWFyY2gpIHtcclxuICAgICAgICAgICAgdXJsID0gX3VybDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zdCB1ID0gbmV3IFVSTChfdXJsLmhyZWYpO1xyXG4gICAgICAgICAgICBjb25zdCBleHRlbnNpb25OYW1lID0gcGFyc2VFeHRlbnNpb25OYW1lKHUucGF0aG5hbWUpO1xyXG4gICAgICAgICAgICByZXBsYWNlRXh0ZW5zaW9uKHUsIGAucHJveHkke2V4dGVuc2lvbk5hbWV9YCk7XHJcbiAgICAgICAgICAgIHVybCA9IHU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyDop4HvvJpodHRwczovL2dpc3QuZ2l0aHViLmNvbS9zaHJpbmt0b2ZpdC81MGYyMzgwNzgyYjYyMTllZDZhNGNiM2EyMTBhNzVmN1xyXG4gICAgICAgIGZvciAoY29uc3QgW2Zyb20sIHRvXSBvZiB0aGlzLl9leHRlbnNpb25NYXBwaW5nKSB7XHJcbiAgICAgICAgICAgIGlmICh1cmwucGF0aG5hbWUuZW5kc1dpdGgoZnJvbSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBhc3NpZ25QYXRobmFtZShcclxuICAgICAgICAgICAgICAgICAgICBuZXcgVVJMKHVybC5ocmVmKSxcclxuICAgICAgICAgICAgICAgICAgICBgJHt1cmwucGF0aG5hbWUuc3Vic3RyKDAsIHVybC5wYXRobmFtZS5sZW5ndGggLSBmcm9tLmxlbmd0aCl9JHt0b31gLFxyXG4gICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIXBhcnNlRXh0ZW5zaW9uTmFtZSh1cmwucGF0aG5hbWUpKSB7XHJcbiAgICAgICAgICAgIC8vIFVSTHMgd2l0aCBubyBleHRlbnNpb24gYXJlIHN0b3JlIGFzIC5qc1xyXG4gICAgICAgICAgICByZXR1cm4gYXNzaWduUGF0aG5hbWUoXHJcbiAgICAgICAgICAgICAgICBuZXcgVVJMKHVybC5ocmVmKSxcclxuICAgICAgICAgICAgICAgIGAke3VybC5wYXRobmFtZX0uanNgXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB1cmw7XHJcbiAgICB9XHJcbn1cclxuXHJcbmludGVyZmFjZSBJbnNwZWN0UmVjb3JkIHtcclxuICAgIGluc3BlY3Q6IFByb21pc2U8eyBtb2R1bGVSZWNvcmQ6IE1vZHVsZVJlY29yZDsgdXBkYXRlZDogYm9vbGVhbjsgfSB8IHVuZGVmaW5lZD47XHJcbiAgICBsaW5rOiBQcm9taXNlPHZvaWQ+IHwgdW5kZWZpbmVkO1xyXG4gICAgZGVwZW5kZW5jaWVzOiBBcnJheTxJbnNwZWN0UmVjb3JkIHwgdW5kZWZpbmVkPiB8IHVuZGVmaW5lZDtcclxufVxyXG5cclxuaW50ZXJmYWNlIEluc3BlY3RDb250ZXh0IHtcclxuICAgIHJldHJ5UmVzb2x1dGlvbk9uVW5jaGFuZ2VkTW9kdWxlOiBib29sZWFuO1xyXG4gICAgbW9kdWxlczogTWFwPHN0cmluZywgSW5zcGVjdFJlY29yZD47XHJcbn1cclxuIl19