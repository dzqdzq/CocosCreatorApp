"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.QuickPack = void 0;
const path_1 = __importDefault(require("path"));
const fs_extra_1 = __importDefault(require("fs-extra"));
const url_1 = require("url");
const writer_1 = require("./utils/chunk-io/writer");
const loader_context_1 = require("./utils/loader-context");
const url_2 = require("../utils/url");
const logger_1 = require("../utils/logger");
const babel = __importStar(require("@babel/core"));
// @ts-expect-error
const plugin_transform_modules_systemjs_1 = __importDefault(require("@babel/plugin-transform-modules-systemjs"));
// @ts-expect-error
const plugin_proposal_dynamic_import_1 = __importDefault(require("@babel/plugin-proposal-dynamic-import"));
const asserts_1 = require("../../utils/asserts");
const detect_imports_1 = require("./utils/detect-imports");
const launch_policy_1 = require("../utils/launch-policy");
const i18n_1 = require("../../utils/i18n");
const specifier_1 = require("../utils/specifier");
const getLauncher = (par) => par ? launch_policy_1.parallelDiscarding : launch_policy_1.sequenceDiscarding;
const resolveLauncher = getLauncher(true);
class QuickPack {
    constructor({ modLo, sourceMaps, origin, workspace, verbose, logger, }) {
        this._moduleRecords = {};
        this._extensionMapping = [
            ['.ts', '.js'],
            ['.mjs', '.js'],
        ];
        this._verbose = verbose !== null && verbose !== void 0 ? verbose : false;
        this._origin = origin;
        this._modLo = modLo;
        this._sourceMaps = sourceMaps !== null && sourceMaps !== void 0 ? sourceMaps : true;
        this._moduleRecordFile = path_1.default.join(workspace, 'modules.json');
        this._chunkRecordFile = path_1.default.join(workspace, 'chunks.json');
        this._sourceCacheDir = path_1.default.join(workspace, 'mods');
        const importMapFile = path_1.default.join(workspace, 'import-map.json');
        this._importMapFile = importMapFile;
        const theLogger = logger !== null && logger !== void 0 ? logger : logger_1.createLogger({});
        this._chunkWriter = new writer_1.ChunkWriter({
            origin,
            chunkRecordFile: this._chunkRecordFile,
            sourceCacheDir: this._sourceCacheDir,
            importMapFile,
            logger: theLogger,
        });
        this._logger = theLogger;
    }
    async build(specifiers, options) {
        var _a, _b;
        const context = {
            modules: new Map(),
            forceAll: (_a = options === null || options === void 0 ? void 0 : options.forceAll) !== null && _a !== void 0 ? _a : false,
            retryResolutionOnUnchangedModule: (_b = options === null || options === void 0 ? void 0 : options.retryResolutionOnUnchangedModule) !== null && _b !== void 0 ? _b : false,
        };
        const entryModuleRecords = [];
        for (const specifier of specifiers) {
            const url = typeof specifier === 'string'
                ? await this._resolveEntry(specifier)
                : specifier;
            if (!url) {
                continue;
            }
            const inspectRecord = await this._getOrCreateInspectRecord(url, context);
            await this._instantiateAll(inspectRecord, new Set());
            const moduleRecord = this._moduleRecords[url.href];
            if (!moduleRecord) {
                this._logger.debug(`Entry ${url} did not library a chunk.`);
                continue;
            }
            entryModuleRecords.push([url, moduleRecord]);
            const chunk = await this._chunkWriter.getChunk(moduleRecord.chunkId);
            asserts_1.asserts(chunk);
            chunk.isEntry = true;
            chunk.exposeAs = url.href;
        }
        await fs_extra_1.default.outputJson(this._moduleRecordFile, this._moduleRecords, { encoding: 'utf8', spaces: 2 });
        const chunkAlias = {};
        for (const [entryURL, entryModuleRecord] of entryModuleRecords) {
            const chunkId = entryModuleRecord.chunkId;
            chunkAlias[entryURL.href] = chunkId;
        }
        await this._chunkWriter.syncChunk(chunkAlias);
    }
    async createLoaderContext() {
        return new loader_context_1.LoaderContext(this._origin, this._chunkRecordFile, this._sourceCacheDir, this._importMapFile);
    }
    async clear() {
        this._moduleRecords = {};
        const moduleRecordFile = this._moduleRecordFile;
        try {
            await fs_extra_1.default.unlink(moduleRecordFile);
        }
        catch (err) {
            this._logger.debug(`Failed to delete module record file ${moduleRecordFile}: ${err}`);
        }
        await this._chunkWriter.clear();
    }
    async loadCache() {
        try {
            const serializedModuleRecords = await fs_extra_1.default.readJson(this._moduleRecordFile);
            for (const moduleRecord of Object.values(serializedModuleRecords)) {
                if (moduleRecord.resolvedImports) {
                    for (const resolveResult of moduleRecord.resolvedImports) {
                        if (resolveResult && !resolveResult.isExternal) {
                            resolveResult.url = new url_1.URL(resolveResult.url);
                        }
                    }
                }
            }
            this._moduleRecords = serializedModuleRecords;
        }
        catch (err) {
            this._logger.debug(`Module record file loaded failed with error: ${err}`);
        }
        await this._chunkWriter.loadCache();
    }
    async _resolveEntry(specifier) {
        try {
            return new url_1.URL(specifier);
        }
        catch (err) {
            this._logger.error(i18n_1.i18nTranslate('quick_pack_could_not_resolve_entry', { specifier }));
            return;
        }
    }
    async _getOrCreateInspectRecord(url, context) {
        const existedInspectRecord = context.modules.get(url.href);
        if (existedInspectRecord) {
            return existedInspectRecord;
        }
        // eslint-disable-next-line prefer-const
        let inspectRecord;
        const inspectPromise = this._inspectWithCache(url);
        const linkPromise = inspectPromise.then(async (moduleInspectInfo) => {
            if (moduleInspectInfo && (moduleInspectInfo.updated || context.forceAll)) {
                const dependencies = await this._link(url, moduleInspectInfo.moduleRecord, context);
                inspectRecord.dependencies = dependencies;
            }
        });
        inspectRecord = {
            inspect: inspectPromise,
            link: linkPromise,
            dependencies: undefined,
        };
        context.modules.set(url.href, inspectRecord);
        return inspectRecord;
    }
    async _instantiateAll(inspectRecord, visited) {
        if (visited.has(inspectRecord)) {
            return;
        }
        visited.add(inspectRecord);
        await inspectRecord.link;
        if (inspectRecord.dependencies) {
            await Promise.all(inspectRecord.dependencies.map(async (dependency) => {
                if (dependency) {
                    await this._instantiateAll(dependency, visited);
                }
            }));
        }
    }
    async _inspectWithCache(url) {
        const mTimestamp = await this._modLo.getMTimestamp(url);
        const oldModuleRecord = this._moduleRecords[url.href];
        if (oldModuleRecord) {
            if (mTimestamp === oldModuleRecord.mTimestamp) {
                return { moduleRecord: oldModuleRecord, updated: false };
            }
            this._logger.debug(`Detected change: ${url}. Last mtime: ${new Date(oldModuleRecord.mTimestamp)}, Current mtime: ${new Date(mTimestamp)}`);
            this._moduleRecords[url.href] = null;
            await this._chunkWriter.removeChunk(oldModuleRecord.chunkId);
        }
        if (this._verbose) {
            this._logger.debug(`Inspect ${url}`);
        }
        const moduleRecord = await this._inspect(url, mTimestamp).catch((err) => {
            this._logger.error(err);
        });
        if (!moduleRecord) {
            // Module record is invalid or cache is valid
            return undefined;
        }
        return { moduleRecord, updated: true };
    }
    async _link(url, moduleRecord, context) {
        const chunkImports = {};
        let forceResolve = false;
        if (!moduleRecord.resolvedImports) {
            forceResolve = true;
            moduleRecord.resolvedImports = new Array(moduleRecord.imports.length).fill(null);
        }
        const resolvedImports = moduleRecord.resolvedImports;
        const depRecords = await Promise.all(moduleRecord.imports.map(async (specifier, iImport) => {
            var _a, _b;
            let resolved = resolvedImports[iImport];
            if (forceResolve || // Not resolved before
                resolved === null && context.retryResolutionOnUnchangedModule // Resolved but failed
            ) {
                resolved = await this._resolve(specifier, url, moduleRecord.modLoMetadata);
                resolvedImports[iImport] = resolved;
            }
            if (!resolved) {
                return;
            }
            const chunkImportKey = (_a = specifier.rewritten) !== null && _a !== void 0 ? _a : specifier.value;
            if (resolved.isExternal) {
                const isResolvedToBare = !url_2.tryParseURL(resolved.specifierOrURL);
                if (isResolvedToBare) {
                    // Only bare specifier may resolved to bare
                    asserts_1.asserts(!specifier.rewritten, `Something wrong with rewriting and resolve ${specifier.value}`);
                    return;
                }
                chunkImports[chunkImportKey] = {
                    external: true,
                    url: resolved.specifierOrURL,
                };
                return;
            }
            const { url: resolvedURL } = resolved;
            const inspectRecord = await this._getOrCreateInspectRecord(resolvedURL, context);
            await inspectRecord.inspect;
            const resolvedChunk = (_b = this._moduleRecords[resolvedURL.href]) === null || _b === void 0 ? void 0 : _b.chunkId;
            if (resolvedChunk) {
                chunkImports[chunkImportKey] = resolvedChunk;
            }
            else {
                this._logger.debug(`We're missing the chunk ${resolvedURL.href}, referenced as '${specifier}'.`);
            }
            return inspectRecord;
        }));
        const chunk = await this._chunkWriter.getChunk(moduleRecord.chunkId);
        asserts_1.asserts(chunk);
        chunk.imports = chunkImports;
        return depRecords;
    }
    async _inspect(url, mTimestamp) {
        let mod;
        try {
            mod = await this._modLo.load(url);
        }
        catch (err) {
            this._logger.error(i18n_1.i18nTranslate('quick_pack_failed_to_load', { url: url.href, cause: err }));
            if (url.protocol === 'node:') {
                this._logger.warn(i18n_1.i18nTranslate('load_error_hint_node_builtin'));
            }
            return;
        }
        const { originalSource, code, modLoMetadata, } = mod;
        let { map, } = mod;
        let ast;
        if (typeof code === 'string') {
            // TODO: input source map
            ast = await this._modLo.parse(code, map);
        }
        else {
            ast = code;
        }
        const chunkURL = this._getChunkURL(url);
        const chunkId = this._chunkWriter.getChunkId(chunkURL);
        let specifiers = [];
        ({ transformResult: { ast, map }, specifiers } = await this._rewriteImports(url, ast, typeof map === 'string' ? JSON.parse(map) : map !== null && map !== void 0 ? map : undefined, originalSource));
        await this._transformAndAdd(chunkId, url, ast, typeof map === 'string' ? JSON.parse(map) : map !== null && map !== void 0 ? map : undefined, originalSource);
        const moduleRecord = {
            mTimestamp,
            chunkId,
            imports: specifiers,
            modLoMetadata,
        };
        this._moduleRecords[url.href] = moduleRecord;
        return moduleRecord;
    }
    async _transformAndAdd(chunkId, url, ast, map, originalSource) {
        const transformed = await this._transform(url, ast, map, originalSource);
        await this._chunkWriter.addChunk(chunkId, transformed.code, transformed.map);
    }
    async _rewriteImports(url, ast, map, originalSource) {
        var _a;
        const specifiers = [];
        let nSpecifier = 0;
        const transformResult = await babel.transformFromAstAsync(ast, originalSource, {
            ast: true,
            code: false,
            sourceFileName: url.href,
            cloneInputAst: false,
            configFile: false,
            sourceType: 'module',
            sourceMaps: this._sourceMaps,
            inputSourceMap: map,
            plugins: [
                [detect_imports_1.createBabelPluginDetectAndRewriteImports({
                        specifiers,
                        rewrite: (specifier) => {
                            if (specifier_1.isBareSpecifier(specifier)) {
                                // If it's bare specifier, we do not rewrite it.
                                return undefined;
                            }
                            const rewritten = `__unresolved_${nSpecifier}`;
                            ++nSpecifier;
                            return rewritten;
                        },
                    })],
            ],
        });
        asserts_1.asserts(transformResult);
        asserts_1.asserts(transformResult.ast);
        return {
            transformResult: {
                ast: transformResult.ast,
                map: (_a = transformResult.map) !== null && _a !== void 0 ? _a : undefined,
            },
            specifiers,
        };
    }
    async _transform(url, ast, map, originalSource) {
        const babelResult = await babel.transformFromAstAsync(ast, originalSource, {
            sourceFileName: url.href,
            // cloneInputAst: false,
            configFile: false,
            sourceType: 'module',
            sourceMaps: this._sourceMaps,
            inputSourceMap: map,
            plugins: [
                [plugin_transform_modules_systemjs_1.default],
                // Dynamic import() transformation must be enabled using the
                // @babel/plugin-proposal-dynamic-import plugin. Babel 8 will
                // no longer transform import() without using that plugin.
                [plugin_proposal_dynamic_import_1.default],
            ],
        });
        asserts_1.asserts(babelResult);
        asserts_1.asserts(babelResult.code);
        return {
            code: babelResult.code,
            map: babelResult.map,
        };
    }
    async _resolve(specifier, parentURL, modLoMetadata) {
        const specifierValue = specifier.value;
        try {
            const resolved = await this._modLo.resolve(specifierValue, parentURL, modLoMetadata);
            if (this._verbose) {
                if (resolved.isExternal) {
                    this._logger.debug(`Resolve ${specifierValue} from ${parentURL.href} as external dependency ${resolved.specifierOrURL}.`);
                }
                else {
                    this._logger.debug(`Resolve ${specifierValue} from ${parentURL.href} as ${resolved.url}.`);
                }
            }
            return resolved;
        }
        catch (err) {
            this._logger.error(i18n_1.i18nTranslate('quick_pack_failed_to_resolve', { specifier: specifierValue, parentURL: parentURL.href, cause: err }));
            if (specifierValue.includes('/')) {
                const lastPortion = specifierValue.split('/').pop();
                if (lastPortion && !lastPortion.includes('.')) {
                    this._logger.warn(i18n_1.i18nTranslate('resolve_error_hint_extension'));
                }
            }
            return null;
        }
    }
    /**
     * Map the module URL to chunk URL.
     * @param url
     */
    _getChunkURL(_url) {
        // TODO: do it better
        let url;
        if (!_url.search) {
            url = _url;
        }
        else {
            const u = new url_1.URL(_url.href);
            const extensionName = url_2.parseExtensionName(u.pathname);
            url_2.replaceExtension(u, `.proxy${extensionName}`);
            url = u;
        }
        // 见：https://gist.github.com/shrinktofit/50f2380782b6219ed6a4cb3a210a75f7
        for (const [from, to] of this._extensionMapping) {
            if (url.pathname.endsWith(from)) {
                return url_2.assignPathname(new url_1.URL(url.href), `${url.pathname.substr(0, url.pathname.length - from.length)}${to}`);
            }
        }
        if (!url_2.parseExtensionName(url.pathname)) {
            // URLs with no extension are store as .js
            return url_2.assignPathname(new url_1.URL(url.href), `${url.pathname}.js`);
        }
        return url;
    }
}
exports.QuickPack = QuickPack;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicXVpY2stcGFjay5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9tb2QtYXNzZW1ibGluZy9xdWljay1wYWNrL3F1aWNrLXBhY2sudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLGdEQUFzQjtBQUN0Qix3REFBMEI7QUFDMUIsNkJBQXlDO0FBR3pDLG9EQUFzRDtBQUV0RCwyREFBdUQ7QUFDdkQsc0NBQWlHO0FBQ2pHLDRDQUF1RDtBQUN2RCxtREFBcUM7QUFDckMsbUJBQW1CO0FBQ25CLGlIQUFvRjtBQUNwRixtQkFBbUI7QUFDbkIsMkdBQXFGO0FBQ3JGLGlEQUE4QztBQUM5QywyREFBNEc7QUFDNUcsMERBQWdGO0FBRWhGLDJDQUFpRDtBQUVqRCxrREFBcUQ7QUFFckQsTUFBTSxXQUFXLEdBQUcsQ0FBQyxHQUFZLEVBQUUsRUFBRSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsa0NBQWtCLENBQUMsQ0FBQyxDQUFDLGtDQUFrQixDQUFDO0FBRXBGLE1BQU0sZUFBZSxHQUFHLFdBQVcsQ0FBQyxJQUFJLENBQUMsQ0FBQztBQUUxQyxNQUFhLFNBQVM7SUFDbEIsWUFBWSxFQUNSLEtBQUssRUFDTCxVQUFVLEVBQ1YsTUFBTSxFQUNOLFNBQVMsRUFDVCxPQUFPLEVBQ1AsTUFBTSxHQVFUO1FBNEdPLG1CQUFjLEdBQXdDLEVBQUUsQ0FBQztRQUV6RCxzQkFBaUIsR0FBNEI7WUFDakQsQ0FBQyxLQUFLLEVBQUUsS0FBSyxDQUFDO1lBQ2QsQ0FBQyxNQUFNLEVBQUUsS0FBSyxDQUFDO1NBQ2xCLENBQUM7UUFoSEUsSUFBSSxDQUFDLFFBQVEsR0FBRyxPQUFPLGFBQVAsT0FBTyxjQUFQLE9BQU8sR0FBSSxLQUFLLENBQUM7UUFDakMsSUFBSSxDQUFDLE9BQU8sR0FBRyxNQUFNLENBQUM7UUFDdEIsSUFBSSxDQUFDLE1BQU0sR0FBRyxLQUFLLENBQUM7UUFDcEIsSUFBSSxDQUFDLFdB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QyxRQUFRLENBQUMsQ0FBQztZQUNyRCxzQkFBZ0IsQ0FBQyxDQUFDLEVBQUUsU0FBUyxhQUFhLEVBQUUsQ0FBQyxDQUFDO1lBQzlDLEdBQUcsR0FBRyxDQUFDLENBQUM7U0FDWDtRQUVELHlFQUF5RTtRQUN6RSxLQUFLLE1BQU0sQ0FBQyxJQUFJLEVBQUUsRUFBRSxDQUFDLElBQUksSUFBSSxDQUFDLGlCQUFpQixFQUFFO1lBQzdDLElBQUksR0FBRyxDQUFDLFFBQVEsQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLEVBQUU7Z0JBQzdCLE9BQU8sb0JBQWMsQ0FDakIsSUFBSSxTQUFHLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxFQUNqQixHQUFHLEdBQUcsQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDLENBQUMsRUFBRSxHQUFHLENBQUMsUUFBUSxDQUFDLE1BQU0sR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLEdBQUcsRUFBRSxFQUFFLENBQ3RFLENBQUM7YUFDTDtTQUNKO1FBQ0QsSUFBSSxDQUFDLHdCQUFrQixDQUFDLEdBQUcsQ0FBQyxRQUFRLENBQUMsRUFBRTtZQUNuQywwQ0FBMEM7WUFDMUMsT0FBTyxvQkFBYyxDQUNqQixJQUFJLFNBQUcsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLEVBQ2pCLEdBQUcsR0FBRyxDQUFDLFFBQVEsS0FBSyxDQUN2QixDQUFDO1NBQ0w7UUFDRCxPQUFPLEdBQUcsQ0FBQztJQUNmLENBQUM7Q0FDSjtBQTlkRCw4QkE4ZEMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgcHMgZnJvbSAncGF0aCc7XG5pbXBvcnQgZnMgZnJvbSAnZnMtZXh0cmEnO1xuaW1wb3J0IHsgcGF0aFRvRmlsZVVSTCwgVVJMIH0gZnJvbSAndXJsJztcbmltcG9ydCB7IE1vZExvTWV0YWRhdGEsIE1vZExvLCBSZXNvbHZlUmVzdWx0LCBTb3VyY2UsIEFzdCwgU291cmNlTWFwLCBNb2QgfSBmcm9tICcuLi9tb2QtbG8vbW9kLWxvJztcbmltcG9ydCB7IE1vZHVsZVJlY29yZCB9IGZyb20gJy4vdXRpbHMvbW9kLXJlY29yZCc7XG5pbXBvcnQgeyBDaHVua1dyaXRlciB9IGZyb20gJy4vdXRpbHMvY2h1bmstaW8vd3JpdGVyJztcbmltcG9ydCB7IENodW5rSWQgfSBmcm9tICcuL3V0aWxzL2NodW5rLWlkJztcbmltcG9ydCB7IExvYWRlckNvbnRleHQgfSBmcm9tICcuL3V0aWxzL2xvYWRlci1jb250ZXh0JztcbmltcG9ydCB7IGFzc2lnblBhdGhuYW1lLCBwYXJzZUV4dGVuc2lvbk5hbWUsIHJlcGxhY2VFeHRlbnNpb24sIHRyeVBhcnNlVVJMIH0gZnJvbSAnLi4vdXRpbHMvdXJsJztcbmltcG9ydCB7IGNyZWF0ZUxvZ2dlciwgTG9nZ2VyIH0gZnJvbSAnLi4vdXRpbHMvbG9nZ2VyJztcbmltcG9ydCAqIGFzIGJhYmVsIGZyb20gJ0BiYWJlbC9jb3JlJztcbi8vIEB0cy1leHBlY3QtZXJyb3JcbmltcG9ydCBiYWJlbFBsdWdpblRyYW5zZm9ybVN5c3RlbUpzIGZyb20gJ0BiYWJlbC9wbHVnaW4tdHJhbnNmb3JtLW1vZHVsZXMtc3lzdGVtanMnO1xuLy8gQHRzLWV4cGVjdC1lcnJvclxuaW1wb3J0IGJhYmVsUGx1Z2luUHJvcG9zYWxEeW5hbWljSW1wb3J0IGZyb20gJ0BiYWJlbC9wbHVnaW4tcHJvcG9zYWwtZHluYW1pYy1pbXBvcnQnO1xuaW1wb3J0IHsgYXNzZXJ0cyB9IGZyb20gJy4uLy4uL3V0aWxzL2Fzc2VydHMnO1xuaW1wb3J0IHsgY3JlYXRlQmFiZWxQbHVnaW5EZXRlY3RBbmRSZXdyaXRlSW1wb3J0cywgZGV0ZWN0SW1wb3J0cywgU3BlY2lmaWVyIH0gZnJvbSAnLi91dGlscy9kZXRlY3QtaW1wb3J0cyc7XG5pbXBvcnQgeyBwYXJhbGxlbERpc2NhcmRpbmcsIHNlcXVlbmNlRGlzY2FyZGluZyB9IGZyb20gJy4uL3V0aWxzL2xhdW5jaC1wb2xpY3knO1xuaW1wb3J0IHsgUmF3U291cmNlTWFwIH0gZnJvbSAnc291cmNlLW1hcCc7XG5pbXBvcnQgeyBpMThuVHJhbnNsYXRlIH0gZnJvbSAnLi4vLi4vdXRpbHMvaTE4bic7XG5pbXBvcnQgeyBDaHVuayB9IGZyb20gJy4vdXRpbHMvY2h1bmsnO1xuaW1wb3J0IHsgaXNCYXJlU3BlY2lmaWVyIH0gZnJvbSAnLi4vdXRpbHMvc3BlY2lmaWVyJztcblxuY29uc3QgZ2V0TGF1bmNoZXIgPSAocGFyOiBib29sZWFuKSA9PiBwYXIgPyBwYXJhbGxlbERpc2NhcmRpbmcgOiBzZXF1ZW5jZURpc2NhcmRpbmc7XG5cbmNvbnN0IHJlc29sdmVMYXVuY2hlciA9IGdldExhdW5jaGVyKHRydWUpO1xuXG5leHBvcnQgY2xhc3MgUXVpY2tQYWNrIHtcbiAgICBjb25zdHJ1Y3Rvcih7XG4gICAgICAgIG1vZExvLFxuICAgICAgICBzb3VyY2VNYXBzLFxuICAgICAgICBvcmlnaW4sXG4gICAgICAgIHdvcmtzcGFjZSxcbiAgICAgICAgdmVyYm9zZSxcbiAgICAgICAgbG9nZ2VyLFxuICAgIH06IHtcbiAgICAgICAgbW9kTG86IE1vZExvO1xuICAgICAgICBzb3VyY2VNYXBzPzogYm9vbGVhbiB8ICdpbmxpbmUnO1xuICAgICAgICBvcmlnaW46IHN0cmluZztcbiAgICAgICAgd29ya3NwYWNlOiBzdHJpbmc7XG4gICAgICAgIHZlcmJvc2U/OiBib29sZWFuO1xuICAgICAgICBsb2dnZXI/OiBMb2dnZXI7XG4gICAgfSkge1xuICAgICAgICB0aGlzLl92ZXJib3NlID0gdmVyYm9zZSA/PyBmYWxzZTtcbiAgICAgICAgdGhpcy5fb3JpZ2luID0gb3JpZ2luO1xuICAgICAgICB0aGlzLl9tb2RMbyA9IG1vZExvO1xuICAgICAgICB0aGlzLl9zb3VyY2VNYXBzID0gc291cmNlTWFwcyA/PyB0cnVlO1xuICAgICAgICB0aGlzLl9tb2R1bGVSZWNvcmRGaWxlID0gcHMuam9pbih3b3Jrc3BhY2UsICdtb2R1bGVzLmpzb24nKTtcbiAgICAgICAgdGhpcy5fY2h1bmtSZWNvcmRGaWxlID0gcHMuam9pbih3b3Jrc3BhY2UsICdjaHVua3MuanNvbicpO1xuICAgICAgICB0aGlzLl9zb3VyY2VDYWNoZURpciA9IHBzLmpvaW4od29ya3NwYWNlLCAnbW9kcycpO1xuICAgICAgICBjb25zdCBpbXBvcnRNYXBGaWxlID0gcHMuam9pbih3b3Jrc3BhY2UsICdpbXBvcnQtbWFwLmpzb24nKTtcbiAgICAgICAgdGhpcy5faW1wb3J0TWFwRmlsZSA9IGltcG9ydE1hcEZpbGU7XG4gICAgICAgIGNvbnN0IHRoZUxvZ2dlciA9IGxvZ2dlciA/PyBjcmVhdGVMb2dnZXIoe30pO1xuICAgICAgICB0aGlzLl9jaHVua1dyaXRlciA9IG5ldyBDaHVua1dyaXRlcih7XG4gICAgICAgICAgICBvcmlnaW4sXG4gICAgICAgICAgICBjaHVua1JlY29yZEZpbGU6IHRoaXMuX2NodW5rUmVjb3JkRmlsZSxcbiAgICAgICAgICAgIHNvdXJjZUNhY2hlRGlyOiB0aGlzLl9zb3VyY2VDYWNoZURpcixcbiAgICAgICAgICAgIGltcG9ydE1hcEZpbGUsXG4gICAgICAgICAgICBsb2dnZXI6IHRoZUxvZ2dlcixcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX2xvZ2dlciA9IHRoZUxvZ2dlcjtcbiAgICB9XG5cbiAgICBwdWJsaWMgYXN5bmMgYnVpbGQoc3BlY2lmaWVyczogSXRlcmFibGU8c3RyaW5nIHwgVVJMPiwgb3B0aW9ucz86IHtcbiAgICAgICAgZm9yY2VBbGw/OiBib29sZWFuO1xuICAgICAgICByZXRyeVJlc29sdXRpb25PblVuY2hhbmdlZE1vZHVsZT86IGJvb2xlYW47XG4gICAgfSkge1xuICAgICAgICBjb25zdCBjb250ZXh0OiBJbnNwZWN0Q29udGV4dCA9IHtcbiAgICAgICAgICAgIG1vZHVsZXM6IG5ldyBNYXAoKSxcbiAgICAgICAgICAgIGZvcmNlQWxsOiBvcHRpb25zPy5mb3JjZUFsbCA/PyBmYWxzZSxcbiAgICAgICAgICAgIHJldHJ5UmVzb2x1dGlvbk9uVW5jaGFuZ2VkTW9kdWxlOiBvcHRpb25zPy5yZXRyeVJlc29sdXRpb25PblVuY2hhbmdlZE1vZHVsZSA/PyBmYWxzZSxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgZW50cnlNb2R1bGVSZWNvcmRzOiBBcnJheTxbVVJMLCBNb2R1bGVSZWNvcmRdPiA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IHNwZWNpZmllciBvZiBzcGVjaWZpZXJzKSB7XG4gICAgICAgICAgICBjb25zdCB1cmwgPSB0eXBlb2Ygc3BlY2lmaWVyID09PSAnc3RyaW5nJ1xuICAgICAgICAgICAgICAgID8gYXdhaXQgdGhpcy5fcmVzb2x2ZUVudHJ5KHNwZWNpZmllcilcbiAgICAgICAgICAgICAgICA6IHNwZWNpZmllcjtcbiAgICAgICAgICAgIGlmICghdXJsKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBpbnNwZWN0UmVjb3JkID0gYXdhaXQgdGhpcy5fZ2V0T3JDcmVhdGVJbnNwZWN0UmVjb3JkKHVybCwgY29udGV4dCk7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9pbnN0YW50aWF0ZUFsbChpbnNwZWN0UmVjb3JkLCBuZXcgU2V0KCkpO1xuICAgICAgICAgICAgY29uc3QgbW9kdWxlUmVjb3JkID0gdGhpcy5fbW9kdWxlUmVjb3Jkc1t1cmwuaHJlZl07XG4gICAgICAgICAgICBpZiAoIW1vZHVsZVJlY29yZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2xvZ2dlci5kZWJ1ZyhgRW50cnkgJHt1cmx9IGRpZCBub3QgbGlicmFyeSBhIGNodW5rLmApO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZW50cnlNb2R1bGVSZWNvcmRzLnB1c2goW3VybCwgbW9kdWxlUmVjb3JkXSk7XG4gICAgICAgICAgICBjb25zdCBjaHVuayA9IGF3YWl0IHRoaXMuX2NodW5rV3JpdGVyLmdldENodW5rKG1vZHVsZVJlY29yZC5jaHVua0lkKTtcbiAgICAgICAgICAgIGFzc2VydHMoY2h1bmspO1xuICAgICAgICAgICAgY2h1bmsuaXNFbnRyeSA9IHRydWU7XG4gICAgICAgICAgICBjaHVuay5leHBvc2VBcyA9IHVybC5ocmVmO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IGZzLm91dHB1dEpzb24odGhpcy5fbW9kdWxlUmVjb3JkRmlsZSwgdGhpcy5fbW9kdWxlUmVjb3JkcywgeyBlbmNvZGluZzogJ3V0ZjgnLCBzcGFjZXM6IDIgfSk7XG5cbiAgICAgICAgY29uc3QgY2h1bmtBbGlhczogUmVjb3JkPHN0cmluZywgQ2h1bmtJZD4gPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCBbZW50cnlVUkwsIGVudHJ5TW9kdWxlUmVjb3JkXSBvZiBlbnRyeU1vZHVsZVJlY29yZHMpIHtcbiAgICAgICAgICAgIGNvbnN0IGNodW5rSWQgPSBlbnRyeU1vZHVsZVJlY29yZC5jaHVua0lkO1xuICAgICAgICAgICAgY2h1bmtBbGlhc1tlbnRyeVVSTC5ocmVmXSA9IGNodW5rSWQ7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgdGhpcy5fY2h1bmtXcml0ZXIuc3luY0NodW5rKGNodW5rQWxpYXMpO1xuICAgIH1cblxuICAgIHB1YmxpYyBhc3luYyBjcmVhdGVMb2FkZXJDb250ZXh0KCkge1xuICAgICAgICByZXR1cm4gbmV3IExvYWRlckNvbnRleHQoXG4gICAgICAgICAgICB0aGlzLl9vcmlnaW4sXG4gICAgICAgICAgICB0aGlzLl9jaHVua1JlY29yZEZpbGUsXG4gICAgICAgICAgICB0aGlzLl9zb3VyY2VDYWNoZURpcixcbiAgICAgICAgICAgIHRoaXMuX2ltcG9ydE1hcEZpbGUsXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgcHVibGljIGFzeW5jIGNsZWFyKCkge1xuICAgICAgICB0aGlzLl9tb2R1bGVSZWNvcmRzID0ge307XG4gICAgICAgIGNvbnN0IG1vZHVsZVJlY29yZEZpbGUgPSB0aGlzLl9tb2R1bGVSZWNvcmRGaWxlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXdhaXQgZnMudW5saW5rKG1vZHVsZVJlY29yZEZpbGUpO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHRoaXMuX2xvZ2dlci5kZWJ1ZyhgRmFpbGVkIHRvIGRlbGV0ZSBtb2R1bGUgcmVjb3JkIGZpbGUgJHttb2R1bGVSZWNvcmRGaWxlfTogJHtlcnJ9YCk7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgdGhpcy5fY2h1bmtXcml0ZXIuY2xlYXIoKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgYXN5bmMgbG9hZENhY2hlKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3Qgc2VyaWFsaXplZE1vZHVsZVJlY29yZHM6IFJlY29yZDxzdHJpbmcsIE1vZHVsZVJlY29yZD4gPSBhd2FpdCBmcy5yZWFkSnNvbih0aGlzLl9tb2R1bGVSZWNvcmRGaWxlKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgbW9kdWxlUmVjb3JkIG9mIE9iamVjdC52YWx1ZXMoc2VyaWFsaXplZE1vZHVsZVJlY29yZHMpKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1vZHVsZVJlY29yZC5yZXNvbHZlZEltcG9ydHMpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCByZXNvbHZlUmVzdWx0IG9mIG1vZHVsZVJlY29yZC5yZXNvbHZlZEltcG9ydHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXNvbHZlUmVzdWx0ICYmICFyZXNvbHZlUmVzdWx0LmlzRXh0ZXJuYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlUmVzdWx0LnVybCA9IG5ldyBVUkwocmVzb2x2ZVJlc3VsdC51cmwgYXMgdW5rbm93biBhcyBzdHJpbmcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fbW9kdWxlUmVjb3JkcyA9IHNlcmlhbGl6ZWRNb2R1bGVSZWNvcmRzO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHRoaXMuX2xvZ2dlci5kZWJ1ZyhgTW9kdWxlIHJlY29yZCBmaWxlIGxvYWRlZCBmYWlsZWQgd2l0aCBlcnJvcjogJHtlcnJ9YCk7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgdGhpcy5fY2h1bmtXcml0ZXIubG9hZENhY2hlKCk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBfdmVyYm9zZTogYm9vbGVhbjtcbiAgICBwcml2YXRlIF9vcmlnaW46IHN0cmluZztcbiAgICBwcml2YXRlIF9tb2R1bGVSZWNvcmRGaWxlOiBzdHJpbmc7XG4gICAgcHJpdmF0ZSBfY2h1bmtSZWNvcmRGaWxlOiBzdHJpbmc7XG4gICAgcHJpdmF0ZSBfc291cmNlQ2FjaGVEaXI6IHN0cmluZztcbiAgICBwcml2YXRlIF9pbXBvcnRNYXBGaWxlOiBzdHJpbmc7XG4gICAgcHJpdmF0ZSBfbW9kTG86IE1vZExvO1xuICAgIHByaXZhdGUgX3NvdXJjZU1hcHM6IGJvb2xlYW4gfCAnaW5saW5lJztcbiAgICBwcml2YXRlIF9tb2R1bGVSZWNvcmRzOiBSZWNvcmQ8c3RyaW5nLCBNb2R1bGVSZWNvcmQgfCBudWxsPiA9IHt9O1xuICAgIHByaXZhdGUgX2NodW5rV3JpdGVyOiBDaHVua1dyaXRlcjtcbiAgICBwcml2YXRlIF9leHRlbnNpb25NYXBwaW5nOiBBcnJheTxbc3RyaW5nLCBzdHJpbmddPiA9IFtcbiAgICAgICAgWycudHMnLCAnLmpzJ10sXG4gICAgICAgIFsnLm1qcycsICcuanMnXSxcbiAgICBdO1xuICAgIHByaXZhdGUgX2xvZ2dlcjogTG9nZ2VyO1xuXG4gICAgcHJpdmF0ZSBhc3luYyBfcmVzb2x2ZUVudHJ5KHNwZWNpZmllcjogc3RyaW5nKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFVSTChzcGVjaWZpZXIpO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHRoaXMuX2xvZ2dlci5lcnJvcihpMThuVHJhbnNsYXRlKCdxdWlja19wYWNrX2NvdWxkX25vdF9yZXNvbHZlX2VudHJ5JywgeyBzcGVjaWZpZXIgfSkpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBhc3luYyBfZ2V0T3JDcmVhdGVJbnNwZWN0UmVjb3JkKHVybDogVVJMLCBjb250ZXh0OiBJbnNwZWN0Q29udGV4dCkge1xuICAgICAgICBjb25zdCBleGlzdGVkSW5zcGVjdFJlY29yZCA9IGNvbnRleHQubW9kdWxlcy5nZXQodXJsLmhyZWYpO1xuICAgICAgICBpZiAoZXhpc3RlZEluc3BlY3RSZWNvcmQpIHtcbiAgICAgICAgICAgIHJldHVybiBleGlzdGVkSW5zcGVjdFJlY29yZDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItY29uc3RcbiAgICAgICAgbGV0IGluc3BlY3RSZWNvcmQ6IEluc3BlY3RSZWNvcmQ7XG5cbiAgICAgICAgY29uc3QgaW5zcGVjdFByb21pc2UgPSB0aGlzLl9pbnNwZWN0V2l0aENhY2hlKHVybCk7XG4gICAgICAgIGNvbnN0IGxpbmtQcm9taXNlID0gaW5zcGVjdFByb21pc2UudGhlbihhc3luYyAobW9kdWxlSW5zcGVjdEluZm8pID0+IHtcbiAgICAgICAgICAgIGlmIChtb2R1bGVJbnNwZWN0SW5mbyAmJiAobW9kdWxlSW5zcGVjdEluZm8udXBkYXRlZCB8fCBjb250ZXh0LmZvcmNlQWxsKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRlcGVuZGVuY2llcyA9IGF3YWl0IHRoaXMuX2xpbmsodXJsLCBtb2R1bGVJbnNwZWN0SW5mby5tb2R1bGVSZWNvcmQsIGNvbnRleHQpO1xuICAgICAgICAgICAgICAgIGluc3BlY3RSZWNvcmQuZGVwZW5kZW5jaWVzID0gZGVwZW5kZW5jaWVzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBpbnNwZWN0UmVjb3JkID0ge1xuICAgICAgICAgICAgaW5zcGVjdDogaW5zcGVjdFByb21pc2UsXG4gICAgICAgICAgICBsaW5rOiBsaW5rUHJvbWlzZSxcbiAgICAgICAgICAgIGRlcGVuZGVuY2llczogdW5kZWZpbmVkLFxuICAgICAgICB9O1xuICAgICAgICBjb250ZXh0Lm1vZHVsZXMuc2V0KHVybC5ocmVmLCBpbnNwZWN0UmVjb3JkKTtcbiAgICAgICAgcmV0dXJuIGluc3BlY3RSZWNvcmQ7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBhc3luYyBfaW5zdGFudGlhdGVBbGwoaW5zcGVjdFJlY29yZDogSW5zcGVjdFJlY29yZCwgdmlzaXRlZDogU2V0PEluc3BlY3RSZWNvcmQ+KSB7XG4gICAgICAgIGlmICh2aXNpdGVkLmhhcyhpbnNwZWN0UmVjb3JkKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZpc2l0ZWQuYWRkKGluc3BlY3RSZWNvcmQpO1xuICAgICAgICBhd2FpdCBpbnNwZWN0UmVjb3JkLmxpbms7XG4gICAgICAgIGlmIChpbnNwZWN0UmVjb3JkLmRlcGVuZGVuY2llcykge1xuICAgICAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoaW5zcGVjdFJlY29yZC5kZXBlbmRlbmNpZXMubWFwKGFzeW5jIChkZXBlbmRlbmN5KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGRlcGVuZGVuY3kpIHtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5faW5zdGFudGlhdGVBbGwoZGVwZW5kZW5jeSwgdmlzaXRlZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBhc3luYyBfaW5zcGVjdFdpdGhDYWNoZSh1cmw6IFVSTCkge1xuICAgICAgICBjb25zdCBtVGltZXN0YW1wID0gYXdhaXQgdGhpcy5fbW9kTG8uZ2V0TVRpbWVzdGFtcCh1cmwpO1xuICAgICAgICBjb25zdCBvbGRNb2R1bGVSZWNvcmQgPSB0aGlzLl9tb2R1bGVSZWNvcmRzW3VybC5ocmVmXTtcbiAgICAgICAgaWYgKG9sZE1vZHVsZVJlY29yZCkge1xuICAgICAgICAgICAgaWYgKG1UaW1lc3RhbXAgPT09IG9sZE1vZHVsZVJlY29yZC5tVGltZXN0YW1wKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgbW9kdWxlUmVjb3JkOiBvbGRNb2R1bGVSZWNvcmQsIHVwZGF0ZWQ6IGZhbHNlIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9sb2dnZXIuZGVidWcoYERldGVjdGVkIGNoYW5nZTogJHt1cmx9LiBMYXN0IG10aW1lOiAke25ldyBEYXRlKG9sZE1vZHVsZVJlY29yZC5tVGltZXN0YW1wKX0sIEN1cnJlbnQgbXRpbWU6ICR7bmV3IERhdGUobVRpbWVzdGFtcCl9YCk7XG4gICAgICAgICAgICB0aGlzLl9tb2R1bGVSZWNvcmRzW3VybC5ocmVmXSA9IG51bGw7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9jaHVua1dyaXRlci5yZW1vdmVDaHVuayhvbGRNb2R1bGVSZWNvcmQuY2h1bmtJZCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fdmVyYm9zZSkge1xuICAgICAgICAgICAgdGhpcy5fbG9nZ2VyLmRlYnVnKGBJbnNwZWN0ICR7dXJsfWApO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgbW9kdWxlUmVjb3JkID0gYXdhaXQgdGhpcy5faW5zcGVjdCh1cmwsIG1UaW1lc3RhbXApLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX2xvZ2dlci5lcnJvcihlcnIpO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCFtb2R1bGVSZWNvcmQpIHtcbiAgICAgICAgICAgIC8vIE1vZHVsZSByZWNvcmQgaXMgaW52YWxpZCBvciBjYWNoZSBpcyB2YWxpZFxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7IG1vZHVsZVJlY29yZCwgdXBkYXRlZDogdHJ1ZSB9O1xuICAgIH1cblxuICAgIHByaXZhdGUgYXN5bmMgX2xpbmsodXJsOiBVUkwsIG1vZHVsZVJlY29yZDogTW9kdWxlUmVjb3JkLCBjb250ZXh0OiBJbnNwZWN0Q29udGV4dCkge1xuICAgICAgICBjb25zdCBjaHVua0ltcG9ydHM6IENodW5rWydpbXBvcnRzJ10gPSB7fTtcblxuICAgICAgICBsZXQgZm9yY2VSZXNvbHZlID0gZmFsc2U7XG4gICAgICAgIGlmICghbW9kdWxlUmVjb3JkLnJlc29sdmVkSW1wb3J0cykge1xuICAgICAgICAgICAgZm9yY2VSZXNvbHZlID0gdHJ1ZTtcbiAgICAgICAgICAgIG1vZHVsZVJlY29yZC5yZXNvbHZlZEltcG9ydHMgPSBuZXcgQXJyYXkobW9kdWxlUmVjb3JkLmltcG9ydHMubGVuZ3RoKS5maWxsKG51bGwpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcmVzb2x2ZWRJbXBvcnRzID0gbW9kdWxlUmVjb3JkLnJlc29sdmVkSW1wb3J0cztcblxuICAgICAgICBjb25zdCBkZXBSZWNvcmRzID0gYXdhaXQgUHJvbWlzZS5hbGwobW9kdWxlUmVjb3JkLmltcG9ydHMubWFwKGFzeW5jIChzcGVjaWZpZXIsIGlJbXBvcnQpOiBQcm9taXNlPHVuZGVmaW5lZCB8IEluc3BlY3RSZWNvcmQ+ID0+IHtcbiAgICAgICAgICAgIGxldCByZXNvbHZlZCA9IHJlc29sdmVkSW1wb3J0c1tpSW1wb3J0XTtcbiAgICAgICAgICAgIGlmIChmb3JjZVJlc29sdmUgfHwgLy8gTm90IHJlc29sdmVkIGJlZm9yZVxuICAgICAgICAgICAgICAgIHJlc29sdmVkID09PSBudWxsICYmIGNvbnRleHQucmV0cnlSZXNvbHV0aW9uT25VbmNoYW5nZWRNb2R1bGUgLy8gUmVzb2x2ZWQgYnV0IGZhaWxlZFxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZWQgPSBhd2FpdCB0aGlzLl9yZXNvbHZlKHNwZWNpZmllciwgdXJsLCBtb2R1bGVSZWNvcmQubW9kTG9NZXRhZGF0YSk7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZWRJbXBvcnRzW2lJbXBvcnRdID0gcmVzb2x2ZWQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghcmVzb2x2ZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IGNodW5rSW1wb3J0S2V5ID0gc3BlY2lmaWVyLnJld3JpdHRlbiA/PyBzcGVjaWZpZXIudmFsdWU7XG5cbiAgICAgICAgICAgIGlmIChyZXNvbHZlZC5pc0V4dGVybmFsKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaXNSZXNvbHZlZFRvQmFyZSA9ICF0cnlQYXJzZVVSTChyZXNvbHZlZC5zcGVjaWZpZXJPclVSTCk7XG4gICAgICAgICAgICAgICAgaWYgKGlzUmVzb2x2ZWRUb0JhcmUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gT25seSBiYXJlIHNwZWNpZmllciBtYXkgcmVzb2x2ZWQgdG8gYmFyZVxuICAgICAgICAgICAgICAgICAgICBhc3NlcnRzKCFzcGVjaWZpZXIucmV3cml0dGVuLCBgU29tZXRoaW5nIHdyb25nIHdpdGggcmV3cml0aW5nIGFuZCByZXNvbHZlICR7c3BlY2lmaWVyLnZhbHVlfWApO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNodW5rSW1wb3J0c1tjaHVua0ltcG9ydEtleV0gPSB7XG4gICAgICAgICAgICAgICAgICAgIGV4dGVybmFsOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICB1cmw6IHJlc29sdmVkLnNwZWNpZmllck9yVVJMLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCB7IHVybDogcmVzb2x2ZWRVUkwgfSA9IHJlc29sdmVkO1xuXG4gICAgICAgICAgICBjb25zdCBpbnNwZWN0UmVjb3JkID0gYXdhaXQgdGhpcy5fZ2V0T3JDcmVhdGVJbnNwZWN0UmVjb3JkKHJlc29sdmVkVVJMLCBjb250ZXh0KTtcbiAgICAgICAgICAgIGF3YWl0IGluc3BlY3RSZWNvcmQuaW5zcGVjdDtcblxuICAgICAgICAgICAgY29uc3QgcmVzb2x2ZWRDaHVuayA9IHRoaXMuX21vZHVsZVJlY29yZHNbcmVzb2x2ZWRVUkwuaHJlZl0/LmNodW5rSWQ7XG4gICAgICAgICAgICBpZiAocmVzb2x2ZWRDaHVuaykge1xuICAgICAgICAgICAgICAgIGNodW5rSW1wb3J0c1tjaHVua0ltcG9ydEtleV0gPSByZXNvbHZlZENodW5rO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9sb2dnZXIuZGVidWcoYFdlJ3JlIG1pc3NpbmcgdGhlIGNodW5rICR7cmVzb2x2ZWRVUkwuaHJlZn0sIHJlZmVyZW5jZWQgYXMgJyR7c3BlY2lmaWVyfScuYCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBpbnNwZWN0UmVjb3JkO1xuICAgICAgICB9KSk7XG5cbiAgICAgICAgY29uc3QgY2h1bmsgPSBhd2FpdCB0aGlzLl9jaHVua1dyaXRlci5nZXRDaHVuayhtb2R1bGVSZWNvcmQuY2h1bmtJZCk7XG4gICAgICAgIGFzc2VydHMoY2h1bmspO1xuICAgICAgICBjaHVuay5pbXBvcnRzID0gY2h1bmtJbXBvcnRzO1xuXG4gICAgICAgIHJldHVybiBkZXBSZWNvcmRzO1xuICAgIH1cblxuICAgIHByaXZhdGUgYXN5bmMgX2luc3BlY3QodXJsOiBVUkwsIG1UaW1lc3RhbXA6IG51bWJlcikge1xuICAgICAgICBsZXQgbW9kOiBNb2Q7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBtb2QgPSBhd2FpdCB0aGlzLl9tb2RMby5sb2FkKHVybCk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgdGhpcy5fbG9nZ2VyLmVycm9yKGkxOG5UcmFuc2xhdGUoJ3F1aWNrX3BhY2tfZmFpbGVkX3RvX2xvYWQnLCB7IHVybDogdXJsLmhyZWYsIGNhdXNlOiBlcnIgfSkpO1xuICAgICAgICAgICAgaWYgKHVybC5wcm90b2NvbCA9PT0gJ25vZGU6Jykge1xuICAgICAgICAgICAgICAgIHRoaXMuX2xvZ2dlci53YXJuKGkxOG5UcmFuc2xhdGUoJ2xvYWRfZXJyb3JfaGludF9ub2RlX2J1aWx0aW4nKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICBvcmlnaW5hbFNvdXJjZSxcbiAgICAgICAgICAgIGNvZGUsXG4gICAgICAgICAgICBtb2RMb01ldGFkYXRhLFxuICAgICAgICB9ID0gbW9kO1xuXG4gICAgICAgIGxldCB7XG4gICAgICAgICAgICBtYXAsXG4gICAgICAgIH0gPSBtb2Q7XG5cbiAgICAgICAgbGV0IGFzdDogQXN0O1xuICAgICAgICBpZiAodHlwZW9mIGNvZGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAvLyBUT0RPOiBpbnB1dCBzb3VyY2UgbWFwXG4gICAgICAgICAgICBhc3QgPSBhd2FpdCB0aGlzLl9tb2RMby5wYXJzZShjb2RlLCBtYXApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYXN0ID0gY29kZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGNodW5rVVJMID0gdGhpcy5fZ2V0Q2h1bmtVUkwodXJsKTtcblxuICAgICAgICBjb25zdCBjaHVua0lkID0gdGhpcy5fY2h1bmtXcml0ZXIuZ2V0Q2h1bmtJZChjaHVua1VSTCk7XG5cbiAgICAgICAgbGV0IHNwZWNpZmllcnM6IFNwZWNpZmllcltdID0gW107XG4gICAgICAgICh7IHRyYW5zZm9ybVJlc3VsdDogeyBhc3QsIG1hcCB9LCBzcGVjaWZpZXJzIH0gPSBhd2FpdCB0aGlzLl9yZXdyaXRlSW1wb3J0cyhcbiAgICAgICAgICAgIHVybCxcbiAgICAgICAgICAgIGFzdCxcbiAgICAgICAgICAgIHR5cGVvZiBtYXAgPT09ICdzdHJpbmcnID8gSlNPTi5wYXJzZShtYXApIDogbWFwID8/IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIG9yaWdpbmFsU291cmNlLFxuICAgICAgICApKTtcblxuICAgICAgICBhd2FpdCB0aGlzLl90cmFuc2Zvcm1BbmRBZGQoXG4gICAgICAgICAgICBjaHVua0lkLFxuICAgICAgICAgICAgdXJsLFxuICAgICAgICAgICAgYXN0LFxuICAgICAgICAgICAgdHlwZW9mIG1hcCA9PT0gJ3N0cmluZycgPyBKU09OLnBhcnNlKG1hcCkgOiBtYXAgPz8gdW5kZWZpbmVkLFxuICAgICAgICAgICAgb3JpZ2luYWxTb3VyY2UsXG4gICAgICAgICk7XG5cbiAgICAgICAgY29uc3QgbW9kdWxlUmVjb3JkOiBNb2R1bGVSZWNvcmQgPSB7XG4gICAgICAgICAgICBtVGltZXN0YW1wLFxuICAgICAgICAgICAgY2h1bmtJZCxcbiAgICAgICAgICAgIGltcG9ydHM6IHNwZWNpZmllcnMsXG4gICAgICAgICAgICBtb2RMb01ldGFkYXRhLFxuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuX21vZHVsZVJlY29yZHNbdXJsLmhyZWZdID0gbW9kdWxlUmVjb3JkO1xuXG4gICAgICAgIHJldHVybiBtb2R1bGVSZWNvcmQ7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBhc3luYyBfdHJhbnNmb3JtQW5kQWRkKGNodW5rSWQ6IHN0cmluZywgdXJsOiBVUkwsIGFzdDogQXN0LCBtYXA6IFJhd1NvdXJjZU1hcCB8IHVuZGVmaW5lZCwgb3JpZ2luYWxTb3VyY2U6IHN0cmluZykge1xuICAgICAgICBjb25zdCB0cmFuc2Zvcm1lZCA9IGF3YWl0IHRoaXMuX3RyYW5zZm9ybSh1cmwsIGFzdCwgbWFwLCBvcmlnaW5hbFNvdXJjZSk7XG5cbiAgICAgICAgYXdhaXQgdGhpcy5fY2h1bmtXcml0ZXIuYWRkQ2h1bmsoXG4gICAgICAgICAgICBjaHVua0lkLFxuICAgICAgICAgICAgdHJhbnNmb3JtZWQuY29kZSxcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkLm1hcCxcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGFzeW5jIF9yZXdyaXRlSW1wb3J0cyh1cmw6IFVSTCwgYXN0OiBBc3QsIG1hcDogUmF3U291cmNlTWFwIHwgdW5kZWZpbmVkLCBvcmlnaW5hbFNvdXJjZTogc3RyaW5nKSB7XG4gICAgICAgIGNvbnN0IHNwZWNpZmllcnM6IFNwZWNpZmllcltdID0gW107XG5cbiAgICAgICAgbGV0IG5TcGVjaWZpZXIgPSAwO1xuXG4gICAgICAgIGNvbnN0IHRyYW5zZm9ybVJlc3VsdCA9IGF3YWl0IGJhYmVsLnRyYW5zZm9ybUZyb21Bc3RBc3luYyhcbiAgICAgICAgICAgIGFzdCwgb3JpZ2luYWxTb3VyY2UsIHtcbiAgICAgICAgICAgICAgICBhc3Q6IHRydWUsXG4gICAgICAgICAgICAgICAgY29kZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgc291cmNlRmlsZU5hbWU6IHVybC5ocmVmLFxuICAgICAgICAgICAgICAgIGNsb25lSW5wdXRBc3Q6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGNvbmZpZ0ZpbGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHNvdXJjZVR5cGU6ICdtb2R1bGUnLFxuICAgICAgICAgICAgICAgIHNvdXJjZU1hcHM6IHRoaXMuX3NvdXJjZU1hcHMsXG4gICAgICAgICAgICAgICAgaW5wdXRTb3VyY2VNYXA6IG1hcCxcbiAgICAgICAgICAgICAgICBwbHVnaW5zOiBbXG4gICAgICAgICAgICAgICAgICAgIFtjcmVhdGVCYWJlbFBsdWdpbkRldGVjdEFuZFJld3JpdGVJbXBvcnRzKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNwZWNpZmllcnMsXG4gICAgICAgICAgICAgICAgICAgICAgICByZXdyaXRlOiAoc3BlY2lmaWVyKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzQmFyZVNwZWNpZmllcihzcGVjaWZpZXIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIGl0J3MgYmFyZSBzcGVjaWZpZXIsIHdlIGRvIG5vdCByZXdyaXRlIGl0LlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZXdyaXR0ZW4gPSBgX191bnJlc29sdmVkXyR7blNwZWNpZmllcn1gO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICsrblNwZWNpZmllcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmV3cml0dGVuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgfSldLFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICB9IGFzIGJhYmVsLlRyYW5zZm9ybU9wdGlvbnMgJiB7XG4gICAgICAgICAgICAgICAgY2xvbmVJbnB1dEFzdD86IGJvb2xlYW47XG4gICAgICAgICAgICB9LFxuICAgICAgICApO1xuXG4gICAgICAgIGFzc2VydHModHJhbnNmb3JtUmVzdWx0KTtcbiAgICAgICAgYXNzZXJ0cyh0cmFuc2Zvcm1SZXN1bHQuYXN0KTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHJhbnNmb3JtUmVzdWx0OiB7XG4gICAgICAgICAgICAgICAgYXN0OiB0cmFuc2Zvcm1SZXN1bHQuYXN0LFxuICAgICAgICAgICAgICAgIG1hcDogKHRyYW5zZm9ybVJlc3VsdC5tYXAgYXMgU291cmNlTWFwIHwgdW5kZWZpbmVkKSA/PyB1bmRlZmluZWQsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc3BlY2lmaWVycyxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGFzeW5jIF90cmFuc2Zvcm0odXJsOiBVUkwsIGFzdDogQXN0LCBtYXA6IFJhd1NvdXJjZU1hcCB8IHVuZGVmaW5lZCwgb3JpZ2luYWxTb3VyY2U6IHN0cmluZykge1xuICAgICAgICBjb25zdCBiYWJlbFJlc3VsdCA9IGF3YWl0IGJhYmVsLnRyYW5zZm9ybUZyb21Bc3RBc3luYyhcbiAgICAgICAgICAgIGFzdCxcbiAgICAgICAgICAgIG9yaWdpbmFsU291cmNlLCB7XG4gICAgICAgICAgICAgICAgc291cmNlRmlsZU5hbWU6IHVybC5ocmVmLFxuICAgICAgICAgICAgICAgIC8vIGNsb25lSW5wdXRBc3Q6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGNvbmZpZ0ZpbGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHNvdXJjZVR5cGU6ICdtb2R1bGUnLFxuICAgICAgICAgICAgICAgIHNvdXJjZU1hcHM6IHRoaXMuX3NvdXJjZU1hcHMsXG4gICAgICAgICAgICAgICAgaW5wdXRTb3VyY2VNYXA6IG1hcCxcbiAgICAgICAgICAgICAgICBwbHVnaW5zOiBbXG4gICAgICAgICAgICAgICAgICAgIFtiYWJlbFBsdWdpblRyYW5zZm9ybVN5c3RlbUpzXSxcbiAgICAgICAgICAgICAgICAgICAgLy8gRHluYW1pYyBpbXBvcnQoKSB0cmFuc2Zvcm1hdGlvbiBtdXN0IGJlIGVuYWJsZWQgdXNpbmcgdGhlXG4gICAgICAgICAgICAgICAgICAgIC8vIEBiYWJlbC9wbHVnaW4tcHJvcG9zYWwtZHluYW1pYy1pbXBvcnQgcGx1Z2luLiBCYWJlbCA4IHdpbGxcbiAgICAgICAgICAgICAgICAgICAgLy8gbm8gbG9uZ2VyIHRyYW5zZm9ybSBpbXBvcnQoKSB3aXRob3V0IHVzaW5nIHRoYXQgcGx1Z2luLlxuICAgICAgICAgICAgICAgICAgICBbYmFiZWxQbHVnaW5Qcm9wb3NhbER5bmFtaWNJbXBvcnRdLFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICB9IGFzIGJhYmVsLlRyYW5zZm9ybU9wdGlvbnMgJiB7XG4gICAgICAgICAgICAgICAgY2xvbmVJbnB1dEFzdD86IGJvb2xlYW47XG4gICAgICAgICAgICB9LFxuICAgICAgICApO1xuICAgICAgICBhc3NlcnRzKGJhYmVsUmVzdWx0KTtcbiAgICAgICAgYXNzZXJ0cyhiYWJlbFJlc3VsdC5jb2RlKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNvZGU6IGJhYmVsUmVzdWx0LmNvZGUsXG4gICAgICAgICAgICBtYXA6IGJhYmVsUmVzdWx0Lm1hcCBhcyB1bmtub3duIGFzIFNvdXJjZU1hcCxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGFzeW5jIF9yZXNvbHZlKHNwZWNpZmllcjogU3BlY2lmaWVyLCBwYXJlbnRVUkw6IFVSTCwgbW9kTG9NZXRhZGF0YTogTW9kTG9NZXRhZGF0YSkge1xuICAgICAgICBjb25zdCBzcGVjaWZpZXJWYWx1ZSA9IHNwZWNpZmllci52YWx1ZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJlc29sdmVkID0gYXdhaXQgdGhpcy5fbW9kTG8ucmVzb2x2ZShzcGVjaWZpZXJWYWx1ZSwgcGFyZW50VVJMLCBtb2RMb01ldGFkYXRhKTtcbiAgICAgICAgICAgIGlmICh0aGlzLl92ZXJib3NlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlc29sdmVkLmlzRXh0ZXJuYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbG9nZ2VyLmRlYnVnKGBSZXNvbHZlICR7c3BlY2lmaWVyVmFsdWV9IGZyb20gJHtwYXJlbnRVUkwuaHJlZn0gYXMgZXh0ZXJuYWwgZGVwZW5kZW5jeSAke3Jlc29sdmVkLnNwZWNpZmllck9yVVJMfS5gKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9sb2dnZXIuZGVidWcoYFJlc29sdmUgJHtzcGVjaWZpZXJWYWx1ZX0gZnJvbSAke3BhcmVudFVSTC5ocmVmfSBhcyAke3Jlc29sdmVkLnVybH0uYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc29sdmVkO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHRoaXMuX2xvZ2dlci5lcnJvcihpMThuVHJhbnNsYXRlKFxuICAgICAgICAgICAgICAgICdxdWlja19wYWNrX2ZhaWxlZF90b19yZXNvbHZlJyxcbiAgICAgICAgICAgICAgICB7IHNwZWNpZmllcjogc3BlY2lmaWVyVmFsdWUsIHBhcmVudFVSTDogcGFyZW50VVJMLmhyZWYsIGNhdXNlOiBlcnIgfSxcbiAgICAgICAgICAgICkpO1xuICAgICAgICAgICAgaWYgKHNwZWNpZmllclZhbHVlLmluY2x1ZGVzKCcvJykpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBsYXN0UG9ydGlvbiA9IHNwZWNpZmllclZhbHVlLnNwbGl0KCcvJykucG9wKCk7XG4gICAgICAgICAgICAgICAgaWYgKGxhc3RQb3J0aW9uICYmICFsYXN0UG9ydGlvbi5pbmNsdWRlcygnLicpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2xvZ2dlci53YXJuKGkxOG5UcmFuc2xhdGUoJ3Jlc29sdmVfZXJyb3JfaGludF9leHRlbnNpb24nKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNYXAgdGhlIG1vZHVsZSBVUkwgdG8gY2h1bmsgVVJMLlxuICAgICAqIEBwYXJhbSB1cmwgXG4gICAgICovXG4gICAgcHJpdmF0ZSBfZ2V0Q2h1bmtVUkwoX3VybDogUmVhZG9ubHk8VVJMPik6IFJlYWRvbmx5PFVSTD4ge1xuICAgICAgICAvLyBUT0RPOiBkbyBpdCBiZXR0ZXJcbiAgICAgICAgbGV0IHVybDogUmVhZG9ubHk8VVJMPjtcbiAgICAgICAgaWYgKCFfdXJsLnNlYXJjaCkge1xuICAgICAgICAgICAgdXJsID0gX3VybDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHUgPSBuZXcgVVJMKF91cmwuaHJlZik7XG4gICAgICAgICAgICBjb25zdCBleHRlbnNpb25OYW1lID0gcGFyc2VFeHRlbnNpb25OYW1lKHUucGF0aG5hbWUpO1xuICAgICAgICAgICAgcmVwbGFjZUV4dGVuc2lvbih1LCBgLnByb3h5JHtleHRlbnNpb25OYW1lfWApO1xuICAgICAgICAgICAgdXJsID0gdTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIOinge+8mmh0dHBzOi8vZ2lzdC5naXRodWIuY29tL3Nocmlua3RvZml0LzUwZjIzODA3ODJiNjIxOWVkNmE0Y2IzYTIxMGE3NWY3XG4gICAgICAgIGZvciAoY29uc3QgW2Zyb20sIHRvXSBvZiB0aGlzLl9leHRlbnNpb25NYXBwaW5nKSB7XG4gICAgICAgICAgICBpZiAodXJsLnBhdGhuYW1lLmVuZHNXaXRoKGZyb20pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFzc2lnblBhdGhuYW1lKFxuICAgICAgICAgICAgICAgICAgICBuZXcgVVJMKHVybC5ocmVmKSxcbiAgICAgICAgICAgICAgICAgICAgYCR7dXJsLnBhdGhuYW1lLnN1YnN0cigwLCB1cmwucGF0aG5hbWUubGVuZ3RoIC0gZnJvbS5sZW5ndGgpfSR7dG99YCxcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghcGFyc2VFeHRlbnNpb25OYW1lKHVybC5wYXRobmFtZSkpIHtcbiAgICAgICAgICAgIC8vIFVSTHMgd2l0aCBubyBleHRlbnNpb24gYXJlIHN0b3JlIGFzIC5qc1xuICAgICAgICAgICAgcmV0dXJuIGFzc2lnblBhdGhuYW1lKFxuICAgICAgICAgICAgICAgIG5ldyBVUkwodXJsLmhyZWYpLFxuICAgICAgICAgICAgICAgIGAke3VybC5wYXRobmFtZX0uanNgXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1cmw7XG4gICAgfVxufVxuXG5pbnRlcmZhY2UgSW5zcGVjdFJlY29yZCB7XG4gICAgaW5zcGVjdDogUHJvbWlzZTx7IG1vZHVsZVJlY29yZDogTW9kdWxlUmVjb3JkOyB1cGRhdGVkOiBib29sZWFuOyB9IHwgdW5kZWZpbmVkPjtcbiAgICBsaW5rOiBQcm9taXNlPHZvaWQ+IHwgdW5kZWZpbmVkO1xuICAgIGRlcGVuZGVuY2llczogQXJyYXk8SW5zcGVjdFJlY29yZCB8IHVuZGVmaW5lZD4gfCB1bmRlZmluZWQ7XG59XG5cbmludGVyZmFjZSBJbnNwZWN0Q29udGV4dCB7XG4gICAgZm9yY2VBbGw6IGJvb2xlYW47XG4gICAgcmV0cnlSZXNvbHV0aW9uT25VbmNoYW5nZWRNb2R1bGU6IGJvb2xlYW47XG4gICAgbW9kdWxlczogTWFwPHN0cmluZywgSW5zcGVjdFJlY29yZD47XG59XG4iXX0=