"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.QuickPack = void 0;
const path_1 = __importDefault(require("path"));
const fs_extra_1 = __importDefault(require("fs-extra"));
const url_1 = require("url");
const mod_lo_1 = require("../mod-lo/mod-lo");
const writer_1 = require("./utils/chunk-io/writer");
const loader_context_1 = require("./utils/loader-context");
const url_2 = require("../utils/url");
const logger_1 = require("../utils/logger");
const babel = __importStar(require("@babel/core"));
// @ts-expect-error
const plugin_transform_modules_systemjs_1 = __importDefault(require("@babel/plugin-transform-modules-systemjs"));
// @ts-expect-error
const plugin_proposal_dynamic_import_1 = __importDefault(require("@babel/plugin-proposal-dynamic-import"));
const asserts_1 = require("../../utils/asserts");
const detect_imports_1 = require("./utils/detect-imports");
const launch_policy_1 = require("../utils/launch-policy");
const i18n_1 = require("../../utils/i18n");
const specifier_1 = require("../utils/specifier");
const getLauncher = (par) => par ? launch_policy_1.parallelDiscarding : launch_policy_1.sequenceDiscarding;
const resolveLauncher = getLauncher(true);
class QuickPack {
    constructor({ modLo, sourceMaps, origin, workspace, verbose, logger, }) {
        this._moduleRecords = {};
        this._extensionMapping = [
            ['.ts', '.js'],
            ['.mjs', '.js'],
        ];
        this._verbose = verbose !== null && verbose !== void 0 ? verbose : false;
        this._origin = origin;
        this._modLo = modLo;
        this._sourceMaps = sourceMaps !== null && sourceMaps !== void 0 ? sourceMaps : true;
        this._moduleRecordFile = path_1.default.join(workspace, 'modules.json');
        this._chunkRecordFile = path_1.default.join(workspace, 'chunks.json');
        this._sourceCacheDir = path_1.default.join(workspace, 'mods');
        const importMapFile = path_1.default.join(workspace, 'import-map.json');
        this._importMapFile = importMapFile;
        const theLogger = logger !== null && logger !== void 0 ? logger : logger_1.createLogger({});
        this._chunkWriter = new writer_1.ChunkWriter({
            origin,
            chunkRecordFile: this._chunkRecordFile,
            sourceCacheDir: this._sourceCacheDir,
            importMapFile,
            logger: theLogger,
        });
        this._logger = theLogger;
    }
    async build(specifiers, options) {
        var _a;
        const context = {
            modules: new Map(),
            retryResolutionOnUnchangedModule: (_a = options === null || options === void 0 ? void 0 : options.retryResolutionOnUnchangedModule) !== null && _a !== void 0 ? _a : false,
        };
        const entryModuleRecords = [];
        for (const specifier of specifiers) {
            const url = typeof specifier === 'string'
                ? await this._resolveEntry(specifier)
                : specifier;
            if (!url) {
                continue;
            }
            const inspectRecord = await this._getOrCreateInspectRecord(url, context);
            await this._instantiateAll(inspectRecord, new Set());
            const moduleRecord = this._moduleRecords[url.href];
            if (!moduleRecord) {
                this._logger.debug(`Entry ${url} did not library a chunk.`);
                continue;
            }
            entryModuleRecords.push([url, moduleRecord]);
            const chunk = await this._chunkWriter.getChunk(moduleRecord.chunkId);
            asserts_1.asserts(chunk);
            chunk.isEntry = true;
            chunk.exposeAs = url.href;
        }
        await fs_extra_1.default.outputJson(this._moduleRecordFile, this._moduleRecords, { encoding: 'utf8', spaces: 2 });
        const chunkAlias = {};
        for (const [entryURL, entryModuleRecord] of entryModuleRecords) {
            const chunkId = entryModuleRecord.chunkId;
            chunkAlias[entryURL.href] = chunkId;
        }
        await this._chunkWriter.syncChunk(chunkAlias);
    }
    async createLoaderContext() {
        return new loader_context_1.LoaderContext(this._origin, this._chunkRecordFile, this._sourceCacheDir, this._importMapFile);
    }
    async clear() {
        this._moduleRecords = {};
        const moduleRecordFile = this._moduleRecordFile;
        try {
            await fs_extra_1.default.unlink(moduleRecordFile);
        }
        catch (err) {
            this._logger.debug(`Failed to delete module record file ${moduleRecordFile}: ${err}`);
        }
        await this._chunkWriter.clear();
    }
    async loadCache() {
        try {
            const serializedModuleRecords = await fs_extra_1.default.readJson(this._moduleRecordFile);
            for (const moduleRecord of Object.values(serializedModuleRecords)) {
                if (moduleRecord.resolvedImports) {
                    for (const resolveResult of moduleRecord.resolvedImports) {
                        if (resolveResult && !resolveResult.isExternal) {
                            resolveResult.url = new url_1.URL(resolveResult.url);
                        }
                    }
                }
            }
            this._moduleRecords = serializedModuleRecords;
        }
        catch (err) {
            this._logger.debug(`Module record file loaded failed with error: ${err}`);
        }
        await this._chunkWriter.loadCache();
    }
    async _resolveEntry(specifier) {
        try {
            return new url_1.URL(specifier);
        }
        catch (err) {
            this._logger.error(i18n_1.i18nTranslate('quick_pack_could_not_resolve_entry', { specifier }));
            return;
        }
    }
    async _getOrCreateInspectRecord(url, context) {
        const existedInspectRecord = context.modules.get(url.href);
        if (existedInspectRecord) {
            return existedInspectRecord;
        }
        // eslint-disable-next-line prefer-const
        let inspectRecord;
        const inspectPromise = this._inspectWithCache(url);
        const linkPromise = inspectPromise.then(async (moduleInspectInfo) => {
            if (moduleInspectInfo) {
                const dependencies = await this._link(url, moduleInspectInfo.moduleRecord, context);
                inspectRecord.dependencies = dependencies;
            }
        });
        inspectRecord = {
            inspect: inspectPromise,
            link: linkPromise,
            dependencies: undefined,
        };
        context.modules.set(url.href, inspectRecord);
        return inspectRecord;
    }
    async _instantiateAll(inspectRecord, visited) {
        if (visited.has(inspectRecord)) {
            return;
        }
        visited.add(inspectRecord);
        await inspectRecord.link;
        if (inspectRecord.dependencies) {
            await Promise.all(inspectRecord.dependencies.map(async (dependency) => {
                if (dependency) {
                    await this._instantiateAll(dependency, visited);
                }
            }));
        }
    }
    async _inspectWithCache(url) {
        const mTimestamp = await this._modLo.getMTimestamp(url);
        const oldModuleRecord = this._moduleRecords[url.href];
        if (oldModuleRecord) {
            if (mod_lo_1.isEqualMTimestamp(mTimestamp, oldModuleRecord.mTimestamp)) {
                return { moduleRecord: oldModuleRecord, updated: false };
            }
            this._logger.debug(`Detected change: ${url}. Last mtime: ${mod_lo_1.mTimestampToString(oldModuleRecord.mTimestamp)}, Current mtime: ${mod_lo_1.mTimestampToString(mTimestamp)}`);
            this._moduleRecords[url.href] = null;
            await this._chunkWriter.removeChunk(oldModuleRecord.chunkId);
        }
        if (this._verbose) {
            this._logger.debug(`Inspect ${url}`);
        }
        const moduleRecord = await this._inspect(url, mTimestamp).catch((err) => {
            this._logger.error(err);
        });
        if (!moduleRecord) {
            // Module record is invalid or cache is valid
            return undefined;
        }
        return { moduleRecord, updated: true };
    }
    async _link(url, moduleRecord, context) {
        const chunkImports = {};
        let forceResolve = false;
        if (!moduleRecord.resolvedImports) {
            forceResolve = true;
            moduleRecord.resolvedImports = new Array(moduleRecord.imports.length).fill(null);
        }
        const resolvedImports = moduleRecord.resolvedImports;
        const depRecords = await Promise.all(moduleRecord.imports.map(async (specifier, iImport) => {
            var _a, _b;
            let resolved = resolvedImports[iImport];
            if (forceResolve || // Not resolved before
                resolved === null && context.retryResolutionOnUnchangedModule // Resolved but failed
            ) {
                resolved = await this._resolve(specifier, url, moduleRecord.modLoMetadata);
                resolvedImports[iImport] = resolved;
            }
            if (!resolved) {
                return;
            }
            const chunkImportKey = (_a = specifier.rewritten) !== null && _a !== void 0 ? _a : specifier.value;
            if (resolved.isExternal) {
                const isResolvedToBare = !url_2.tryParseURL(resolved.specifierOrURL);
                if (isResolvedToBare) {
                    // Only bare specifier may resolved to bare
                    asserts_1.asserts(!specifier.rewritten, `Something wrong with rewriting and resolve ${specifier.value}`);
                    return;
                }
                chunkImports[chunkImportKey] = {
                    external: true,
                    url: resolved.specifierOrURL,
                };
                return;
            }
            const { url: resolvedURL } = resolved;
            const inspectRecord = await this._getOrCreateInspectRecord(resolvedURL, context);
            await inspectRecord.inspect;
            const resolvedChunk = (_b = this._moduleRecords[resolvedURL.href]) === null || _b === void 0 ? void 0 : _b.chunkId;
            if (resolvedChunk) {
                chunkImports[chunkImportKey] = resolvedChunk;
            }
            else {
                this._logger.debug(`We're missing the chunk ${resolvedURL.href}, referenced as '${specifier}'.`);
            }
            return inspectRecord;
        }));
        const chunk = await this._chunkWriter.getChunk(moduleRecord.chunkId);
        asserts_1.asserts(chunk);
        chunk.imports = chunkImports;
        return depRecords;
    }
    async _inspect(url, mTimestamp) {
        let mod;
        try {
            mod = await this._modLo.load(url);
        }
        catch (err) {
            this._logger.error(i18n_1.i18nTranslate('quick_pack_failed_to_load', { url: url.href, cause: err }));
            if (url.protocol === 'node:') {
                this._logger.warn(i18n_1.i18nTranslate('load_error_hint_node_builtin'));
            }
            return;
        }
        const { originalSource, code, modLoMetadata, } = mod;
        let { map, } = mod;
        let ast;
        if (typeof code === 'string') {
            // TODO: input source map
            ast = await this._modLo.parse(code, map);
        }
        else {
            ast = code;
        }
        const chunkURL = this._getChunkURL(url);
        const chunkId = this._chunkWriter.getChunkId(chunkURL);
        let specifiers = [];
        ({ transformResult: { ast, map }, specifiers } = await this._rewriteImports(url, ast, typeof map === 'string' ? JSON.parse(map) : map !== null && map !== void 0 ? map : undefined, originalSource));
        await this._transformAndAdd(chunkId, url, ast, typeof map === 'string' ? JSON.parse(map) : map !== null && map !== void 0 ? map : undefined, originalSource);
        const moduleRecord = {
            mTimestamp,
            chunkId,
            imports: specifiers,
            modLoMetadata,
        };
        this._moduleRecords[url.href] = moduleRecord;
        return moduleRecord;
    }
    async _transformAndAdd(chunkId, url, ast, map, originalSource) {
        const transformed = await this._transform(url, ast, map, originalSource);
        await this._chunkWriter.addChunk(chunkId, transformed.code, transformed.map);
    }
    async _rewriteImports(url, ast, map, originalSource) {
        var _a;
        const specifiers = [];
        let nSpecifier = 0;
        const transformResult = await babel.transformFromAstAsync(ast, originalSource, {
            ast: true,
            code: false,
            sourceFileName: url.href,
            cloneInputAst: false,
            configFile: false,
            sourceType: 'module',
            sourceMaps: this._sourceMaps,
            inputSourceMap: map,
            plugins: [
                [detect_imports_1.createBabelPluginDetectAndRewriteImports({
                        specifiers,
                        rewrite: (specifier) => {
                            if (specifier_1.isBareSpecifier(specifier)) {
                                // If it's bare specifier, we do not rewrite it.
                                return undefined;
                            }
                            const rewritten = `__unresolved_${nSpecifier}`;
                            ++nSpecifier;
                            return rewritten;
                        },
                    })],
            ],
        });
        asserts_1.asserts(transformResult);
        asserts_1.asserts(transformResult.ast);
        return {
            transformResult: {
                ast: transformResult.ast,
                map: (_a = transformResult.map) !== null && _a !== void 0 ? _a : undefined,
            },
            specifiers,
        };
    }
    async _transform(url, ast, map, originalSource) {
        const babelResult = await babel.transformFromAstAsync(ast, originalSource, {
            sourceFileName: url.href,
            // cloneInputAst: false,
            configFile: false,
            sourceType: 'module',
            sourceMaps: this._sourceMaps,
            inputSourceMap: map,
            plugins: [
                [plugin_transform_modules_systemjs_1.default],
                // Dynamic import() transformation must be enabled using the
                // @babel/plugin-proposal-dynamic-import plugin. Babel 8 will
                // no longer transform import() without using that plugin.
                [plugin_proposal_dynamic_import_1.default],
            ],
        });
        asserts_1.asserts(babelResult);
        asserts_1.asserts(babelResult.code);
        return {
            code: babelResult.code,
            map: babelResult.map,
        };
    }
    async _resolve(specifier, parentURL, modLoMetadata) {
        const specifierValue = specifier.value;
        try {
            const resolved = await this._modLo.resolve(specifierValue, parentURL, modLoMetadata);
            if (this._verbose) {
                if (resolved.isExternal) {
                    this._logger.debug(`Resolve ${specifierValue} from ${parentURL.href} as external dependency ${resolved.specifierOrURL}.`);
                }
                else {
                    this._logger.debug(`Resolve ${specifierValue} from ${parentURL.href} as ${resolved.url}.`);
                }
            }
            return resolved;
        }
        catch (err) {
            this._logger.error(i18n_1.i18nTranslate('quick_pack_failed_to_resolve', { specifier: specifierValue, parentURL: parentURL.href, cause: err }));
            if (specifierValue.includes('/')) {
                const lastPortion = specifierValue.split('/').pop();
                if (lastPortion && !lastPortion.includes('.')) {
                    this._logger.warn(i18n_1.i18nTranslate('resolve_error_hint_extension'));
                }
            }
            return null;
        }
    }
    /**
     * Map the module URL to chunk URL.
     * @param url
     */
    _getChunkURL(_url) {
        // TODO: do it better
        let url;
        if (!_url.search) {
            url = _url;
        }
        else {
            const u = new url_1.URL(_url.href);
            const extensionName = url_2.parseExtensionName(u.pathname);
            url_2.replaceExtension(u, `.proxy${extensionName}`);
            url = u;
        }
        // 见：https://gist.github.com/shrinktofit/50f2380782b6219ed6a4cb3a210a75f7
        for (const [from, to] of this._extensionMapping) {
            if (url.pathname.endsWith(from)) {
                return url_2.assignPathname(new url_1.URL(url.href), `${url.pathname.substr(0, url.pathname.length - from.length)}${to}`);
            }
        }
        if (!url_2.parseExtensionName(url.pathname)) {
            // URLs with no extension are store as .js
            return url_2.assignPathname(new url_1.URL(url.href), `${url.pathname}.js`);
        }
        return url;
    }
}
exports.QuickPack = QuickPack;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicXVpY2stcGFjay5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9tb2QtYXNzZW1ibGluZy9xdWljay1wYWNrL3F1aWNrLXBhY2sudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLGdEQUFzQjtBQUN0Qix3REFBMEI7QUFDMUIsNkJBQXlDO0FBQ3pDLDZDQUF1SjtBQUV2SixvREFBc0Q7QUFFdEQsMkRBQXVEO0FBQ3ZELHNDQUFpRztBQUNqRyw0Q0FBdUQ7QUFDdkQsbURBQXFDO0FBQ3JDLG1CQUFtQjtBQUNuQixpSEFBb0Y7QUFDcEYsbUJBQW1CO0FBQ25CLDJHQUFxRjtBQUNyRixpREFBOEM7QUFDOUMsMkRBQTRHO0FBQzVHLDBEQUFnRjtBQUVoRiwyQ0FBaUQ7QUFFakQsa0RBQXFEO0FBRXJELE1BQU0sV0FBVyxHQUFHLENBQUMsR0FBWSxFQUFFLEVBQUUsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLGtDQUFrQixDQUFDLENBQUMsQ0FBQyxrQ0FBa0IsQ0FBQztBQUVwRixNQUFNLGVBQWUsR0FBRyxXQUFXLENBQUMsSUFBSSxDQUFDLENBQUM7QUFFMUMsTUFBYSxTQUFTO0lBQ2xCLFlBQVksRUFDUixLQUFLLEVBQ0wsVUFBVSxFQUNWLE1BQU0sRUFDTixTQUFTLEVBQ1QsT0FBTyxFQUNQLE1BQU0sR0FRVDtRQTBHTyxtQkFBYyxHQUF3QyxFQUFFLENBQUM7UUFFekQsc0JBQWlCLEdBQTRCO1lBQ2pELENBQUMsS0FBSyxFQUFFLEtBQUssQ0FBQztZQUNkLENBQUMsTUFBTSxFQUFFLEtBQUssQ0FBQztTQUNsQixDQUFDO1FBOUdFLElBQUksQ0FBQyxRQUFRLEdBQUcsT0FBTyxhQUFQLE9BQU8sY0FBUCxPQUFPLEdBQUksS0FBSyxDQUFDO1FBQ2pDLElBQUksQ0FBQyxPQUFPLEdBQUcsTUFBTSxDQUFDO1FBQ3RCLElBQUksQ0FBQyxNQUFNLEdBQUcsS0FBSyxDQUFDO1FBQ3BC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Q0FBQztTQUNYO1FBRUQseUVBQXlFO1FBQ3pFLEtBQUssTUFBTSxDQUFDLElBQUksRUFBRSxFQUFFLENBQUMsSUFBSSxJQUFJLENBQUMsaUJBQWlCLEVBQUU7WUFDN0MsSUFBSSxHQUFHLENBQUMsUUFBUSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsRUFBRTtnQkFDN0IsT0FBTyxvQkFBYyxDQUNqQixJQUFJLFNBQUcsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLEVBQ2pCLEdBQUcsR0FBRyxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsQ0FBQyxFQUFFLEdBQUcsQ0FBQyxRQUFRLENBQUMsTUFBTSxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsR0FBRyxFQUFFLEVBQUUsQ0FDdEUsQ0FBQzthQUNMO1NBQ0o7UUFDRCxJQUFJLENBQUMsd0JBQWtCLENBQUMsR0FBRyxDQUFDLFFBQVEsQ0FBQyxFQUFFO1lBQ25DLDBDQUEwQztZQUMxQyxPQUFPLG9CQUFjLENBQ2pCLElBQUksU0FBRyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsRUFDakIsR0FBRyxHQUFHLENBQUMsUUFBUSxLQUFLLENBQ3ZCLENBQUM7U0FDTDtRQUNELE9BQU8sR0FBRyxDQUFDO0lBQ2YsQ0FBQztDQUNKO0FBNWRELDhCQTRkQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBwcyBmcm9tICdwYXRoJztcclxuaW1wb3J0IGZzIGZyb20gJ2ZzLWV4dHJhJztcclxuaW1wb3J0IHsgcGF0aFRvRmlsZVVSTCwgVVJMIH0gZnJvbSAndXJsJztcclxuaW1wb3J0IHsgTW9kTG9NZXRhZGF0YSwgTW9kTG8sIFJlc29sdmVSZXN1bHQsIFNvdXJjZSwgQXN0LCBTb3VyY2VNYXAsIE1vZCwgTVRpbWVzdGFtcCwgbVRpbWVzdGFtcFRvU3RyaW5nLCBpc0VxdWFsTVRpbWVzdGFtcCB9IGZyb20gJy4uL21vZC1sby9tb2QtbG8nO1xyXG5pbXBvcnQgeyBNb2R1bGVSZWNvcmQgfSBmcm9tICcuL3V0aWxzL21vZC1yZWNvcmQnO1xyXG5pbXBvcnQgeyBDaHVua1dyaXRlciB9IGZyb20gJy4vdXRpbHMvY2h1bmstaW8vd3JpdGVyJztcclxuaW1wb3J0IHsgQ2h1bmtJZCB9IGZyb20gJy4vdXRpbHMvY2h1bmstaWQnO1xyXG5pbXBvcnQgeyBMb2FkZXJDb250ZXh0IH0gZnJvbSAnLi91dGlscy9sb2FkZXItY29udGV4dCc7XHJcbmltcG9ydCB7IGFzc2lnblBhdGhuYW1lLCBwYXJzZUV4dGVuc2lvbk5hbWUsIHJlcGxhY2VFeHRlbnNpb24sIHRyeVBhcnNlVVJMIH0gZnJvbSAnLi4vdXRpbHMvdXJsJztcclxuaW1wb3J0IHsgY3JlYXRlTG9nZ2VyLCBMb2dnZXIgfSBmcm9tICcuLi91dGlscy9sb2dnZXInO1xyXG5pbXBvcnQgKiBhcyBiYWJlbCBmcm9tICdAYmFiZWwvY29yZSc7XHJcbi8vIEB0cy1leHBlY3QtZXJyb3JcclxuaW1wb3J0IGJhYmVsUGx1Z2luVHJhbnNmb3JtU3lzdGVtSnMgZnJvbSAnQGJhYmVsL3BsdWdpbi10cmFuc2Zvcm0tbW9kdWxlcy1zeXN0ZW1qcyc7XHJcbi8vIEB0cy1leHBlY3QtZXJyb3JcclxuaW1wb3J0IGJhYmVsUGx1Z2luUHJvcG9zYWxEeW5hbWljSW1wb3J0IGZyb20gJ0BiYWJlbC9wbHVnaW4tcHJvcG9zYWwtZHluYW1pYy1pbXBvcnQnO1xyXG5pbXBvcnQgeyBhc3NlcnRzIH0gZnJvbSAnLi4vLi4vdXRpbHMvYXNzZXJ0cyc7XHJcbmltcG9ydCB7IGNyZWF0ZUJhYmVsUGx1Z2luRGV0ZWN0QW5kUmV3cml0ZUltcG9ydHMsIGRldGVjdEltcG9ydHMsIFNwZWNpZmllciB9IGZyb20gJy4vdXRpbHMvZGV0ZWN0LWltcG9ydHMnO1xyXG5pbXBvcnQgeyBwYXJhbGxlbERpc2NhcmRpbmcsIHNlcXVlbmNlRGlzY2FyZGluZyB9IGZyb20gJy4uL3V0aWxzL2xhdW5jaC1wb2xpY3knO1xyXG5pbXBvcnQgeyBSYXdTb3VyY2VNYXAgfSBmcm9tICdzb3VyY2UtbWFwJztcclxuaW1wb3J0IHsgaTE4blRyYW5zbGF0ZSB9IGZyb20gJy4uLy4uL3V0aWxzL2kxOG4nO1xyXG5pbXBvcnQgeyBDaHVuayB9IGZyb20gJy4vdXRpbHMvY2h1bmsnO1xyXG5pbXBvcnQgeyBpc0JhcmVTcGVjaWZpZXIgfSBmcm9tICcuLi91dGlscy9zcGVjaWZpZXInO1xyXG5cclxuY29uc3QgZ2V0TGF1bmNoZXIgPSAocGFyOiBib29sZWFuKSA9PiBwYXIgPyBwYXJhbGxlbERpc2NhcmRpbmcgOiBzZXF1ZW5jZURpc2NhcmRpbmc7XHJcblxyXG5jb25zdCByZXNvbHZlTGF1bmNoZXIgPSBnZXRMYXVuY2hlcih0cnVlKTtcclxuXHJcbmV4cG9ydCBjbGFzcyBRdWlja1BhY2sge1xyXG4gICAgY29uc3RydWN0b3Ioe1xyXG4gICAgICAgIG1vZExvLFxyXG4gICAgICAgIHNvdXJjZU1hcHMsXHJcbiAgICAgICAgb3JpZ2luLFxyXG4gICAgICAgIHdvcmtzcGFjZSxcclxuICAgICAgICB2ZXJib3NlLFxyXG4gICAgICAgIGxvZ2dlcixcclxuICAgIH06IHtcclxuICAgICAgICBtb2RMbzogTW9kTG87XHJcbiAgICAgICAgc291cmNlTWFwcz86IGJvb2xlYW4gfCAnaW5saW5lJztcclxuICAgICAgICBvcmlnaW46IHN0cmluZztcclxuICAgICAgICB3b3Jrc3BhY2U6IHN0cmluZztcclxuICAgICAgICB2ZXJib3NlPzogYm9vbGVhbjtcclxuICAgICAgICBsb2dnZXI/OiBMb2dnZXI7XHJcbiAgICB9KSB7XHJcbiAgICAgICAgdGhpcy5fdmVyYm9zZSA9IHZlcmJvc2UgPz8gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5fb3JpZ2luID0gb3JpZ2luO1xyXG4gICAgICAgIHRoaXMuX21vZExvID0gbW9kTG87XHJcbiAgICAgICAgdGhpcy5fc291cmNlTWFwcyA9IHNvdXJjZU1hcHMgPz8gdHJ1ZTtcclxuICAgICAgICB0aGlzLl9tb2R1bGVSZWNvcmRGaWxlID0gcHMuam9pbih3b3Jrc3BhY2UsICdtb2R1bGVzLmpzb24nKTtcclxuICAgICAgICB0aGlzLl9jaHVua1JlY29yZEZpbGUgPSBwcy5qb2luKHdvcmtzcGFjZSwgJ2NodW5rcy5qc29uJyk7XHJcbiAgICAgICAgdGhpcy5fc291cmNlQ2FjaGVEaXIgPSBwcy5qb2luKHdvcmtzcGFjZSwgJ21vZHMnKTtcclxuICAgICAgICBjb25zdCBpbXBvcnRNYXBGaWxlID0gcHMuam9pbih3b3Jrc3BhY2UsICdpbXBvcnQtbWFwLmpzb24nKTtcclxuICAgICAgICB0aGlzLl9pbXBvcnRNYXBGaWxlID0gaW1wb3J0TWFwRmlsZTtcclxuICAgICAgICBjb25zdCB0aGVMb2dnZXIgPSBsb2dnZXIgPz8gY3JlYXRlTG9nZ2VyKHt9KTtcclxuICAgICAgICB0aGlzLl9jaHVua1dyaXRlciA9IG5ldyBDaHVua1dyaXRlcih7XHJcbiAgICAgICAgICAgIG9yaWdpbixcclxuICAgICAgICAgICAgY2h1bmtSZWNvcmRGaWxlOiB0aGlzLl9jaHVua1JlY29yZEZpbGUsXHJcbiAgICAgICAgICAgIHNvdXJjZUNhY2hlRGlyOiB0aGlzLl9zb3VyY2VDYWNoZURpcixcclxuICAgICAgICAgICAgaW1wb3J0TWFwRmlsZSxcclxuICAgICAgICAgICAgbG9nZ2VyOiB0aGVMb2dnZXIsXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5fbG9nZ2VyID0gdGhlTG9nZ2VyO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBhc3luYyBidWlsZChzcGVjaWZpZXJzOiBJdGVyYWJsZTxzdHJpbmcgfCBVUkw+LCBvcHRpb25zPzoge1xyXG4gICAgICAgIHJldHJ5UmVzb2x1dGlvbk9uVW5jaGFuZ2VkTW9kdWxlPzogYm9vbGVhbjtcclxuICAgIH0pIHtcclxuICAgICAgICBjb25zdCBjb250ZXh0OiBJbnNwZWN0Q29udGV4dCA9IHtcclxuICAgICAgICAgICAgbW9kdWxlczogbmV3IE1hcCgpLFxyXG4gICAgICAgICAgICByZXRyeVJlc29sdXRpb25PblVuY2hhbmdlZE1vZHVsZTogb3B0aW9ucz8ucmV0cnlSZXNvbHV0aW9uT25VbmNoYW5nZWRNb2R1bGUgPz8gZmFsc2UsXHJcbiAgICAgICAgfTtcclxuICAgICAgICBjb25zdCBlbnRyeU1vZHVsZVJlY29yZHM6IEFycmF5PFtVUkwsIE1vZHVsZVJlY29yZF0+ID0gW107XHJcbiAgICAgICAgZm9yIChjb25zdCBzcGVjaWZpZXIgb2Ygc3BlY2lmaWVycykge1xyXG4gICAgICAgICAgICBjb25zdCB1cmwgPSB0eXBlb2Ygc3BlY2lmaWVyID09PSAnc3RyaW5nJ1xyXG4gICAgICAgICAgICAgICAgPyBhd2FpdCB0aGlzLl9yZXNvbHZlRW50cnkoc3BlY2lmaWVyKVxyXG4gICAgICAgICAgICAgICAgOiBzcGVjaWZpZXI7XHJcbiAgICAgICAgICAgIGlmICghdXJsKSB7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBpbnNwZWN0UmVjb3JkID0gYXdhaXQgdGhpcy5fZ2V0T3JDcmVhdGVJbnNwZWN0UmVjb3JkKHVybCwgY29udGV4dCk7XHJcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX2luc3RhbnRpYXRlQWxsKGluc3BlY3RSZWNvcmQsIG5ldyBTZXQoKSk7XHJcbiAgICAgICAgICAgIGNvbnN0IG1vZHVsZVJlY29yZCA9IHRoaXMuX21vZHVsZVJlY29yZHNbdXJsLmhyZWZdO1xyXG4gICAgICAgICAgICBpZiAoIW1vZHVsZVJlY29yZCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbG9nZ2VyLmRlYnVnKGBFbnRyeSAke3VybH0gZGlkIG5vdCBsaWJyYXJ5IGEgY2h1bmsuYCk7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbnRyeU1vZHVsZVJlY29yZHMucHVzaChbdXJsLCBtb2R1bGVSZWNvcmRdKTtcclxuICAgICAgICAgICAgY29uc3QgY2h1bmsgPSBhd2FpdCB0aGlzLl9jaHVua1dyaXRlci5nZXRDaHVuayhtb2R1bGVSZWNvcmQuY2h1bmtJZCk7XHJcbiAgICAgICAgICAgIGFzc2VydHMoY2h1bmspO1xyXG4gICAgICAgICAgICBjaHVuay5pc0VudHJ5ID0gdHJ1ZTtcclxuICAgICAgICAgICAgY2h1bmsuZXhwb3NlQXMgPSB1cmwuaHJlZjtcclxuICAgICAgICB9XHJcbiAgICAgICAgYXdhaXQgZnMub3V0cHV0SnNvbih0aGlzLl9tb2R1bGVSZWNvcmRGaWxlLCB0aGlzLl9tb2R1bGVSZWNvcmRzLCB7IGVuY29kaW5nOiAndXRmOCcsIHNwYWNlczogMiB9KTtcclxuXHJcbiAgICAgICAgY29uc3QgY2h1bmtBbGlhczogUmVjb3JkPHN0cmluZywgQ2h1bmtJZD4gPSB7fTtcclxuICAgICAgICBmb3IgKGNvbnN0IFtlbnRyeVVSTCwgZW50cnlNb2R1bGVSZWNvcmRdIG9mIGVudHJ5TW9kdWxlUmVjb3Jkcykge1xyXG4gICAgICAgICAgICBjb25zdCBjaHVua0lkID0gZW50cnlNb2R1bGVSZWNvcmQuY2h1bmtJZDtcclxuICAgICAgICAgICAgY2h1bmtBbGlhc1tlbnRyeVVSTC5ocmVmXSA9IGNodW5rSWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGF3YWl0IHRoaXMuX2NodW5rV3JpdGVyLnN5bmNDaHVuayhjaHVua0FsaWFzKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgYXN5bmMgY3JlYXRlTG9hZGVyQ29udGV4dCgpIHtcclxuICAgICAgICByZXR1cm4gbmV3IExvYWRlckNvbnRleHQoXHJcbiAgICAgICAgICAgIHRoaXMuX29yaWdpbixcclxuICAgICAgICAgICAgdGhpcy5fY2h1bmtSZWNvcmRGaWxlLFxyXG4gICAgICAgICAgICB0aGlzLl9zb3VyY2VDYWNoZURpcixcclxuICAgICAgICAgICAgdGhpcy5faW1wb3J0TWFwRmlsZSxcclxuICAgICAgICApO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBhc3luYyBjbGVhcigpIHtcclxuICAgICAgICB0aGlzLl9tb2R1bGVSZWNvcmRzID0ge307XHJcbiAgICAgICAgY29uc3QgbW9kdWxlUmVjb3JkRmlsZSA9IHRoaXMuX21vZHVsZVJlY29yZEZpbGU7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgYXdhaXQgZnMudW5saW5rKG1vZHVsZVJlY29yZEZpbGUpO1xyXG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xyXG4gICAgICAgICAgICB0aGlzLl9sb2dnZXIuZGVidWcoYEZhaWxlZCB0byBkZWxldGUgbW9kdWxlIHJlY29yZCBmaWxlICR7bW9kdWxlUmVjb3JkRmlsZX06ICR7ZXJyfWApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBhd2FpdCB0aGlzLl9jaHVua1dyaXRlci5jbGVhcigpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBhc3luYyBsb2FkQ2FjaGUoKSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgY29uc3Qgc2VyaWFsaXplZE1vZHVsZVJlY29yZHM6IFJlY29yZDxzdHJpbmcsIE1vZHVsZVJlY29yZD4gPSBhd2FpdCBmcy5yZWFkSnNvbih0aGlzLl9tb2R1bGVSZWNvcmRGaWxlKTtcclxuICAgICAgICAgICAgZm9yIChjb25zdCBtb2R1bGVSZWNvcmQgb2YgT2JqZWN0LnZhbHVlcyhzZXJpYWxpemVkTW9kdWxlUmVjb3JkcykpIHtcclxuICAgICAgICAgICAgICAgIGlmIChtb2R1bGVSZWNvcmQucmVzb2x2ZWRJbXBvcnRzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCByZXNvbHZlUmVzdWx0IG9mIG1vZHVsZVJlY29yZC5yZXNvbHZlZEltcG9ydHMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc29sdmVSZXN1bHQgJiYgIXJlc29sdmVSZXN1bHQuaXNFeHRlcm5hbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZVJlc3VsdC51cmwgPSBuZXcgVVJMKHJlc29sdmVSZXN1bHQudXJsIGFzIHVua25vd24gYXMgc3RyaW5nKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl9tb2R1bGVSZWNvcmRzID0gc2VyaWFsaXplZE1vZHVsZVJlY29yZHM7XHJcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2xvZ2dlci5kZWJ1ZyhgTW9kdWxlIHJlY29yZCBmaWxlIGxvYWRlZCBmYWlsZWQgd2l0aCBlcnJvcjogJHtlcnJ9YCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGF3YWl0IHRoaXMuX2NodW5rV3JpdGVyLmxvYWRDYWNoZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgX3ZlcmJvc2U6IGJvb2xlYW47XHJcbiAgICBwcml2YXRlIF9vcmlnaW46IHN0cmluZztcclxuICAgIHByaXZhdGUgX21vZHVsZVJlY29yZEZpbGU6IHN0cmluZztcclxuICAgIHByaXZhdGUgX2NodW5rUmVjb3JkRmlsZTogc3RyaW5nO1xyXG4gICAgcHJpdmF0ZSBfc291cmNlQ2FjaGVEaXI6IHN0cmluZztcclxuICAgIHByaXZhdGUgX2ltcG9ydE1hcEZpbGU6IHN0cmluZztcclxuICAgIHByaXZhdGUgX21vZExvOiBNb2RMbztcclxuICAgIHByaXZhdGUgX3NvdXJjZU1hcHM6IGJvb2xlYW4gfCAnaW5saW5lJztcclxuICAgIHByaXZhdGUgX21vZHVsZVJlY29yZHM6IFJlY29yZDxzdHJpbmcsIE1vZHVsZVJlY29yZCB8IG51bGw+ID0ge307XHJcbiAgICBwcml2YXRlIF9jaHVua1dyaXRlcjogQ2h1bmtXcml0ZXI7XHJcbiAgICBwcml2YXRlIF9leHRlbnNpb25NYXBwaW5nOiBBcnJheTxbc3RyaW5nLCBzdHJpbmddPiA9IFtcclxuICAgICAgICBbJy50cycsICcuanMnXSxcclxuICAgICAgICBbJy5tanMnLCAnLmpzJ10sXHJcbiAgICBdO1xyXG4gICAgcHJpdmF0ZSBfbG9nZ2VyOiBMb2dnZXI7XHJcblxyXG4gICAgcHJpdmF0ZSBhc3luYyBfcmVzb2x2ZUVudHJ5KHNwZWNpZmllcjogc3RyaW5nKSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBVUkwoc3BlY2lmaWVyKTtcclxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgICAgICAgdGhpcy5fbG9nZ2VyLmVycm9yKGkxOG5UcmFuc2xhdGUoJ3F1aWNrX3BhY2tfY291bGRfbm90X3Jlc29sdmVfZW50cnknLCB7IHNwZWNpZmllciB9KSk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBhc3luYyBfZ2V0T3JDcmVhdGVJbnNwZWN0UmVjb3JkKHVybDogVVJMLCBjb250ZXh0OiBJbnNwZWN0Q29udGV4dCkge1xyXG4gICAgICAgIGNvbnN0IGV4aXN0ZWRJbnNwZWN0UmVjb3JkID0gY29udGV4dC5tb2R1bGVzLmdldCh1cmwuaHJlZik7XHJcbiAgICAgICAgaWYgKGV4aXN0ZWRJbnNwZWN0UmVjb3JkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBleGlzdGVkSW5zcGVjdFJlY29yZDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItY29uc3RcclxuICAgICAgICBsZXQgaW5zcGVjdFJlY29yZDogSW5zcGVjdFJlY29yZDtcclxuXHJcbiAgICAgICAgY29uc3QgaW5zcGVjdFByb21pc2UgPSB0aGlzLl9pbnNwZWN0V2l0aENhY2hlKHVybCk7XHJcbiAgICAgICAgY29uc3QgbGlua1Byb21pc2UgPSBpbnNwZWN0UHJvbWlzZS50aGVuKGFzeW5jIChtb2R1bGVJbnNwZWN0SW5mbykgPT4ge1xyXG4gICAgICAgICAgICBpZiAobW9kdWxlSW5zcGVjdEluZm8pIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGRlcGVuZGVuY2llcyA9IGF3YWl0IHRoaXMuX2xpbmsodXJsLCBtb2R1bGVJbnNwZWN0SW5mby5tb2R1bGVSZWNvcmQsIGNvbnRleHQpO1xyXG4gICAgICAgICAgICAgICAgaW5zcGVjdFJlY29yZC5kZXBlbmRlbmNpZXMgPSBkZXBlbmRlbmNpZXM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgaW5zcGVjdFJlY29yZCA9IHtcclxuICAgICAgICAgICAgaW5zcGVjdDogaW5zcGVjdFByb21pc2UsXHJcbiAgICAgICAgICAgIGxpbms6IGxpbmtQcm9taXNlLFxyXG4gICAgICAgICAgICBkZXBlbmRlbmNpZXM6IHVuZGVmaW5lZCxcclxuICAgICAgICB9O1xyXG4gICAgICAgIGNvbnRleHQubW9kdWxlcy5zZXQodXJsLmhyZWYsIGluc3BlY3RSZWNvcmQpO1xyXG4gICAgICAgIHJldHVybiBpbnNwZWN0UmVjb3JkO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgYXN5bmMgX2luc3RhbnRpYXRlQWxsKGluc3BlY3RSZWNvcmQ6IEluc3BlY3RSZWNvcmQsIHZpc2l0ZWQ6IFNldDxJbnNwZWN0UmVjb3JkPikge1xyXG4gICAgICAgIGlmICh2aXNpdGVkLmhhcyhpbnNwZWN0UmVjb3JkKSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZpc2l0ZWQuYWRkKGluc3BlY3RSZWNvcmQpO1xyXG4gICAgICAgIGF3YWl0IGluc3BlY3RSZWNvcmQubGluaztcclxuICAgICAgICBpZiAoaW5zcGVjdFJlY29yZC5kZXBlbmRlbmNpZXMpIHtcclxuICAgICAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoaW5zcGVjdFJlY29yZC5kZXBlbmRlbmNpZXMubWFwKGFzeW5jIChkZXBlbmRlbmN5KSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZGVwZW5kZW5jeSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX2luc3RhbnRpYXRlQWxsKGRlcGVuZGVuY3ksIHZpc2l0ZWQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgYXN5bmMgX2luc3BlY3RXaXRoQ2FjaGUodXJsOiBVUkwpIHtcclxuICAgICAgICBjb25zdCBtVGltZXN0YW1wID0gYXdhaXQgdGhpcy5fbW9kTG8uZ2V0TVRpbWVzdGFtcCh1cmwpO1xyXG4gICAgICAgIGNvbnN0IG9sZE1vZHVsZVJlY29yZCA9IHRoaXMuX21vZHVsZVJlY29yZHNbdXJsLmhyZWZdO1xyXG4gICAgICAgIGlmIChvbGRNb2R1bGVSZWNvcmQpIHtcclxuICAgICAgICAgICAgaWYgKGlzRXF1YWxNVGltZXN0YW1wKG1UaW1lc3RhbXAsIG9sZE1vZHVsZVJlY29yZC5tVGltZXN0YW1wKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgbW9kdWxlUmVjb3JkOiBvbGRNb2R1bGVSZWNvcmQsIHVwZGF0ZWQ6IGZhbHNlIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fbG9nZ2VyLmRlYnVnKGBEZXRlY3RlZCBjaGFuZ2U6ICR7dXJsfS4gTGFzdCBtdGltZTogJHttVGltZXN0YW1wVG9TdHJpbmcob2xkTW9kdWxlUmVjb3JkLm1UaW1lc3RhbXApfSwgQ3VycmVudCBtdGltZTogJHttVGltZXN0YW1wVG9TdHJpbmcobVRpbWVzdGFtcCl9YCk7XHJcbiAgICAgICAgICAgIHRoaXMuX21vZHVsZVJlY29yZHNbdXJsLmhyZWZdID0gbnVsbDtcclxuICAgICAgICAgICAgYXdhaXQgdGhpcy5fY2h1bmtXcml0ZXIucmVtb3ZlQ2h1bmsob2xkTW9kdWxlUmVjb3JkLmNodW5rSWQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHRoaXMuX3ZlcmJvc2UpIHtcclxuICAgICAgICAgICAgdGhpcy5fbG9nZ2VyLmRlYnVnKGBJbnNwZWN0ICR7dXJsfWApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc3QgbW9kdWxlUmVjb3JkID0gYXdhaXQgdGhpcy5faW5zcGVjdCh1cmwsIG1UaW1lc3RhbXApLmNhdGNoKChlcnIpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5fbG9nZ2VyLmVycm9yKGVycik7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaWYgKCFtb2R1bGVSZWNvcmQpIHtcclxuICAgICAgICAgICAgLy8gTW9kdWxlIHJlY29yZCBpcyBpbnZhbGlkIG9yIGNhY2hlIGlzIHZhbGlkXHJcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4geyBtb2R1bGVSZWNvcmQsIHVwZGF0ZWQ6IHRydWUgfTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIGFzeW5jIF9saW5rKHVybDogVVJMLCBtb2R1bGVSZWNvcmQ6IE1vZHVsZVJlY29yZCwgY29udGV4dDogSW5zcGVjdENvbnRleHQpIHtcclxuICAgICAgICBjb25zdCBjaHVua0ltcG9ydHM6IENodW5rWydpbXBvcnRzJ10gPSB7fTtcclxuXHJcbiAgICAgICAgbGV0IGZvcmNlUmVzb2x2ZSA9IGZhbHNlO1xyXG4gICAgICAgIGlmICghbW9kdWxlUmVjb3JkLnJlc29sdmVkSW1wb3J0cykge1xyXG4gICAgICAgICAgICBmb3JjZVJlc29sdmUgPSB0cnVlO1xyXG4gICAgICAgICAgICBtb2R1bGVSZWNvcmQucmVzb2x2ZWRJbXBvcnRzID0gbmV3IEFycmF5KG1vZHVsZVJlY29yZC5pbXBvcnRzLmxlbmd0aCkuZmlsbChudWxsKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IHJlc29sdmVkSW1wb3J0cyA9IG1vZHVsZVJlY29yZC5yZXNvbHZlZEltcG9ydHM7XHJcblxyXG4gICAgICAgIGNvbnN0IGRlcFJlY29yZHMgPSBhd2FpdCBQcm9taXNlLmFsbChtb2R1bGVSZWNvcmQuaW1wb3J0cy5tYXAoYXN5bmMgKHNwZWNpZmllciwgaUltcG9ydCk6IFByb21pc2U8dW5kZWZpbmVkIHwgSW5zcGVjdFJlY29yZD4gPT4ge1xyXG4gICAgICAgICAgICBsZXQgcmVzb2x2ZWQgPSByZXNvbHZlZEltcG9ydHNbaUltcG9ydF07XHJcbiAgICAgICAgICAgIGlmIChmb3JjZVJlc29sdmUgfHwgLy8gTm90IHJlc29sdmVkIGJlZm9yZVxyXG4gICAgICAgICAgICAgICAgcmVzb2x2ZWQgPT09IG51bGwgJiYgY29udGV4dC5yZXRyeVJlc29sdXRpb25PblVuY2hhbmdlZE1vZHVsZSAvLyBSZXNvbHZlZCBidXQgZmFpbGVkXHJcbiAgICAgICAgICAgICkge1xyXG4gICAgICAgICAgICAgICAgcmVzb2x2ZWQgPSBhd2FpdCB0aGlzLl9yZXNvbHZlKHNwZWNpZmllciwgdXJsLCBtb2R1bGVSZWNvcmQubW9kTG9NZXRhZGF0YSk7XHJcbiAgICAgICAgICAgICAgICByZXNvbHZlZEltcG9ydHNbaUltcG9ydF0gPSByZXNvbHZlZDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKCFyZXNvbHZlZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBjb25zdCBjaHVua0ltcG9ydEtleSA9IHNwZWNpZmllci5yZXdyaXR0ZW4gPz8gc3BlY2lmaWVyLnZhbHVlO1xyXG5cclxuICAgICAgICAgICAgaWYgKHJlc29sdmVkLmlzRXh0ZXJuYWwpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGlzUmVzb2x2ZWRUb0JhcmUgPSAhdHJ5UGFyc2VVUkwocmVzb2x2ZWQuc3BlY2lmaWVyT3JVUkwpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzUmVzb2x2ZWRUb0JhcmUpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBPbmx5IGJhcmUgc3BlY2lmaWVyIG1heSByZXNvbHZlZCB0byBiYXJlXHJcbiAgICAgICAgICAgICAgICAgICAgYXNzZXJ0cyghc3BlY2lmaWVyLnJld3JpdHRlbiwgYFNvbWV0aGluZyB3cm9uZyB3aXRoIHJld3JpdGluZyBhbmQgcmVzb2x2ZSAke3NwZWNpZmllci52YWx1ZX1gKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjaHVua0ltcG9ydHNbY2h1bmtJbXBvcnRLZXldID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIGV4dGVybmFsOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgICAgIHVybDogcmVzb2x2ZWQuc3BlY2lmaWVyT3JVUkwsXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBjb25zdCB7IHVybDogcmVzb2x2ZWRVUkwgfSA9IHJlc29sdmVkO1xyXG5cclxuICAgICAgICAgICAgY29uc3QgaW5zcGVjdFJlY29yZCA9IGF3YWl0IHRoaXMuX2dldE9yQ3JlYXRlSW5zcGVjdFJlY29yZChyZXNvbHZlZFVSTCwgY29udGV4dCk7XHJcbiAgICAgICAgICAgIGF3YWl0IGluc3BlY3RSZWNvcmQuaW5zcGVjdDtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IHJlc29sdmVkQ2h1bmsgPSB0aGlzLl9tb2R1bGVSZWNvcmRzW3Jlc29sdmVkVVJMLmhyZWZdPy5jaHVua0lkO1xyXG4gICAgICAgICAgICBpZiAocmVzb2x2ZWRDaHVuaykge1xyXG4gICAgICAgICAgICAgICAgY2h1bmtJbXBvcnRzW2NodW5rSW1wb3J0S2V5XSA9IHJlc29sdmVkQ2h1bms7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9sb2dnZXIuZGVidWcoYFdlJ3JlIG1pc3NpbmcgdGhlIGNodW5rICR7cmVzb2x2ZWRVUkwuaHJlZn0sIHJlZmVyZW5jZWQgYXMgJyR7c3BlY2lmaWVyfScuYCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBpbnNwZWN0UmVjb3JkO1xyXG4gICAgICAgIH0pKTtcclxuXHJcbiAgICAgICAgY29uc3QgY2h1bmsgPSBhd2FpdCB0aGlzLl9jaHVua1dyaXRlci5nZXRDaHVuayhtb2R1bGVSZWNvcmQuY2h1bmtJZCk7XHJcbiAgICAgICAgYXNzZXJ0cyhjaHVuayk7XHJcbiAgICAgICAgY2h1bmsuaW1wb3J0cyA9IGNodW5rSW1wb3J0cztcclxuXHJcbiAgICAgICAgcmV0dXJuIGRlcFJlY29yZHM7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBhc3luYyBfaW5zcGVjdCh1cmw6IFVSTCwgbVRpbWVzdGFtcDogTVRpbWVzdGFtcCkge1xyXG4gICAgICAgIGxldCBtb2Q6IE1vZDtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBtb2QgPSBhd2FpdCB0aGlzLl9tb2RMby5sb2FkKHVybCk7XHJcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2xvZ2dlci5lcnJvcihpMThuVHJhbnNsYXRlKCdxdWlja19wYWNrX2ZhaWxlZF90b19sb2FkJywgeyB1cmw6IHVybC5ocmVmLCBjYXVzZTogZXJyIH0pKTtcclxuICAgICAgICAgICAgaWYgKHVybC5wcm90b2NvbCA9PT0gJ25vZGU6Jykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbG9nZ2VyLndhcm4oaTE4blRyYW5zbGF0ZSgnbG9hZF9lcnJvcl9oaW50X25vZGVfYnVpbHRpbicpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCB7XHJcbiAgICAgICAgICAgIG9yaWdpbmFsU291cmNlLFxyXG4gICAgICAgICAgICBjb2RlLFxyXG4gICAgICAgICAgICBtb2RMb01ldGFkYXRhLFxyXG4gICAgICAgIH0gPSBtb2Q7XHJcblxyXG4gICAgICAgIGxldCB7XHJcbiAgICAgICAgICAgIG1hcCxcclxuICAgICAgICB9ID0gbW9kO1xyXG5cclxuICAgICAgICBsZXQgYXN0OiBBc3Q7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBjb2RlID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICAvLyBUT0RPOiBpbnB1dCBzb3VyY2UgbWFwXHJcbiAgICAgICAgICAgIGFzdCA9IGF3YWl0IHRoaXMuX21vZExvLnBhcnNlKGNvZGUsIG1hcCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgYXN0ID0gY29kZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IGNodW5rVVJMID0gdGhpcy5fZ2V0Q2h1bmtVUkwodXJsKTtcclxuXHJcbiAgICAgICAgY29uc3QgY2h1bmtJZCA9IHRoaXMuX2NodW5rV3JpdGVyLmdldENodW5rSWQoY2h1bmtVUkwpO1xyXG5cclxuICAgICAgICBsZXQgc3BlY2lmaWVyczogU3BlY2lmaWVyW10gPSBbXTtcclxuICAgICAgICAoeyB0cmFuc2Zvcm1SZXN1bHQ6IHsgYXN0LCBtYXAgfSwgc3BlY2lmaWVycyB9ID0gYXdhaXQgdGhpcy5fcmV3cml0ZUltcG9ydHMoXHJcbiAgICAgICAgICAgIHVybCxcclxuICAgICAgICAgICAgYXN0LFxyXG4gICAgICAgICAgICB0eXBlb2YgbWFwID09PSAnc3RyaW5nJyA/IEpTT04ucGFyc2UobWFwKSA6IG1hcCA/PyB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgIG9yaWdpbmFsU291cmNlLFxyXG4gICAgICAgICkpO1xyXG5cclxuICAgICAgICBhd2FpdCB0aGlzLl90cmFuc2Zvcm1BbmRBZGQoXHJcbiAgICAgICAgICAgIGNodW5rSWQsXHJcbiAgICAgICAgICAgIHVybCxcclxuICAgICAgICAgICAgYXN0LFxyXG4gICAgICAgICAgICB0eXBlb2YgbWFwID09PSAnc3RyaW5nJyA/IEpTT04ucGFyc2UobWFwKSA6IG1hcCA/PyB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgIG9yaWdpbmFsU291cmNlLFxyXG4gICAgICAgICk7XHJcblxyXG4gICAgICAgIGNvbnN0IG1vZHVsZVJlY29yZDogTW9kdWxlUmVjb3JkID0ge1xyXG4gICAgICAgICAgICBtVGltZXN0YW1wLFxyXG4gICAgICAgICAgICBjaHVua0lkLFxyXG4gICAgICAgICAgICBpbXBvcnRzOiBzcGVjaWZpZXJzLFxyXG4gICAgICAgICAgICBtb2RMb01ldGFkYXRhLFxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHRoaXMuX21vZHVsZVJlY29yZHNbdXJsLmhyZWZdID0gbW9kdWxlUmVjb3JkO1xyXG5cclxuICAgICAgICByZXR1cm4gbW9kdWxlUmVjb3JkO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgYXN5bmMgX3RyYW5zZm9ybUFuZEFkZChjaHVua0lkOiBzdHJpbmcsIHVybDogVVJMLCBhc3Q6IEFzdCwgbWFwOiBSYXdTb3VyY2VNYXAgfCB1bmRlZmluZWQsIG9yaWdpbmFsU291cmNlOiBzdHJpbmcpIHtcclxuICAgICAgICBjb25zdCB0cmFuc2Zvcm1lZCA9IGF3YWl0IHRoaXMuX3RyYW5zZm9ybSh1cmwsIGFzdCwgbWFwLCBvcmlnaW5hbFNvdXJjZSk7XHJcblxyXG4gICAgICAgIGF3YWl0IHRoaXMuX2NodW5rV3JpdGVyLmFkZENodW5rKFxyXG4gICAgICAgICAgICBjaHVua0lkLFxyXG4gICAgICAgICAgICB0cmFuc2Zvcm1lZC5jb2RlLFxyXG4gICAgICAgICAgICB0cmFuc2Zvcm1lZC5tYXAsXHJcbiAgICAgICAgKTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIGFzeW5jIF9yZXdyaXRlSW1wb3J0cyh1cmw6IFVSTCwgYXN0OiBBc3QsIG1hcDogUmF3U291cmNlTWFwIHwgdW5kZWZpbmVkLCBvcmlnaW5hbFNvdXJjZTogc3RyaW5nKSB7XHJcbiAgICAgICAgY29uc3Qgc3BlY2lmaWVyczogU3BlY2lmaWVyW10gPSBbXTtcclxuXHJcbiAgICAgICAgbGV0IG5TcGVjaWZpZXIgPSAwO1xyXG5cclxuICAgICAgICBjb25zdCB0cmFuc2Zvcm1SZXN1bHQgPSBhd2FpdCBiYWJlbC50cmFuc2Zvcm1Gcm9tQXN0QXN5bmMoXHJcbiAgICAgICAgICAgIGFzdCwgb3JpZ2luYWxTb3VyY2UsIHtcclxuICAgICAgICAgICAgICAgIGFzdDogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIGNvZGU6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgc291cmNlRmlsZU5hbWU6IHVybC5ocmVmLFxyXG4gICAgICAgICAgICAgICAgY2xvbmVJbnB1dEFzdDogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICBjb25maWdGaWxlOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIHNvdXJjZVR5cGU6ICdtb2R1bGUnLFxyXG4gICAgICAgICAgICAgICAgc291cmNlTWFwczogdGhpcy5fc291cmNlTWFwcyxcclxuICAgICAgICAgICAgICAgIGlucHV0U291cmNlTWFwOiBtYXAsXHJcbiAgICAgICAgICAgICAgICBwbHVnaW5zOiBbXHJcbiAgICAgICAgICAgICAgICAgICAgW2NyZWF0ZUJhYmVsUGx1Z2luRGV0ZWN0QW5kUmV3cml0ZUltcG9ydHMoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzcGVjaWZpZXJzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXdyaXRlOiAoc3BlY2lmaWVyKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNCYXJlU3BlY2lmaWVyKHNwZWNpZmllcikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiBpdCdzIGJhcmUgc3BlY2lmaWVyLCB3ZSBkbyBub3QgcmV3cml0ZSBpdC5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmV3cml0dGVuID0gYF9fdW5yZXNvbHZlZF8ke25TcGVjaWZpZXJ9YDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICsrblNwZWNpZmllcjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXdyaXR0ZW47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgfSldLFxyXG4gICAgICAgICAgICAgICAgXSxcclxuICAgICAgICAgICAgfSBhcyBiYWJlbC5UcmFuc2Zvcm1PcHRpb25zICYge1xyXG4gICAgICAgICAgICAgICAgY2xvbmVJbnB1dEFzdD86IGJvb2xlYW47XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgKTtcclxuXHJcbiAgICAgICAgYXNzZXJ0cyh0cmFuc2Zvcm1SZXN1bHQpO1xyXG4gICAgICAgIGFzc2VydHModHJhbnNmb3JtUmVzdWx0LmFzdCk7XHJcblxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHRyYW5zZm9ybVJlc3VsdDoge1xyXG4gICAgICAgICAgICAgICAgYXN0OiB0cmFuc2Zvcm1SZXN1bHQuYXN0LFxyXG4gICAgICAgICAgICAgICAgbWFwOiAodHJhbnNmb3JtUmVzdWx0Lm1hcCBhcyBTb3VyY2VNYXAgfCB1bmRlZmluZWQpID8/IHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgc3BlY2lmaWVycyxcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgYXN5bmMgX3RyYW5zZm9ybSh1cmw6IFVSTCwgYXN0OiBBc3QsIG1hcDogUmF3U291cmNlTWFwIHwgdW5kZWZpbmVkLCBvcmlnaW5hbFNvdXJjZTogc3RyaW5nKSB7XHJcbiAgICAgICAgY29uc3QgYmFiZWxSZXN1bHQgPSBhd2FpdCBiYWJlbC50cmFuc2Zvcm1Gcm9tQXN0QXN5bmMoXHJcbiAgICAgICAgICAgIGFzdCxcclxuICAgICAgICAgICAgb3JpZ2luYWxTb3VyY2UsIHtcclxuICAgICAgICAgICAgICAgIHNvdXJjZUZpbGVOYW1lOiB1cmwuaHJlZixcclxuICAgICAgICAgICAgICAgIC8vIGNsb25lSW5wdXRBc3Q6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgY29uZmlnRmlsZTogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICBzb3VyY2VUeXBlOiAnbW9kdWxlJyxcclxuICAgICAgICAgICAgICAgIHNvdXJjZU1hcHM6IHRoaXMuX3NvdXJjZU1hcHMsXHJcbiAgICAgICAgICAgICAgICBpbnB1dFNvdXJjZU1hcDogbWFwLFxyXG4gICAgICAgICAgICAgICAgcGx1Z2luczogW1xyXG4gICAgICAgICAgICAgICAgICAgIFtiYWJlbFBsdWdpblRyYW5zZm9ybVN5c3RlbUpzXSxcclxuICAgICAgICAgICAgICAgICAgICAvLyBEeW5hbWljIGltcG9ydCgpIHRyYW5zZm9ybWF0aW9uIG11c3QgYmUgZW5hYmxlZCB1c2luZyB0aGVcclxuICAgICAgICAgICAgICAgICAgICAvLyBAYmFiZWwvcGx1Z2luLXByb3Bvc2FsLWR5bmFtaWMtaW1wb3J0IHBsdWdpbi4gQmFiZWwgOCB3aWxsXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gbm8gbG9uZ2VyIHRyYW5zZm9ybSBpbXBvcnQoKSB3aXRob3V0IHVzaW5nIHRoYXQgcGx1Z2luLlxyXG4gICAgICAgICAgICAgICAgICAgIFtiYWJlbFBsdWdpblByb3Bvc2FsRHluYW1pY0ltcG9ydF0sXHJcbiAgICAgICAgICAgICAgICBdLFxyXG4gICAgICAgICAgICB9IGFzIGJhYmVsLlRyYW5zZm9ybU9wdGlvbnMgJiB7XHJcbiAgICAgICAgICAgICAgICBjbG9uZUlucHV0QXN0PzogYm9vbGVhbjtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICApO1xyXG4gICAgICAgIGFzc2VydHMoYmFiZWxSZXN1bHQpO1xyXG4gICAgICAgIGFzc2VydHMoYmFiZWxSZXN1bHQuY29kZSk7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgY29kZTogYmFiZWxSZXN1bHQuY29kZSxcclxuICAgICAgICAgICAgbWFwOiBiYWJlbFJlc3VsdC5tYXAgYXMgdW5rbm93biBhcyBTb3VyY2VNYXAsXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIGFzeW5jIF9yZXNvbHZlKHNwZWNpZmllcjogU3BlY2lmaWVyLCBwYXJlbnRVUkw6IFVSTCwgbW9kTG9NZXRhZGF0YTogTW9kTG9NZXRhZGF0YSkge1xyXG4gICAgICAgIGNvbnN0IHNwZWNpZmllclZhbHVlID0gc3BlY2lmaWVyLnZhbHVlO1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHJlc29sdmVkID0gYXdhaXQgdGhpcy5fbW9kTG8ucmVzb2x2ZShzcGVjaWZpZXJWYWx1ZSwgcGFyZW50VVJMLCBtb2RMb01ldGFkYXRhKTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX3ZlcmJvc2UpIHtcclxuICAgICAgICAgICAgICAgIGlmIChyZXNvbHZlZC5pc0V4dGVybmFsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbG9nZ2VyLmRlYnVnKGBSZXNvbHZlICR7c3BlY2lmaWVyVmFsdWV9IGZyb20gJHtwYXJlbnRVUkwuaHJlZn0gYXMgZXh0ZXJuYWwgZGVwZW5kZW5jeSAke3Jlc29sdmVkLnNwZWNpZmllck9yVVJMfS5gKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbG9nZ2VyLmRlYnVnKGBSZXNvbHZlICR7c3BlY2lmaWVyVmFsdWV9IGZyb20gJHtwYXJlbnRVUkwuaHJlZn0gYXMgJHtyZXNvbHZlZC51cmx9LmApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiByZXNvbHZlZDtcclxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgICAgICAgdGhpcy5fbG9nZ2VyLmVycm9yKGkxOG5UcmFuc2xhdGUoXHJcbiAgICAgICAgICAgICAgICAncXVpY2tfcGFja19mYWlsZWRfdG9fcmVzb2x2ZScsXHJcbiAgICAgICAgICAgICAgICB7IHNwZWNpZmllcjogc3BlY2lmaWVyVmFsdWUsIHBhcmVudFVSTDogcGFyZW50VVJMLmhyZWYsIGNhdXNlOiBlcnIgfSxcclxuICAgICAgICAgICAgKSk7XHJcbiAgICAgICAgICAgIGlmIChzcGVjaWZpZXJWYWx1ZS5pbmNsdWRlcygnLycpKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBsYXN0UG9ydGlvbiA9IHNwZWNpZmllclZhbHVlLnNwbGl0KCcvJykucG9wKCk7XHJcbiAgICAgICAgICAgICAgICBpZiAobGFzdFBvcnRpb24gJiYgIWxhc3RQb3J0aW9uLmluY2x1ZGVzKCcuJykpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9sb2dnZXIud2FybihpMThuVHJhbnNsYXRlKCdyZXNvbHZlX2Vycm9yX2hpbnRfZXh0ZW5zaW9uJykpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIE1hcCB0aGUgbW9kdWxlIFVSTCB0byBjaHVuayBVUkwuXHJcbiAgICAgKiBAcGFyYW0gdXJsIFxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIF9nZXRDaHVua1VSTChfdXJsOiBSZWFkb25seTxVUkw+KTogUmVhZG9ubHk8VVJMPiB7XHJcbiAgICAgICAgLy8gVE9ETzogZG8gaXQgYmV0dGVyXHJcbiAgICAgICAgbGV0IHVybDogUmVhZG9ubHk8VVJMPjtcclxuICAgICAgICBpZiAoIV91cmwuc2VhcmNoKSB7XHJcbiAgICAgICAgICAgIHVybCA9IF91cmw7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgY29uc3QgdSA9IG5ldyBVUkwoX3VybC5ocmVmKTtcclxuICAgICAgICAgICAgY29uc3QgZXh0ZW5zaW9uTmFtZSA9IHBhcnNlRXh0ZW5zaW9uTmFtZSh1LnBhdGhuYW1lKTtcclxuICAgICAgICAgICAgcmVwbGFjZUV4dGVuc2lvbih1LCBgLnByb3h5JHtleHRlbnNpb25OYW1lfWApO1xyXG4gICAgICAgICAgICB1cmwgPSB1O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8g6KeB77yaaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vc2hyaW5rdG9maXQvNTBmMjM4MDc4MmI2MjE5ZWQ2YTRjYjNhMjEwYTc1ZjdcclxuICAgICAgICBmb3IgKGNvbnN0IFtmcm9tLCB0b10gb2YgdGhpcy5fZXh0ZW5zaW9uTWFwcGluZykge1xyXG4gICAgICAgICAgICBpZiAodXJsLnBhdGhuYW1lLmVuZHNXaXRoKGZyb20pKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYXNzaWduUGF0aG5hbWUoXHJcbiAgICAgICAgICAgICAgICAgICAgbmV3IFVSTCh1cmwuaHJlZiksXHJcbiAgICAgICAgICAgICAgICAgICAgYCR7dXJsLnBhdGhuYW1lLnN1YnN0cigwLCB1cmwucGF0aG5hbWUubGVuZ3RoIC0gZnJvbS5sZW5ndGgpfSR7dG99YCxcclxuICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFwYXJzZUV4dGVuc2lvbk5hbWUodXJsLnBhdGhuYW1lKSkge1xyXG4gICAgICAgICAgICAvLyBVUkxzIHdpdGggbm8gZXh0ZW5zaW9uIGFyZSBzdG9yZSBhcyAuanNcclxuICAgICAgICAgICAgcmV0dXJuIGFzc2lnblBhdGhuYW1lKFxyXG4gICAgICAgICAgICAgICAgbmV3IFVSTCh1cmwuaHJlZiksXHJcbiAgICAgICAgICAgICAgICBgJHt1cmwucGF0aG5hbWV9LmpzYFxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdXJsO1xyXG4gICAgfVxyXG59XHJcblxyXG5pbnRlcmZhY2UgSW5zcGVjdFJlY29yZCB7XHJcbiAgICBpbnNwZWN0OiBQcm9taXNlPHsgbW9kdWxlUmVjb3JkOiBNb2R1bGVSZWNvcmQ7IHVwZGF0ZWQ6IGJvb2xlYW47IH0gfCB1bmRlZmluZWQ+O1xyXG4gICAgbGluazogUHJvbWlzZTx2b2lkPiB8IHVuZGVmaW5lZDtcclxuICAgIGRlcGVuZGVuY2llczogQXJyYXk8SW5zcGVjdFJlY29yZCB8IHVuZGVmaW5lZD4gfCB1bmRlZmluZWQ7XHJcbn1cclxuXHJcbmludGVyZmFjZSBJbnNwZWN0Q29udGV4dCB7XHJcbiAgICByZXRyeVJlc29sdXRpb25PblVuY2hhbmdlZE1vZHVsZTogYm9vbGVhbjtcclxuICAgIG1vZHVsZXM6IE1hcDxzdHJpbmcsIEluc3BlY3RSZWNvcmQ+O1xyXG59XHJcbiJdfQ==