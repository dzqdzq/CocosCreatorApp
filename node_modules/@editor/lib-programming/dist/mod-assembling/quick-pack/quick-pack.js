"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.QuickPack = void 0;
const path_1 = __importDefault(require("path"));
const fs_extra_1 = __importDefault(require("fs-extra"));
const url_1 = require("url");
const writer_1 = require("./utils/chunk-io/writer");
const loader_context_1 = require("./utils/loader-context");
const url_2 = require("../utils/url");
const logger_1 = require("../utils/logger");
const babel = __importStar(require("@babel/core"));
// @ts-expect-error
const plugin_transform_modules_systemjs_1 = __importDefault(require("@babel/plugin-transform-modules-systemjs"));
// @ts-expect-error
const plugin_proposal_dynamic_import_1 = __importDefault(require("@babel/plugin-proposal-dynamic-import"));
const asserts_1 = require("../../utils/asserts");
const detect_imports_1 = require("./utils/detect-imports");
const launch_policy_1 = require("../utils/launch-policy");
const i18n_1 = require("../../utils/i18n");
const getLauncher = (par) => par ? launch_policy_1.parallelDiscarding : launch_policy_1.sequenceDiscarding;
const resolveLauncher = getLauncher(true);
class QuickPack {
    constructor({ modLo, sourceMaps, origin, workspace, verbose, logger, }) {
        this._moduleRecords = {};
        this._extensionMapping = [
            ['.ts', '.js'],
            ['.mjs', '.js'],
        ];
        this._verbose = verbose !== null && verbose !== void 0 ? verbose : false;
        this._origin = origin;
        this._modLo = modLo;
        this._sourceMaps = sourceMaps !== null && sourceMaps !== void 0 ? sourceMaps : true;
        this._moduleRecordFile = path_1.default.join(workspace, 'modules.json');
        this._chunkRecordFile = path_1.default.join(workspace, 'chunks.json');
        this._sourceCacheDir = path_1.default.join(workspace, 'mods');
        this._chunkWriter = new writer_1.ChunkWriter({
            origin,
            chunkRecordFile: this._chunkRecordFile,
            sourceCacheDir: this._sourceCacheDir,
        });
        this._logger = logger !== null && logger !== void 0 ? logger : logger_1.createLogger({});
    }
    async build(specifiers, options) {
        var _a, _b;
        const context = {
            modules: new Map(),
            forceAll: (_a = options === null || options === void 0 ? void 0 : options.forceAll) !== null && _a !== void 0 ? _a : false,
            retryResolutionOnUnchangedModule: (_b = options === null || options === void 0 ? void 0 : options.retryResolutionOnUnchangedModule) !== null && _b !== void 0 ? _b : false,
        };
        for (const specifier of specifiers) {
            const url = typeof specifier === 'string'
                ? await this._resolveEntry(specifier)
                : specifier;
            if (!url) {
                continue;
            }
            const inspectRecord = await this._getOrCreateInspectRecord(url, context);
            await this._instantiateAll(inspectRecord, new Set());
            const moduleRecord = this._moduleRecords[url.href];
            if (!moduleRecord) {
                this._logger.debug(`Entry ${url} did not library a chunk.`);
                continue;
            }
            const chunk = await this._chunkWriter.getChunk(moduleRecord.chunkId);
            asserts_1.asserts(chunk);
            chunk.isEntry = true;
            chunk.exposeAs = url.href;
        }
        await fs_extra_1.default.outputJson(this._moduleRecordFile, this._moduleRecords, { encoding: 'utf8', spaces: 2 });
        await this._chunkWriter.syncChunk();
    }
    async createLoaderContext() {
        return new loader_context_1.LoaderContext(this._origin, this._chunkRecordFile, this._sourceCacheDir);
    }
    async loadCache() {
        try {
            const serializedModuleRecords = await fs_extra_1.default.readJson(this._moduleRecordFile);
            for (const moduleRecord of Object.values(serializedModuleRecords)) {
                if (moduleRecord.resolvedImports) {
                    for (const resolveResult of moduleRecord.resolvedImports) {
                        if (resolveResult && !resolveResult.isExternal) {
                            resolveResult.url = new url_1.URL(resolveResult.url);
                        }
                    }
                }
            }
            this._moduleRecords = serializedModuleRecords;
        }
        catch (err) {
            this._logger.debug(`Module record file loaded failed with error: ${err}`);
        }
        await this._chunkWriter.loadCache();
    }
    async _resolveEntry(specifier) {
        try {
            return new url_1.URL(specifier);
        }
        catch (err) {
            this._logger.error(i18n_1.i18nTranslate('quick_pack_could_not_resolve_entry', { specifier }));
            return;
        }
    }
    async _getOrCreateInspectRecord(url, context) {
        const existedInspectRecord = context.modules.get(url.href);
        if (existedInspectRecord) {
            return existedInspectRecord;
        }
        let inspectRecord;
        const inspectPromise = this._inspectWithCache(url);
        const linkPromise = inspectPromise.then(async (moduleInspectInfo) => {
            if (moduleInspectInfo && (moduleInspectInfo.updated || context.forceAll)) {
                const dependencies = await this._link(url, moduleInspectInfo.moduleRecord, context);
                inspectRecord.dependencies = dependencies;
            }
        });
        inspectRecord = {
            inspect: inspectPromise,
            link: linkPromise,
            dependencies: undefined,
        };
        context.modules.set(url.href, inspectRecord);
        return inspectRecord;
    }
    async _instantiateAll(inspectRecord, visited) {
        if (visited.has(inspectRecord)) {
            return;
        }
        visited.add(inspectRecord);
        await inspectRecord.link;
        if (inspectRecord.dependencies) {
            await Promise.all(inspectRecord.dependencies.map(async (dependency) => {
                if (dependency) {
                    await this._instantiateAll(dependency, visited);
                }
            }));
        }
    }
    async _inspectWithCache(url) {
        const mTimestamp = await this._modLo.getMTimestamp(url);
        const oldModuleRecord = this._moduleRecords[url.href];
        if (oldModuleRecord) {
            if (mTimestamp === oldModuleRecord.mTimestamp) {
                return { moduleRecord: oldModuleRecord, updated: false };
            }
            this._logger.debug(`Detected change: ${url}. Last mtime: ${new Date(oldModuleRecord.mTimestamp)}, Current mtime: ${new Date(mTimestamp)}`);
            this._moduleRecords[url.href] = null;
            await this._chunkWriter.removeChunk(oldModuleRecord.chunkId);
        }
        if (this._verbose) {
            this._logger.debug(`Inspect ${url}`);
        }
        const moduleRecord = await this._inspect(url, mTimestamp).catch((err) => {
            this._logger.error(err);
        });
        if (!moduleRecord) {
            // Module record is invalid or cache is valid
            return undefined;
        }
        return { moduleRecord, updated: true };
    }
    async _link(url, moduleRecord, context) {
        const chunkImports = {};
        let forceResolve = false;
        if (!moduleRecord.resolvedImports) {
            forceResolve = true;
            moduleRecord.resolvedImports = new Array(moduleRecord.imports.length).fill(null);
        }
        const resolvedImports = moduleRecord.resolvedImports;
        const depRecords = await Promise.all(moduleRecord.imports.map(async (specifier, iImport) => {
            var _a;
            let resolved = resolvedImports[iImport];
            if (forceResolve || // Not resolved before
                resolved === null && context.retryResolutionOnUnchangedModule // Resolved but failed
            ) {
                resolved = await this._resolve(specifier, url, moduleRecord.modLoMetadata);
                resolvedImports[iImport] = resolved;
            }
            if (!resolved || resolved.isExternal) {
                return;
            }
            const { url: resolvedURL } = resolved;
            const inspectRecord = await this._getOrCreateInspectRecord(resolvedURL, context);
            await inspectRecord.inspect;
            const resolvedChunk = (_a = this._moduleRecords[resolvedURL.href]) === null || _a === void 0 ? void 0 : _a.chunkId;
            if (resolvedChunk) {
                chunkImports[specifier.value] = resolvedChunk;
            }
            else {
                this._logger.debug(`We're missing the chunk ${resolvedURL.href}, referenced as '${specifier}'.`);
            }
            return inspectRecord;
        }));
        const chunk = await this._chunkWriter.getChunk(moduleRecord.chunkId);
        asserts_1.asserts(chunk);
        chunk.imports = chunkImports;
        return depRecords;
    }
    async _inspect(url, mTimestamp) {
        let mod;
        try {
            mod = await this._modLo.load(url);
        }
        catch (err) {
            this._logger.error(i18n_1.i18nTranslate('quick_pack_failed_to_load', { url: url.href, cause: err }));
            return;
        }
        const { originalSource, code, map, modLoMetadata, } = mod;
        let ast;
        if (typeof code === 'string') {
            // TODO: input source map
            ast = await this._modLo.parse(code, map);
        }
        else {
            ast = code;
        }
        const imports = await detect_imports_1.detectImports(ast);
        const chunkURL = this._getChunkURL(url);
        const chunkId = this._chunkWriter.getChunkId(chunkURL);
        this._transformAndAdd(chunkId, url, ast, typeof map === 'string' ? JSON.parse(map) : map !== null && map !== void 0 ? map : undefined, originalSource);
        const moduleRecord = {
            mTimestamp,
            chunkId,
            imports: imports,
            modLoMetadata,
        };
        this._moduleRecords[url.href] = moduleRecord;
        return moduleRecord;
    }
    async _transformAndAdd(chunkId, url, ast, map, originalSource) {
        const transformed = await this._transform(url, ast, map, originalSource);
        await this._chunkWriter.addChunk(chunkId, transformed.code, transformed.map);
    }
    async _transform(url, ast, map, originalSource) {
        const babelResult = await babel.transformFromAstAsync(ast, originalSource, {
            sourceFileName: url.href,
            // cloneInputAst: false,
            configFile: false,
            sourceType: 'module',
            sourceMaps: this._sourceMaps,
            inputSourceMap: map,
            plugins: [
                [plugin_transform_modules_systemjs_1.default],
                // Dynamic import() transformation must be enabled using the
                // @babel/plugin-proposal-dynamic-import plugin. Babel 8 will
                // no longer transform import() without using that plugin.
                [plugin_proposal_dynamic_import_1.default],
            ],
        });
        asserts_1.asserts(babelResult);
        asserts_1.asserts(babelResult.code);
        return {
            code: babelResult.code,
            map: babelResult.map,
        };
    }
    async _resolve(specifier, parentURL, modLoMetadata) {
        const specifierValue = specifier.value;
        try {
            const resolved = await this._modLo.resolve(specifierValue, parentURL, modLoMetadata);
            if (this._verbose) {
                if (resolved.isExternal) {
                    this._logger.debug(`Resolve ${specifierValue} from ${parentURL.href} as external dependency ${resolved.specifierOrURL}.`);
                }
                else {
                    this._logger.debug(`Resolve ${specifierValue} from ${parentURL.href} as ${resolved.url}.`);
                }
            }
            return resolved;
        }
        catch (err) {
            this._logger.error(i18n_1.i18nTranslate('quick_pack_failed_to_resolve', { specifier: specifierValue, parentURL: parentURL.href, cause: err }));
            return null;
        }
    }
    /**
     * Map the module URL to chunk URL.
     * @param url
     */
    _getChunkURL(_url) {
        // TODO: do it better
        let url;
        if (!_url.search) {
            url = _url;
        }
        else {
            const u = new url_1.URL(_url.href);
            const extensionName = url_2.parseExtensionName(u.pathname);
            url_2.replaceExtension(u, `.proxy${extensionName}`);
            url = u;
        }
        // 见：https://gist.github.com/shrinktofit/50f2380782b6219ed6a4cb3a210a75f7
        for (const [from, to] of this._extensionMapping) {
            if (url.pathname.endsWith(from)) {
                return url_2.assignPathname(new url_1.URL(url.href), `${url.pathname.substr(0, url.pathname.length - from.length)}${to}`);
            }
        }
        if (!url_2.parseExtensionName(url.pathname)) {
            // URLs with no extension are store as .js
            return url_2.assignPathname(new url_1.URL(url.href), `${url.pathname}.js`);
        }
        return url;
    }
}
exports.QuickPack = QuickPack;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicXVpY2stcGFjay5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9tb2QtYXNzZW1ibGluZy9xdWljay1wYWNrL3F1aWNrLXBhY2sudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLGdEQUFzQjtBQUN0Qix3REFBMEI7QUFDMUIsNkJBQXlDO0FBR3pDLG9EQUFzRDtBQUV0RCwyREFBdUQ7QUFDdkQsc0NBQW9GO0FBQ3BGLDRDQUF1RDtBQUN2RCxtREFBcUM7QUFDckMsbUJBQW1CO0FBQ25CLGlIQUFvRjtBQUNwRixtQkFBbUI7QUFDbkIsMkdBQXFGO0FBQ3JGLGlEQUE4QztBQUM5QywyREFBa0U7QUFDbEUsMERBQWdGO0FBRWhGLDJDQUFpRDtBQUVqRCxNQUFNLFdBQVcsR0FBRyxDQUFDLEdBQVksRUFBRSxFQUFFLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxrQ0FBa0IsQ0FBQyxDQUFDLENBQUMsa0NBQWtCLENBQUM7QUFFcEYsTUFBTSxlQUFlLEdBQUcsV0FBVyxDQUFDLElBQUksQ0FBQyxDQUFDO0FBRTFDLE1BQWEsU0FBUztJQUNsQixZQUFZLEVBQ1IsS0FBSyxFQUNMLFVBQVUsRUFDVixNQUFNLEVBQ04sU0FBUyxFQUNULE9BQU8sRUFDUCxNQUFNLEdBUVQ7UUFrRk8sbUJBQWMsR0FBd0MsRUFBRSxDQUFDO1FBRXpELHNCQUFpQixHQUE0QjtZQUNqRCxDQUFDLEtBQUssRUFBRSxLQUFLLENBQUM7WUFDZCxDQUFDLE1BQU0sRUFBRSxLQUFLLENBQUM7U0FDbEIsQ0FBQztRQXRGRSxJQUFJLENBQUMsUUFBUSxHQUFHLE9BQU8sYUFBUCxPQUFPLGNBQVAsT0FBTyxHQUFJLEtBQUssQ0FBQztRQUNqQyxJQUFJLENBQUMsT0FBTyxHQUFHLE1BQU0sQ0FBQztRQUN0QixJQUFJLENBQUMsTUFBTSxHQUFHLEtBQUssQ0FBQztRQUNwQixJQUFJLENBQUMsV0FBVyxHQUFHLFVBQVUs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LGFBQWEsRUFBRSxDQUFDLENBQUM7WUFDOUMsR0FBRyxHQUFHLENBQUMsQ0FBQztTQUNYO1FBRUQseUVBQXlFO1FBQ3pFLEtBQUssTUFBTSxDQUFDLElBQUksRUFBRSxFQUFFLENBQUMsSUFBSSxJQUFJLENBQUMsaUJBQWlCLEVBQUU7WUFDN0MsSUFBSSxHQUFHLENBQUMsUUFBUSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsRUFBRTtnQkFDN0IsT0FBTyxvQkFBYyxDQUNqQixJQUFJLFNBQUcsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLEVBQ2pCLEdBQUcsR0FBRyxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsQ0FBQyxFQUFFLEdBQUcsQ0FBQyxRQUFRLENBQUMsTUFBTSxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsR0FBRyxFQUFFLEVBQUUsQ0FDdEUsQ0FBQzthQUNMO1NBQ0o7UUFDRCxJQUFJLENBQUMsd0JBQWtCLENBQUMsR0FBRyxDQUFDLFFBQVEsQ0FBQyxFQUFFO1lBQ25DLDBDQUEwQztZQUMxQyxPQUFPLG9CQUFjLENBQ2pCLElBQUksU0FBRyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsRUFDakIsR0FBRyxHQUFHLENBQUMsUUFBUSxLQUFLLENBQ3ZCLENBQUM7U0FDTDtRQUNELE9BQU8sR0FBRyxDQUFDO0lBQ2YsQ0FBQztDQUNKO0FBblhELDhCQW1YQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBwcyBmcm9tICdwYXRoJztcbmltcG9ydCBmcyBmcm9tICdmcy1leHRyYSc7XG5pbXBvcnQgeyBwYXRoVG9GaWxlVVJMLCBVUkwgfSBmcm9tICd1cmwnO1xuaW1wb3J0IHsgTW9kTG9NZXRhZGF0YSwgTW9kTG8sIFJlc29sdmVSZXN1bHQsIFNvdXJjZSwgQXN0LCBTb3VyY2VNYXAsIE1vZCB9IGZyb20gJy4uL21vZC1sby9tb2QtbG8nO1xuaW1wb3J0IHsgTW9kdWxlUmVjb3JkIH0gZnJvbSAnLi91dGlscy9tb2QtcmVjb3JkJztcbmltcG9ydCB7IENodW5rV3JpdGVyIH0gZnJvbSAnLi91dGlscy9jaHVuay1pby93cml0ZXInO1xuaW1wb3J0IHsgQ2h1bmtJZCB9IGZyb20gJy4vdXRpbHMvY2h1bmstaWQnO1xuaW1wb3J0IHsgTG9hZGVyQ29udGV4dCB9IGZyb20gJy4vdXRpbHMvbG9hZGVyLWNvbnRleHQnO1xuaW1wb3J0IHsgYXNzaWduUGF0aG5hbWUsIHBhcnNlRXh0ZW5zaW9uTmFtZSwgcmVwbGFjZUV4dGVuc2lvbiB9IGZyb20gJy4uL3V0aWxzL3VybCc7XG5pbXBvcnQgeyBjcmVhdGVMb2dnZXIsIExvZ2dlciB9IGZyb20gJy4uL3V0aWxzL2xvZ2dlcic7XG5pbXBvcnQgKiBhcyBiYWJlbCBmcm9tICdAYmFiZWwvY29yZSc7XG4vLyBAdHMtZXhwZWN0LWVycm9yXG5pbXBvcnQgYmFiZWxQbHVnaW5UcmFuc2Zvcm1TeXN0ZW1KcyBmcm9tICdAYmFiZWwvcGx1Z2luLXRyYW5zZm9ybS1tb2R1bGVzLXN5c3RlbWpzJztcbi8vIEB0cy1leHBlY3QtZXJyb3JcbmltcG9ydCBiYWJlbFBsdWdpblByb3Bvc2FsRHluYW1pY0ltcG9ydCBmcm9tICdAYmFiZWwvcGx1Z2luLXByb3Bvc2FsLWR5bmFtaWMtaW1wb3J0JztcbmltcG9ydCB7IGFzc2VydHMgfSBmcm9tICcuLi8uLi91dGlscy9hc3NlcnRzJztcbmltcG9ydCB7IGRldGVjdEltcG9ydHMsIFNwZWNpZmllciB9IGZyb20gJy4vdXRpbHMvZGV0ZWN0LWltcG9ydHMnO1xuaW1wb3J0IHsgcGFyYWxsZWxEaXNjYXJkaW5nLCBzZXF1ZW5jZURpc2NhcmRpbmcgfSBmcm9tICcuLi91dGlscy9sYXVuY2gtcG9saWN5JztcbmltcG9ydCB7IFJhd1NvdXJjZU1hcCB9IGZyb20gJ3NvdXJjZS1tYXAnO1xuaW1wb3J0IHsgaTE4blRyYW5zbGF0ZSB9IGZyb20gJy4uLy4uL3V0aWxzL2kxOG4nO1xuXG5jb25zdCBnZXRMYXVuY2hlciA9IChwYXI6IGJvb2xlYW4pID0+IHBhciA/IHBhcmFsbGVsRGlzY2FyZGluZyA6IHNlcXVlbmNlRGlzY2FyZGluZztcblxuY29uc3QgcmVzb2x2ZUxhdW5jaGVyID0gZ2V0TGF1bmNoZXIodHJ1ZSk7XG5cbmV4cG9ydCBjbGFzcyBRdWlja1BhY2sge1xuICAgIGNvbnN0cnVjdG9yKHtcbiAgICAgICAgbW9kTG8sXG4gICAgICAgIHNvdXJjZU1hcHMsXG4gICAgICAgIG9yaWdpbixcbiAgICAgICAgd29ya3NwYWNlLFxuICAgICAgICB2ZXJib3NlLFxuICAgICAgICBsb2dnZXIsXG4gICAgfToge1xuICAgICAgICBtb2RMbzogTW9kTG87XG4gICAgICAgIHNvdXJjZU1hcHM/OiBib29sZWFuIHwgJ2lubGluZSc7XG4gICAgICAgIG9yaWdpbjogc3RyaW5nO1xuICAgICAgICB3b3Jrc3BhY2U6IHN0cmluZztcbiAgICAgICAgdmVyYm9zZT86IGJvb2xlYW47XG4gICAgICAgIGxvZ2dlcj86IExvZ2dlcjtcbiAgICB9KSB7XG4gICAgICAgIHRoaXMuX3ZlcmJvc2UgPSB2ZXJib3NlID8/IGZhbHNlO1xuICAgICAgICB0aGlzLl9vcmlnaW4gPSBvcmlnaW47XG4gICAgICAgIHRoaXMuX21vZExvID0gbW9kTG87XG4gICAgICAgIHRoaXMuX3NvdXJjZU1hcHMgPSBzb3VyY2VNYXBzID8/IHRydWU7XG4gICAgICAgIHRoaXMuX21vZHVsZVJlY29yZEZpbGUgPSBwcy5qb2luKHdvcmtzcGFjZSwgJ21vZHVsZXMuanNvbicpO1xuICAgICAgICB0aGlzLl9jaHVua1JlY29yZEZpbGUgPSBwcy5qb2luKHdvcmtzcGFjZSwgJ2NodW5rcy5qc29uJyk7XG4gICAgICAgIHRoaXMuX3NvdXJjZUNhY2hlRGlyID0gcHMuam9pbih3b3Jrc3BhY2UsICdtb2RzJyk7XG4gICAgICAgIHRoaXMuX2NodW5rV3JpdGVyID0gbmV3IENodW5rV3JpdGVyKHtcbiAgICAgICAgICAgIG9yaWdpbixcbiAgICAgICAgICAgIGNodW5rUmVjb3JkRmlsZTogdGhpcy5fY2h1bmtSZWNvcmRGaWxlLFxuICAgICAgICAgICAgc291cmNlQ2FjaGVEaXI6IHRoaXMuX3NvdXJjZUNhY2hlRGlyLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fbG9nZ2VyID0gbG9nZ2VyID8/IGNyZWF0ZUxvZ2dlcih7fSk7XG4gICAgfVxuXG4gICAgcHVibGljIGFzeW5jIGJ1aWxkKHNwZWNpZmllcnM6IEl0ZXJhYmxlPHN0cmluZyB8IFVSTD4sIG9wdGlvbnM/OiB7XG4gICAgICAgIGZvcmNlQWxsPzogYm9vbGVhbjtcbiAgICAgICAgcmV0cnlSZXNvbHV0aW9uT25VbmNoYW5nZWRNb2R1bGU/OiBib29sZWFuO1xuICAgIH0pIHtcbiAgICAgICAgY29uc3QgY29udGV4dDogSW5zcGVjdENvbnRleHQgPSB7XG4gICAgICAgICAgICBtb2R1bGVzOiBuZXcgTWFwKCksXG4gICAgICAgICAgICBmb3JjZUFsbDogb3B0aW9ucz8uZm9yY2VBbGwgPz8gZmFsc2UsXG4gICAgICAgICAgICByZXRyeVJlc29sdXRpb25PblVuY2hhbmdlZE1vZHVsZTogb3B0aW9ucz8ucmV0cnlSZXNvbHV0aW9uT25VbmNoYW5nZWRNb2R1bGUgPz8gZmFsc2UsXG4gICAgICAgIH07XG4gICAgICAgIGZvciAoY29uc3Qgc3BlY2lmaWVyIG9mIHNwZWNpZmllcnMpIHtcbiAgICAgICAgICAgIGNvbnN0IHVybCA9IHR5cGVvZiBzcGVjaWZpZXIgPT09ICdzdHJpbmcnXG4gICAgICAgICAgICAgICAgPyBhd2FpdCB0aGlzLl9yZXNvbHZlRW50cnkoc3BlY2lmaWVyKVxuICAgICAgICAgICAgICAgIDogc3BlY2lmaWVyO1xuICAgICAgICAgICAgaWYgKCF1cmwpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGluc3BlY3RSZWNvcmQgPSBhd2FpdCB0aGlzLl9nZXRPckNyZWF0ZUluc3BlY3RSZWNvcmQodXJsLCBjb250ZXh0KTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX2luc3RhbnRpYXRlQWxsKGluc3BlY3RSZWNvcmQsIG5ldyBTZXQoKSk7XG4gICAgICAgICAgICBjb25zdCBtb2R1bGVSZWNvcmQgPSB0aGlzLl9tb2R1bGVSZWNvcmRzW3VybC5ocmVmXTtcbiAgICAgICAgICAgIGlmICghbW9kdWxlUmVjb3JkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbG9nZ2VyLmRlYnVnKGBFbnRyeSAke3VybH0gZGlkIG5vdCBsaWJyYXJ5IGEgY2h1bmsuYCk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBjaHVuayA9IGF3YWl0IHRoaXMuX2NodW5rV3JpdGVyLmdldENodW5rKG1vZHVsZVJlY29yZC5jaHVua0lkKTtcbiAgICAgICAgICAgIGFzc2VydHMoY2h1bmspO1xuICAgICAgICAgICAgY2h1bmsuaXNFbnRyeSA9IHRydWU7XG4gICAgICAgICAgICBjaHVuay5leHBvc2VBcyA9IHVybC5ocmVmO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IGZzLm91dHB1dEpzb24odGhpcy5fbW9kdWxlUmVjb3JkRmlsZSwgdGhpcy5fbW9kdWxlUmVjb3JkcywgeyBlbmNvZGluZzogJ3V0ZjgnLCBzcGFjZXM6IDIgfSk7XG4gICAgICAgIGF3YWl0IHRoaXMuX2NodW5rV3JpdGVyLnN5bmNDaHVuaygpO1xuICAgIH1cblxuICAgIHB1YmxpYyBhc3luYyBjcmVhdGVMb2FkZXJDb250ZXh0KCkge1xuICAgICAgICByZXR1cm4gbmV3IExvYWRlckNvbnRleHQoXG4gICAgICAgICAgICB0aGlzLl9vcmlnaW4sXG4gICAgICAgICAgICB0aGlzLl9jaHVua1JlY29yZEZpbGUsXG4gICAgICAgICAgICB0aGlzLl9zb3VyY2VDYWNoZURpcixcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgYXN5bmMgbG9hZENhY2hlKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3Qgc2VyaWFsaXplZE1vZHVsZVJlY29yZHM6IFJlY29yZDxzdHJpbmcsIE1vZHVsZVJlY29yZD4gPSBhd2FpdCBmcy5yZWFkSnNvbih0aGlzLl9tb2R1bGVSZWNvcmRGaWxlKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgbW9kdWxlUmVjb3JkIG9mIE9iamVjdC52YWx1ZXMoc2VyaWFsaXplZE1vZHVsZVJlY29yZHMpKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1vZHVsZVJlY29yZC5yZXNvbHZlZEltcG9ydHMpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCByZXNvbHZlUmVzdWx0IG9mIG1vZHVsZVJlY29yZC5yZXNvbHZlZEltcG9ydHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXNvbHZlUmVzdWx0ICYmICFyZXNvbHZlUmVzdWx0LmlzRXh0ZXJuYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlUmVzdWx0LnVybCA9IG5ldyBVUkwocmVzb2x2ZVJlc3VsdC51cmwgYXMgdW5rbm93biBhcyBzdHJpbmcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fbW9kdWxlUmVjb3JkcyA9IHNlcmlhbGl6ZWRNb2R1bGVSZWNvcmRzO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHRoaXMuX2xvZ2dlci5kZWJ1ZyhgTW9kdWxlIHJlY29yZCBmaWxlIGxvYWRlZCBmYWlsZWQgd2l0aCBlcnJvcjogJHtlcnJ9YCk7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgdGhpcy5fY2h1bmtXcml0ZXIubG9hZENhY2hlKCk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBfdmVyYm9zZTogYm9vbGVhbjtcbiAgICBwcml2YXRlIF9vcmlnaW46IHN0cmluZztcbiAgICBwcml2YXRlIF9tb2R1bGVSZWNvcmRGaWxlOiBzdHJpbmc7XG4gICAgcHJpdmF0ZSBfY2h1bmtSZWNvcmRGaWxlOiBzdHJpbmc7XG4gICAgcHJpdmF0ZSBfc291cmNlQ2FjaGVEaXI6IHN0cmluZztcbiAgICBwcml2YXRlIF9tb2RMbzogTW9kTG87XG4gICAgcHJpdmF0ZSBfc291cmNlTWFwczogYm9vbGVhbiB8ICdpbmxpbmUnO1xuICAgIHByaXZhdGUgX21vZHVsZVJlY29yZHM6IFJlY29yZDxzdHJpbmcsIE1vZHVsZVJlY29yZCB8IG51bGw+ID0ge307XG4gICAgcHJpdmF0ZSBfY2h1bmtXcml0ZXI6IENodW5rV3JpdGVyO1xuICAgIHByaXZhdGUgX2V4dGVuc2lvbk1hcHBpbmc6IEFycmF5PFtzdHJpbmcsIHN0cmluZ10+ID0gW1xuICAgICAgICBbJy50cycsICcuanMnXSxcbiAgICAgICAgWycubWpzJywgJy5qcyddLFxuICAgIF07XG4gICAgcHJpdmF0ZSBfbG9nZ2VyOiBMb2dnZXI7XG5cbiAgICBwcml2YXRlIGFzeW5jIF9yZXNvbHZlRW50cnkoc3BlY2lmaWVyOiBzdHJpbmcpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgVVJMKHNwZWNpZmllcik7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgdGhpcy5fbG9nZ2VyLmVycm9yKGkxOG5UcmFuc2xhdGUoJ3F1aWNrX3BhY2tfY291bGRfbm90X3Jlc29sdmVfZW50cnknLCB7IHNwZWNpZmllciB9KSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIGFzeW5jIF9nZXRPckNyZWF0ZUluc3BlY3RSZWNvcmQodXJsOiBVUkwsIGNvbnRleHQ6IEluc3BlY3RDb250ZXh0KSB7XG4gICAgICAgIGNvbnN0IGV4aXN0ZWRJbnNwZWN0UmVjb3JkID0gY29udGV4dC5tb2R1bGVzLmdldCh1cmwuaHJlZik7XG4gICAgICAgIGlmIChleGlzdGVkSW5zcGVjdFJlY29yZCkge1xuICAgICAgICAgICAgcmV0dXJuIGV4aXN0ZWRJbnNwZWN0UmVjb3JkO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGluc3BlY3RSZWNvcmQ6IEluc3BlY3RSZWNvcmQ7XG5cbiAgICAgICAgY29uc3QgaW5zcGVjdFByb21pc2UgPSB0aGlzLl9pbnNwZWN0V2l0aENhY2hlKHVybCk7XG4gICAgICAgIGNvbnN0IGxpbmtQcm9taXNlID0gaW5zcGVjdFByb21pc2UudGhlbihhc3luYyAobW9kdWxlSW5zcGVjdEluZm8pID0+IHtcbiAgICAgICAgICAgIGlmIChtb2R1bGVJbnNwZWN0SW5mbyAmJiAobW9kdWxlSW5zcGVjdEluZm8udXBkYXRlZCB8fCBjb250ZXh0LmZvcmNlQWxsKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRlcGVuZGVuY2llcyA9IGF3YWl0IHRoaXMuX2xpbmsodXJsLCBtb2R1bGVJbnNwZWN0SW5mby5tb2R1bGVSZWNvcmQsIGNvbnRleHQpO1xuICAgICAgICAgICAgICAgIGluc3BlY3RSZWNvcmQuZGVwZW5kZW5jaWVzID0gZGVwZW5kZW5jaWVzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBpbnNwZWN0UmVjb3JkID0ge1xuICAgICAgICAgICAgaW5zcGVjdDogaW5zcGVjdFByb21pc2UsXG4gICAgICAgICAgICBsaW5rOiBsaW5rUHJvbWlzZSxcbiAgICAgICAgICAgIGRlcGVuZGVuY2llczogdW5kZWZpbmVkLFxuICAgICAgICB9O1xuICAgICAgICBjb250ZXh0Lm1vZHVsZXMuc2V0KHVybC5ocmVmLCBpbnNwZWN0UmVjb3JkKTtcbiAgICAgICAgcmV0dXJuIGluc3BlY3RSZWNvcmQ7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBhc3luYyBfaW5zdGFudGlhdGVBbGwoaW5zcGVjdFJlY29yZDogSW5zcGVjdFJlY29yZCwgdmlzaXRlZDogU2V0PEluc3BlY3RSZWNvcmQ+KSB7XG4gICAgICAgIGlmICh2aXNpdGVkLmhhcyhpbnNwZWN0UmVjb3JkKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZpc2l0ZWQuYWRkKGluc3BlY3RSZWNvcmQpO1xuICAgICAgICBhd2FpdCBpbnNwZWN0UmVjb3JkLmxpbms7XG4gICAgICAgIGlmIChpbnNwZWN0UmVjb3JkLmRlcGVuZGVuY2llcykge1xuICAgICAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoaW5zcGVjdFJlY29yZC5kZXBlbmRlbmNpZXMubWFwKGFzeW5jIChkZXBlbmRlbmN5KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGRlcGVuZGVuY3kpIHtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5faW5zdGFudGlhdGVBbGwoZGVwZW5kZW5jeSwgdmlzaXRlZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBhc3luYyBfaW5zcGVjdFdpdGhDYWNoZSh1cmw6IFVSTCkge1xuICAgICAgICBjb25zdCBtVGltZXN0YW1wID0gYXdhaXQgdGhpcy5fbW9kTG8uZ2V0TVRpbWVzdGFtcCh1cmwpO1xuICAgICAgICBjb25zdCBvbGRNb2R1bGVSZWNvcmQgPSB0aGlzLl9tb2R1bGVSZWNvcmRzW3VybC5ocmVmXTtcbiAgICAgICAgaWYgKG9sZE1vZHVsZVJlY29yZCkge1xuICAgICAgICAgICAgaWYgKG1UaW1lc3RhbXAgPT09IG9sZE1vZHVsZVJlY29yZC5tVGltZXN0YW1wKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgbW9kdWxlUmVjb3JkOiBvbGRNb2R1bGVSZWNvcmQsIHVwZGF0ZWQ6IGZhbHNlIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9sb2dnZXIuZGVidWcoYERldGVjdGVkIGNoYW5nZTogJHt1cmx9LiBMYXN0IG10aW1lOiAke25ldyBEYXRlKG9sZE1vZHVsZVJlY29yZC5tVGltZXN0YW1wKX0sIEN1cnJlbnQgbXRpbWU6ICR7bmV3IERhdGUobVRpbWVzdGFtcCl9YCk7XG4gICAgICAgICAgICB0aGlzLl9tb2R1bGVSZWNvcmRzW3VybC5ocmVmXSA9IG51bGw7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9jaHVua1dyaXRlci5yZW1vdmVDaHVuayhvbGRNb2R1bGVSZWNvcmQuY2h1bmtJZCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fdmVyYm9zZSkge1xuICAgICAgICAgICAgdGhpcy5fbG9nZ2VyLmRlYnVnKGBJbnNwZWN0ICR7dXJsfWApO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgbW9kdWxlUmVjb3JkID0gYXdhaXQgdGhpcy5faW5zcGVjdCh1cmwsIG1UaW1lc3RhbXApLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX2xvZ2dlci5lcnJvcihlcnIpO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCFtb2R1bGVSZWNvcmQpIHtcbiAgICAgICAgICAgIC8vIE1vZHVsZSByZWNvcmQgaXMgaW52YWxpZCBvciBjYWNoZSBpcyB2YWxpZFxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7IG1vZHVsZVJlY29yZCwgdXBkYXRlZDogdHJ1ZSB9O1xuICAgIH1cblxuICAgIHByaXZhdGUgYXN5bmMgX2xpbmsodXJsOiBVUkwsIG1vZHVsZVJlY29yZDogTW9kdWxlUmVjb3JkLCBjb250ZXh0OiBJbnNwZWN0Q29udGV4dCkge1xuICAgICAgICBjb25zdCBjaHVua0ltcG9ydHM6IFJlY29yZDxzdHJpbmcsIENodW5rSWQ+ID0ge307XG5cbiAgICAgICAgbGV0IGZvcmNlUmVzb2x2ZSA9IGZhbHNlO1xuICAgICAgICBpZiAoIW1vZHVsZVJlY29yZC5yZXNvbHZlZEltcG9ydHMpIHtcbiAgICAgICAgICAgIGZvcmNlUmVzb2x2ZSA9IHRydWU7XG4gICAgICAgICAgICBtb2R1bGVSZWNvcmQucmVzb2x2ZWRJbXBvcnRzID0gbmV3IEFycmF5KG1vZHVsZVJlY29yZC5pbXBvcnRzLmxlbmd0aCkuZmlsbChudWxsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHJlc29sdmVkSW1wb3J0cyA9IG1vZHVsZVJlY29yZC5yZXNvbHZlZEltcG9ydHM7XG5cbiAgICAgICAgY29uc3QgZGVwUmVjb3JkcyA9IGF3YWl0IFByb21pc2UuYWxsKG1vZHVsZVJlY29yZC5pbXBvcnRzLm1hcChhc3luYyAoc3BlY2lmaWVyLCBpSW1wb3J0KTogUHJvbWlzZTx1bmRlZmluZWQgfCBJbnNwZWN0UmVjb3JkPiA9PiB7XG4gICAgICAgICAgICBsZXQgcmVzb2x2ZWQgPSByZXNvbHZlZEltcG9ydHNbaUltcG9ydF07XG4gICAgICAgICAgICBpZiAoZm9yY2VSZXNvbHZlIHx8IC8vIE5vdCByZXNvbHZlZCBiZWZvcmVcbiAgICAgICAgICAgICAgICByZXNvbHZlZCA9PT0gbnVsbCAmJiBjb250ZXh0LnJldHJ5UmVzb2x1dGlvbk9uVW5jaGFuZ2VkTW9kdWxlIC8vIFJlc29sdmVkIGJ1dCBmYWlsZWRcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHJlc29sdmVkID0gYXdhaXQgdGhpcy5fcmVzb2x2ZShzcGVjaWZpZXIsIHVybCwgbW9kdWxlUmVjb3JkLm1vZExvTWV0YWRhdGEpO1xuICAgICAgICAgICAgICAgIHJlc29sdmVkSW1wb3J0c1tpSW1wb3J0XSA9IHJlc29sdmVkO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIXJlc29sdmVkIHx8IHJlc29sdmVkLmlzRXh0ZXJuYWwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IHsgdXJsOiByZXNvbHZlZFVSTCB9ID0gcmVzb2x2ZWQ7XG5cbiAgICAgICAgICAgIGNvbnN0IGluc3BlY3RSZWNvcmQgPSBhd2FpdCB0aGlzLl9nZXRPckNyZWF0ZUluc3BlY3RSZWNvcmQocmVzb2x2ZWRVUkwsIGNvbnRleHQpO1xuICAgICAgICAgICAgYXdhaXQgaW5zcGVjdFJlY29yZC5pbnNwZWN0O1xuXG4gICAgICAgICAgICBjb25zdCByZXNvbHZlZENodW5rID0gdGhpcy5fbW9kdWxlUmVjb3Jkc1tyZXNvbHZlZFVSTC5ocmVmXT8uY2h1bmtJZDtcbiAgICAgICAgICAgIGlmIChyZXNvbHZlZENodW5rKSB7XG4gICAgICAgICAgICAgICAgY2h1bmtJbXBvcnRzW3NwZWNpZmllci52YWx1ZV0gPSByZXNvbHZlZENodW5rO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9sb2dnZXIuZGVidWcoYFdlJ3JlIG1pc3NpbmcgdGhlIGNodW5rICR7cmVzb2x2ZWRVUkwuaHJlZn0sIHJlZmVyZW5jZWQgYXMgJyR7c3BlY2lmaWVyfScuYCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBpbnNwZWN0UmVjb3JkO1xuICAgICAgICB9KSk7XG5cbiAgICAgICAgY29uc3QgY2h1bmsgPSBhd2FpdCB0aGlzLl9jaHVua1dyaXRlci5nZXRDaHVuayhtb2R1bGVSZWNvcmQuY2h1bmtJZCk7XG4gICAgICAgIGFzc2VydHMoY2h1bmspO1xuICAgICAgICBjaHVuay5pbXBvcnRzID0gY2h1bmtJbXBvcnRzO1xuXG4gICAgICAgIHJldHVybiBkZXBSZWNvcmRzO1xuICAgIH1cblxuICAgIHByaXZhdGUgYXN5bmMgX2luc3BlY3QodXJsOiBVUkwsIG1UaW1lc3RhbXA6IG51bWJlcikge1xuICAgICAgICBsZXQgbW9kOiBNb2Q7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBtb2QgPSBhd2FpdCB0aGlzLl9tb2RMby5sb2FkKHVybCk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgdGhpcy5fbG9nZ2VyLmVycm9yKGkxOG5UcmFuc2xhdGUoJ3F1aWNrX3BhY2tfZmFpbGVkX3RvX2xvYWQnLCB7IHVybDogdXJsLmhyZWYsIGNhdXNlOiBlcnIgfSkpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgb3JpZ2luYWxTb3VyY2UsXG4gICAgICAgICAgICBjb2RlLFxuICAgICAgICAgICAgbWFwLFxuICAgICAgICAgICAgbW9kTG9NZXRhZGF0YSxcbiAgICAgICAgfSA9IG1vZDtcblxuICAgICAgICBsZXQgYXN0OiBBc3Q7XG4gICAgICAgIGlmICh0eXBlb2YgY29kZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIC8vIFRPRE86IGlucHV0IHNvdXJjZSBtYXBcbiAgICAgICAgICAgIGFzdCA9IGF3YWl0IHRoaXMuX21vZExvLnBhcnNlKGNvZGUsIG1hcCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhc3QgPSBjb2RlO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgaW1wb3J0cyA9IGF3YWl0IGRldGVjdEltcG9ydHMoYXN0KTtcblxuICAgICAgICBjb25zdCBjaHVua1VSTCA9IHRoaXMuX2dldENodW5rVVJMKHVybCk7XG5cbiAgICAgICAgY29uc3QgY2h1bmtJZCA9IHRoaXMuX2NodW5rV3JpdGVyLmdldENodW5rSWQoY2h1bmtVUkwpO1xuXG4gICAgICAgIHRoaXMuX3RyYW5zZm9ybUFuZEFkZChcbiAgICAgICAgICAgIGNodW5rSWQsXG4gICAgICAgICAgICB1cmwsXG4gICAgICAgICAgICBhc3QsXG4gICAgICAgICAgICB0eXBlb2YgbWFwID09PSAnc3RyaW5nJyA/IEpTT04ucGFyc2UobWFwKSA6IG1hcCA/PyB1bmRlZmluZWQsXG4gICAgICAgICAgICBvcmlnaW5hbFNvdXJjZSxcbiAgICAgICAgKTtcblxuICAgICAgICBjb25zdCBtb2R1bGVSZWNvcmQ6IE1vZHVsZVJlY29yZCA9IHtcbiAgICAgICAgICAgIG1UaW1lc3RhbXAsXG4gICAgICAgICAgICBjaHVua0lkLFxuICAgICAgICAgICAgaW1wb3J0czogaW1wb3J0cyxcbiAgICAgICAgICAgIG1vZExvTWV0YWRhdGEsXG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5fbW9kdWxlUmVjb3Jkc1t1cmwuaHJlZl0gPSBtb2R1bGVSZWNvcmQ7XG5cbiAgICAgICAgcmV0dXJuIG1vZHVsZVJlY29yZDtcbiAgICB9XG5cbiAgICBwcml2YXRlIGFzeW5jIF90cmFuc2Zvcm1BbmRBZGQoY2h1bmtJZDogc3RyaW5nLCB1cmw6IFVSTCwgYXN0OiBBc3QsIG1hcDogUmF3U291cmNlTWFwIHwgdW5kZWZpbmVkLCBvcmlnaW5hbFNvdXJjZTogc3RyaW5nKSB7XG4gICAgICAgIGNvbnN0IHRyYW5zZm9ybWVkID0gYXdhaXQgdGhpcy5fdHJhbnNmb3JtKHVybCwgYXN0LCBtYXAsIG9yaWdpbmFsU291cmNlKTtcblxuICAgICAgICBhd2FpdCB0aGlzLl9jaHVua1dyaXRlci5hZGRDaHVuayhcbiAgICAgICAgICAgIGNodW5rSWQsXG4gICAgICAgICAgICB0cmFuc2Zvcm1lZC5jb2RlLFxuICAgICAgICAgICAgdHJhbnNmb3JtZWQubWFwLFxuICAgICAgICApO1xuICAgIH1cblxuICAgIHByaXZhdGUgYXN5bmMgX3RyYW5zZm9ybSh1cmw6IFVSTCwgYXN0OiBBc3QsIG1hcDogUmF3U291cmNlTWFwIHwgdW5kZWZpbmVkLCBvcmlnaW5hbFNvdXJjZTogc3RyaW5nKSB7XG4gICAgICAgIGNvbnN0IGJhYmVsUmVzdWx0ID0gYXdhaXQgYmFiZWwudHJhbnNmb3JtRnJvbUFzdEFzeW5jKFxuICAgICAgICAgICAgYXN0LFxuICAgICAgICAgICAgb3JpZ2luYWxTb3VyY2UsIHtcbiAgICAgICAgICAgICAgICBzb3VyY2VGaWxlTmFtZTogdXJsLmhyZWYsXG4gICAgICAgICAgICAgICAgLy8gY2xvbmVJbnB1dEFzdDogZmFsc2UsXG4gICAgICAgICAgICAgICAgY29uZmlnRmlsZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgc291cmNlVHlwZTogJ21vZHVsZScsXG4gICAgICAgICAgICAgICAgc291cmNlTWFwczogdGhpcy5fc291cmNlTWFwcyxcbiAgICAgICAgICAgICAgICBpbnB1dFNvdXJjZU1hcDogbWFwLFxuICAgICAgICAgICAgICAgIHBsdWdpbnM6IFtcbiAgICAgICAgICAgICAgICAgICAgW2JhYmVsUGx1Z2luVHJhbnNmb3JtU3lzdGVtSnNdLFxuICAgICAgICAgICAgICAgICAgICAvLyBEeW5hbWljIGltcG9ydCgpIHRyYW5zZm9ybWF0aW9uIG11c3QgYmUgZW5hYmxlZCB1c2luZyB0aGVcbiAgICAgICAgICAgICAgICAgICAgLy8gQGJhYmVsL3BsdWdpbi1wcm9wb3NhbC1keW5hbWljLWltcG9ydCBwbHVnaW4uIEJhYmVsIDggd2lsbFxuICAgICAgICAgICAgICAgICAgICAvLyBubyBsb25nZXIgdHJhbnNmb3JtIGltcG9ydCgpIHdpdGhvdXQgdXNpbmcgdGhhdCBwbHVnaW4uXG4gICAgICAgICAgICAgICAgICAgIFtiYWJlbFBsdWdpblByb3Bvc2FsRHluYW1pY0ltcG9ydF0sXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIH0gYXMgYmFiZWwuVHJhbnNmb3JtT3B0aW9ucyAmIHtcbiAgICAgICAgICAgICAgICBjbG9uZUlucHV0QXN0PzogYm9vbGVhbjtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICk7XG4gICAgICAgIGFzc2VydHMoYmFiZWxSZXN1bHQpO1xuICAgICAgICBhc3NlcnRzKGJhYmVsUmVzdWx0LmNvZGUpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY29kZTogYmFiZWxSZXN1bHQuY29kZSxcbiAgICAgICAgICAgIG1hcDogYmFiZWxSZXN1bHQubWFwIGFzIHVua25vd24gYXMgU291cmNlTWFwLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIHByaXZhdGUgYXN5bmMgX3Jlc29sdmUoc3BlY2lmaWVyOiBTcGVjaWZpZXIsIHBhcmVudFVSTDogVVJMLCBtb2RMb01ldGFkYXRhOiBNb2RMb01ldGFkYXRhKSB7XG4gICAgICAgIGNvbnN0IHNwZWNpZmllclZhbHVlID0gc3BlY2lmaWVyLnZhbHVlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmVzb2x2ZWQgPSBhd2FpdCB0aGlzLl9tb2RMby5yZXNvbHZlKHNwZWNpZmllclZhbHVlLCBwYXJlbnRVUkwsIG1vZExvTWV0YWRhdGEpO1xuICAgICAgICAgICAgaWYgKHRoaXMuX3ZlcmJvc2UpIHtcbiAgICAgICAgICAgICAgICBpZiAocmVzb2x2ZWQuaXNFeHRlcm5hbCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9sb2dnZXIuZGVidWcoYFJlc29sdmUgJHtzcGVjaWZpZXJWYWx1ZX0gZnJvbSAke3BhcmVudFVSTC5ocmVmfSBhcyBleHRlcm5hbCBkZXBlbmRlbmN5ICR7cmVzb2x2ZWQuc3BlY2lmaWVyT3JVUkx9LmApO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2xvZ2dlci5kZWJ1ZyhgUmVzb2x2ZSAke3NwZWNpZmllclZhbHVlfSBmcm9tICR7cGFyZW50VVJMLmhyZWZ9IGFzICR7cmVzb2x2ZWQudXJsfS5gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzb2x2ZWQ7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgdGhpcy5fbG9nZ2VyLmVycm9yKGkxOG5UcmFuc2xhdGUoXG4gICAgICAgICAgICAgICAgJ3F1aWNrX3BhY2tfZmFpbGVkX3RvX3Jlc29sdmUnLFxuICAgICAgICAgICAgICAgIHsgc3BlY2lmaWVyOiBzcGVjaWZpZXJWYWx1ZSwgcGFyZW50VVJMOiBwYXJlbnRVUkwuaHJlZiwgY2F1c2U6IGVyciB9LFxuICAgICAgICAgICAgKSk7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1hcCB0aGUgbW9kdWxlIFVSTCB0byBjaHVuayBVUkwuXG4gICAgICogQHBhcmFtIHVybCBcbiAgICAgKi9cbiAgICBwcml2YXRlIF9nZXRDaHVua1VSTChfdXJsOiBSZWFkb25seTxVUkw+KTogUmVhZG9ubHk8VVJMPiB7XG4gICAgICAgIC8vIFRPRE86IGRvIGl0IGJldHRlclxuICAgICAgICBsZXQgdXJsOiBSZWFkb25seTxVUkw+O1xuICAgICAgICBpZiAoIV91cmwuc2VhcmNoKSB7XG4gICAgICAgICAgICB1cmwgPSBfdXJsO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgdSA9IG5ldyBVUkwoX3VybC5ocmVmKTtcbiAgICAgICAgICAgIGNvbnN0IGV4dGVuc2lvbk5hbWUgPSBwYXJzZUV4dGVuc2lvbk5hbWUodS5wYXRobmFtZSk7XG4gICAgICAgICAgICByZXBsYWNlRXh0ZW5zaW9uKHUsIGAucHJveHkke2V4dGVuc2lvbk5hbWV9YCk7XG4gICAgICAgICAgICB1cmwgPSB1O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8g6KeB77yaaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vc2hyaW5rdG9maXQvNTBmMjM4MDc4MmI2MjE5ZWQ2YTRjYjNhMjEwYTc1ZjdcbiAgICAgICAgZm9yIChjb25zdCBbZnJvbSwgdG9dIG9mIHRoaXMuX2V4dGVuc2lvbk1hcHBpbmcpIHtcbiAgICAgICAgICAgIGlmICh1cmwucGF0aG5hbWUuZW5kc1dpdGgoZnJvbSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXNzaWduUGF0aG5hbWUoXG4gICAgICAgICAgICAgICAgICAgIG5ldyBVUkwodXJsLmhyZWYpLFxuICAgICAgICAgICAgICAgICAgICBgJHt1cmwucGF0aG5hbWUuc3Vic3RyKDAsIHVybC5wYXRobmFtZS5sZW5ndGggLSBmcm9tLmxlbmd0aCl9JHt0b31gLFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFwYXJzZUV4dGVuc2lvbk5hbWUodXJsLnBhdGhuYW1lKSkge1xuICAgICAgICAgICAgLy8gVVJMcyB3aXRoIG5vIGV4dGVuc2lvbiBhcmUgc3RvcmUgYXMgLmpzXG4gICAgICAgICAgICByZXR1cm4gYXNzaWduUGF0aG5hbWUoXG4gICAgICAgICAgICAgICAgbmV3IFVSTCh1cmwuaHJlZiksXG4gICAgICAgICAgICAgICAgYCR7dXJsLnBhdGhuYW1lfS5qc2BcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVybDtcbiAgICB9XG59XG5cbmludGVyZmFjZSBJbnNwZWN0UmVjb3JkIHtcbiAgICBpbnNwZWN0OiBQcm9taXNlPHsgbW9kdWxlUmVjb3JkOiBNb2R1bGVSZWNvcmQ7IHVwZGF0ZWQ6IGJvb2xlYW47IH0gfCB1bmRlZmluZWQ+O1xuICAgIGxpbms6IFByb21pc2U8dm9pZD4gfCB1bmRlZmluZWQ7XG4gICAgZGVwZW5kZW5jaWVzOiBBcnJheTxJbnNwZWN0UmVjb3JkIHwgdW5kZWZpbmVkPiB8IHVuZGVmaW5lZDtcbn1cblxuaW50ZXJmYWNlIEluc3BlY3RDb250ZXh0IHtcbiAgICBmb3JjZUFsbDogYm9vbGVhbjtcbiAgICByZXRyeVJlc29sdXRpb25PblVuY2hhbmdlZE1vZHVsZTogYm9vbGVhbjtcbiAgICBtb2R1bGVzOiBNYXA8c3RyaW5nLCBJbnNwZWN0UmVjb3JkPjtcbn1cbiJdfQ==