"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.QuickPack = void 0;
const path_1 = __importDefault(require("path"));
const fs_extra_1 = __importDefault(require("fs-extra"));
const url_1 = require("url");
const writer_1 = require("./utils/chunk-io/writer");
const loader_context_1 = require("./utils/loader-context");
const url_2 = require("../utils/url");
const logger_1 = require("../utils/logger");
const babel = __importStar(require("@babel/core"));
// @ts-expect-error
const plugin_transform_modules_systemjs_1 = __importDefault(require("@babel/plugin-transform-modules-systemjs"));
// @ts-expect-error
const plugin_proposal_dynamic_import_1 = __importDefault(require("@babel/plugin-proposal-dynamic-import"));
const asserts_1 = require("../../utils/asserts");
const detect_imports_1 = require("./utils/detect-imports");
const launch_policy_1 = require("../utils/launch-policy");
const i18n_1 = require("../../utils/i18n");
const getLauncher = (par) => par ? launch_policy_1.parallelDiscarding : launch_policy_1.sequenceDiscarding;
const resolveLauncher = getLauncher(true);
class QuickPack {
    constructor({ modLo, sourceMaps, origin, workspace, verbose, logger, }) {
        this._moduleRecords = {};
        this._extensionMapping = [
            ['.ts', '.js'],
            ['.mjs', '.js'],
        ];
        this._verbose = verbose !== null && verbose !== void 0 ? verbose : false;
        this._origin = origin;
        this._modLo = modLo;
        this._sourceMaps = sourceMaps !== null && sourceMaps !== void 0 ? sourceMaps : true;
        this._moduleRecordFile = path_1.default.join(workspace, 'modules.json');
        this._chunkRecordFile = path_1.default.join(workspace, 'chunks.json');
        this._sourceCacheDir = path_1.default.join(workspace, 'mods');
        this._chunkWriter = new writer_1.ChunkWriter({
            origin,
            chunkRecordFile: this._chunkRecordFile,
            sourceCacheDir: this._sourceCacheDir,
        });
        this._logger = logger !== null && logger !== void 0 ? logger : logger_1.createLogger({});
    }
    async build(specifiers, options) {
        var _a, _b;
        const context = {
            modules: new Map(),
            forceAll: (_a = options === null || options === void 0 ? void 0 : options.forceAll) !== null && _a !== void 0 ? _a : false,
            retryResolutionOnUnchangedModule: (_b = options === null || options === void 0 ? void 0 : options.retryResolutionOnUnchangedModule) !== null && _b !== void 0 ? _b : false,
        };
        for (const specifier of specifiers) {
            const url = typeof specifier === 'string'
                ? await this._resolveEntry(specifier)
                : specifier;
            if (!url) {
                continue;
            }
            const inspectRecord = await this._getOrCreateInspectRecord(url, context);
            await this._instantiateAll(inspectRecord, new Set());
            const moduleRecord = this._moduleRecords[url.href];
            if (!moduleRecord) {
                this._logger.debug(`Entry ${url} did not library a chunk.`);
                continue;
            }
            const chunk = await this._chunkWriter.getChunk(moduleRecord.chunkId);
            asserts_1.asserts(chunk);
            chunk.isEntry = true;
            chunk.exposeAs = url.href;
        }
        await fs_extra_1.default.outputJson(this._moduleRecordFile, this._moduleRecords, { encoding: 'utf8', spaces: 2 });
        await this._chunkWriter.syncChunk();
    }
    async createLoaderContext() {
        return new loader_context_1.LoaderContext(this._origin, this._chunkRecordFile, this._sourceCacheDir);
    }
    async loadCache() {
        try {
            const serializedModuleRecords = await fs_extra_1.default.readJson(this._moduleRecordFile);
            for (const moduleRecord of Object.values(serializedModuleRecords)) {
                if (moduleRecord.resolvedImports) {
                    for (const resolveResult of moduleRecord.resolvedImports) {
                        if (resolveResult && !resolveResult.isExternal) {
                            resolveResult.url = new url_1.URL(resolveResult.url);
                        }
                    }
                }
            }
            this._moduleRecords = serializedModuleRecords;
        }
        catch (err) {
            this._logger.debug(`Module record file loaded failed with error: ${err}`);
        }
        await this._chunkWriter.loadCache();
    }
    async _resolveEntry(specifier) {
        try {
            return new url_1.URL(specifier);
        }
        catch (err) {
            this._logger.error(i18n_1.i18nTranslate('quick_pack_could_not_resolve_entry', { specifier }));
            return;
        }
    }
    async _getOrCreateInspectRecord(url, context) {
        const existedInspectRecord = context.modules.get(url.href);
        if (existedInspectRecord) {
            return existedInspectRecord;
        }
        let inspectRecord;
        const inspectPromise = this._inspectWithCache(url);
        const linkPromise = inspectPromise.then(async (moduleInspectInfo) => {
            if (moduleInspectInfo && (moduleInspectInfo.updated || context.forceAll)) {
                const dependencies = await this._link(url, moduleInspectInfo.moduleRecord, context);
                inspectRecord.dependencies = dependencies;
            }
        });
        inspectRecord = {
            inspect: inspectPromise,
            link: linkPromise,
            dependencies: undefined,
        };
        context.modules.set(url.href, inspectRecord);
        return inspectRecord;
    }
    async _instantiateAll(inspectRecord, visited) {
        if (visited.has(inspectRecord)) {
            return;
        }
        visited.add(inspectRecord);
        await inspectRecord.link;
        if (inspectRecord.dependencies) {
            await Promise.all(inspectRecord.dependencies.map(async (dependency) => {
                if (dependency) {
                    await this._instantiateAll(dependency, visited);
                }
            }));
        }
    }
    async _inspectWithCache(url) {
        const mTimestamp = await this._modLo.getMTimestamp(url);
        const oldModuleRecord = this._moduleRecords[url.href];
        if (oldModuleRecord) {
            if (mTimestamp === oldModuleRecord.mTimestamp) {
                return { moduleRecord: oldModuleRecord, updated: false };
            }
            this._logger.debug(`Detected change: ${url}. Last mtime: ${new Date(oldModuleRecord.mTimestamp)}, Current mtime: ${new Date(mTimestamp)}`);
            this._moduleRecords[url.href] = null;
            await this._chunkWriter.removeChunk(oldModuleRecord.chunkId);
        }
        if (this._verbose) {
            this._logger.debug(`Inspect ${url}`);
        }
        const moduleRecord = await this._inspect(url, mTimestamp).catch((err) => {
            this._logger.error(err);
        });
        if (!moduleRecord) {
            // Module record is invalid or cache is valid
            return undefined;
        }
        return { moduleRecord, updated: true };
    }
    async _link(url, moduleRecord, context) {
        const chunkImports = {};
        let forceResolve = false;
        if (!moduleRecord.resolvedImports) {
            forceResolve = true;
            moduleRecord.resolvedImports = new Array(moduleRecord.imports.length).fill(null);
        }
        const resolvedImports = moduleRecord.resolvedImports;
        const depRecords = await Promise.all(moduleRecord.imports.map(async (specifier, iImport) => {
            var _a;
            let resolved = resolvedImports[iImport];
            if (forceResolve || // Not resolved before
                resolved === null && context.retryResolutionOnUnchangedModule // Resolved but failed
            ) {
                resolved = await this._resolve(specifier, url, moduleRecord.modLoMetadata);
                resolvedImports[iImport] = resolved;
            }
            if (!resolved || resolved.isExternal) {
                return;
            }
            const { url: resolvedURL } = resolved;
            const inspectRecord = await this._getOrCreateInspectRecord(resolvedURL, context);
            await inspectRecord.inspect;
            const resolvedChunk = (_a = this._moduleRecords[resolvedURL.href]) === null || _a === void 0 ? void 0 : _a.chunkId;
            if (resolvedChunk) {
                chunkImports[specifier.value] = resolvedChunk;
            }
            else {
                this._logger.debug(`We're missing the chunk ${resolvedURL.href}, referenced as '${specifier}'.`);
            }
            return inspectRecord;
        }));
        const chunk = await this._chunkWriter.getChunk(moduleRecord.chunkId);
        asserts_1.asserts(chunk);
        chunk.imports = chunkImports;
        return depRecords;
    }
    async _inspect(url, mTimestamp) {
        let mod;
        try {
            mod = await this._modLo.load(url);
        }
        catch (err) {
            this._logger.error(i18n_1.i18nTranslate('quick_pack_failed_to_load', { url: url.href, cause: err }));
            if (url.protocol === 'node:') {
                this._logger.warn(i18n_1.i18nTranslate('load_error_hint_node_builtin'));
            }
            return;
        }
        const { originalSource, code, map, modLoMetadata, } = mod;
        let ast;
        if (typeof code === 'string') {
            // TODO: input source map
            ast = await this._modLo.parse(code, map);
        }
        else {
            ast = code;
        }
        const imports = await detect_imports_1.detectImports(ast);
        const chunkURL = this._getChunkURL(url);
        const chunkId = this._chunkWriter.getChunkId(chunkURL);
        this._transformAndAdd(chunkId, url, ast, typeof map === 'string' ? JSON.parse(map) : map !== null && map !== void 0 ? map : undefined, originalSource);
        const moduleRecord = {
            mTimestamp,
            chunkId,
            imports: imports,
            modLoMetadata,
        };
        this._moduleRecords[url.href] = moduleRecord;
        return moduleRecord;
    }
    async _transformAndAdd(chunkId, url, ast, map, originalSource) {
        const transformed = await this._transform(url, ast, map, originalSource);
        await this._chunkWriter.addChunk(chunkId, transformed.code, transformed.map);
    }
    async _transform(url, ast, map, originalSource) {
        const babelResult = await babel.transformFromAstAsync(ast, originalSource, {
            sourceFileName: url.href,
            // cloneInputAst: false,
            configFile: false,
            sourceType: 'module',
            sourceMaps: this._sourceMaps,
            inputSourceMap: map,
            plugins: [
                [plugin_transform_modules_systemjs_1.default],
                // Dynamic import() transformation must be enabled using the
                // @babel/plugin-proposal-dynamic-import plugin. Babel 8 will
                // no longer transform import() without using that plugin.
                [plugin_proposal_dynamic_import_1.default],
            ],
        });
        asserts_1.asserts(babelResult);
        asserts_1.asserts(babelResult.code);
        return {
            code: babelResult.code,
            map: babelResult.map,
        };
    }
    async _resolve(specifier, parentURL, modLoMetadata) {
        const specifierValue = specifier.value;
        try {
            const resolved = await this._modLo.resolve(specifierValue, parentURL, modLoMetadata);
            if (this._verbose) {
                if (resolved.isExternal) {
                    this._logger.debug(`Resolve ${specifierValue} from ${parentURL.href} as external dependency ${resolved.specifierOrURL}.`);
                }
                else {
                    this._logger.debug(`Resolve ${specifierValue} from ${parentURL.href} as ${resolved.url}.`);
                }
            }
            return resolved;
        }
        catch (err) {
            this._logger.error(i18n_1.i18nTranslate('quick_pack_failed_to_resolve', { specifier: specifierValue, parentURL: parentURL.href, cause: err }));
            if (specifierValue.includes('/')) {
                const lastPortion = specifierValue.split('/').pop();
                if (lastPortion && !lastPortion.includes('.')) {
                    this._logger.warn(i18n_1.i18nTranslate('resolve_error_hint_extension'));
                }
            }
            return null;
        }
    }
    /**
     * Map the module URL to chunk URL.
     * @param url
     */
    _getChunkURL(_url) {
        // TODO: do it better
        let url;
        if (!_url.search) {
            url = _url;
        }
        else {
            const u = new url_1.URL(_url.href);
            const extensionName = url_2.parseExtensionName(u.pathname);
            url_2.replaceExtension(u, `.proxy${extensionName}`);
            url = u;
        }
        // 见：https://gist.github.com/shrinktofit/50f2380782b6219ed6a4cb3a210a75f7
        for (const [from, to] of this._extensionMapping) {
            if (url.pathname.endsWith(from)) {
                return url_2.assignPathname(new url_1.URL(url.href), `${url.pathname.substr(0, url.pathname.length - from.length)}${to}`);
            }
        }
        if (!url_2.parseExtensionName(url.pathname)) {
            // URLs with no extension are store as .js
            return url_2.assignPathname(new url_1.URL(url.href), `${url.pathname}.js`);
        }
        return url;
    }
}
exports.QuickPack = QuickPack;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicXVpY2stcGFjay5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9tb2QtYXNzZW1ibGluZy9xdWljay1wYWNrL3F1aWNrLXBhY2sudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLGdEQUFzQjtBQUN0Qix3REFBMEI7QUFDMUIsNkJBQXlDO0FBR3pDLG9EQUFzRDtBQUV0RCwyREFBdUQ7QUFDdkQsc0NBQW9GO0FBQ3BGLDRDQUF1RDtBQUN2RCxtREFBcUM7QUFDckMsbUJBQW1CO0FBQ25CLGlIQUFvRjtBQUNwRixtQkFBbUI7QUFDbkIsMkdBQXFGO0FBQ3JGLGlEQUE4QztBQUM5QywyREFBa0U7QUFDbEUsMERBQWdGO0FBRWhGLDJDQUFpRDtBQUVqRCxNQUFNLFdBQVcsR0FBRyxDQUFDLEdBQVksRUFBRSxFQUFFLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxrQ0FBa0IsQ0FBQyxDQUFDLENBQUMsa0NBQWtCLENBQUM7QUFFcEYsTUFBTSxlQUFlLEdBQUcsV0FBVyxDQUFDLElBQUksQ0FBQyxDQUFDO0FBRTFDLE1BQWEsU0FBUztJQUNsQixZQUFZLEVBQ1IsS0FBSyxFQUNMLFVBQVUsRUFDVixNQUFNLEVBQ04sU0FBUyxFQUNULE9BQU8sRUFDUCxNQUFNLEdBUVQ7UUFrRk8sbUJBQWMsR0FBd0MsRUFBRSxDQUFDO1FBRXpELHNCQUFpQixHQUE0QjtZQUNqRCxDQUFDLEtBQUssRUFBRSxLQUFLLENBQUM7WUFDZCxDQUFDLE1BQU0sRUFBRSxLQUFLLENBQUM7U0FDbEIsQ0FBQztRQXRGRSxJQUFJLENBQUMsUUFBUSxHQUFHLE9BQU8sYUFBUCxPQUFPLGNBQVAsT0FBTyxHQUFJLEtBQUssQ0FBQztRQUNqQyxJQUFJLENBQUMsT0FBTyxHQUFHLE1BQU0sQ0FBQztRQUN0QixJQUFJLENBQUMsTUFBTSxHQUFHLEtBQUssQ0FBQztRQUNwQixJQUFJLENBQUMsV0FBVyxHQUFHLFVBQVUs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Q0FBQyxRQUFRLEtBQUssQ0FDdkIsQ0FBQztTQUNMO1FBQ0QsT0FBTyxHQUFHLENBQUM7SUFDZixDQUFDO0NBQ0o7QUE1WEQsOEJBNFhDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHBzIGZyb20gJ3BhdGgnO1xuaW1wb3J0IGZzIGZyb20gJ2ZzLWV4dHJhJztcbmltcG9ydCB7IHBhdGhUb0ZpbGVVUkwsIFVSTCB9IGZyb20gJ3VybCc7XG5pbXBvcnQgeyBNb2RMb01ldGFkYXRhLCBNb2RMbywgUmVzb2x2ZVJlc3VsdCwgU291cmNlLCBBc3QsIFNvdXJjZU1hcCwgTW9kIH0gZnJvbSAnLi4vbW9kLWxvL21vZC1sbyc7XG5pbXBvcnQgeyBNb2R1bGVSZWNvcmQgfSBmcm9tICcuL3V0aWxzL21vZC1yZWNvcmQnO1xuaW1wb3J0IHsgQ2h1bmtXcml0ZXIgfSBmcm9tICcuL3V0aWxzL2NodW5rLWlvL3dyaXRlcic7XG5pbXBvcnQgeyBDaHVua0lkIH0gZnJvbSAnLi91dGlscy9jaHVuay1pZCc7XG5pbXBvcnQgeyBMb2FkZXJDb250ZXh0IH0gZnJvbSAnLi91dGlscy9sb2FkZXItY29udGV4dCc7XG5pbXBvcnQgeyBhc3NpZ25QYXRobmFtZSwgcGFyc2VFeHRlbnNpb25OYW1lLCByZXBsYWNlRXh0ZW5zaW9uIH0gZnJvbSAnLi4vdXRpbHMvdXJsJztcbmltcG9ydCB7IGNyZWF0ZUxvZ2dlciwgTG9nZ2VyIH0gZnJvbSAnLi4vdXRpbHMvbG9nZ2VyJztcbmltcG9ydCAqIGFzIGJhYmVsIGZyb20gJ0BiYWJlbC9jb3JlJztcbi8vIEB0cy1leHBlY3QtZXJyb3JcbmltcG9ydCBiYWJlbFBsdWdpblRyYW5zZm9ybVN5c3RlbUpzIGZyb20gJ0BiYWJlbC9wbHVnaW4tdHJhbnNmb3JtLW1vZHVsZXMtc3lzdGVtanMnO1xuLy8gQHRzLWV4cGVjdC1lcnJvclxuaW1wb3J0IGJhYmVsUGx1Z2luUHJvcG9zYWxEeW5hbWljSW1wb3J0IGZyb20gJ0BiYWJlbC9wbHVnaW4tcHJvcG9zYWwtZHluYW1pYy1pbXBvcnQnO1xuaW1wb3J0IHsgYXNzZXJ0cyB9IGZyb20gJy4uLy4uL3V0aWxzL2Fzc2VydHMnO1xuaW1wb3J0IHsgZGV0ZWN0SW1wb3J0cywgU3BlY2lmaWVyIH0gZnJvbSAnLi91dGlscy9kZXRlY3QtaW1wb3J0cyc7XG5pbXBvcnQgeyBwYXJhbGxlbERpc2NhcmRpbmcsIHNlcXVlbmNlRGlzY2FyZGluZyB9IGZyb20gJy4uL3V0aWxzL2xhdW5jaC1wb2xpY3knO1xuaW1wb3J0IHsgUmF3U291cmNlTWFwIH0gZnJvbSAnc291cmNlLW1hcCc7XG5pbXBvcnQgeyBpMThuVHJhbnNsYXRlIH0gZnJvbSAnLi4vLi4vdXRpbHMvaTE4bic7XG5cbmNvbnN0IGdldExhdW5jaGVyID0gKHBhcjogYm9vbGVhbikgPT4gcGFyID8gcGFyYWxsZWxEaXNjYXJkaW5nIDogc2VxdWVuY2VEaXNjYXJkaW5nO1xuXG5jb25zdCByZXNvbHZlTGF1bmNoZXIgPSBnZXRMYXVuY2hlcih0cnVlKTtcblxuZXhwb3J0IGNsYXNzIFF1aWNrUGFjayB7XG4gICAgY29uc3RydWN0b3Ioe1xuICAgICAgICBtb2RMbyxcbiAgICAgICAgc291cmNlTWFwcyxcbiAgICAgICAgb3JpZ2luLFxuICAgICAgICB3b3Jrc3BhY2UsXG4gICAgICAgIHZlcmJvc2UsXG4gICAgICAgIGxvZ2dlcixcbiAgICB9OiB7XG4gICAgICAgIG1vZExvOiBNb2RMbztcbiAgICAgICAgc291cmNlTWFwcz86IGJvb2xlYW4gfCAnaW5saW5lJztcbiAgICAgICAgb3JpZ2luOiBzdHJpbmc7XG4gICAgICAgIHdvcmtzcGFjZTogc3RyaW5nO1xuICAgICAgICB2ZXJib3NlPzogYm9vbGVhbjtcbiAgICAgICAgbG9nZ2VyPzogTG9nZ2VyO1xuICAgIH0pIHtcbiAgICAgICAgdGhpcy5fdmVyYm9zZSA9IHZlcmJvc2UgPz8gZmFsc2U7XG4gICAgICAgIHRoaXMuX29yaWdpbiA9IG9yaWdpbjtcbiAgICAgICAgdGhpcy5fbW9kTG8gPSBtb2RMbztcbiAgICAgICAgdGhpcy5fc291cmNlTWFwcyA9IHNvdXJjZU1hcHMgPz8gdHJ1ZTtcbiAgICAgICAgdGhpcy5fbW9kdWxlUmVjb3JkRmlsZSA9IHBzLmpvaW4od29ya3NwYWNlLCAnbW9kdWxlcy5qc29uJyk7XG4gICAgICAgIHRoaXMuX2NodW5rUmVjb3JkRmlsZSA9IHBzLmpvaW4od29ya3NwYWNlLCAnY2h1bmtzLmpzb24nKTtcbiAgICAgICAgdGhpcy5fc291cmNlQ2FjaGVEaXIgPSBwcy5qb2luKHdvcmtzcGFjZSwgJ21vZHMnKTtcbiAgICAgICAgdGhpcy5fY2h1bmtXcml0ZXIgPSBuZXcgQ2h1bmtXcml0ZXIoe1xuICAgICAgICAgICAgb3JpZ2luLFxuICAgICAgICAgICAgY2h1bmtSZWNvcmRGaWxlOiB0aGlzLl9jaHVua1JlY29yZEZpbGUsXG4gICAgICAgICAgICBzb3VyY2VDYWNoZURpcjogdGhpcy5fc291cmNlQ2FjaGVEaXIsXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9sb2dnZXIgPSBsb2dnZXIgPz8gY3JlYXRlTG9nZ2VyKHt9KTtcbiAgICB9XG5cbiAgICBwdWJsaWMgYXN5bmMgYnVpbGQoc3BlY2lmaWVyczogSXRlcmFibGU8c3RyaW5nIHwgVVJMPiwgb3B0aW9ucz86IHtcbiAgICAgICAgZm9yY2VBbGw/OiBib29sZWFuO1xuICAgICAgICByZXRyeVJlc29sdXRpb25PblVuY2hhbmdlZE1vZHVsZT86IGJvb2xlYW47XG4gICAgfSkge1xuICAgICAgICBjb25zdCBjb250ZXh0OiBJbnNwZWN0Q29udGV4dCA9IHtcbiAgICAgICAgICAgIG1vZHVsZXM6IG5ldyBNYXAoKSxcbiAgICAgICAgICAgIGZvcmNlQWxsOiBvcHRpb25zPy5mb3JjZUFsbCA/PyBmYWxzZSxcbiAgICAgICAgICAgIHJldHJ5UmVzb2x1dGlvbk9uVW5jaGFuZ2VkTW9kdWxlOiBvcHRpb25zPy5yZXRyeVJlc29sdXRpb25PblVuY2hhbmdlZE1vZHVsZSA/PyBmYWxzZSxcbiAgICAgICAgfTtcbiAgICAgICAgZm9yIChjb25zdCBzcGVjaWZpZXIgb2Ygc3BlY2lmaWVycykge1xuICAgICAgICAgICAgY29uc3QgdXJsID0gdHlwZW9mIHNwZWNpZmllciA9PT0gJ3N0cmluZydcbiAgICAgICAgICAgICAgICA/IGF3YWl0IHRoaXMuX3Jlc29sdmVFbnRyeShzcGVjaWZpZXIpXG4gICAgICAgICAgICAgICAgOiBzcGVjaWZpZXI7XG4gICAgICAgICAgICBpZiAoIXVybCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgaW5zcGVjdFJlY29yZCA9IGF3YWl0IHRoaXMuX2dldE9yQ3JlYXRlSW5zcGVjdFJlY29yZCh1cmwsIGNvbnRleHQpO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5faW5zdGFudGlhdGVBbGwoaW5zcGVjdFJlY29yZCwgbmV3IFNldCgpKTtcbiAgICAgICAgICAgIGNvbnN0IG1vZHVsZVJlY29yZCA9IHRoaXMuX21vZHVsZVJlY29yZHNbdXJsLmhyZWZdO1xuICAgICAgICAgICAgaWYgKCFtb2R1bGVSZWNvcmQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9sb2dnZXIuZGVidWcoYEVudHJ5ICR7dXJsfSBkaWQgbm90IGxpYnJhcnkgYSBjaHVuay5gKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGNodW5rID0gYXdhaXQgdGhpcy5fY2h1bmtXcml0ZXIuZ2V0Q2h1bmsobW9kdWxlUmVjb3JkLmNodW5rSWQpO1xuICAgICAgICAgICAgYXNzZXJ0cyhjaHVuayk7XG4gICAgICAgICAgICBjaHVuay5pc0VudHJ5ID0gdHJ1ZTtcbiAgICAgICAgICAgIGNodW5rLmV4cG9zZUFzID0gdXJsLmhyZWY7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgZnMub3V0cHV0SnNvbih0aGlzLl9tb2R1bGVSZWNvcmRGaWxlLCB0aGlzLl9tb2R1bGVSZWNvcmRzLCB7IGVuY29kaW5nOiAndXRmOCcsIHNwYWNlczogMiB9KTtcbiAgICAgICAgYXdhaXQgdGhpcy5fY2h1bmtXcml0ZXIuc3luY0NodW5rKCk7XG4gICAgfVxuXG4gICAgcHVibGljIGFzeW5jIGNyZWF0ZUxvYWRlckNvbnRleHQoKSB7XG4gICAgICAgIHJldHVybiBuZXcgTG9hZGVyQ29udGV4dChcbiAgICAgICAgICAgIHRoaXMuX29yaWdpbixcbiAgICAgICAgICAgIHRoaXMuX2NodW5rUmVjb3JkRmlsZSxcbiAgICAgICAgICAgIHRoaXMuX3NvdXJjZUNhY2hlRGlyLFxuICAgICAgICApO1xuICAgIH1cblxuICAgIHB1YmxpYyBhc3luYyBsb2FkQ2FjaGUoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBzZXJpYWxpemVkTW9kdWxlUmVjb3JkczogUmVjb3JkPHN0cmluZywgTW9kdWxlUmVjb3JkPiA9IGF3YWl0IGZzLnJlYWRKc29uKHRoaXMuX21vZHVsZVJlY29yZEZpbGUpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBtb2R1bGVSZWNvcmQgb2YgT2JqZWN0LnZhbHVlcyhzZXJpYWxpemVkTW9kdWxlUmVjb3JkcykpIHtcbiAgICAgICAgICAgICAgICBpZiAobW9kdWxlUmVjb3JkLnJlc29sdmVkSW1wb3J0cykge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHJlc29sdmVSZXN1bHQgb2YgbW9kdWxlUmVjb3JkLnJlc29sdmVkSW1wb3J0cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc29sdmVSZXN1bHQgJiYgIXJlc29sdmVSZXN1bHQuaXNFeHRlcm5hbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmVSZXN1bHQudXJsID0gbmV3IFVSTChyZXNvbHZlUmVzdWx0LnVybCBhcyB1bmtub3duIGFzIHN0cmluZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9tb2R1bGVSZWNvcmRzID0gc2VyaWFsaXplZE1vZHVsZVJlY29yZHM7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgdGhpcy5fbG9nZ2VyLmRlYnVnKGBNb2R1bGUgcmVjb3JkIGZpbGUgbG9hZGVkIGZhaWxlZCB3aXRoIGVycm9yOiAke2Vycn1gKTtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCB0aGlzLl9jaHVua1dyaXRlci5sb2FkQ2FjaGUoKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIF92ZXJib3NlOiBib29sZWFuO1xuICAgIHByaXZhdGUgX29yaWdpbjogc3RyaW5nO1xuICAgIHByaXZhdGUgX21vZHVsZVJlY29yZEZpbGU6IHN0cmluZztcbiAgICBwcml2YXRlIF9jaHVua1JlY29yZEZpbGU6IHN0cmluZztcbiAgICBwcml2YXRlIF9zb3VyY2VDYWNoZURpcjogc3RyaW5nO1xuICAgIHByaXZhdGUgX21vZExvOiBNb2RMbztcbiAgICBwcml2YXRlIF9zb3VyY2VNYXBzOiBib29sZWFuIHwgJ2lubGluZSc7XG4gICAgcHJpdmF0ZSBfbW9kdWxlUmVjb3JkczogUmVjb3JkPHN0cmluZywgTW9kdWxlUmVjb3JkIHwgbnVsbD4gPSB7fTtcbiAgICBwcml2YXRlIF9jaHVua1dyaXRlcjogQ2h1bmtXcml0ZXI7XG4gICAgcHJpdmF0ZSBfZXh0ZW5zaW9uTWFwcGluZzogQXJyYXk8W3N0cmluZywgc3RyaW5nXT4gPSBbXG4gICAgICAgIFsnLnRzJywgJy5qcyddLFxuICAgICAgICBbJy5tanMnLCAnLmpzJ10sXG4gICAgXTtcbiAgICBwcml2YXRlIF9sb2dnZXI6IExvZ2dlcjtcblxuICAgIHByaXZhdGUgYXN5bmMgX3Jlc29sdmVFbnRyeShzcGVjaWZpZXI6IHN0cmluZykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBVUkwoc3BlY2lmaWVyKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICB0aGlzLl9sb2dnZXIuZXJyb3IoaTE4blRyYW5zbGF0ZSgncXVpY2tfcGFja19jb3VsZF9ub3RfcmVzb2x2ZV9lbnRyeScsIHsgc3BlY2lmaWVyIH0pKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgYXN5bmMgX2dldE9yQ3JlYXRlSW5zcGVjdFJlY29yZCh1cmw6IFVSTCwgY29udGV4dDogSW5zcGVjdENvbnRleHQpIHtcbiAgICAgICAgY29uc3QgZXhpc3RlZEluc3BlY3RSZWNvcmQgPSBjb250ZXh0Lm1vZHVsZXMuZ2V0KHVybC5ocmVmKTtcbiAgICAgICAgaWYgKGV4aXN0ZWRJbnNwZWN0UmVjb3JkKSB7XG4gICAgICAgICAgICByZXR1cm4gZXhpc3RlZEluc3BlY3RSZWNvcmQ7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgaW5zcGVjdFJlY29yZDogSW5zcGVjdFJlY29yZDtcblxuICAgICAgICBjb25zdCBpbnNwZWN0UHJvbWlzZSA9IHRoaXMuX2luc3BlY3RXaXRoQ2FjaGUodXJsKTtcbiAgICAgICAgY29uc3QgbGlua1Byb21pc2UgPSBpbnNwZWN0UHJvbWlzZS50aGVuKGFzeW5jIChtb2R1bGVJbnNwZWN0SW5mbykgPT4ge1xuICAgICAgICAgICAgaWYgKG1vZHVsZUluc3BlY3RJbmZvICYmIChtb2R1bGVJbnNwZWN0SW5mby51cGRhdGVkIHx8IGNvbnRleHQuZm9yY2VBbGwpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGVwZW5kZW5jaWVzID0gYXdhaXQgdGhpcy5fbGluayh1cmwsIG1vZHVsZUluc3BlY3RJbmZvLm1vZHVsZVJlY29yZCwgY29udGV4dCk7XG4gICAgICAgICAgICAgICAgaW5zcGVjdFJlY29yZC5kZXBlbmRlbmNpZXMgPSBkZXBlbmRlbmNpZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGluc3BlY3RSZWNvcmQgPSB7XG4gICAgICAgICAgICBpbnNwZWN0OiBpbnNwZWN0UHJvbWlzZSxcbiAgICAgICAgICAgIGxpbms6IGxpbmtQcm9taXNlLFxuICAgICAgICAgICAgZGVwZW5kZW5jaWVzOiB1bmRlZmluZWQsXG4gICAgICAgIH07XG4gICAgICAgIGNvbnRleHQubW9kdWxlcy5zZXQodXJsLmhyZWYsIGluc3BlY3RSZWNvcmQpO1xuICAgICAgICByZXR1cm4gaW5zcGVjdFJlY29yZDtcbiAgICB9XG5cbiAgICBwcml2YXRlIGFzeW5jIF9pbnN0YW50aWF0ZUFsbChpbnNwZWN0UmVjb3JkOiBJbnNwZWN0UmVjb3JkLCB2aXNpdGVkOiBTZXQ8SW5zcGVjdFJlY29yZD4pIHtcbiAgICAgICAgaWYgKHZpc2l0ZWQuaGFzKGluc3BlY3RSZWNvcmQpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmlzaXRlZC5hZGQoaW5zcGVjdFJlY29yZCk7XG4gICAgICAgIGF3YWl0IGluc3BlY3RSZWNvcmQubGluaztcbiAgICAgICAgaWYgKGluc3BlY3RSZWNvcmQuZGVwZW5kZW5jaWVzKSB7XG4gICAgICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChpbnNwZWN0UmVjb3JkLmRlcGVuZGVuY2llcy5tYXAoYXN5bmMgKGRlcGVuZGVuY3kpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZGVwZW5kZW5jeSkge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl9pbnN0YW50aWF0ZUFsbChkZXBlbmRlbmN5LCB2aXNpdGVkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIGFzeW5jIF9pbnNwZWN0V2l0aENhY2hlKHVybDogVVJMKSB7XG4gICAgICAgIGNvbnN0IG1UaW1lc3RhbXAgPSBhd2FpdCB0aGlzLl9tb2RMby5nZXRNVGltZXN0YW1wKHVybCk7XG4gICAgICAgIGNvbnN0IG9sZE1vZHVsZVJlY29yZCA9IHRoaXMuX21vZHVsZVJlY29yZHNbdXJsLmhyZWZdO1xuICAgICAgICBpZiAob2xkTW9kdWxlUmVjb3JkKSB7XG4gICAgICAgICAgICBpZiAobVRpbWVzdGFtcCA9PT0gb2xkTW9kdWxlUmVjb3JkLm1UaW1lc3RhbXApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBtb2R1bGVSZWNvcmQ6IG9sZE1vZHVsZVJlY29yZCwgdXBkYXRlZDogZmFsc2UgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2xvZ2dlci5kZWJ1ZyhgRGV0ZWN0ZWQgY2hhbmdlOiAke3VybH0uIExhc3QgbXRpbWU6ICR7bmV3IERhdGUob2xkTW9kdWxlUmVjb3JkLm1UaW1lc3RhbXApfSwgQ3VycmVudCBtdGltZTogJHtuZXcgRGF0ZShtVGltZXN0YW1wKX1gKTtcbiAgICAgICAgICAgIHRoaXMuX21vZHVsZVJlY29yZHNbdXJsLmhyZWZdID0gbnVsbDtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX2NodW5rV3JpdGVyLnJlbW92ZUNodW5rKG9sZE1vZHVsZVJlY29yZC5jaHVua0lkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl92ZXJib3NlKSB7XG4gICAgICAgICAgICB0aGlzLl9sb2dnZXIuZGVidWcoYEluc3BlY3QgJHt1cmx9YCk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBtb2R1bGVSZWNvcmQgPSBhd2FpdCB0aGlzLl9pbnNwZWN0KHVybCwgbVRpbWVzdGFtcCkuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICAgICAgdGhpcy5fbG9nZ2VyLmVycm9yKGVycik7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIW1vZHVsZVJlY29yZCkge1xuICAgICAgICAgICAgLy8gTW9kdWxlIHJlY29yZCBpcyBpbnZhbGlkIG9yIGNhY2hlIGlzIHZhbGlkXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHsgbW9kdWxlUmVjb3JkLCB1cGRhdGVkOiB0cnVlIH07XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBhc3luYyBfbGluayh1cmw6IFVSTCwgbW9kdWxlUmVjb3JkOiBNb2R1bGVSZWNvcmQsIGNvbnRleHQ6IEluc3BlY3RDb250ZXh0KSB7XG4gICAgICAgIGNvbnN0IGNodW5rSW1wb3J0czogUmVjb3JkPHN0cmluZywgQ2h1bmtJZD4gPSB7fTtcblxuICAgICAgICBsZXQgZm9yY2VSZXNvbHZlID0gZmFsc2U7XG4gICAgICAgIGlmICghbW9kdWxlUmVjb3JkLnJlc29sdmVkSW1wb3J0cykge1xuICAgICAgICAgICAgZm9yY2VSZXNvbHZlID0gdHJ1ZTtcbiAgICAgICAgICAgIG1vZHVsZVJlY29yZC5yZXNvbHZlZEltcG9ydHMgPSBuZXcgQXJyYXkobW9kdWxlUmVjb3JkLmltcG9ydHMubGVuZ3RoKS5maWxsKG51bGwpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcmVzb2x2ZWRJbXBvcnRzID0gbW9kdWxlUmVjb3JkLnJlc29sdmVkSW1wb3J0cztcblxuICAgICAgICBjb25zdCBkZXBSZWNvcmRzID0gYXdhaXQgUHJvbWlzZS5hbGwobW9kdWxlUmVjb3JkLmltcG9ydHMubWFwKGFzeW5jIChzcGVjaWZpZXIsIGlJbXBvcnQpOiBQcm9taXNlPHVuZGVmaW5lZCB8IEluc3BlY3RSZWNvcmQ+ID0+IHtcbiAgICAgICAgICAgIGxldCByZXNvbHZlZCA9IHJlc29sdmVkSW1wb3J0c1tpSW1wb3J0XTtcbiAgICAgICAgICAgIGlmIChmb3JjZVJlc29sdmUgfHwgLy8gTm90IHJlc29sdmVkIGJlZm9yZVxuICAgICAgICAgICAgICAgIHJlc29sdmVkID09PSBudWxsICYmIGNvbnRleHQucmV0cnlSZXNvbHV0aW9uT25VbmNoYW5nZWRNb2R1bGUgLy8gUmVzb2x2ZWQgYnV0IGZhaWxlZFxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZWQgPSBhd2FpdCB0aGlzLl9yZXNvbHZlKHNwZWNpZmllciwgdXJsLCBtb2R1bGVSZWNvcmQubW9kTG9NZXRhZGF0YSk7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZWRJbXBvcnRzW2lJbXBvcnRdID0gcmVzb2x2ZWQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghcmVzb2x2ZWQgfHwgcmVzb2x2ZWQuaXNFeHRlcm5hbCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgeyB1cmw6IHJlc29sdmVkVVJMIH0gPSByZXNvbHZlZDtcblxuICAgICAgICAgICAgY29uc3QgaW5zcGVjdFJlY29yZCA9IGF3YWl0IHRoaXMuX2dldE9yQ3JlYXRlSW5zcGVjdFJlY29yZChyZXNvbHZlZFVSTCwgY29udGV4dCk7XG4gICAgICAgICAgICBhd2FpdCBpbnNwZWN0UmVjb3JkLmluc3BlY3Q7XG5cbiAgICAgICAgICAgIGNvbnN0IHJlc29sdmVkQ2h1bmsgPSB0aGlzLl9tb2R1bGVSZWNvcmRzW3Jlc29sdmVkVVJMLmhyZWZdPy5jaHVua0lkO1xuICAgICAgICAgICAgaWYgKHJlc29sdmVkQ2h1bmspIHtcbiAgICAgICAgICAgICAgICBjaHVua0ltcG9ydHNbc3BlY2lmaWVyLnZhbHVlXSA9IHJlc29sdmVkQ2h1bms7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX2xvZ2dlci5kZWJ1ZyhgV2UncmUgbWlzc2luZyB0aGUgY2h1bmsgJHtyZXNvbHZlZFVSTC5ocmVmfSwgcmVmZXJlbmNlZCBhcyAnJHtzcGVjaWZpZXJ9Jy5gKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGluc3BlY3RSZWNvcmQ7XG4gICAgICAgIH0pKTtcblxuICAgICAgICBjb25zdCBjaHVuayA9IGF3YWl0IHRoaXMuX2NodW5rV3JpdGVyLmdldENodW5rKG1vZHVsZVJlY29yZC5jaHVua0lkKTtcbiAgICAgICAgYXNzZXJ0cyhjaHVuayk7XG4gICAgICAgIGNodW5rLmltcG9ydHMgPSBjaHVua0ltcG9ydHM7XG5cbiAgICAgICAgcmV0dXJuIGRlcFJlY29yZHM7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBhc3luYyBfaW5zcGVjdCh1cmw6IFVSTCwgbVRpbWVzdGFtcDogbnVtYmVyKSB7XG4gICAgICAgIGxldCBtb2Q6IE1vZDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIG1vZCA9IGF3YWl0IHRoaXMuX21vZExvLmxvYWQodXJsKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICB0aGlzLl9sb2dnZXIuZXJyb3IoaTE4blRyYW5zbGF0ZSgncXVpY2tfcGFja19mYWlsZWRfdG9fbG9hZCcsIHsgdXJsOiB1cmwuaHJlZiwgY2F1c2U6IGVyciB9KSk7XG4gICAgICAgICAgICBpZiAodXJsLnByb3RvY29sID09PSAnbm9kZTonKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbG9nZ2VyLndhcm4oaTE4blRyYW5zbGF0ZSgnbG9hZF9lcnJvcl9oaW50X25vZGVfYnVpbHRpbicpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIG9yaWdpbmFsU291cmNlLFxuICAgICAgICAgICAgY29kZSxcbiAgICAgICAgICAgIG1hcCxcbiAgICAgICAgICAgIG1vZExvTWV0YWRhdGEsXG4gICAgICAgIH0gPSBtb2Q7XG5cbiAgICAgICAgbGV0IGFzdDogQXN0O1xuICAgICAgICBpZiAodHlwZW9mIGNvZGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAvLyBUT0RPOiBpbnB1dCBzb3VyY2UgbWFwXG4gICAgICAgICAgICBhc3QgPSBhd2FpdCB0aGlzLl9tb2RMby5wYXJzZShjb2RlLCBtYXApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYXN0ID0gY29kZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGltcG9ydHMgPSBhd2FpdCBkZXRlY3RJbXBvcnRzKGFzdCk7XG5cbiAgICAgICAgY29uc3QgY2h1bmtVUkwgPSB0aGlzLl9nZXRDaHVua1VSTCh1cmwpO1xuXG4gICAgICAgIGNvbnN0IGNodW5rSWQgPSB0aGlzLl9jaHVua1dyaXRlci5nZXRDaHVua0lkKGNodW5rVVJMKTtcblxuICAgICAgICB0aGlzLl90cmFuc2Zvcm1BbmRBZGQoXG4gICAgICAgICAgICBjaHVua0lkLFxuICAgICAgICAgICAgdXJsLFxuICAgICAgICAgICAgYXN0LFxuICAgICAgICAgICAgdHlwZW9mIG1hcCA9PT0gJ3N0cmluZycgPyBKU09OLnBhcnNlKG1hcCkgOiBtYXAgPz8gdW5kZWZpbmVkLFxuICAgICAgICAgICAgb3JpZ2luYWxTb3VyY2UsXG4gICAgICAgICk7XG5cbiAgICAgICAgY29uc3QgbW9kdWxlUmVjb3JkOiBNb2R1bGVSZWNvcmQgPSB7XG4gICAgICAgICAgICBtVGltZXN0YW1wLFxuICAgICAgICAgICAgY2h1bmtJZCxcbiAgICAgICAgICAgIGltcG9ydHM6IGltcG9ydHMsXG4gICAgICAgICAgICBtb2RMb01ldGFkYXRhLFxuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuX21vZHVsZVJlY29yZHNbdXJsLmhyZWZdID0gbW9kdWxlUmVjb3JkO1xuXG4gICAgICAgIHJldHVybiBtb2R1bGVSZWNvcmQ7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBhc3luYyBfdHJhbnNmb3JtQW5kQWRkKGNodW5rSWQ6IHN0cmluZywgdXJsOiBVUkwsIGFzdDogQXN0LCBtYXA6IFJhd1NvdXJjZU1hcCB8IHVuZGVmaW5lZCwgb3JpZ2luYWxTb3VyY2U6IHN0cmluZykge1xuICAgICAgICBjb25zdCB0cmFuc2Zvcm1lZCA9IGF3YWl0IHRoaXMuX3RyYW5zZm9ybSh1cmwsIGFzdCwgbWFwLCBvcmlnaW5hbFNvdXJjZSk7XG5cbiAgICAgICAgYXdhaXQgdGhpcy5fY2h1bmtXcml0ZXIuYWRkQ2h1bmsoXG4gICAgICAgICAgICBjaHVua0lkLFxuICAgICAgICAgICAgdHJhbnNmb3JtZWQuY29kZSxcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkLm1hcCxcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGFzeW5jIF90cmFuc2Zvcm0odXJsOiBVUkwsIGFzdDogQXN0LCBtYXA6IFJhd1NvdXJjZU1hcCB8IHVuZGVmaW5lZCwgb3JpZ2luYWxTb3VyY2U6IHN0cmluZykge1xuICAgICAgICBjb25zdCBiYWJlbFJlc3VsdCA9IGF3YWl0IGJhYmVsLnRyYW5zZm9ybUZyb21Bc3RBc3luYyhcbiAgICAgICAgICAgIGFzdCxcbiAgICAgICAgICAgIG9yaWdpbmFsU291cmNlLCB7XG4gICAgICAgICAgICAgICAgc291cmNlRmlsZU5hbWU6IHVybC5ocmVmLFxuICAgICAgICAgICAgICAgIC8vIGNsb25lSW5wdXRBc3Q6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGNvbmZpZ0ZpbGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHNvdXJjZVR5cGU6ICdtb2R1bGUnLFxuICAgICAgICAgICAgICAgIHNvdXJjZU1hcHM6IHRoaXMuX3NvdXJjZU1hcHMsXG4gICAgICAgICAgICAgICAgaW5wdXRTb3VyY2VNYXA6IG1hcCxcbiAgICAgICAgICAgICAgICBwbHVnaW5zOiBbXG4gICAgICAgICAgICAgICAgICAgIFtiYWJlbFBsdWdpblRyYW5zZm9ybVN5c3RlbUpzXSxcbiAgICAgICAgICAgICAgICAgICAgLy8gRHluYW1pYyBpbXBvcnQoKSB0cmFuc2Zvcm1hdGlvbiBtdXN0IGJlIGVuYWJsZWQgdXNpbmcgdGhlXG4gICAgICAgICAgICAgICAgICAgIC8vIEBiYWJlbC9wbHVnaW4tcHJvcG9zYWwtZHluYW1pYy1pbXBvcnQgcGx1Z2luLiBCYWJlbCA4IHdpbGxcbiAgICAgICAgICAgICAgICAgICAgLy8gbm8gbG9uZ2VyIHRyYW5zZm9ybSBpbXBvcnQoKSB3aXRob3V0IHVzaW5nIHRoYXQgcGx1Z2luLlxuICAgICAgICAgICAgICAgICAgICBbYmFiZWxQbHVnaW5Qcm9wb3NhbER5bmFtaWNJbXBvcnRdLFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICB9IGFzIGJhYmVsLlRyYW5zZm9ybU9wdGlvbnMgJiB7XG4gICAgICAgICAgICAgICAgY2xvbmVJbnB1dEFzdD86IGJvb2xlYW47XG4gICAgICAgICAgICB9LFxuICAgICAgICApO1xuICAgICAgICBhc3NlcnRzKGJhYmVsUmVzdWx0KTtcbiAgICAgICAgYXNzZXJ0cyhiYWJlbFJlc3VsdC5jb2RlKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNvZGU6IGJhYmVsUmVzdWx0LmNvZGUsXG4gICAgICAgICAgICBtYXA6IGJhYmVsUmVzdWx0Lm1hcCBhcyB1bmtub3duIGFzIFNvdXJjZU1hcCxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGFzeW5jIF9yZXNvbHZlKHNwZWNpZmllcjogU3BlY2lmaWVyLCBwYXJlbnRVUkw6IFVSTCwgbW9kTG9NZXRhZGF0YTogTW9kTG9NZXRhZGF0YSkge1xuICAgICAgICBjb25zdCBzcGVjaWZpZXJWYWx1ZSA9IHNwZWNpZmllci52YWx1ZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJlc29sdmVkID0gYXdhaXQgdGhpcy5fbW9kTG8ucmVzb2x2ZShzcGVjaWZpZXJWYWx1ZSwgcGFyZW50VVJMLCBtb2RMb01ldGFkYXRhKTtcbiAgICAgICAgICAgIGlmICh0aGlzLl92ZXJib3NlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlc29sdmVkLmlzRXh0ZXJuYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbG9nZ2VyLmRlYnVnKGBSZXNvbHZlICR7c3BlY2lmaWVyVmFsdWV9IGZyb20gJHtwYXJlbnRVUkwuaHJlZn0gYXMgZXh0ZXJuYWwgZGVwZW5kZW5jeSAke3Jlc29sdmVkLnNwZWNpZmllck9yVVJMfS5gKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9sb2dnZXIuZGVidWcoYFJlc29sdmUgJHtzcGVjaWZpZXJWYWx1ZX0gZnJvbSAke3BhcmVudFVSTC5ocmVmfSBhcyAke3Jlc29sdmVkLnVybH0uYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc29sdmVkO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHRoaXMuX2xvZ2dlci5lcnJvcihpMThuVHJhbnNsYXRlKFxuICAgICAgICAgICAgICAgICdxdWlja19wYWNrX2ZhaWxlZF90b19yZXNvbHZlJyxcbiAgICAgICAgICAgICAgICB7IHNwZWNpZmllcjogc3BlY2lmaWVyVmFsdWUsIHBhcmVudFVSTDogcGFyZW50VVJMLmhyZWYsIGNhdXNlOiBlcnIgfSxcbiAgICAgICAgICAgICkpO1xuICAgICAgICAgICAgaWYgKHNwZWNpZmllclZhbHVlLmluY2x1ZGVzKCcvJykpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBsYXN0UG9ydGlvbiA9IHNwZWNpZmllclZhbHVlLnNwbGl0KCcvJykucG9wKCk7XG4gICAgICAgICAgICAgICAgaWYgKGxhc3RQb3J0aW9uICYmICFsYXN0UG9ydGlvbi5pbmNsdWRlcygnLicpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2xvZ2dlci53YXJuKGkxOG5UcmFuc2xhdGUoJ3Jlc29sdmVfZXJyb3JfaGludF9leHRlbnNpb24nKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNYXAgdGhlIG1vZHVsZSBVUkwgdG8gY2h1bmsgVVJMLlxuICAgICAqIEBwYXJhbSB1cmwgXG4gICAgICovXG4gICAgcHJpdmF0ZSBfZ2V0Q2h1bmtVUkwoX3VybDogUmVhZG9ubHk8VVJMPik6IFJlYWRvbmx5PFVSTD4ge1xuICAgICAgICAvLyBUT0RPOiBkbyBpdCBiZXR0ZXJcbiAgICAgICAgbGV0IHVybDogUmVhZG9ubHk8VVJMPjtcbiAgICAgICAgaWYgKCFfdXJsLnNlYXJjaCkge1xuICAgICAgICAgICAgdXJsID0gX3VybDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHUgPSBuZXcgVVJMKF91cmwuaHJlZik7XG4gICAgICAgICAgICBjb25zdCBleHRlbnNpb25OYW1lID0gcGFyc2VFeHRlbnNpb25OYW1lKHUucGF0aG5hbWUpO1xuICAgICAgICAgICAgcmVwbGFjZUV4dGVuc2lvbih1LCBgLnByb3h5JHtleHRlbnNpb25OYW1lfWApO1xuICAgICAgICAgICAgdXJsID0gdTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIOinge+8mmh0dHBzOi8vZ2lzdC5naXRodWIuY29tL3Nocmlua3RvZml0LzUwZjIzODA3ODJiNjIxOWVkNmE0Y2IzYTIxMGE3NWY3XG4gICAgICAgIGZvciAoY29uc3QgW2Zyb20sIHRvXSBvZiB0aGlzLl9leHRlbnNpb25NYXBwaW5nKSB7XG4gICAgICAgICAgICBpZiAodXJsLnBhdGhuYW1lLmVuZHNXaXRoKGZyb20pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFzc2lnblBhdGhuYW1lKFxuICAgICAgICAgICAgICAgICAgICBuZXcgVVJMKHVybC5ocmVmKSxcbiAgICAgICAgICAgICAgICAgICAgYCR7dXJsLnBhdGhuYW1lLnN1YnN0cigwLCB1cmwucGF0aG5hbWUubGVuZ3RoIC0gZnJvbS5sZW5ndGgpfSR7dG99YCxcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghcGFyc2VFeHRlbnNpb25OYW1lKHVybC5wYXRobmFtZSkpIHtcbiAgICAgICAgICAgIC8vIFVSTHMgd2l0aCBubyBleHRlbnNpb24gYXJlIHN0b3JlIGFzIC5qc1xuICAgICAgICAgICAgcmV0dXJuIGFzc2lnblBhdGhuYW1lKFxuICAgICAgICAgICAgICAgIG5ldyBVUkwodXJsLmhyZWYpLFxuICAgICAgICAgICAgICAgIGAke3VybC5wYXRobmFtZX0uanNgXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1cmw7XG4gICAgfVxufVxuXG5pbnRlcmZhY2UgSW5zcGVjdFJlY29yZCB7XG4gICAgaW5zcGVjdDogUHJvbWlzZTx7IG1vZHVsZVJlY29yZDogTW9kdWxlUmVjb3JkOyB1cGRhdGVkOiBib29sZWFuOyB9IHwgdW5kZWZpbmVkPjtcbiAgICBsaW5rOiBQcm9taXNlPHZvaWQ+IHwgdW5kZWZpbmVkO1xuICAgIGRlcGVuZGVuY2llczogQXJyYXk8SW5zcGVjdFJlY29yZCB8IHVuZGVmaW5lZD4gfCB1bmRlZmluZWQ7XG59XG5cbmludGVyZmFjZSBJbnNwZWN0Q29udGV4dCB7XG4gICAgZm9yY2VBbGw6IGJvb2xlYW47XG4gICAgcmV0cnlSZXNvbHV0aW9uT25VbmNoYW5nZWRNb2R1bGU6IGJvb2xlYW47XG4gICAgbW9kdWxlczogTWFwPHN0cmluZywgSW5zcGVjdFJlY29yZD47XG59XG4iXX0=