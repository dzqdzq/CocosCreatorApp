"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.QuickPack = void 0;
const path_1 = __importDefault(require("path"));
const fs_extra_1 = __importDefault(require("fs-extra"));
const url_1 = require("url");
const mod_lo_1 = require("../mod-lo/mod-lo");
const writer_1 = require("./utils/chunk-io/writer");
const loader_context_1 = require("./utils/loader-context");
const url_2 = require("../utils/url");
const logger_1 = require("../utils/logger");
const babel = __importStar(require("@babel/core"));
// @ts-expect-error
const plugin_transform_modules_systemjs_1 = __importDefault(require("@babel/plugin-transform-modules-systemjs"));
// @ts-expect-error
const plugin_proposal_dynamic_import_1 = __importDefault(require("@babel/plugin-proposal-dynamic-import"));
const asserts_1 = require("../../utils/asserts");
const detect_imports_1 = require("./utils/detect-imports");
const launch_policy_1 = require("../utils/launch-policy");
const i18n_1 = require("../../utils/i18n");
const specifier_1 = require("../utils/specifier");
const getLauncher = (par) => par ? launch_policy_1.parallelDiscarding : launch_policy_1.sequenceDiscarding;
const resolveLauncher = getLauncher(true);
class QuickPack {
    constructor({ modLo, sourceMaps, origin, workspace, verbose, logger, }) {
        this._moduleRecords = {};
        this._extensionMapping = [
            ['.ts', '.js'],
            ['.mjs', '.js'],
        ];
        this._verbose = verbose !== null && verbose !== void 0 ? verbose : false;
        this._origin = origin;
        this._modLo = modLo;
        this._sourceMaps = sourceMaps !== null && sourceMaps !== void 0 ? sourceMaps : true;
        this._moduleRecordFile = path_1.default.join(workspace, 'modules.json');
        this._chunkRecordFile = path_1.default.join(workspace, 'chunks.json');
        this._sourceCacheDir = path_1.default.join(workspace, 'mods');
        const importMapFile = path_1.default.join(workspace, 'import-map.json');
        this._importMapFile = importMapFile;
        const theLogger = logger !== null && logger !== void 0 ? logger : logger_1.createLogger({});
        this._chunkWriter = new writer_1.ChunkWriter({
            origin,
            chunkRecordFile: this._chunkRecordFile,
            sourceCacheDir: this._sourceCacheDir,
            importMapFile,
            logger: theLogger,
        });
        this._logger = theLogger;
    }
    async build(specifiers, options) {
        var _a;
        const context = {
            modules: new Map(),
            retryResolutionOnUnchangedModule: (_a = options === null || options === void 0 ? void 0 : options.retryResolutionOnUnchangedModule) !== null && _a !== void 0 ? _a : false,
        };
        const entryModuleRecords = [];
        for (const specifier of specifiers) {
            const url = typeof specifier === 'string'
                ? await this._resolveEntry(specifier)
                : specifier;
            if (!url) {
                continue;
            }
            const inspectRecord = await this._getOrCreateInspectRecord(url, context);
            await this._instantiateAll(inspectRecord, new Set());
            const moduleRecord = this._moduleRecords[url.href];
            if (!moduleRecord) {
                this._logger.debug(`Entry ${url} did not library a chunk.`);
                continue;
            }
            entryModuleRecords.push([url, moduleRecord]);
            const chunk = await this._chunkWriter.getChunk(moduleRecord.chunkId);
            asserts_1.asserts(chunk);
            chunk.isEntry = true;
            chunk.exposeAs = url.href;
        }
        await fs_extra_1.default.outputJson(this._moduleRecordFile, this._moduleRecords, { encoding: 'utf8', spaces: 2 });
        const chunkAlias = {};
        for (const [entryURL, entryModuleRecord] of entryModuleRecords) {
            const chunkId = entryModuleRecord.chunkId;
            chunkAlias[entryURL.href] = chunkId;
        }
        await this._chunkWriter.syncChunk(chunkAlias);
    }
    async createLoaderContext() {
        return new loader_context_1.LoaderContext(this._origin, this._chunkRecordFile, this._sourceCacheDir, this._importMapFile);
    }
    async clear() {
        this._moduleRecords = {};
        const moduleRecordFile = this._moduleRecordFile;
        try {
            await fs_extra_1.default.unlink(moduleRecordFile);
        }
        catch (err) {
            this._logger.debug(`Failed to delete module record file ${moduleRecordFile}: ${err}`);
        }
        await this._chunkWriter.clear();
    }
    async loadCache() {
        try {
            const serializedModuleRecords = await fs_extra_1.default.readJson(this._moduleRecordFile);
            for (const moduleRecord of Object.values(serializedModuleRecords)) {
                if (moduleRecord.resolvedImports) {
                    for (const resolveResult of moduleRecord.resolvedImports) {
                        if (resolveResult && !resolveResult.isExternal) {
                            resolveResult.url = new url_1.URL(resolveResult.url);
                        }
                    }
                }
            }
            this._moduleRecords = serializedModuleRecords;
        }
        catch (err) {
            this._logger.debug(`Module record file loaded failed with error: ${err}`);
        }
        await this._chunkWriter.loadCache();
    }
    async _resolveEntry(specifier) {
        try {
            return new url_1.URL(specifier);
        }
        catch (err) {
            this._logger.error(i18n_1.i18nTranslate('quick_pack_could_not_resolve_entry', { specifier }));
            return;
        }
    }
    async _getOrCreateInspectRecord(url, context) {
        const existedInspectRecord = context.modules.get(url.href);
        if (existedInspectRecord) {
            return existedInspectRecord;
        }
        // eslint-disable-next-line prefer-const
        let inspectRecord;
        const inspectPromise = this._inspectWithCache(url);
        const linkPromise = inspectPromise.then(async (moduleInspectInfo) => {
            if (moduleInspectInfo) {
                const dependencies = await this._link(url, moduleInspectInfo.moduleRecord, context);
                inspectRecord.dependencies = dependencies;
            }
        });
        inspectRecord = {
            inspect: inspectPromise,
            link: linkPromise,
            dependencies: undefined,
        };
        context.modules.set(url.href, inspectRecord);
        return inspectRecord;
    }
    async _instantiateAll(inspectRecord, visited) {
        if (visited.has(inspectRecord)) {
            return;
        }
        visited.add(inspectRecord);
        await inspectRecord.link;
        if (inspectRecord.dependencies) {
            await Promise.all(inspectRecord.dependencies.map(async (dependency) => {
                if (dependency) {
                    await this._instantiateAll(dependency, visited);
                }
            }));
        }
    }
    async _inspectWithCache(url) {
        const mTimestamp = await this._modLo.getMTimestamp(url);
        const oldModuleRecord = this._moduleRecords[url.href];
        if (oldModuleRecord) {
            if (mod_lo_1.isEqualMTimestamp(mTimestamp, oldModuleRecord.mTimestamp)) {
                return { moduleRecord: oldModuleRecord, updated: false };
            }
            this._logger.debug(`Detected change: ${url}. Last mtime: ${mod_lo_1.mTimestampToString(oldModuleRecord.mTimestamp)}, Current mtime: ${mod_lo_1.mTimestampToString(mTimestamp)}`);
            this._moduleRecords[url.href] = null;
            await this._chunkWriter.removeChunk(oldModuleRecord.chunkId);
        }
        if (this._verbose) {
            this._logger.debug(`Inspect ${url}`);
        }
        const moduleRecord = await this._inspect(url, mTimestamp).catch((err) => {
            this._logger.error(err);
        });
        if (!moduleRecord) {
            // Module record is invalid or cache is valid
            return undefined;
        }
        return { moduleRecord, updated: true };
    }
    async _link(url, moduleRecord, context) {
        const chunkImports = {};
        let forceResolve = false;
        if (!moduleRecord.resolvedImports) {
            forceResolve = true;
            moduleRecord.resolvedImports = new Array(moduleRecord.imports.length).fill(null);
        }
        const resolvedImports = moduleRecord.resolvedImports;
        const depRecords = await Promise.all(moduleRecord.imports.map(async (specifier, iImport) => {
            var _a, _b;
            let resolved = resolvedImports[iImport];
            if (forceResolve || // Not resolved before
                resolved === null && context.retryResolutionOnUnchangedModule // Resolved but failed
            ) {
                resolved = await this._resolve(specifier, url, moduleRecord.modLoMetadata);
                resolvedImports[iImport] = resolved;
            }
            if (!resolved) {
                return;
            }
            const chunkImportKey = (_a = specifier.rewritten) !== null && _a !== void 0 ? _a : specifier.value;
            if (resolved.isExternal) {
                const isResolvedToBare = !url_2.tryParseURL(resolved.specifierOrURL);
                if (isResolvedToBare) {
                    // Only bare specifier may resolved to bare
                    asserts_1.asserts(!specifier.rewritten, `Something wrong with rewriting and resolve ${specifier.value}`);
                    return;
                }
                chunkImports[chunkImportKey] = {
                    external: true,
                    url: resolved.specifierOrURL,
                };
                return;
            }
            const { url: resolvedURL } = resolved;
            const inspectRecord = await this._getOrCreateInspectRecord(resolvedURL, context);
            await inspectRecord.inspect;
            const resolvedChunk = (_b = this._moduleRecords[resolvedURL.href]) === null || _b === void 0 ? void 0 : _b.chunkId;
            if (resolvedChunk) {
                chunkImports[chunkImportKey] = resolvedChunk;
            }
            else {
                this._logger.debug(`We're missing the chunk ${resolvedURL.href}, referenced as '${specifier}'.`);
            }
            return inspectRecord;
        }));
        const chunk = await this._chunkWriter.getChunk(moduleRecord.chunkId);
        asserts_1.asserts(chunk);
        chunk.imports = chunkImports;
        return depRecords;
    }
    async _inspect(url, mTimestamp) {
        let mod;
        try {
            mod = await this._modLo.load(url);
        }
        catch (err) {
            this._logger.error(i18n_1.i18nTranslate('quick_pack_failed_to_load', { url: url.href, cause: err }));
            if (url.protocol === 'node:') {
                this._logger.warn(i18n_1.i18nTranslate('load_error_hint_node_builtin'));
            }
            return;
        }
        const { originalSource, code, modLoMetadata, } = mod;
        let { map, } = mod;
        let ast;
        if (typeof code === 'string') {
            // TODO: input source map
            ast = await this._modLo.parse(code, map);
        }
        else {
            ast = code;
        }
        const chunkURL = this._getChunkURL(url);
        const chunkId = this._chunkWriter.getChunkId(chunkURL);
        let specifiers = [];
        ({ transformResult: { ast, map }, specifiers } = await this._rewriteImports(url, ast, typeof map === 'string' ? JSON.parse(map) : map !== null && map !== void 0 ? map : undefined, originalSource));
        await this._transformAndAdd(chunkId, url, ast, typeof map === 'string' ? JSON.parse(map) : map !== null && map !== void 0 ? map : undefined, originalSource);
        const moduleRecord = {
            mTimestamp,
            chunkId,
            imports: specifiers,
            modLoMetadata,
        };
        this._moduleRecords[url.href] = moduleRecord;
        return moduleRecord;
    }
    async _transformAndAdd(chunkId, url, ast, map, originalSource) {
        const transformed = await this._transform(url, ast, map, originalSource);
        await this._chunkWriter.addChunk(chunkId, transformed.code, transformed.map);
    }
    async _rewriteImports(url, ast, map, originalSource) {
        var _a;
        const specifiers = [];
        let nSpecifier = 0;
        const transformResult = await babel.transformFromAstAsync(ast, originalSource, {
            ast: true,
            code: false,
            sourceFileName: url.href,
            cloneInputAst: false,
            configFile: false,
            sourceType: 'module',
            sourceMaps: this._sourceMaps,
            inputSourceMap: map,
            plugins: [
                [detect_imports_1.createBabelPluginDetectAndRewriteImports({
                        specifiers,
                        rewrite: (specifier) => {
                            if (specifier_1.isBareSpecifier(specifier)) {
                                // If it's bare specifier, we do not rewrite it.
                                return undefined;
                            }
                            const rewritten = `__unresolved_${nSpecifier}`;
                            ++nSpecifier;
                            return rewritten;
                        },
                    })],
            ],
        });
        asserts_1.asserts(transformResult);
        asserts_1.asserts(transformResult.ast);
        return {
            transformResult: {
                ast: transformResult.ast,
                map: (_a = transformResult.map) !== null && _a !== void 0 ? _a : undefined,
            },
            specifiers,
        };
    }
    async _transform(url, ast, map, originalSource) {
        const babelResult = await babel.transformFromAstAsync(ast, originalSource, {
            sourceFileName: url.href,
            // cloneInputAst: false,
            configFile: false,
            sourceType: 'module',
            sourceMaps: this._sourceMaps,
            inputSourceMap: map,
            plugins: [
                [plugin_transform_modules_systemjs_1.default],
                // Dynamic import() transformation must be enabled using the
                // @babel/plugin-proposal-dynamic-import plugin. Babel 8 will
                // no longer transform import() without using that plugin.
                [plugin_proposal_dynamic_import_1.default],
            ],
        });
        asserts_1.asserts(babelResult);
        asserts_1.asserts(babelResult.code);
        return {
            code: babelResult.code,
            map: babelResult.map,
        };
    }
    async _resolve(specifier, parentURL, modLoMetadata) {
        const specifierValue = specifier.value;
        try {
            const resolved = await this._modLo.resolve(specifierValue, parentURL, modLoMetadata);
            if (this._verbose) {
                if (resolved.isExternal) {
                    this._logger.debug(`Resolve ${specifierValue} from ${parentURL.href} as external dependency ${resolved.specifierOrURL}.`);
                }
                else {
                    this._logger.debug(`Resolve ${specifierValue} from ${parentURL.href} as ${resolved.url}.`);
                }
            }
            return resolved;
        }
        catch (err) {
            this._logger.error(i18n_1.i18nTranslate('quick_pack_failed_to_resolve', { specifier: specifierValue, parentURL: parentURL.href, cause: err }));
            if (specifierValue.includes('/')) {
                const lastPortion = specifierValue.split('/').pop();
                if (lastPortion && !lastPortion.includes('.')) {
                    this._logger.warn(i18n_1.i18nTranslate('resolve_error_hint_extension'));
                }
            }
            return null;
        }
    }
    /**
     * Map the module URL to chunk URL.
     * @param url
     */
    _getChunkURL(_url) {
        // TODO: do it better
        let url;
        if (!_url.search) {
            url = _url;
        }
        else {
            const u = new url_1.URL(_url.href);
            const extensionName = url_2.parseExtensionName(u.pathname);
            url_2.replaceExtension(u, `.proxy${extensionName}`);
            url = u;
        }
        // 见：https://gist.github.com/shrinktofit/50f2380782b6219ed6a4cb3a210a75f7
        for (const [from, to] of this._extensionMapping) {
            if (url.pathname.endsWith(from)) {
                return url_2.assignPathname(new url_1.URL(url.href), `${url.pathname.substr(0, url.pathname.length - from.length)}${to}`);
            }
        }
        if (!url_2.parseExtensionName(url.pathname)) {
            // URLs with no extension are store as .js
            return url_2.assignPathname(new url_1.URL(url.href), `${url.pathname}.js`);
        }
        return url;
    }
}
exports.QuickPack = QuickPack;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicXVpY2stcGFjay5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9tb2QtYXNzZW1ibGluZy9xdWljay1wYWNrL3F1aWNrLXBhY2sudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLGdEQUFzQjtBQUN0Qix3REFBMEI7QUFDMUIsNkJBQXlDO0FBQ3pDLDZDQUF1SjtBQUV2SixvREFBc0Q7QUFFdEQsMkRBQXVEO0FBQ3ZELHNDQUFpRztBQUNqRyw0Q0FBdUQ7QUFDdkQsbURBQXFDO0FBQ3JDLG1CQUFtQjtBQUNuQixpSEFBb0Y7QUFDcEYsbUJBQW1CO0FBQ25CLDJHQUFxRjtBQUNyRixpREFBOEM7QUFDOUMsMkRBQTRHO0FBQzVHLDBEQUFnRjtBQUVoRiwyQ0FBaUQ7QUFFakQsa0RBQXFEO0FBRXJELE1BQU0sV0FBVyxHQUFHLENBQUMsR0FBWSxFQUFFLEVBQUUsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLGtDQUFrQixDQUFDLENBQUMsQ0FBQyxrQ0FBa0IsQ0FBQztBQUVwRixNQUFNLGVBQWUsR0FBRyxXQUFXLENBQUMsSUFBSSxDQUFDLENBQUM7QUFFMUMsTUFBYSxTQUFTO0lBQ2xCLFlBQVksRUFDUixLQUFLLEVBQ0wsVUFBVSxFQUNWLE1BQU0sRUFDTixTQUFTLEVBQ1QsT0FBTyxFQUNQLE1BQU0sR0FRVDtRQTBHTyxtQkFBYyxHQUF3QyxFQUFFLENBQUM7UUFFekQsc0JBQWlCLEdBQTRCO1lBQ2pELENBQUMsS0FBSyxFQUFFLEtBQUssQ0FBQztZQUNkLENBQUMsTUFBTSxFQUFFLEtBQUssQ0FBQztTQUNsQixDQUFDO1FBOUdFLElBQUksQ0FBQyxRQUFRLEdBQUcsT0FBTyxhQUFQLE9BQU8sY0FBUCxPQUFPLEdBQUksS0FBSyxDQUFDO1FBQ2pDLElBQUksQ0FBQyxPQUFPLEdBQUcsTUFBTSxDQUFDO1FBQ3RCLElBQUksQ0FBQyxNQUFNLEdBQUcsS0FBSyxDQUFDO1FBQ3BC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Q0FBQztTQUNYO1FBRUQseUVBQXlFO1FBQ3pFLEtBQUssTUFBTSxDQUFDLElBQUksRUFBRSxFQUFFLENBQUMsSUFBSSxJQUFJLENBQUMsaUJBQWlCLEVBQUU7WUFDN0MsSUFBSSxHQUFHLENBQUMsUUFBUSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsRUFBRTtnQkFDN0IsT0FBTyxvQkFBYyxDQUNqQixJQUFJLFNBQUcsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLEVBQ2pCLEdBQUcsR0FBRyxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsQ0FBQyxFQUFFLEdBQUcsQ0FBQyxRQUFRLENBQUMsTUFBTSxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsR0FBRyxFQUFFLEVBQUUsQ0FDdEUsQ0FBQzthQUNMO1NBQ0o7UUFDRCxJQUFJLENBQUMsd0JBQWtCLENBQUMsR0FBRyxDQUFDLFFBQVEsQ0FBQyxFQUFFO1lBQ25DLDBDQUEwQztZQUMxQyxPQUFPLG9CQUFjLENBQ2pCLElBQUksU0FBRyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsRUFDakIsR0FBRyxHQUFHLENBQUMsUUFBUSxLQUFLLENBQ3ZCLENBQUM7U0FDTDtRQUNELE9BQU8sR0FBRyxDQUFDO0lBQ2YsQ0FBQztDQUNKO0FBNWRELDhCQTRkQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBwcyBmcm9tICdwYXRoJztcbmltcG9ydCBmcyBmcm9tICdmcy1leHRyYSc7XG5pbXBvcnQgeyBwYXRoVG9GaWxlVVJMLCBVUkwgfSBmcm9tICd1cmwnO1xuaW1wb3J0IHsgTW9kTG9NZXRhZGF0YSwgTW9kTG8sIFJlc29sdmVSZXN1bHQsIFNvdXJjZSwgQXN0LCBTb3VyY2VNYXAsIE1vZCwgTVRpbWVzdGFtcCwgbVRpbWVzdGFtcFRvU3RyaW5nLCBpc0VxdWFsTVRpbWVzdGFtcCB9IGZyb20gJy4uL21vZC1sby9tb2QtbG8nO1xuaW1wb3J0IHsgTW9kdWxlUmVjb3JkIH0gZnJvbSAnLi91dGlscy9tb2QtcmVjb3JkJztcbmltcG9ydCB7IENodW5rV3JpdGVyIH0gZnJvbSAnLi91dGlscy9jaHVuay1pby93cml0ZXInO1xuaW1wb3J0IHsgQ2h1bmtJZCB9IGZyb20gJy4vdXRpbHMvY2h1bmstaWQnO1xuaW1wb3J0IHsgTG9hZGVyQ29udGV4dCB9IGZyb20gJy4vdXRpbHMvbG9hZGVyLWNvbnRleHQnO1xuaW1wb3J0IHsgYXNzaWduUGF0aG5hbWUsIHBhcnNlRXh0ZW5zaW9uTmFtZSwgcmVwbGFjZUV4dGVuc2lvbiwgdHJ5UGFyc2VVUkwgfSBmcm9tICcuLi91dGlscy91cmwnO1xuaW1wb3J0IHsgY3JlYXRlTG9nZ2VyLCBMb2dnZXIgfSBmcm9tICcuLi91dGlscy9sb2dnZXInO1xuaW1wb3J0ICogYXMgYmFiZWwgZnJvbSAnQGJhYmVsL2NvcmUnO1xuLy8gQHRzLWV4cGVjdC1lcnJvclxuaW1wb3J0IGJhYmVsUGx1Z2luVHJhbnNmb3JtU3lzdGVtSnMgZnJvbSAnQGJhYmVsL3BsdWdpbi10cmFuc2Zvcm0tbW9kdWxlcy1zeXN0ZW1qcyc7XG4vLyBAdHMtZXhwZWN0LWVycm9yXG5pbXBvcnQgYmFiZWxQbHVnaW5Qcm9wb3NhbER5bmFtaWNJbXBvcnQgZnJvbSAnQGJhYmVsL3BsdWdpbi1wcm9wb3NhbC1keW5hbWljLWltcG9ydCc7XG5pbXBvcnQgeyBhc3NlcnRzIH0gZnJvbSAnLi4vLi4vdXRpbHMvYXNzZXJ0cyc7XG5pbXBvcnQgeyBjcmVhdGVCYWJlbFBsdWdpbkRldGVjdEFuZFJld3JpdGVJbXBvcnRzLCBkZXRlY3RJbXBvcnRzLCBTcGVjaWZpZXIgfSBmcm9tICcuL3V0aWxzL2RldGVjdC1pbXBvcnRzJztcbmltcG9ydCB7IHBhcmFsbGVsRGlzY2FyZGluZywgc2VxdWVuY2VEaXNjYXJkaW5nIH0gZnJvbSAnLi4vdXRpbHMvbGF1bmNoLXBvbGljeSc7XG5pbXBvcnQgeyBSYXdTb3VyY2VNYXAgfSBmcm9tICdzb3VyY2UtbWFwJztcbmltcG9ydCB7IGkxOG5UcmFuc2xhdGUgfSBmcm9tICcuLi8uLi91dGlscy9pMThuJztcbmltcG9ydCB7IENodW5rIH0gZnJvbSAnLi91dGlscy9jaHVuayc7XG5pbXBvcnQgeyBpc0JhcmVTcGVjaWZpZXIgfSBmcm9tICcuLi91dGlscy9zcGVjaWZpZXInO1xuXG5jb25zdCBnZXRMYXVuY2hlciA9IChwYXI6IGJvb2xlYW4pID0+IHBhciA/IHBhcmFsbGVsRGlzY2FyZGluZyA6IHNlcXVlbmNlRGlzY2FyZGluZztcblxuY29uc3QgcmVzb2x2ZUxhdW5jaGVyID0gZ2V0TGF1bmNoZXIodHJ1ZSk7XG5cbmV4cG9ydCBjbGFzcyBRdWlja1BhY2sge1xuICAgIGNvbnN0cnVjdG9yKHtcbiAgICAgICAgbW9kTG8sXG4gICAgICAgIHNvdXJjZU1hcHMsXG4gICAgICAgIG9yaWdpbixcbiAgICAgICAgd29ya3NwYWNlLFxuICAgICAgICB2ZXJib3NlLFxuICAgICAgICBsb2dnZXIsXG4gICAgfToge1xuICAgICAgICBtb2RMbzogTW9kTG87XG4gICAgICAgIHNvdXJjZU1hcHM/OiBib29sZWFuIHwgJ2lubGluZSc7XG4gICAgICAgIG9yaWdpbjogc3RyaW5nO1xuICAgICAgICB3b3Jrc3BhY2U6IHN0cmluZztcbiAgICAgICAgdmVyYm9zZT86IGJvb2xlYW47XG4gICAgICAgIGxvZ2dlcj86IExvZ2dlcjtcbiAgICB9KSB7XG4gICAgICAgIHRoaXMuX3ZlcmJvc2UgPSB2ZXJib3NlID8/IGZhbHNlO1xuICAgICAgICB0aGlzLl9vcmlnaW4gPSBvcmlnaW47XG4gICAgICAgIHRoaXMuX21vZExvID0gbW9kTG87XG4gICAgICAgIHRoaXMuX3NvdXJjZU1hcHMgPSBzb3VyY2VNYXBzID8/IHRydWU7XG4gICAgICAgIHRoaXMuX21vZHVsZVJlY29yZEZpbGUgPSBwcy5qb2luKHdvcmtzcGFjZSwgJ21vZHVsZXMuanNvbicpO1xuICAgICAgICB0aGlzLl9jaHVua1JlY29yZEZpbGUgPSBwcy5qb2luKHdvcmtzcGFjZSwgJ2NodW5rcy5qc29uJyk7XG4gICAgICAgIHRoaXMuX3NvdXJjZUNhY2hlRGlyID0gcHMuam9pbih3b3Jrc3BhY2UsICdtb2RzJyk7XG4gICAgICAgIGNvbnN0IGltcG9ydE1hcEZpbGUgPSBwcy5qb2luKHdvcmtzcGFjZSwgJ2ltcG9ydC1tYXAuanNvbicpO1xuICAgICAgICB0aGlzLl9pbXBvcnRNYXBGaWxlID0gaW1wb3J0TWFwRmlsZTtcbiAgICAgICAgY29uc3QgdGhlTG9nZ2VyID0gbG9nZ2VyID8/IGNyZWF0ZUxvZ2dlcih7fSk7XG4gICAgICAgIHRoaXMuX2NodW5rV3JpdGVyID0gbmV3IENodW5rV3JpdGVyKHtcbiAgICAgICAgICAgIG9yaWdpbixcbiAgICAgICAgICAgIGNodW5rUmVjb3JkRmlsZTogdGhpcy5fY2h1bmtSZWNvcmRGaWxlLFxuICAgICAgICAgICAgc291cmNlQ2FjaGVEaXI6IHRoaXMuX3NvdXJjZUNhY2hlRGlyLFxuICAgICAgICAgICAgaW1wb3J0TWFwRmlsZSxcbiAgICAgICAgICAgIGxvZ2dlcjogdGhlTG9nZ2VyLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fbG9nZ2VyID0gdGhlTG9nZ2VyO1xuICAgIH1cblxuICAgIHB1YmxpYyBhc3luYyBidWlsZChzcGVjaWZpZXJzOiBJdGVyYWJsZTxzdHJpbmcgfCBVUkw+LCBvcHRpb25zPzoge1xuICAgICAgICByZXRyeVJlc29sdXRpb25PblVuY2hhbmdlZE1vZHVsZT86IGJvb2xlYW47XG4gICAgfSkge1xuICAgICAgICBjb25zdCBjb250ZXh0OiBJbnNwZWN0Q29udGV4dCA9IHtcbiAgICAgICAgICAgIG1vZHVsZXM6IG5ldyBNYXAoKSxcbiAgICAgICAgICAgIHJldHJ5UmVzb2x1dGlvbk9uVW5jaGFuZ2VkTW9kdWxlOiBvcHRpb25zPy5yZXRyeVJlc29sdXRpb25PblVuY2hhbmdlZE1vZHVsZSA/PyBmYWxzZSxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgZW50cnlNb2R1bGVSZWNvcmRzOiBBcnJheTxbVVJMLCBNb2R1bGVSZWNvcmRdPiA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IHNwZWNpZmllciBvZiBzcGVjaWZpZXJzKSB7XG4gICAgICAgICAgICBjb25zdCB1cmwgPSB0eXBlb2Ygc3BlY2lmaWVyID09PSAnc3RyaW5nJ1xuICAgICAgICAgICAgICAgID8gYXdhaXQgdGhpcy5fcmVzb2x2ZUVudHJ5KHNwZWNpZmllcilcbiAgICAgICAgICAgICAgICA6IHNwZWNpZmllcjtcbiAgICAgICAgICAgIGlmICghdXJsKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBpbnNwZWN0UmVjb3JkID0gYXdhaXQgdGhpcy5fZ2V0T3JDcmVhdGVJbnNwZWN0UmVjb3JkKHVybCwgY29udGV4dCk7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9pbnN0YW50aWF0ZUFsbChpbnNwZWN0UmVjb3JkLCBuZXcgU2V0KCkpO1xuICAgICAgICAgICAgY29uc3QgbW9kdWxlUmVjb3JkID0gdGhpcy5fbW9kdWxlUmVjb3Jkc1t1cmwuaHJlZl07XG4gICAgICAgICAgICBpZiAoIW1vZHVsZVJlY29yZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2xvZ2dlci5kZWJ1ZyhgRW50cnkgJHt1cmx9IGRpZCBub3QgbGlicmFyeSBhIGNodW5rLmApO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZW50cnlNb2R1bGVSZWNvcmRzLnB1c2goW3VybCwgbW9kdWxlUmVjb3JkXSk7XG4gICAgICAgICAgICBjb25zdCBjaHVuayA9IGF3YWl0IHRoaXMuX2NodW5rV3JpdGVyLmdldENodW5rKG1vZHVsZVJlY29yZC5jaHVua0lkKTtcbiAgICAgICAgICAgIGFzc2VydHMoY2h1bmspO1xuICAgICAgICAgICAgY2h1bmsuaXNFbnRyeSA9IHRydWU7XG4gICAgICAgICAgICBjaHVuay5leHBvc2VBcyA9IHVybC5ocmVmO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IGZzLm91dHB1dEpzb24odGhpcy5fbW9kdWxlUmVjb3JkRmlsZSwgdGhpcy5fbW9kdWxlUmVjb3JkcywgeyBlbmNvZGluZzogJ3V0ZjgnLCBzcGFjZXM6IDIgfSk7XG5cbiAgICAgICAgY29uc3QgY2h1bmtBbGlhczogUmVjb3JkPHN0cmluZywgQ2h1bmtJZD4gPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCBbZW50cnlVUkwsIGVudHJ5TW9kdWxlUmVjb3JkXSBvZiBlbnRyeU1vZHVsZVJlY29yZHMpIHtcbiAgICAgICAgICAgIGNvbnN0IGNodW5rSWQgPSBlbnRyeU1vZHVsZVJlY29yZC5jaHVua0lkO1xuICAgICAgICAgICAgY2h1bmtBbGlhc1tlbnRyeVVSTC5ocmVmXSA9IGNodW5rSWQ7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgdGhpcy5fY2h1bmtXcml0ZXIuc3luY0NodW5rKGNodW5rQWxpYXMpO1xuICAgIH1cblxuICAgIHB1YmxpYyBhc3luYyBjcmVhdGVMb2FkZXJDb250ZXh0KCkge1xuICAgICAgICByZXR1cm4gbmV3IExvYWRlckNvbnRleHQoXG4gICAgICAgICAgICB0aGlzLl9vcmlnaW4sXG4gICAgICAgICAgICB0aGlzLl9jaHVua1JlY29yZEZpbGUsXG4gICAgICAgICAgICB0aGlzLl9zb3VyY2VDYWNoZURpcixcbiAgICAgICAgICAgIHRoaXMuX2ltcG9ydE1hcEZpbGUsXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgcHVibGljIGFzeW5jIGNsZWFyKCkge1xuICAgICAgICB0aGlzLl9tb2R1bGVSZWNvcmRzID0ge307XG4gICAgICAgIGNvbnN0IG1vZHVsZVJlY29yZEZpbGUgPSB0aGlzLl9tb2R1bGVSZWNvcmRGaWxlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXdhaXQgZnMudW5saW5rKG1vZHVsZVJlY29yZEZpbGUpO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHRoaXMuX2xvZ2dlci5kZWJ1ZyhgRmFpbGVkIHRvIGRlbGV0ZSBtb2R1bGUgcmVjb3JkIGZpbGUgJHttb2R1bGVSZWNvcmRGaWxlfTogJHtlcnJ9YCk7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgdGhpcy5fY2h1bmtXcml0ZXIuY2xlYXIoKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgYXN5bmMgbG9hZENhY2hlKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3Qgc2VyaWFsaXplZE1vZHVsZVJlY29yZHM6IFJlY29yZDxzdHJpbmcsIE1vZHVsZVJlY29yZD4gPSBhd2FpdCBmcy5yZWFkSnNvbih0aGlzLl9tb2R1bGVSZWNvcmRGaWxlKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgbW9kdWxlUmVjb3JkIG9mIE9iamVjdC52YWx1ZXMoc2VyaWFsaXplZE1vZHVsZVJlY29yZHMpKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1vZHVsZVJlY29yZC5yZXNvbHZlZEltcG9ydHMpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCByZXNvbHZlUmVzdWx0IG9mIG1vZHVsZVJlY29yZC5yZXNvbHZlZEltcG9ydHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXNvbHZlUmVzdWx0ICYmICFyZXNvbHZlUmVzdWx0LmlzRXh0ZXJuYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlUmVzdWx0LnVybCA9IG5ldyBVUkwocmVzb2x2ZVJlc3VsdC51cmwgYXMgdW5rbm93biBhcyBzdHJpbmcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fbW9kdWxlUmVjb3JkcyA9IHNlcmlhbGl6ZWRNb2R1bGVSZWNvcmRzO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHRoaXMuX2xvZ2dlci5kZWJ1ZyhgTW9kdWxlIHJlY29yZCBmaWxlIGxvYWRlZCBmYWlsZWQgd2l0aCBlcnJvcjogJHtlcnJ9YCk7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgdGhpcy5fY2h1bmtXcml0ZXIubG9hZENhY2hlKCk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBfdmVyYm9zZTogYm9vbGVhbjtcbiAgICBwcml2YXRlIF9vcmlnaW46IHN0cmluZztcbiAgICBwcml2YXRlIF9tb2R1bGVSZWNvcmRGaWxlOiBzdHJpbmc7XG4gICAgcHJpdmF0ZSBfY2h1bmtSZWNvcmRGaWxlOiBzdHJpbmc7XG4gICAgcHJpdmF0ZSBfc291cmNlQ2FjaGVEaXI6IHN0cmluZztcbiAgICBwcml2YXRlIF9pbXBvcnRNYXBGaWxlOiBzdHJpbmc7XG4gICAgcHJpdmF0ZSBfbW9kTG86IE1vZExvO1xuICAgIHByaXZhdGUgX3NvdXJjZU1hcHM6IGJvb2xlYW4gfCAnaW5saW5lJztcbiAgICBwcml2YXRlIF9tb2R1bGVSZWNvcmRzOiBSZWNvcmQ8c3RyaW5nLCBNb2R1bGVSZWNvcmQgfCBudWxsPiA9IHt9O1xuICAgIHByaXZhdGUgX2NodW5rV3JpdGVyOiBDaHVua1dyaXRlcjtcbiAgICBwcml2YXRlIF9leHRlbnNpb25NYXBwaW5nOiBBcnJheTxbc3RyaW5nLCBzdHJpbmddPiA9IFtcbiAgICAgICAgWycudHMnLCAnLmpzJ10sXG4gICAgICAgIFsnLm1qcycsICcuanMnXSxcbiAgICBdO1xuICAgIHByaXZhdGUgX2xvZ2dlcjogTG9nZ2VyO1xuXG4gICAgcHJpdmF0ZSBhc3luYyBfcmVzb2x2ZUVudHJ5KHNwZWNpZmllcjogc3RyaW5nKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFVSTChzcGVjaWZpZXIpO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHRoaXMuX2xvZ2dlci5lcnJvcihpMThuVHJhbnNsYXRlKCdxdWlja19wYWNrX2NvdWxkX25vdF9yZXNvbHZlX2VudHJ5JywgeyBzcGVjaWZpZXIgfSkpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBhc3luYyBfZ2V0T3JDcmVhdGVJbnNwZWN0UmVjb3JkKHVybDogVVJMLCBjb250ZXh0OiBJbnNwZWN0Q29udGV4dCkge1xuICAgICAgICBjb25zdCBleGlzdGVkSW5zcGVjdFJlY29yZCA9IGNvbnRleHQubW9kdWxlcy5nZXQodXJsLmhyZWYpO1xuICAgICAgICBpZiAoZXhpc3RlZEluc3BlY3RSZWNvcmQpIHtcbiAgICAgICAgICAgIHJldHVybiBleGlzdGVkSW5zcGVjdFJlY29yZDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItY29uc3RcbiAgICAgICAgbGV0IGluc3BlY3RSZWNvcmQ6IEluc3BlY3RSZWNvcmQ7XG5cbiAgICAgICAgY29uc3QgaW5zcGVjdFByb21pc2UgPSB0aGlzLl9pbnNwZWN0V2l0aENhY2hlKHVybCk7XG4gICAgICAgIGNvbnN0IGxpbmtQcm9taXNlID0gaW5zcGVjdFByb21pc2UudGhlbihhc3luYyAobW9kdWxlSW5zcGVjdEluZm8pID0+IHtcbiAgICAgICAgICAgIGlmIChtb2R1bGVJbnNwZWN0SW5mbykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRlcGVuZGVuY2llcyA9IGF3YWl0IHRoaXMuX2xpbmsodXJsLCBtb2R1bGVJbnNwZWN0SW5mby5tb2R1bGVSZWNvcmQsIGNvbnRleHQpO1xuICAgICAgICAgICAgICAgIGluc3BlY3RSZWNvcmQuZGVwZW5kZW5jaWVzID0gZGVwZW5kZW5jaWVzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBpbnNwZWN0UmVjb3JkID0ge1xuICAgICAgICAgICAgaW5zcGVjdDogaW5zcGVjdFByb21pc2UsXG4gICAgICAgICAgICBsaW5rOiBsaW5rUHJvbWlzZSxcbiAgICAgICAgICAgIGRlcGVuZGVuY2llczogdW5kZWZpbmVkLFxuICAgICAgICB9O1xuICAgICAgICBjb250ZXh0Lm1vZHVsZXMuc2V0KHVybC5ocmVmLCBpbnNwZWN0UmVjb3JkKTtcbiAgICAgICAgcmV0dXJuIGluc3BlY3RSZWNvcmQ7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBhc3luYyBfaW5zdGFudGlhdGVBbGwoaW5zcGVjdFJlY29yZDogSW5zcGVjdFJlY29yZCwgdmlzaXRlZDogU2V0PEluc3BlY3RSZWNvcmQ+KSB7XG4gICAgICAgIGlmICh2aXNpdGVkLmhhcyhpbnNwZWN0UmVjb3JkKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZpc2l0ZWQuYWRkKGluc3BlY3RSZWNvcmQpO1xuICAgICAgICBhd2FpdCBpbnNwZWN0UmVjb3JkLmxpbms7XG4gICAgICAgIGlmIChpbnNwZWN0UmVjb3JkLmRlcGVuZGVuY2llcykge1xuICAgICAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoaW5zcGVjdFJlY29yZC5kZXBlbmRlbmNpZXMubWFwKGFzeW5jIChkZXBlbmRlbmN5KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGRlcGVuZGVuY3kpIHtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5faW5zdGFudGlhdGVBbGwoZGVwZW5kZW5jeSwgdmlzaXRlZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBhc3luYyBfaW5zcGVjdFdpdGhDYWNoZSh1cmw6IFVSTCkge1xuICAgICAgICBjb25zdCBtVGltZXN0YW1wID0gYXdhaXQgdGhpcy5fbW9kTG8uZ2V0TVRpbWVzdGFtcCh1cmwpO1xuICAgICAgICBjb25zdCBvbGRNb2R1bGVSZWNvcmQgPSB0aGlzLl9tb2R1bGVSZWNvcmRzW3VybC5ocmVmXTtcbiAgICAgICAgaWYgKG9sZE1vZHVsZVJlY29yZCkge1xuICAgICAgICAgICAgaWYgKGlzRXF1YWxNVGltZXN0YW1wKG1UaW1lc3RhbXAsIG9sZE1vZHVsZVJlY29yZC5tVGltZXN0YW1wKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IG1vZHVsZVJlY29yZDogb2xkTW9kdWxlUmVjb3JkLCB1cGRhdGVkOiBmYWxzZSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fbG9nZ2VyLmRlYnVnKGBEZXRlY3RlZCBjaGFuZ2U6ICR7dXJsfS4gTGFzdCBtdGltZTogJHttVGltZXN0YW1wVG9TdHJpbmcob2xkTW9kdWxlUmVjb3JkLm1UaW1lc3RhbXApfSwgQ3VycmVudCBtdGltZTogJHttVGltZXN0YW1wVG9TdHJpbmcobVRpbWVzdGFtcCl9YCk7XG4gICAgICAgICAgICB0aGlzLl9tb2R1bGVSZWNvcmRzW3VybC5ocmVmXSA9IG51bGw7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9jaHVua1dyaXRlci5yZW1vdmVDaHVuayhvbGRNb2R1bGVSZWNvcmQuY2h1bmtJZCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fdmVyYm9zZSkge1xuICAgICAgICAgICAgdGhpcy5fbG9nZ2VyLmRlYnVnKGBJbnNwZWN0ICR7dXJsfWApO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgbW9kdWxlUmVjb3JkID0gYXdhaXQgdGhpcy5faW5zcGVjdCh1cmwsIG1UaW1lc3RhbXApLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX2xvZ2dlci5lcnJvcihlcnIpO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCFtb2R1bGVSZWNvcmQpIHtcbiAgICAgICAgICAgIC8vIE1vZHVsZSByZWNvcmQgaXMgaW52YWxpZCBvciBjYWNoZSBpcyB2YWxpZFxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7IG1vZHVsZVJlY29yZCwgdXBkYXRlZDogdHJ1ZSB9O1xuICAgIH1cblxuICAgIHByaXZhdGUgYXN5bmMgX2xpbmsodXJsOiBVUkwsIG1vZHVsZVJlY29yZDogTW9kdWxlUmVjb3JkLCBjb250ZXh0OiBJbnNwZWN0Q29udGV4dCkge1xuICAgICAgICBjb25zdCBjaHVua0ltcG9ydHM6IENodW5rWydpbXBvcnRzJ10gPSB7fTtcblxuICAgICAgICBsZXQgZm9yY2VSZXNvbHZlID0gZmFsc2U7XG4gICAgICAgIGlmICghbW9kdWxlUmVjb3JkLnJlc29sdmVkSW1wb3J0cykge1xuICAgICAgICAgICAgZm9yY2VSZXNvbHZlID0gdHJ1ZTtcbiAgICAgICAgICAgIG1vZHVsZVJlY29yZC5yZXNvbHZlZEltcG9ydHMgPSBuZXcgQXJyYXkobW9kdWxlUmVjb3JkLmltcG9ydHMubGVuZ3RoKS5maWxsKG51bGwpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcmVzb2x2ZWRJbXBvcnRzID0gbW9kdWxlUmVjb3JkLnJlc29sdmVkSW1wb3J0cztcblxuICAgICAgICBjb25zdCBkZXBSZWNvcmRzID0gYXdhaXQgUHJvbWlzZS5hbGwobW9kdWxlUmVjb3JkLmltcG9ydHMubWFwKGFzeW5jIChzcGVjaWZpZXIsIGlJbXBvcnQpOiBQcm9taXNlPHVuZGVmaW5lZCB8IEluc3BlY3RSZWNvcmQ+ID0+IHtcbiAgICAgICAgICAgIGxldCByZXNvbHZlZCA9IHJlc29sdmVkSW1wb3J0c1tpSW1wb3J0XTtcbiAgICAgICAgICAgIGlmIChmb3JjZVJlc29sdmUgfHwgLy8gTm90IHJlc29sdmVkIGJlZm9yZVxuICAgICAgICAgICAgICAgIHJlc29sdmVkID09PSBudWxsICYmIGNvbnRleHQucmV0cnlSZXNvbHV0aW9uT25VbmNoYW5nZWRNb2R1bGUgLy8gUmVzb2x2ZWQgYnV0IGZhaWxlZFxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZWQgPSBhd2FpdCB0aGlzLl9yZXNvbHZlKHNwZWNpZmllciwgdXJsLCBtb2R1bGVSZWNvcmQubW9kTG9NZXRhZGF0YSk7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZWRJbXBvcnRzW2lJbXBvcnRdID0gcmVzb2x2ZWQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghcmVzb2x2ZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IGNodW5rSW1wb3J0S2V5ID0gc3BlY2lmaWVyLnJld3JpdHRlbiA/PyBzcGVjaWZpZXIudmFsdWU7XG5cbiAgICAgICAgICAgIGlmIChyZXNvbHZlZC5pc0V4dGVybmFsKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaXNSZXNvbHZlZFRvQmFyZSA9ICF0cnlQYXJzZVVSTChyZXNvbHZlZC5zcGVjaWZpZXJPclVSTCk7XG4gICAgICAgICAgICAgICAgaWYgKGlzUmVzb2x2ZWRUb0JhcmUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gT25seSBiYXJlIHNwZWNpZmllciBtYXkgcmVzb2x2ZWQgdG8gYmFyZVxuICAgICAgICAgICAgICAgICAgICBhc3NlcnRzKCFzcGVjaWZpZXIucmV3cml0dGVuLCBgU29tZXRoaW5nIHdyb25nIHdpdGggcmV3cml0aW5nIGFuZCByZXNvbHZlICR7c3BlY2lmaWVyLnZhbHVlfWApO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNodW5rSW1wb3J0c1tjaHVua0ltcG9ydEtleV0gPSB7XG4gICAgICAgICAgICAgICAgICAgIGV4dGVybmFsOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICB1cmw6IHJlc29sdmVkLnNwZWNpZmllck9yVVJMLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCB7IHVybDogcmVzb2x2ZWRVUkwgfSA9IHJlc29sdmVkO1xuXG4gICAgICAgICAgICBjb25zdCBpbnNwZWN0UmVjb3JkID0gYXdhaXQgdGhpcy5fZ2V0T3JDcmVhdGVJbnNwZWN0UmVjb3JkKHJlc29sdmVkVVJMLCBjb250ZXh0KTtcbiAgICAgICAgICAgIGF3YWl0IGluc3BlY3RSZWNvcmQuaW5zcGVjdDtcblxuICAgICAgICAgICAgY29uc3QgcmVzb2x2ZWRDaHVuayA9IHRoaXMuX21vZHVsZVJlY29yZHNbcmVzb2x2ZWRVUkwuaHJlZl0/LmNodW5rSWQ7XG4gICAgICAgICAgICBpZiAocmVzb2x2ZWRDaHVuaykge1xuICAgICAgICAgICAgICAgIGNodW5rSW1wb3J0c1tjaHVua0ltcG9ydEtleV0gPSByZXNvbHZlZENodW5rO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9sb2dnZXIuZGVidWcoYFdlJ3JlIG1pc3NpbmcgdGhlIGNodW5rICR7cmVzb2x2ZWRVUkwuaHJlZn0sIHJlZmVyZW5jZWQgYXMgJyR7c3BlY2lmaWVyfScuYCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBpbnNwZWN0UmVjb3JkO1xuICAgICAgICB9KSk7XG5cbiAgICAgICAgY29uc3QgY2h1bmsgPSBhd2FpdCB0aGlzLl9jaHVua1dyaXRlci5nZXRDaHVuayhtb2R1bGVSZWNvcmQuY2h1bmtJZCk7XG4gICAgICAgIGFzc2VydHMoY2h1bmspO1xuICAgICAgICBjaHVuay5pbXBvcnRzID0gY2h1bmtJbXBvcnRzO1xuXG4gICAgICAgIHJldHVybiBkZXBSZWNvcmRzO1xuICAgIH1cblxuICAgIHByaXZhdGUgYXN5bmMgX2luc3BlY3QodXJsOiBVUkwsIG1UaW1lc3RhbXA6IE1UaW1lc3RhbXApIHtcbiAgICAgICAgbGV0IG1vZDogTW9kO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgbW9kID0gYXdhaXQgdGhpcy5fbW9kTG8ubG9hZCh1cmwpO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHRoaXMuX2xvZ2dlci5lcnJvcihpMThuVHJhbnNsYXRlKCdxdWlja19wYWNrX2ZhaWxlZF90b19sb2FkJywgeyB1cmw6IHVybC5ocmVmLCBjYXVzZTogZXJyIH0pKTtcbiAgICAgICAgICAgIGlmICh1cmwucHJvdG9jb2wgPT09ICdub2RlOicpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9sb2dnZXIud2FybihpMThuVHJhbnNsYXRlKCdsb2FkX2Vycm9yX2hpbnRfbm9kZV9idWlsdGluJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgb3JpZ2luYWxTb3VyY2UsXG4gICAgICAgICAgICBjb2RlLFxuICAgICAgICAgICAgbW9kTG9NZXRhZGF0YSxcbiAgICAgICAgfSA9IG1vZDtcblxuICAgICAgICBsZXQge1xuICAgICAgICAgICAgbWFwLFxuICAgICAgICB9ID0gbW9kO1xuXG4gICAgICAgIGxldCBhc3Q6IEFzdDtcbiAgICAgICAgaWYgKHR5cGVvZiBjb2RlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgLy8gVE9ETzogaW5wdXQgc291cmNlIG1hcFxuICAgICAgICAgICAgYXN0ID0gYXdhaXQgdGhpcy5fbW9kTG8ucGFyc2UoY29kZSwgbWFwKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFzdCA9IGNvZGU7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBjaHVua1VSTCA9IHRoaXMuX2dldENodW5rVVJMKHVybCk7XG5cbiAgICAgICAgY29uc3QgY2h1bmtJZCA9IHRoaXMuX2NodW5rV3JpdGVyLmdldENodW5rSWQoY2h1bmtVUkwpO1xuXG4gICAgICAgIGxldCBzcGVjaWZpZXJzOiBTcGVjaWZpZXJbXSA9IFtdO1xuICAgICAgICAoeyB0cmFuc2Zvcm1SZXN1bHQ6IHsgYXN0LCBtYXAgfSwgc3BlY2lmaWVycyB9ID0gYXdhaXQgdGhpcy5fcmV3cml0ZUltcG9ydHMoXG4gICAgICAgICAgICB1cmwsXG4gICAgICAgICAgICBhc3QsXG4gICAgICAgICAgICB0eXBlb2YgbWFwID09PSAnc3RyaW5nJyA/IEpTT04ucGFyc2UobWFwKSA6IG1hcCA/PyB1bmRlZmluZWQsXG4gICAgICAgICAgICBvcmlnaW5hbFNvdXJjZSxcbiAgICAgICAgKSk7XG5cbiAgICAgICAgYXdhaXQgdGhpcy5fdHJhbnNmb3JtQW5kQWRkKFxuICAgICAgICAgICAgY2h1bmtJZCxcbiAgICAgICAgICAgIHVybCxcbiAgICAgICAgICAgIGFzdCxcbiAgICAgICAgICAgIHR5cGVvZiBtYXAgPT09ICdzdHJpbmcnID8gSlNPTi5wYXJzZShtYXApIDogbWFwID8/IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIG9yaWdpbmFsU291cmNlLFxuICAgICAgICApO1xuXG4gICAgICAgIGNvbnN0IG1vZHVsZVJlY29yZDogTW9kdWxlUmVjb3JkID0ge1xuICAgICAgICAgICAgbVRpbWVzdGFtcCxcbiAgICAgICAgICAgIGNodW5rSWQsXG4gICAgICAgICAgICBpbXBvcnRzOiBzcGVjaWZpZXJzLFxuICAgICAgICAgICAgbW9kTG9NZXRhZGF0YSxcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLl9tb2R1bGVSZWNvcmRzW3VybC5ocmVmXSA9IG1vZHVsZVJlY29yZDtcblxuICAgICAgICByZXR1cm4gbW9kdWxlUmVjb3JkO1xuICAgIH1cblxuICAgIHByaXZhdGUgYXN5bmMgX3RyYW5zZm9ybUFuZEFkZChjaHVua0lkOiBzdHJpbmcsIHVybDogVVJMLCBhc3Q6IEFzdCwgbWFwOiBSYXdTb3VyY2VNYXAgfCB1bmRlZmluZWQsIG9yaWdpbmFsU291cmNlOiBzdHJpbmcpIHtcbiAgICAgICAgY29uc3QgdHJhbnNmb3JtZWQgPSBhd2FpdCB0aGlzLl90cmFuc2Zvcm0odXJsLCBhc3QsIG1hcCwgb3JpZ2luYWxTb3VyY2UpO1xuXG4gICAgICAgIGF3YWl0IHRoaXMuX2NodW5rV3JpdGVyLmFkZENodW5rKFxuICAgICAgICAgICAgY2h1bmtJZCxcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkLmNvZGUsXG4gICAgICAgICAgICB0cmFuc2Zvcm1lZC5tYXAsXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBhc3luYyBfcmV3cml0ZUltcG9ydHModXJsOiBVUkwsIGFzdDogQXN0LCBtYXA6IFJhd1NvdXJjZU1hcCB8IHVuZGVmaW5lZCwgb3JpZ2luYWxTb3VyY2U6IHN0cmluZykge1xuICAgICAgICBjb25zdCBzcGVjaWZpZXJzOiBTcGVjaWZpZXJbXSA9IFtdO1xuXG4gICAgICAgIGxldCBuU3BlY2lmaWVyID0gMDtcblxuICAgICAgICBjb25zdCB0cmFuc2Zvcm1SZXN1bHQgPSBhd2FpdCBiYWJlbC50cmFuc2Zvcm1Gcm9tQXN0QXN5bmMoXG4gICAgICAgICAgICBhc3QsIG9yaWdpbmFsU291cmNlLCB7XG4gICAgICAgICAgICAgICAgYXN0OiB0cnVlLFxuICAgICAgICAgICAgICAgIGNvZGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHNvdXJjZUZpbGVOYW1lOiB1cmwuaHJlZixcbiAgICAgICAgICAgICAgICBjbG9uZUlucHV0QXN0OiBmYWxzZSxcbiAgICAgICAgICAgICAgICBjb25maWdGaWxlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBzb3VyY2VUeXBlOiAnbW9kdWxlJyxcbiAgICAgICAgICAgICAgICBzb3VyY2VNYXBzOiB0aGlzLl9zb3VyY2VNYXBzLFxuICAgICAgICAgICAgICAgIGlucHV0U291cmNlTWFwOiBtYXAsXG4gICAgICAgICAgICAgICAgcGx1Z2luczogW1xuICAgICAgICAgICAgICAgICAgICBbY3JlYXRlQmFiZWxQbHVnaW5EZXRlY3RBbmRSZXdyaXRlSW1wb3J0cyh7XG4gICAgICAgICAgICAgICAgICAgICAgICBzcGVjaWZpZXJzLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmV3cml0ZTogKHNwZWNpZmllcikgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc0JhcmVTcGVjaWZpZXIoc3BlY2lmaWVyKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiBpdCdzIGJhcmUgc3BlY2lmaWVyLCB3ZSBkbyBub3QgcmV3cml0ZSBpdC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmV3cml0dGVuID0gYF9fdW5yZXNvbHZlZF8ke25TcGVjaWZpZXJ9YDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICArK25TcGVjaWZpZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJld3JpdHRlbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIH0pXSxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgfSBhcyBiYWJlbC5UcmFuc2Zvcm1PcHRpb25zICYge1xuICAgICAgICAgICAgICAgIGNsb25lSW5wdXRBc3Q/OiBib29sZWFuO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgKTtcblxuICAgICAgICBhc3NlcnRzKHRyYW5zZm9ybVJlc3VsdCk7XG4gICAgICAgIGFzc2VydHModHJhbnNmb3JtUmVzdWx0LmFzdCk7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybVJlc3VsdDoge1xuICAgICAgICAgICAgICAgIGFzdDogdHJhbnNmb3JtUmVzdWx0LmFzdCxcbiAgICAgICAgICAgICAgICBtYXA6ICh0cmFuc2Zvcm1SZXN1bHQubWFwIGFzIFNvdXJjZU1hcCB8IHVuZGVmaW5lZCkgPz8gdW5kZWZpbmVkLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNwZWNpZmllcnMsXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBhc3luYyBfdHJhbnNmb3JtKHVybDogVVJMLCBhc3Q6IEFzdCwgbWFwOiBSYXdTb3VyY2VNYXAgfCB1bmRlZmluZWQsIG9yaWdpbmFsU291cmNlOiBzdHJpbmcpIHtcbiAgICAgICAgY29uc3QgYmFiZWxSZXN1bHQgPSBhd2FpdCBiYWJlbC50cmFuc2Zvcm1Gcm9tQXN0QXN5bmMoXG4gICAgICAgICAgICBhc3QsXG4gICAgICAgICAgICBvcmlnaW5hbFNvdXJjZSwge1xuICAgICAgICAgICAgICAgIHNvdXJjZUZpbGVOYW1lOiB1cmwuaHJlZixcbiAgICAgICAgICAgICAgICAvLyBjbG9uZUlucHV0QXN0OiBmYWxzZSxcbiAgICAgICAgICAgICAgICBjb25maWdGaWxlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBzb3VyY2VUeXBlOiAnbW9kdWxlJyxcbiAgICAgICAgICAgICAgICBzb3VyY2VNYXBzOiB0aGlzLl9zb3VyY2VNYXBzLFxuICAgICAgICAgICAgICAgIGlucHV0U291cmNlTWFwOiBtYXAsXG4gICAgICAgICAgICAgICAgcGx1Z2luczogW1xuICAgICAgICAgICAgICAgICAgICBbYmFiZWxQbHVnaW5UcmFuc2Zvcm1TeXN0ZW1Kc10sXG4gICAgICAgICAgICAgICAgICAgIC8vIER5bmFtaWMgaW1wb3J0KCkgdHJhbnNmb3JtYXRpb24gbXVzdCBiZSBlbmFibGVkIHVzaW5nIHRoZVxuICAgICAgICAgICAgICAgICAgICAvLyBAYmFiZWwvcGx1Z2luLXByb3Bvc2FsLWR5bmFtaWMtaW1wb3J0IHBsdWdpbi4gQmFiZWwgOCB3aWxsXG4gICAgICAgICAgICAgICAgICAgIC8vIG5vIGxvbmdlciB0cmFuc2Zvcm0gaW1wb3J0KCkgd2l0aG91dCB1c2luZyB0aGF0IHBsdWdpbi5cbiAgICAgICAgICAgICAgICAgICAgW2JhYmVsUGx1Z2luUHJvcG9zYWxEeW5hbWljSW1wb3J0XSxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgfSBhcyBiYWJlbC5UcmFuc2Zvcm1PcHRpb25zICYge1xuICAgICAgICAgICAgICAgIGNsb25lSW5wdXRBc3Q/OiBib29sZWFuO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgKTtcbiAgICAgICAgYXNzZXJ0cyhiYWJlbFJlc3VsdCk7XG4gICAgICAgIGFzc2VydHMoYmFiZWxSZXN1bHQuY29kZSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjb2RlOiBiYWJlbFJlc3VsdC5jb2RlLFxuICAgICAgICAgICAgbWFwOiBiYWJlbFJlc3VsdC5tYXAgYXMgdW5rbm93biBhcyBTb3VyY2VNYXAsXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBhc3luYyBfcmVzb2x2ZShzcGVjaWZpZXI6IFNwZWNpZmllciwgcGFyZW50VVJMOiBVUkwsIG1vZExvTWV0YWRhdGE6IE1vZExvTWV0YWRhdGEpIHtcbiAgICAgICAgY29uc3Qgc3BlY2lmaWVyVmFsdWUgPSBzcGVjaWZpZXIudmFsdWU7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXNvbHZlZCA9IGF3YWl0IHRoaXMuX21vZExvLnJlc29sdmUoc3BlY2lmaWVyVmFsdWUsIHBhcmVudFVSTCwgbW9kTG9NZXRhZGF0YSk7XG4gICAgICAgICAgICBpZiAodGhpcy5fdmVyYm9zZSkge1xuICAgICAgICAgICAgICAgIGlmIChyZXNvbHZlZC5pc0V4dGVybmFsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2xvZ2dlci5kZWJ1ZyhgUmVzb2x2ZSAke3NwZWNpZmllclZhbHVlfSBmcm9tICR7cGFyZW50VVJMLmhyZWZ9IGFzIGV4dGVybmFsIGRlcGVuZGVuY3kgJHtyZXNvbHZlZC5zcGVjaWZpZXJPclVSTH0uYCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbG9nZ2VyLmRlYnVnKGBSZXNvbHZlICR7c3BlY2lmaWVyVmFsdWV9IGZyb20gJHtwYXJlbnRVUkwuaHJlZn0gYXMgJHtyZXNvbHZlZC51cmx9LmApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXNvbHZlZDtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICB0aGlzLl9sb2dnZXIuZXJyb3IoaTE4blRyYW5zbGF0ZShcbiAgICAgICAgICAgICAgICAncXVpY2tfcGFja19mYWlsZWRfdG9fcmVzb2x2ZScsXG4gICAgICAgICAgICAgICAgeyBzcGVjaWZpZXI6IHNwZWNpZmllclZhbHVlLCBwYXJlbnRVUkw6IHBhcmVudFVSTC5ocmVmLCBjYXVzZTogZXJyIH0sXG4gICAgICAgICAgICApKTtcbiAgICAgICAgICAgIGlmIChzcGVjaWZpZXJWYWx1ZS5pbmNsdWRlcygnLycpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbGFzdFBvcnRpb24gPSBzcGVjaWZpZXJWYWx1ZS5zcGxpdCgnLycpLnBvcCgpO1xuICAgICAgICAgICAgICAgIGlmIChsYXN0UG9ydGlvbiAmJiAhbGFzdFBvcnRpb24uaW5jbHVkZXMoJy4nKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9sb2dnZXIud2FybihpMThuVHJhbnNsYXRlKCdyZXNvbHZlX2Vycm9yX2hpbnRfZXh0ZW5zaW9uJykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWFwIHRoZSBtb2R1bGUgVVJMIHRvIGNodW5rIFVSTC5cbiAgICAgKiBAcGFyYW0gdXJsIFxuICAgICAqL1xuICAgIHByaXZhdGUgX2dldENodW5rVVJMKF91cmw6IFJlYWRvbmx5PFVSTD4pOiBSZWFkb25seTxVUkw+IHtcbiAgICAgICAgLy8gVE9ETzogZG8gaXQgYmV0dGVyXG4gICAgICAgIGxldCB1cmw6IFJlYWRvbmx5PFVSTD47XG4gICAgICAgIGlmICghX3VybC5zZWFyY2gpIHtcbiAgICAgICAgICAgIHVybCA9IF91cmw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCB1ID0gbmV3IFVSTChfdXJsLmhyZWYpO1xuICAgICAgICAgICAgY29uc3QgZXh0ZW5zaW9uTmFtZSA9IHBhcnNlRXh0ZW5zaW9uTmFtZSh1LnBhdGhuYW1lKTtcbiAgICAgICAgICAgIHJlcGxhY2VFeHRlbnNpb24odSwgYC5wcm94eSR7ZXh0ZW5zaW9uTmFtZX1gKTtcbiAgICAgICAgICAgIHVybCA9IHU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyDop4HvvJpodHRwczovL2dpc3QuZ2l0aHViLmNvbS9zaHJpbmt0b2ZpdC81MGYyMzgwNzgyYjYyMTllZDZhNGNiM2EyMTBhNzVmN1xuICAgICAgICBmb3IgKGNvbnN0IFtmcm9tLCB0b10gb2YgdGhpcy5fZXh0ZW5zaW9uTWFwcGluZykge1xuICAgICAgICAgICAgaWYgKHVybC5wYXRobmFtZS5lbmRzV2l0aChmcm9tKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBhc3NpZ25QYXRobmFtZShcbiAgICAgICAgICAgICAgICAgICAgbmV3IFVSTCh1cmwuaHJlZiksXG4gICAgICAgICAgICAgICAgICAgIGAke3VybC5wYXRobmFtZS5zdWJzdHIoMCwgdXJsLnBhdGhuYW1lLmxlbmd0aCAtIGZyb20ubGVuZ3RoKX0ke3RvfWAsXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIXBhcnNlRXh0ZW5zaW9uTmFtZSh1cmwucGF0aG5hbWUpKSB7XG4gICAgICAgICAgICAvLyBVUkxzIHdpdGggbm8gZXh0ZW5zaW9uIGFyZSBzdG9yZSBhcyAuanNcbiAgICAgICAgICAgIHJldHVybiBhc3NpZ25QYXRobmFtZShcbiAgICAgICAgICAgICAgICBuZXcgVVJMKHVybC5ocmVmKSxcbiAgICAgICAgICAgICAgICBgJHt1cmwucGF0aG5hbWV9LmpzYFxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdXJsO1xuICAgIH1cbn1cblxuaW50ZXJmYWNlIEluc3BlY3RSZWNvcmQge1xuICAgIGluc3BlY3Q6IFByb21pc2U8eyBtb2R1bGVSZWNvcmQ6IE1vZHVsZVJlY29yZDsgdXBkYXRlZDogYm9vbGVhbjsgfSB8IHVuZGVmaW5lZD47XG4gICAgbGluazogUHJvbWlzZTx2b2lkPiB8IHVuZGVmaW5lZDtcbiAgICBkZXBlbmRlbmNpZXM6IEFycmF5PEluc3BlY3RSZWNvcmQgfCB1bmRlZmluZWQ+IHwgdW5kZWZpbmVkO1xufVxuXG5pbnRlcmZhY2UgSW5zcGVjdENvbnRleHQge1xuICAgIHJldHJ5UmVzb2x1dGlvbk9uVW5jaGFuZ2VkTW9kdWxlOiBib29sZWFuO1xuICAgIG1vZHVsZXM6IE1hcDxzdHJpbmcsIEluc3BlY3RSZWNvcmQ+O1xufVxuIl19