"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.QuickPack = void 0;
const path_1 = __importDefault(require("path"));
const fs_extra_1 = __importDefault(require("fs-extra"));
const url_1 = require("url");
const writer_1 = require("./utils/chunk-io/writer");
const loader_context_1 = require("./utils/loader-context");
const url_2 = require("../utils/url");
const logger_1 = require("../utils/logger");
const babel = __importStar(require("@babel/core"));
// @ts-expect-error
const plugin_transform_modules_systemjs_1 = __importDefault(require("@babel/plugin-transform-modules-systemjs"));
// @ts-expect-error
const plugin_proposal_dynamic_import_1 = __importDefault(require("@babel/plugin-proposal-dynamic-import"));
const asserts_1 = require("../../utils/asserts");
const detect_imports_1 = require("./utils/detect-imports");
const launch_policy_1 = require("../utils/launch-policy");
const i18n_1 = require("../../utils/i18n");
const getLauncher = (par) => par ? launch_policy_1.parallelDiscarding : launch_policy_1.sequenceDiscarding;
const resolveLauncher = getLauncher(true);
class QuickPack {
    constructor({ modLo, sourceMaps, origin, workspace, verbose, logger, }) {
        this._moduleRecords = {};
        this._extensionMapping = [
            ['.ts', '.js'],
            ['.mjs', '.js'],
        ];
        this._verbose = verbose !== null && verbose !== void 0 ? verbose : false;
        this._origin = origin;
        this._modLo = modLo;
        this._sourceMaps = sourceMaps !== null && sourceMaps !== void 0 ? sourceMaps : true;
        this._moduleRecordFile = path_1.default.join(workspace, 'modules.json');
        this._chunkRecordFile = path_1.default.join(workspace, 'chunks.json');
        this._sourceCacheDir = path_1.default.join(workspace, 'mods');
        this._chunkWriter = new writer_1.ChunkWriter({
            origin,
            chunkRecordFile: this._chunkRecordFile,
            sourceCacheDir: this._sourceCacheDir,
        });
        this._logger = logger !== null && logger !== void 0 ? logger : logger_1.createLogger({});
    }
    async build(specifiers, options) {
        var _a, _b;
        const context = {
            modules: new Map(),
            forceAll: (_a = options === null || options === void 0 ? void 0 : options.forceAll) !== null && _a !== void 0 ? _a : false,
            retryResolutionOnUnchangedModule: (_b = options === null || options === void 0 ? void 0 : options.retryResolutionOnUnchangedModule) !== null && _b !== void 0 ? _b : false,
        };
        for (const specifier of specifiers) {
            const url = typeof specifier === 'string'
                ? await this._resolveEntry(specifier)
                : specifier;
            if (!url) {
                continue;
            }
            const inspectRecord = await this._getOrCreateInspectRecord(url, context);
            await this._instantiateAll(inspectRecord, new Set());
            const moduleRecord = this._moduleRecords[url.href];
            if (!moduleRecord) {
                this._logger.debug(`Entry ${url} did not library a chunk.`);
                continue;
            }
            const chunk = await this._chunkWriter.getChunk(moduleRecord.chunkId);
            asserts_1.asserts(chunk);
            chunk.isEntry = true;
            chunk.exposeAs = url.href;
        }
        await fs_extra_1.default.outputJson(this._moduleRecordFile, this._moduleRecords, { encoding: 'utf8', spaces: 2 });
        await this._chunkWriter.syncChunk();
    }
    async createLoaderContext() {
        return new loader_context_1.LoaderContext(this._origin, this._chunkRecordFile, this._sourceCacheDir);
    }
    async loadCache() {
        try {
            const serializedModuleRecords = await fs_extra_1.default.readJson(this._moduleRecordFile);
            for (const moduleRecord of Object.values(serializedModuleRecords)) {
                if (moduleRecord.resolvedImports) {
                    for (const resolveResult of moduleRecord.resolvedImports) {
                        if (resolveResult && !resolveResult.isExternal) {
                            resolveResult.url = new url_1.URL(resolveResult.url);
                        }
                    }
                }
            }
            this._moduleRecords = serializedModuleRecords;
        }
        catch (err) {
            this._logger.debug(`Module record file loaded failed with error: ${err}`);
        }
        await this._chunkWriter.loadCache();
    }
    async _resolveEntry(specifier) {
        try {
            return new url_1.URL(specifier);
        }
        catch (err) {
            this._logger.error(i18n_1.i18nTranslate('quick_pack_could_not_resolve_entry', { specifier }));
            return;
        }
    }
    async _getOrCreateInspectRecord(url, context) {
        const existedInspectRecord = context.modules.get(url.href);
        if (existedInspectRecord) {
            return existedInspectRecord;
        }
        let inspectRecord;
        const inspectPromise = this._inspectWithCache(url);
        const linkPromise = inspectPromise.then(async (moduleInspectInfo) => {
            if (moduleInspectInfo && (moduleInspectInfo.updated || context.forceAll)) {
                const dependencies = await this._link(url, moduleInspectInfo.moduleRecord, context);
                inspectRecord.dependencies = dependencies;
            }
        });
        inspectRecord = {
            inspect: inspectPromise,
            link: linkPromise,
            dependencies: undefined,
        };
        context.modules.set(url.href, inspectRecord);
        return inspectRecord;
    }
    async _instantiateAll(inspectRecord, visited) {
        if (visited.has(inspectRecord)) {
            return;
        }
        visited.add(inspectRecord);
        await inspectRecord.link;
        if (inspectRecord.dependencies) {
            await Promise.all(inspectRecord.dependencies.map(async (dependency) => {
                if (dependency) {
                    await this._instantiateAll(dependency, visited);
                }
            }));
        }
    }
    async _inspectWithCache(url) {
        const mTimestamp = await this._modLo.getMTimestamp(url);
        const oldModuleRecord = this._moduleRecords[url.href];
        if (oldModuleRecord) {
            if (mTimestamp === oldModuleRecord.mTimestamp) {
                return { moduleRecord: oldModuleRecord, updated: false };
            }
            this._logger.debug(`Detected change: ${url}. Last mtime: ${new Date(oldModuleRecord.mTimestamp)}, Current mtime: ${new Date(mTimestamp)}`);
            this._moduleRecords[url.href] = null;
            await this._chunkWriter.removeChunk(oldModuleRecord.chunkId);
        }
        if (this._verbose) {
            this._logger.debug(`Inspect ${url}`);
        }
        const moduleRecord = await this._inspect(url, mTimestamp).catch((err) => {
            this._logger.error(err);
        });
        if (!moduleRecord) {
            // Module record is invalid or cache is valid
            return undefined;
        }
        return { moduleRecord, updated: true };
    }
    async _link(url, moduleRecord, context) {
        const chunkImports = {};
        let forceResolve = false;
        if (!moduleRecord.resolvedImports) {
            forceResolve = true;
            moduleRecord.resolvedImports = new Array(moduleRecord.imports.length).fill(null);
        }
        const resolvedImports = moduleRecord.resolvedImports;
        const depRecords = await Promise.all(moduleRecord.imports.map(async (specifier, iImport) => {
            var _a;
            let resolved = resolvedImports[iImport];
            if (forceResolve || // Not resolved before
                resolved === null && context.retryResolutionOnUnchangedModule // Resolved but failed
            ) {
                resolved = await this._resolve(specifier, url, moduleRecord.modLoMetadata);
                resolvedImports[iImport] = resolved;
            }
            if (!resolved || resolved.isExternal) {
                return;
            }
            const { url: resolvedURL } = resolved;
            const inspectRecord = await this._getOrCreateInspectRecord(resolvedURL, context);
            await inspectRecord.inspect;
            const resolvedChunk = (_a = this._moduleRecords[resolvedURL.href]) === null || _a === void 0 ? void 0 : _a.chunkId;
            if (resolvedChunk) {
                chunkImports[specifier.value] = resolvedChunk;
            }
            else {
                this._logger.debug(`We're missing the chunk ${resolvedURL.href}, referenced as '${specifier}'.`);
            }
            return inspectRecord;
        }));
        const chunk = await this._chunkWriter.getChunk(moduleRecord.chunkId);
        asserts_1.asserts(chunk);
        chunk.imports = chunkImports;
        return depRecords;
    }
    async _inspect(url, mTimestamp) {
        let mod;
        try {
            mod = await this._modLo.load(url);
        }
        catch (err) {
            this._logger.error(i18n_1.i18nTranslate('quick_pack_failed_to_load', { url: url.href, cause: err }));
            if (url.protocol === 'node:') {
                this._logger.warn(i18n_1.i18nTranslate('load_error_hint_node_builtin'));
            }
            return;
        }
        const { originalSource, code, map, modLoMetadata, } = mod;
        let ast;
        if (typeof code === 'string') {
            // TODO: input source map
            ast = await this._modLo.parse(code, map);
        }
        else {
            ast = code;
        }
        const imports = await detect_imports_1.detectImports(ast);
        const chunkURL = this._getChunkURL(url);
        const chunkId = this._chunkWriter.getChunkId(chunkURL);
        await this._transformAndAdd(chunkId, url, ast, typeof map === 'string' ? JSON.parse(map) : map !== null && map !== void 0 ? map : undefined, originalSource);
        const moduleRecord = {
            mTimestamp,
            chunkId,
            imports: imports,
            modLoMetadata,
        };
        this._moduleRecords[url.href] = moduleRecord;
        return moduleRecord;
    }
    async _transformAndAdd(chunkId, url, ast, map, originalSource) {
        const transformed = await this._transform(url, ast, map, originalSource);
        await this._chunkWriter.addChunk(chunkId, transformed.code, transformed.map);
    }
    async _transform(url, ast, map, originalSource) {
        const babelResult = await babel.transformFromAstAsync(ast, originalSource, {
            sourceFileName: url.href,
            // cloneInputAst: false,
            configFile: false,
            sourceType: 'module',
            sourceMaps: this._sourceMaps,
            inputSourceMap: map,
            plugins: [
                [plugin_transform_modules_systemjs_1.default],
                // Dynamic import() transformation must be enabled using the
                // @babel/plugin-proposal-dynamic-import plugin. Babel 8 will
                // no longer transform import() without using that plugin.
                [plugin_proposal_dynamic_import_1.default],
            ],
        });
        asserts_1.asserts(babelResult);
        asserts_1.asserts(babelResult.code);
        return {
            code: babelResult.code,
            map: babelResult.map,
        };
    }
    async _resolve(specifier, parentURL, modLoMetadata) {
        const specifierValue = specifier.value;
        try {
            const resolved = await this._modLo.resolve(specifierValue, parentURL, modLoMetadata);
            if (this._verbose) {
                if (resolved.isExternal) {
                    this._logger.debug(`Resolve ${specifierValue} from ${parentURL.href} as external dependency ${resolved.specifierOrURL}.`);
                }
                else {
                    this._logger.debug(`Resolve ${specifierValue} from ${parentURL.href} as ${resolved.url}.`);
                }
            }
            return resolved;
        }
        catch (err) {
            this._logger.error(i18n_1.i18nTranslate('quick_pack_failed_to_resolve', { specifier: specifierValue, parentURL: parentURL.href, cause: err }));
            if (specifierValue.includes('/')) {
                const lastPortion = specifierValue.split('/').pop();
                if (lastPortion && !lastPortion.includes('.')) {
                    this._logger.warn(i18n_1.i18nTranslate('resolve_error_hint_extension'));
                }
            }
            return null;
        }
    }
    /**
     * Map the module URL to chunk URL.
     * @param url
     */
    _getChunkURL(_url) {
        // TODO: do it better
        let url;
        if (!_url.search) {
            url = _url;
        }
        else {
            const u = new url_1.URL(_url.href);
            const extensionName = url_2.parseExtensionName(u.pathname);
            url_2.replaceExtension(u, `.proxy${extensionName}`);
            url = u;
        }
        // 见：https://gist.github.com/shrinktofit/50f2380782b6219ed6a4cb3a210a75f7
        for (const [from, to] of this._extensionMapping) {
            if (url.pathname.endsWith(from)) {
                return url_2.assignPathname(new url_1.URL(url.href), `${url.pathname.substr(0, url.pathname.length - from.length)}${to}`);
            }
        }
        if (!url_2.parseExtensionName(url.pathname)) {
            // URLs with no extension are store as .js
            return url_2.assignPathname(new url_1.URL(url.href), `${url.pathname}.js`);
        }
        return url;
    }
}
exports.QuickPack = QuickPack;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicXVpY2stcGFjay5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9tb2QtYXNzZW1ibGluZy9xdWljay1wYWNrL3F1aWNrLXBhY2sudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLGdEQUFzQjtBQUN0Qix3REFBMEI7QUFDMUIsNkJBQXlDO0FBR3pDLG9EQUFzRDtBQUV0RCwyREFBdUQ7QUFDdkQsc0NBQW9GO0FBQ3BGLDRDQUF1RDtBQUN2RCxtREFBcUM7QUFDckMsbUJBQW1CO0FBQ25CLGlIQUFvRjtBQUNwRixtQkFBbUI7QUFDbkIsMkdBQXFGO0FBQ3JGLGlEQUE4QztBQUM5QywyREFBa0U7QUFDbEUsMERBQWdGO0FBRWhGLDJDQUFpRDtBQUVqRCxNQUFNLFdBQVcsR0FBRyxDQUFDLEdBQVksRUFBRSxFQUFFLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxrQ0FBa0IsQ0FBQyxDQUFDLENBQUMsa0NBQWtCLENBQUM7QUFFcEYsTUFBTSxlQUFlLEdBQUcsV0FBVyxDQUFDLElBQUksQ0FBQyxDQUFDO0FBRTFDLE1BQWEsU0FBUztJQUNsQixZQUFZLEVBQ1IsS0FBSyxFQUNMLFVBQVUsRUFDVixNQUFNLEVBQ04sU0FBUyxFQUNULE9BQU8sRUFDUCxNQUFNLEdBUVQ7UUFrRk8sbUJBQWMsR0FBd0MsRUFBRSxDQUFDO1FBRXpELHNCQUFpQixHQUE0QjtZQUNqRCxDQUFDLEtBQUssRUFBRSxLQUFLLENBQUM7WUFDZCxDQUFDLE1BQU0sRUFBRSxLQUFLLENBQUM7U0FDbEIsQ0FBQztRQXRGRSxJQUFJLENBQUMsUUFBUSxHQUFHLE9BQU8sYUFBUCxPQUFPLGNBQVAsT0FBTyxHQUFJLEtBQUssQ0FBQztRQUNqQyxJQUFJLENBQUMsT0FBTyxHQUFHLE1BQU0sQ0FBQztRQUN0QixJQUFJLENBQUMsTUFBTSxHQUFHLEtBQUssQ0FBQztRQUNwQixJQUFJLENBQUMsV0FBVyxHQUFHLFVBQVUs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R0FBRyxDQUFDLFFBQVEsS0FBSyxDQUN2QixDQUFDO1NBQ0w7UUFDRCxPQUFPLEdBQUcsQ0FBQztJQUNmLENBQUM7Q0FDSjtBQTVYRCw4QkE0WEMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgcHMgZnJvbSAncGF0aCc7XG5pbXBvcnQgZnMgZnJvbSAnZnMtZXh0cmEnO1xuaW1wb3J0IHsgcGF0aFRvRmlsZVVSTCwgVVJMIH0gZnJvbSAndXJsJztcbmltcG9ydCB7IE1vZExvTWV0YWRhdGEsIE1vZExvLCBSZXNvbHZlUmVzdWx0LCBTb3VyY2UsIEFzdCwgU291cmNlTWFwLCBNb2QgfSBmcm9tICcuLi9tb2QtbG8vbW9kLWxvJztcbmltcG9ydCB7IE1vZHVsZVJlY29yZCB9IGZyb20gJy4vdXRpbHMvbW9kLXJlY29yZCc7XG5pbXBvcnQgeyBDaHVua1dyaXRlciB9IGZyb20gJy4vdXRpbHMvY2h1bmstaW8vd3JpdGVyJztcbmltcG9ydCB7IENodW5rSWQgfSBmcm9tICcuL3V0aWxzL2NodW5rLWlkJztcbmltcG9ydCB7IExvYWRlckNvbnRleHQgfSBmcm9tICcuL3V0aWxzL2xvYWRlci1jb250ZXh0JztcbmltcG9ydCB7IGFzc2lnblBhdGhuYW1lLCBwYXJzZUV4dGVuc2lvbk5hbWUsIHJlcGxhY2VFeHRlbnNpb24gfSBmcm9tICcuLi91dGlscy91cmwnO1xuaW1wb3J0IHsgY3JlYXRlTG9nZ2VyLCBMb2dnZXIgfSBmcm9tICcuLi91dGlscy9sb2dnZXInO1xuaW1wb3J0ICogYXMgYmFiZWwgZnJvbSAnQGJhYmVsL2NvcmUnO1xuLy8gQHRzLWV4cGVjdC1lcnJvclxuaW1wb3J0IGJhYmVsUGx1Z2luVHJhbnNmb3JtU3lzdGVtSnMgZnJvbSAnQGJhYmVsL3BsdWdpbi10cmFuc2Zvcm0tbW9kdWxlcy1zeXN0ZW1qcyc7XG4vLyBAdHMtZXhwZWN0LWVycm9yXG5pbXBvcnQgYmFiZWxQbHVnaW5Qcm9wb3NhbER5bmFtaWNJbXBvcnQgZnJvbSAnQGJhYmVsL3BsdWdpbi1wcm9wb3NhbC1keW5hbWljLWltcG9ydCc7XG5pbXBvcnQgeyBhc3NlcnRzIH0gZnJvbSAnLi4vLi4vdXRpbHMvYXNzZXJ0cyc7XG5pbXBvcnQgeyBkZXRlY3RJbXBvcnRzLCBTcGVjaWZpZXIgfSBmcm9tICcuL3V0aWxzL2RldGVjdC1pbXBvcnRzJztcbmltcG9ydCB7IHBhcmFsbGVsRGlzY2FyZGluZywgc2VxdWVuY2VEaXNjYXJkaW5nIH0gZnJvbSAnLi4vdXRpbHMvbGF1bmNoLXBvbGljeSc7XG5pbXBvcnQgeyBSYXdTb3VyY2VNYXAgfSBmcm9tICdzb3VyY2UtbWFwJztcbmltcG9ydCB7IGkxOG5UcmFuc2xhdGUgfSBmcm9tICcuLi8uLi91dGlscy9pMThuJztcblxuY29uc3QgZ2V0TGF1bmNoZXIgPSAocGFyOiBib29sZWFuKSA9PiBwYXIgPyBwYXJhbGxlbERpc2NhcmRpbmcgOiBzZXF1ZW5jZURpc2NhcmRpbmc7XG5cbmNvbnN0IHJlc29sdmVMYXVuY2hlciA9IGdldExhdW5jaGVyKHRydWUpO1xuXG5leHBvcnQgY2xhc3MgUXVpY2tQYWNrIHtcbiAgICBjb25zdHJ1Y3Rvcih7XG4gICAgICAgIG1vZExvLFxuICAgICAgICBzb3VyY2VNYXBzLFxuICAgICAgICBvcmlnaW4sXG4gICAgICAgIHdvcmtzcGFjZSxcbiAgICAgICAgdmVyYm9zZSxcbiAgICAgICAgbG9nZ2VyLFxuICAgIH06IHtcbiAgICAgICAgbW9kTG86IE1vZExvO1xuICAgICAgICBzb3VyY2VNYXBzPzogYm9vbGVhbiB8ICdpbmxpbmUnO1xuICAgICAgICBvcmlnaW46IHN0cmluZztcbiAgICAgICAgd29ya3NwYWNlOiBzdHJpbmc7XG4gICAgICAgIHZlcmJvc2U/OiBib29sZWFuO1xuICAgICAgICBsb2dnZXI/OiBMb2dnZXI7XG4gICAgfSkge1xuICAgICAgICB0aGlzLl92ZXJib3NlID0gdmVyYm9zZSA/PyBmYWxzZTtcbiAgICAgICAgdGhpcy5fb3JpZ2luID0gb3JpZ2luO1xuICAgICAgICB0aGlzLl9tb2RMbyA9IG1vZExvO1xuICAgICAgICB0aGlzLl9zb3VyY2VNYXBzID0gc291cmNlTWFwcyA/PyB0cnVlO1xuICAgICAgICB0aGlzLl9tb2R1bGVSZWNvcmRGaWxlID0gcHMuam9pbih3b3Jrc3BhY2UsICdtb2R1bGVzLmpzb24nKTtcbiAgICAgICAgdGhpcy5fY2h1bmtSZWNvcmRGaWxlID0gcHMuam9pbih3b3Jrc3BhY2UsICdjaHVua3MuanNvbicpO1xuICAgICAgICB0aGlzLl9zb3VyY2VDYWNoZURpciA9IHBzLmpvaW4od29ya3NwYWNlLCAnbW9kcycpO1xuICAgICAgICB0aGlzLl9jaHVua1dyaXRlciA9IG5ldyBDaHVua1dyaXRlcih7XG4gICAgICAgICAgICBvcmlnaW4sXG4gICAgICAgICAgICBjaHVua1JlY29yZEZpbGU6IHRoaXMuX2NodW5rUmVjb3JkRmlsZSxcbiAgICAgICAgICAgIHNvdXJjZUNhY2hlRGlyOiB0aGlzLl9zb3VyY2VDYWNoZURpcixcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX2xvZ2dlciA9IGxvZ2dlciA/PyBjcmVhdGVMb2dnZXIoe30pO1xuICAgIH1cblxuICAgIHB1YmxpYyBhc3luYyBidWlsZChzcGVjaWZpZXJzOiBJdGVyYWJsZTxzdHJpbmcgfCBVUkw+LCBvcHRpb25zPzoge1xuICAgICAgICBmb3JjZUFsbD86IGJvb2xlYW47XG4gICAgICAgIHJldHJ5UmVzb2x1dGlvbk9uVW5jaGFuZ2VkTW9kdWxlPzogYm9vbGVhbjtcbiAgICB9KSB7XG4gICAgICAgIGNvbnN0IGNvbnRleHQ6IEluc3BlY3RDb250ZXh0ID0ge1xuICAgICAgICAgICAgbW9kdWxlczogbmV3IE1hcCgpLFxuICAgICAgICAgICAgZm9yY2VBbGw6IG9wdGlvbnM/LmZvcmNlQWxsID8/IGZhbHNlLFxuICAgICAgICAgICAgcmV0cnlSZXNvbHV0aW9uT25VbmNoYW5nZWRNb2R1bGU6IG9wdGlvbnM/LnJldHJ5UmVzb2x1dGlvbk9uVW5jaGFuZ2VkTW9kdWxlID8/IGZhbHNlLFxuICAgICAgICB9O1xuICAgICAgICBmb3IgKGNvbnN0IHNwZWNpZmllciBvZiBzcGVjaWZpZXJzKSB7XG4gICAgICAgICAgICBjb25zdCB1cmwgPSB0eXBlb2Ygc3BlY2lmaWVyID09PSAnc3RyaW5nJ1xuICAgICAgICAgICAgICAgID8gYXdhaXQgdGhpcy5fcmVzb2x2ZUVudHJ5KHNwZWNpZmllcilcbiAgICAgICAgICAgICAgICA6IHNwZWNpZmllcjtcbiAgICAgICAgICAgIGlmICghdXJsKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBpbnNwZWN0UmVjb3JkID0gYXdhaXQgdGhpcy5fZ2V0T3JDcmVhdGVJbnNwZWN0UmVjb3JkKHVybCwgY29udGV4dCk7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9pbnN0YW50aWF0ZUFsbChpbnNwZWN0UmVjb3JkLCBuZXcgU2V0KCkpO1xuICAgICAgICAgICAgY29uc3QgbW9kdWxlUmVjb3JkID0gdGhpcy5fbW9kdWxlUmVjb3Jkc1t1cmwuaHJlZl07XG4gICAgICAgICAgICBpZiAoIW1vZHVsZVJlY29yZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2xvZ2dlci5kZWJ1ZyhgRW50cnkgJHt1cmx9IGRpZCBub3QgbGlicmFyeSBhIGNodW5rLmApO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgY2h1bmsgPSBhd2FpdCB0aGlzLl9jaHVua1dyaXRlci5nZXRDaHVuayhtb2R1bGVSZWNvcmQuY2h1bmtJZCk7XG4gICAgICAgICAgICBhc3NlcnRzKGNodW5rKTtcbiAgICAgICAgICAgIGNodW5rLmlzRW50cnkgPSB0cnVlO1xuICAgICAgICAgICAgY2h1bmsuZXhwb3NlQXMgPSB1cmwuaHJlZjtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCBmcy5vdXRwdXRKc29uKHRoaXMuX21vZHVsZVJlY29yZEZpbGUsIHRoaXMuX21vZHVsZVJlY29yZHMsIHsgZW5jb2Rpbmc6ICd1dGY4Jywgc3BhY2VzOiAyIH0pO1xuICAgICAgICBhd2FpdCB0aGlzLl9jaHVua1dyaXRlci5zeW5jQ2h1bmsoKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgYXN5bmMgY3JlYXRlTG9hZGVyQ29udGV4dCgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBMb2FkZXJDb250ZXh0KFxuICAgICAgICAgICAgdGhpcy5fb3JpZ2luLFxuICAgICAgICAgICAgdGhpcy5fY2h1bmtSZWNvcmRGaWxlLFxuICAgICAgICAgICAgdGhpcy5fc291cmNlQ2FjaGVEaXIsXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgcHVibGljIGFzeW5jIGxvYWRDYWNoZSgpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHNlcmlhbGl6ZWRNb2R1bGVSZWNvcmRzOiBSZWNvcmQ8c3RyaW5nLCBNb2R1bGVSZWNvcmQ+ID0gYXdhaXQgZnMucmVhZEpzb24odGhpcy5fbW9kdWxlUmVjb3JkRmlsZSk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IG1vZHVsZVJlY29yZCBvZiBPYmplY3QudmFsdWVzKHNlcmlhbGl6ZWRNb2R1bGVSZWNvcmRzKSkge1xuICAgICAgICAgICAgICAgIGlmIChtb2R1bGVSZWNvcmQucmVzb2x2ZWRJbXBvcnRzKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgcmVzb2x2ZVJlc3VsdCBvZiBtb2R1bGVSZWNvcmQucmVzb2x2ZWRJbXBvcnRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzb2x2ZVJlc3VsdCAmJiAhcmVzb2x2ZVJlc3VsdC5pc0V4dGVybmFsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZVJlc3VsdC51cmwgPSBuZXcgVVJMKHJlc29sdmVSZXN1bHQudXJsIGFzIHVua25vd24gYXMgc3RyaW5nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX21vZHVsZVJlY29yZHMgPSBzZXJpYWxpemVkTW9kdWxlUmVjb3JkcztcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICB0aGlzLl9sb2dnZXIuZGVidWcoYE1vZHVsZSByZWNvcmQgZmlsZSBsb2FkZWQgZmFpbGVkIHdpdGggZXJyb3I6ICR7ZXJyfWApO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IHRoaXMuX2NodW5rV3JpdGVyLmxvYWRDYWNoZSgpO1xuICAgIH1cblxuICAgIHByaXZhdGUgX3ZlcmJvc2U6IGJvb2xlYW47XG4gICAgcHJpdmF0ZSBfb3JpZ2luOiBzdHJpbmc7XG4gICAgcHJpdmF0ZSBfbW9kdWxlUmVjb3JkRmlsZTogc3RyaW5nO1xuICAgIHByaXZhdGUgX2NodW5rUmVjb3JkRmlsZTogc3RyaW5nO1xuICAgIHByaXZhdGUgX3NvdXJjZUNhY2hlRGlyOiBzdHJpbmc7XG4gICAgcHJpdmF0ZSBfbW9kTG86IE1vZExvO1xuICAgIHByaXZhdGUgX3NvdXJjZU1hcHM6IGJvb2xlYW4gfCAnaW5saW5lJztcbiAgICBwcml2YXRlIF9tb2R1bGVSZWNvcmRzOiBSZWNvcmQ8c3RyaW5nLCBNb2R1bGVSZWNvcmQgfCBudWxsPiA9IHt9O1xuICAgIHByaXZhdGUgX2NodW5rV3JpdGVyOiBDaHVua1dyaXRlcjtcbiAgICBwcml2YXRlIF9leHRlbnNpb25NYXBwaW5nOiBBcnJheTxbc3RyaW5nLCBzdHJpbmddPiA9IFtcbiAgICAgICAgWycudHMnLCAnLmpzJ10sXG4gICAgICAgIFsnLm1qcycsICcuanMnXSxcbiAgICBdO1xuICAgIHByaXZhdGUgX2xvZ2dlcjogTG9nZ2VyO1xuXG4gICAgcHJpdmF0ZSBhc3luYyBfcmVzb2x2ZUVudHJ5KHNwZWNpZmllcjogc3RyaW5nKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFVSTChzcGVjaWZpZXIpO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHRoaXMuX2xvZ2dlci5lcnJvcihpMThuVHJhbnNsYXRlKCdxdWlja19wYWNrX2NvdWxkX25vdF9yZXNvbHZlX2VudHJ5JywgeyBzcGVjaWZpZXIgfSkpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBhc3luYyBfZ2V0T3JDcmVhdGVJbnNwZWN0UmVjb3JkKHVybDogVVJMLCBjb250ZXh0OiBJbnNwZWN0Q29udGV4dCkge1xuICAgICAgICBjb25zdCBleGlzdGVkSW5zcGVjdFJlY29yZCA9IGNvbnRleHQubW9kdWxlcy5nZXQodXJsLmhyZWYpO1xuICAgICAgICBpZiAoZXhpc3RlZEluc3BlY3RSZWNvcmQpIHtcbiAgICAgICAgICAgIHJldHVybiBleGlzdGVkSW5zcGVjdFJlY29yZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBpbnNwZWN0UmVjb3JkOiBJbnNwZWN0UmVjb3JkO1xuXG4gICAgICAgIGNvbnN0IGluc3BlY3RQcm9taXNlID0gdGhpcy5faW5zcGVjdFdpdGhDYWNoZSh1cmwpO1xuICAgICAgICBjb25zdCBsaW5rUHJvbWlzZSA9IGluc3BlY3RQcm9taXNlLnRoZW4oYXN5bmMgKG1vZHVsZUluc3BlY3RJbmZvKSA9PiB7XG4gICAgICAgICAgICBpZiAobW9kdWxlSW5zcGVjdEluZm8gJiYgKG1vZHVsZUluc3BlY3RJbmZvLnVwZGF0ZWQgfHwgY29udGV4dC5mb3JjZUFsbCkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkZXBlbmRlbmNpZXMgPSBhd2FpdCB0aGlzLl9saW5rKHVybCwgbW9kdWxlSW5zcGVjdEluZm8ubW9kdWxlUmVjb3JkLCBjb250ZXh0KTtcbiAgICAgICAgICAgICAgICBpbnNwZWN0UmVjb3JkLmRlcGVuZGVuY2llcyA9IGRlcGVuZGVuY2llcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgaW5zcGVjdFJlY29yZCA9IHtcbiAgICAgICAgICAgIGluc3BlY3Q6IGluc3BlY3RQcm9taXNlLFxuICAgICAgICAgICAgbGluazogbGlua1Byb21pc2UsXG4gICAgICAgICAgICBkZXBlbmRlbmNpZXM6IHVuZGVmaW5lZCxcbiAgICAgICAgfTtcbiAgICAgICAgY29udGV4dC5tb2R1bGVzLnNldCh1cmwuaHJlZiwgaW5zcGVjdFJlY29yZCk7XG4gICAgICAgIHJldHVybiBpbnNwZWN0UmVjb3JkO1xuICAgIH1cblxuICAgIHByaXZhdGUgYXN5bmMgX2luc3RhbnRpYXRlQWxsKGluc3BlY3RSZWNvcmQ6IEluc3BlY3RSZWNvcmQsIHZpc2l0ZWQ6IFNldDxJbnNwZWN0UmVjb3JkPikge1xuICAgICAgICBpZiAodmlzaXRlZC5oYXMoaW5zcGVjdFJlY29yZCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2aXNpdGVkLmFkZChpbnNwZWN0UmVjb3JkKTtcbiAgICAgICAgYXdhaXQgaW5zcGVjdFJlY29yZC5saW5rO1xuICAgICAgICBpZiAoaW5zcGVjdFJlY29yZC5kZXBlbmRlbmNpZXMpIHtcbiAgICAgICAgICAgIGF3YWl0IFByb21pc2UuYWxsKGluc3BlY3RSZWNvcmQuZGVwZW5kZW5jaWVzLm1hcChhc3luYyAoZGVwZW5kZW5jeSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChkZXBlbmRlbmN5KSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX2luc3RhbnRpYXRlQWxsKGRlcGVuZGVuY3ksIHZpc2l0ZWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgYXN5bmMgX2luc3BlY3RXaXRoQ2FjaGUodXJsOiBVUkwpIHtcbiAgICAgICAgY29uc3QgbVRpbWVzdGFtcCA9IGF3YWl0IHRoaXMuX21vZExvLmdldE1UaW1lc3RhbXAodXJsKTtcbiAgICAgICAgY29uc3Qgb2xkTW9kdWxlUmVjb3JkID0gdGhpcy5fbW9kdWxlUmVjb3Jkc1t1cmwuaHJlZl07XG4gICAgICAgIGlmIChvbGRNb2R1bGVSZWNvcmQpIHtcbiAgICAgICAgICAgIGlmIChtVGltZXN0YW1wID09PSBvbGRNb2R1bGVSZWNvcmQubVRpbWVzdGFtcCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IG1vZHVsZVJlY29yZDogb2xkTW9kdWxlUmVjb3JkLCB1cGRhdGVkOiBmYWxzZSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fbG9nZ2VyLmRlYnVnKGBEZXRlY3RlZCBjaGFuZ2U6ICR7dXJsfS4gTGFzdCBtdGltZTogJHtuZXcgRGF0ZShvbGRNb2R1bGVSZWNvcmQubVRpbWVzdGFtcCl9LCBDdXJyZW50IG10aW1lOiAke25ldyBEYXRlKG1UaW1lc3RhbXApfWApO1xuICAgICAgICAgICAgdGhpcy5fbW9kdWxlUmVjb3Jkc1t1cmwuaHJlZl0gPSBudWxsO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fY2h1bmtXcml0ZXIucmVtb3ZlQ2h1bmsob2xkTW9kdWxlUmVjb3JkLmNodW5rSWQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX3ZlcmJvc2UpIHtcbiAgICAgICAgICAgIHRoaXMuX2xvZ2dlci5kZWJ1ZyhgSW5zcGVjdCAke3VybH1gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IG1vZHVsZVJlY29yZCA9IGF3YWl0IHRoaXMuX2luc3BlY3QodXJsLCBtVGltZXN0YW1wKS5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgICAgICB0aGlzLl9sb2dnZXIuZXJyb3IoZXJyKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghbW9kdWxlUmVjb3JkKSB7XG4gICAgICAgICAgICAvLyBNb2R1bGUgcmVjb3JkIGlzIGludmFsaWQgb3IgY2FjaGUgaXMgdmFsaWRcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4geyBtb2R1bGVSZWNvcmQsIHVwZGF0ZWQ6IHRydWUgfTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGFzeW5jIF9saW5rKHVybDogVVJMLCBtb2R1bGVSZWNvcmQ6IE1vZHVsZVJlY29yZCwgY29udGV4dDogSW5zcGVjdENvbnRleHQpIHtcbiAgICAgICAgY29uc3QgY2h1bmtJbXBvcnRzOiBSZWNvcmQ8c3RyaW5nLCBDaHVua0lkPiA9IHt9O1xuXG4gICAgICAgIGxldCBmb3JjZVJlc29sdmUgPSBmYWxzZTtcbiAgICAgICAgaWYgKCFtb2R1bGVSZWNvcmQucmVzb2x2ZWRJbXBvcnRzKSB7XG4gICAgICAgICAgICBmb3JjZVJlc29sdmUgPSB0cnVlO1xuICAgICAgICAgICAgbW9kdWxlUmVjb3JkLnJlc29sdmVkSW1wb3J0cyA9IG5ldyBBcnJheShtb2R1bGVSZWNvcmQuaW1wb3J0cy5sZW5ndGgpLmZpbGwobnVsbCk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCByZXNvbHZlZEltcG9ydHMgPSBtb2R1bGVSZWNvcmQucmVzb2x2ZWRJbXBvcnRzO1xuXG4gICAgICAgIGNvbnN0IGRlcFJlY29yZHMgPSBhd2FpdCBQcm9taXNlLmFsbChtb2R1bGVSZWNvcmQuaW1wb3J0cy5tYXAoYXN5bmMgKHNwZWNpZmllciwgaUltcG9ydCk6IFByb21pc2U8dW5kZWZpbmVkIHwgSW5zcGVjdFJlY29yZD4gPT4ge1xuICAgICAgICAgICAgbGV0IHJlc29sdmVkID0gcmVzb2x2ZWRJbXBvcnRzW2lJbXBvcnRdO1xuICAgICAgICAgICAgaWYgKGZvcmNlUmVzb2x2ZSB8fCAvLyBOb3QgcmVzb2x2ZWQgYmVmb3JlXG4gICAgICAgICAgICAgICAgcmVzb2x2ZWQgPT09IG51bGwgJiYgY29udGV4dC5yZXRyeVJlc29sdXRpb25PblVuY2hhbmdlZE1vZHVsZSAvLyBSZXNvbHZlZCBidXQgZmFpbGVkXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlZCA9IGF3YWl0IHRoaXMuX3Jlc29sdmUoc3BlY2lmaWVyLCB1cmwsIG1vZHVsZVJlY29yZC5tb2RMb01ldGFkYXRhKTtcbiAgICAgICAgICAgICAgICByZXNvbHZlZEltcG9ydHNbaUltcG9ydF0gPSByZXNvbHZlZDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFyZXNvbHZlZCB8fCByZXNvbHZlZC5pc0V4dGVybmFsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCB7IHVybDogcmVzb2x2ZWRVUkwgfSA9IHJlc29sdmVkO1xuXG4gICAgICAgICAgICBjb25zdCBpbnNwZWN0UmVjb3JkID0gYXdhaXQgdGhpcy5fZ2V0T3JDcmVhdGVJbnNwZWN0UmVjb3JkKHJlc29sdmVkVVJMLCBjb250ZXh0KTtcbiAgICAgICAgICAgIGF3YWl0IGluc3BlY3RSZWNvcmQuaW5zcGVjdDtcblxuICAgICAgICAgICAgY29uc3QgcmVzb2x2ZWRDaHVuayA9IHRoaXMuX21vZHVsZVJlY29yZHNbcmVzb2x2ZWRVUkwuaHJlZl0/LmNodW5rSWQ7XG4gICAgICAgICAgICBpZiAocmVzb2x2ZWRDaHVuaykge1xuICAgICAgICAgICAgICAgIGNodW5rSW1wb3J0c1tzcGVjaWZpZXIudmFsdWVdID0gcmVzb2x2ZWRDaHVuaztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbG9nZ2VyLmRlYnVnKGBXZSdyZSBtaXNzaW5nIHRoZSBjaHVuayAke3Jlc29sdmVkVVJMLmhyZWZ9LCByZWZlcmVuY2VkIGFzICcke3NwZWNpZmllcn0nLmApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gaW5zcGVjdFJlY29yZDtcbiAgICAgICAgfSkpO1xuXG4gICAgICAgIGNvbnN0IGNodW5rID0gYXdhaXQgdGhpcy5fY2h1bmtXcml0ZXIuZ2V0Q2h1bmsobW9kdWxlUmVjb3JkLmNodW5rSWQpO1xuICAgICAgICBhc3NlcnRzKGNodW5rKTtcbiAgICAgICAgY2h1bmsuaW1wb3J0cyA9IGNodW5rSW1wb3J0cztcblxuICAgICAgICByZXR1cm4gZGVwUmVjb3JkcztcbiAgICB9XG5cbiAgICBwcml2YXRlIGFzeW5jIF9pbnNwZWN0KHVybDogVVJMLCBtVGltZXN0YW1wOiBudW1iZXIpIHtcbiAgICAgICAgbGV0IG1vZDogTW9kO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgbW9kID0gYXdhaXQgdGhpcy5fbW9kTG8ubG9hZCh1cmwpO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHRoaXMuX2xvZ2dlci5lcnJvcihpMThuVHJhbnNsYXRlKCdxdWlja19wYWNrX2ZhaWxlZF90b19sb2FkJywgeyB1cmw6IHVybC5ocmVmLCBjYXVzZTogZXJyIH0pKTtcbiAgICAgICAgICAgIGlmICh1cmwucHJvdG9jb2wgPT09ICdub2RlOicpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9sb2dnZXIud2FybihpMThuVHJhbnNsYXRlKCdsb2FkX2Vycm9yX2hpbnRfbm9kZV9idWlsdGluJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgb3JpZ2luYWxTb3VyY2UsXG4gICAgICAgICAgICBjb2RlLFxuICAgICAgICAgICAgbWFwLFxuICAgICAgICAgICAgbW9kTG9NZXRhZGF0YSxcbiAgICAgICAgfSA9IG1vZDtcblxuICAgICAgICBsZXQgYXN0OiBBc3Q7XG4gICAgICAgIGlmICh0eXBlb2YgY29kZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIC8vIFRPRE86IGlucHV0IHNvdXJjZSBtYXBcbiAgICAgICAgICAgIGFzdCA9IGF3YWl0IHRoaXMuX21vZExvLnBhcnNlKGNvZGUsIG1hcCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhc3QgPSBjb2RlO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgaW1wb3J0cyA9IGF3YWl0IGRldGVjdEltcG9ydHMoYXN0KTtcblxuICAgICAgICBjb25zdCBjaHVua1VSTCA9IHRoaXMuX2dldENodW5rVVJMKHVybCk7XG5cbiAgICAgICAgY29uc3QgY2h1bmtJZCA9IHRoaXMuX2NodW5rV3JpdGVyLmdldENodW5rSWQoY2h1bmtVUkwpO1xuXG4gICAgICAgIGF3YWl0IHRoaXMuX3RyYW5zZm9ybUFuZEFkZChcbiAgICAgICAgICAgIGNodW5rSWQsXG4gICAgICAgICAgICB1cmwsXG4gICAgICAgICAgICBhc3QsXG4gICAgICAgICAgICB0eXBlb2YgbWFwID09PSAnc3RyaW5nJyA/IEpTT04ucGFyc2UobWFwKSA6IG1hcCA/PyB1bmRlZmluZWQsXG4gICAgICAgICAgICBvcmlnaW5hbFNvdXJjZSxcbiAgICAgICAgKTtcblxuICAgICAgICBjb25zdCBtb2R1bGVSZWNvcmQ6IE1vZHVsZVJlY29yZCA9IHtcbiAgICAgICAgICAgIG1UaW1lc3RhbXAsXG4gICAgICAgICAgICBjaHVua0lkLFxuICAgICAgICAgICAgaW1wb3J0czogaW1wb3J0cyxcbiAgICAgICAgICAgIG1vZExvTWV0YWRhdGEsXG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5fbW9kdWxlUmVjb3Jkc1t1cmwuaHJlZl0gPSBtb2R1bGVSZWNvcmQ7XG5cbiAgICAgICAgcmV0dXJuIG1vZHVsZVJlY29yZDtcbiAgICB9XG5cbiAgICBwcml2YXRlIGFzeW5jIF90cmFuc2Zvcm1BbmRBZGQoY2h1bmtJZDogc3RyaW5nLCB1cmw6IFVSTCwgYXN0OiBBc3QsIG1hcDogUmF3U291cmNlTWFwIHwgdW5kZWZpbmVkLCBvcmlnaW5hbFNvdXJjZTogc3RyaW5nKSB7XG4gICAgICAgIGNvbnN0IHRyYW5zZm9ybWVkID0gYXdhaXQgdGhpcy5fdHJhbnNmb3JtKHVybCwgYXN0LCBtYXAsIG9yaWdpbmFsU291cmNlKTtcblxuICAgICAgICBhd2FpdCB0aGlzLl9jaHVua1dyaXRlci5hZGRDaHVuayhcbiAgICAgICAgICAgIGNodW5rSWQsXG4gICAgICAgICAgICB0cmFuc2Zvcm1lZC5jb2RlLFxuICAgICAgICAgICAgdHJhbnNmb3JtZWQubWFwLFxuICAgICAgICApO1xuICAgIH1cblxuICAgIHByaXZhdGUgYXN5bmMgX3RyYW5zZm9ybSh1cmw6IFVSTCwgYXN0OiBBc3QsIG1hcDogUmF3U291cmNlTWFwIHwgdW5kZWZpbmVkLCBvcmlnaW5hbFNvdXJjZTogc3RyaW5nKSB7XG4gICAgICAgIGNvbnN0IGJhYmVsUmVzdWx0ID0gYXdhaXQgYmFiZWwudHJhbnNmb3JtRnJvbUFzdEFzeW5jKFxuICAgICAgICAgICAgYXN0LFxuICAgICAgICAgICAgb3JpZ2luYWxTb3VyY2UsIHtcbiAgICAgICAgICAgICAgICBzb3VyY2VGaWxlTmFtZTogdXJsLmhyZWYsXG4gICAgICAgICAgICAgICAgLy8gY2xvbmVJbnB1dEFzdDogZmFsc2UsXG4gICAgICAgICAgICAgICAgY29uZmlnRmlsZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgc291cmNlVHlwZTogJ21vZHVsZScsXG4gICAgICAgICAgICAgICAgc291cmNlTWFwczogdGhpcy5fc291cmNlTWFwcyxcbiAgICAgICAgICAgICAgICBpbnB1dFNvdXJjZU1hcDogbWFwLFxuICAgICAgICAgICAgICAgIHBsdWdpbnM6IFtcbiAgICAgICAgICAgICAgICAgICAgW2JhYmVsUGx1Z2luVHJhbnNmb3JtU3lzdGVtSnNdLFxuICAgICAgICAgICAgICAgICAgICAvLyBEeW5hbWljIGltcG9ydCgpIHRyYW5zZm9ybWF0aW9uIG11c3QgYmUgZW5hYmxlZCB1c2luZyB0aGVcbiAgICAgICAgICAgICAgICAgICAgLy8gQGJhYmVsL3BsdWdpbi1wcm9wb3NhbC1keW5hbWljLWltcG9ydCBwbHVnaW4uIEJhYmVsIDggd2lsbFxuICAgICAgICAgICAgICAgICAgICAvLyBubyBsb25nZXIgdHJhbnNmb3JtIGltcG9ydCgpIHdpdGhvdXQgdXNpbmcgdGhhdCBwbHVnaW4uXG4gICAgICAgICAgICAgICAgICAgIFtiYWJlbFBsdWdpblByb3Bvc2FsRHluYW1pY0ltcG9ydF0sXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIH0gYXMgYmFiZWwuVHJhbnNmb3JtT3B0aW9ucyAmIHtcbiAgICAgICAgICAgICAgICBjbG9uZUlucHV0QXN0PzogYm9vbGVhbjtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICk7XG4gICAgICAgIGFzc2VydHMoYmFiZWxSZXN1bHQpO1xuICAgICAgICBhc3NlcnRzKGJhYmVsUmVzdWx0LmNvZGUpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY29kZTogYmFiZWxSZXN1bHQuY29kZSxcbiAgICAgICAgICAgIG1hcDogYmFiZWxSZXN1bHQubWFwIGFzIHVua25vd24gYXMgU291cmNlTWFwLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIHByaXZhdGUgYXN5bmMgX3Jlc29sdmUoc3BlY2lmaWVyOiBTcGVjaWZpZXIsIHBhcmVudFVSTDogVVJMLCBtb2RMb01ldGFkYXRhOiBNb2RMb01ldGFkYXRhKSB7XG4gICAgICAgIGNvbnN0IHNwZWNpZmllclZhbHVlID0gc3BlY2lmaWVyLnZhbHVlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmVzb2x2ZWQgPSBhd2FpdCB0aGlzLl9tb2RMby5yZXNvbHZlKHNwZWNpZmllclZhbHVlLCBwYXJlbnRVUkwsIG1vZExvTWV0YWRhdGEpO1xuICAgICAgICAgICAgaWYgKHRoaXMuX3ZlcmJvc2UpIHtcbiAgICAgICAgICAgICAgICBpZiAocmVzb2x2ZWQuaXNFeHRlcm5hbCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9sb2dnZXIuZGVidWcoYFJlc29sdmUgJHtzcGVjaWZpZXJWYWx1ZX0gZnJvbSAke3BhcmVudFVSTC5ocmVmfSBhcyBleHRlcm5hbCBkZXBlbmRlbmN5ICR7cmVzb2x2ZWQuc3BlY2lmaWVyT3JVUkx9LmApO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2xvZ2dlci5kZWJ1ZyhgUmVzb2x2ZSAke3NwZWNpZmllclZhbHVlfSBmcm9tICR7cGFyZW50VVJMLmhyZWZ9IGFzICR7cmVzb2x2ZWQudXJsfS5gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzb2x2ZWQ7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgdGhpcy5fbG9nZ2VyLmVycm9yKGkxOG5UcmFuc2xhdGUoXG4gICAgICAgICAgICAgICAgJ3F1aWNrX3BhY2tfZmFpbGVkX3RvX3Jlc29sdmUnLFxuICAgICAgICAgICAgICAgIHsgc3BlY2lmaWVyOiBzcGVjaWZpZXJWYWx1ZSwgcGFyZW50VVJMOiBwYXJlbnRVUkwuaHJlZiwgY2F1c2U6IGVyciB9LFxuICAgICAgICAgICAgKSk7XG4gICAgICAgICAgICBpZiAoc3BlY2lmaWVyVmFsdWUuaW5jbHVkZXMoJy8nKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxhc3RQb3J0aW9uID0gc3BlY2lmaWVyVmFsdWUuc3BsaXQoJy8nKS5wb3AoKTtcbiAgICAgICAgICAgICAgICBpZiAobGFzdFBvcnRpb24gJiYgIWxhc3RQb3J0aW9uLmluY2x1ZGVzKCcuJykpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbG9nZ2VyLndhcm4oaTE4blRyYW5zbGF0ZSgncmVzb2x2ZV9lcnJvcl9oaW50X2V4dGVuc2lvbicpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1hcCB0aGUgbW9kdWxlIFVSTCB0byBjaHVuayBVUkwuXG4gICAgICogQHBhcmFtIHVybCBcbiAgICAgKi9cbiAgICBwcml2YXRlIF9nZXRDaHVua1VSTChfdXJsOiBSZWFkb25seTxVUkw+KTogUmVhZG9ubHk8VVJMPiB7XG4gICAgICAgIC8vIFRPRE86IGRvIGl0IGJldHRlclxuICAgICAgICBsZXQgdXJsOiBSZWFkb25seTxVUkw+O1xuICAgICAgICBpZiAoIV91cmwuc2VhcmNoKSB7XG4gICAgICAgICAgICB1cmwgPSBfdXJsO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgdSA9IG5ldyBVUkwoX3VybC5ocmVmKTtcbiAgICAgICAgICAgIGNvbnN0IGV4dGVuc2lvbk5hbWUgPSBwYXJzZUV4dGVuc2lvbk5hbWUodS5wYXRobmFtZSk7XG4gICAgICAgICAgICByZXBsYWNlRXh0ZW5zaW9uKHUsIGAucHJveHkke2V4dGVuc2lvbk5hbWV9YCk7XG4gICAgICAgICAgICB1cmwgPSB1O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8g6KeB77yaaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vc2hyaW5rdG9maXQvNTBmMjM4MDc4MmI2MjE5ZWQ2YTRjYjNhMjEwYTc1ZjdcbiAgICAgICAgZm9yIChjb25zdCBbZnJvbSwgdG9dIG9mIHRoaXMuX2V4dGVuc2lvbk1hcHBpbmcpIHtcbiAgICAgICAgICAgIGlmICh1cmwucGF0aG5hbWUuZW5kc1dpdGgoZnJvbSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXNzaWduUGF0aG5hbWUoXG4gICAgICAgICAgICAgICAgICAgIG5ldyBVUkwodXJsLmhyZWYpLFxuICAgICAgICAgICAgICAgICAgICBgJHt1cmwucGF0aG5hbWUuc3Vic3RyKDAsIHVybC5wYXRobmFtZS5sZW5ndGggLSBmcm9tLmxlbmd0aCl9JHt0b31gLFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFwYXJzZUV4dGVuc2lvbk5hbWUodXJsLnBhdGhuYW1lKSkge1xuICAgICAgICAgICAgLy8gVVJMcyB3aXRoIG5vIGV4dGVuc2lvbiBhcmUgc3RvcmUgYXMgLmpzXG4gICAgICAgICAgICByZXR1cm4gYXNzaWduUGF0aG5hbWUoXG4gICAgICAgICAgICAgICAgbmV3IFVSTCh1cmwuaHJlZiksXG4gICAgICAgICAgICAgICAgYCR7dXJsLnBhdGhuYW1lfS5qc2BcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVybDtcbiAgICB9XG59XG5cbmludGVyZmFjZSBJbnNwZWN0UmVjb3JkIHtcbiAgICBpbnNwZWN0OiBQcm9taXNlPHsgbW9kdWxlUmVjb3JkOiBNb2R1bGVSZWNvcmQ7IHVwZGF0ZWQ6IGJvb2xlYW47IH0gfCB1bmRlZmluZWQ+O1xuICAgIGxpbms6IFByb21pc2U8dm9pZD4gfCB1bmRlZmluZWQ7XG4gICAgZGVwZW5kZW5jaWVzOiBBcnJheTxJbnNwZWN0UmVjb3JkIHwgdW5kZWZpbmVkPiB8IHVuZGVmaW5lZDtcbn1cblxuaW50ZXJmYWNlIEluc3BlY3RDb250ZXh0IHtcbiAgICBmb3JjZUFsbDogYm9vbGVhbjtcbiAgICByZXRyeVJlc29sdXRpb25PblVuY2hhbmdlZE1vZHVsZTogYm9vbGVhbjtcbiAgICBtb2R1bGVzOiBNYXA8c3RyaW5nLCBJbnNwZWN0UmVjb3JkPjtcbn1cbiJdfQ==