"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SourceMapSupport = void 0;
const source_map_1 = require("source-map");
const url_1 = require("url");
const fs_extra_1 = __importDefault(require("fs-extra"));
const path_1 = __importDefault(require("path"));
/**
 * 参考 https://github.com/evanw/node-source-map-support/blob/master/source-map-support.js
 */
class SourceMapSupport {
    constructor() {
        this._sourceMapCache = {};
        this._fileContentsCache = {};
        this._myStackProperty = Symbol('[[Creator::stack]]');
    }
    install() {
        if (this._vendorPrepareStackTrace) {
            return;
        }
        this._vendorPrepareStackTrace = Error.prepareStackTrace;
        Error.prepareStackTrace =
            (...args) => this._prepareStackTrace(...args);
    }
    uninstall() {
        if (!this._vendorPrepareStackTrace) {
            return;
        }
        Error.prepareStackTrace = this._vendorPrepareStackTrace;
    }
    hasStackProperty(value) {
        return this._myStackProperty in value;
    }
    getStackProperty(value) {
        return value[this._myStackProperty];
    }
    _prepareStackTrace(err, stackTraces) {
        let vendorResult;
        if (this._vendorPrepareStackTrace) {
            // @ts-ignore
            vendorResult = this._vendorPrepareStackTrace.apply(undefined, arguments);
        }
        else {
            vendorResult = stackTraces.map(callSite => this._callSiteToString(callSite)).join('\n');
        }
        const myResult = this._prepareStackTracePostVendor(err, stackTraces, vendorResult);
        if (myResult) {
            return myResult;
        }
        return vendorResult;
    }
    _prepareStackTracePostVendor(err, stackTraces, _vendorResult) {
        if (typeof err !== 'object' || err === null) {
            return;
        }
        // const wrappedCallSites: WrappedCallSite[] = [];
        // for (const callSite of stackTraces) {
        //     const wrapped = this._wrapCallSite(callSite);
        //     if (wrapped) {
        //         wrappedCallSites.push(wrapped);
        //     }
        // }
        // if (wrappedCallSites.length !== 0) {
        //     Object.defineProperty(err, this._myStackProperty, {
        //         value: wrappedCallSites,
        //         enumerable: false,
        //     });
        //     return this._formatStack(err, wrappedCallSites);
        // }
        const state = { current: null, next: null };
        const wrappedCallSites = stackTraces.map((callSite) => {
            var _a;
            const wrapped = (_a = this._tryWrapCallSite(callSite, state)) !== null && _a !== void 0 ? _a : callSite;
            state.next = state.current;
            return wrapped;
        });
        state.current = state.next = null;
        return this._formatStack(err, wrappedCallSites);
    }
    _formatStack(err, wrappedCallSites) {
        var _a, _b;
        const stack = wrappedCallSites.map(callSite => `\n    at ${this._callSiteToString(callSite)}`).join('');
        return `${(_a = err.name) !== null && _a !== void 0 ? _a : 'Error'}: ${(_b = err.message) !== null && _b !== void 0 ? _b : ''}${stack}`;
    }
    _tryWrapCallSite(callSite, state) {
        try {
            return this._wrapCallSite(callSite, state);
        }
        catch (err) {
            console.debug(err);
            return;
        }
    }
    _wrapCallSite(callSite, state) {
        var _a, _b;
        state.current = null;
        if (callSite.isNative()) {
            return;
        }
        // Most call sites will return the source file from getFileName(), but code
        // passed to eval() ending in "//# sourceURL=..." will return the source file
        // from getScriptNameOrSourceURL() instead
        const source = (_a = callSite.getFileName()) !== null && _a !== void 0 ? _a : callSite.getScriptNameOrSourceURL();
        if (source) {
            const line = callSite.getLineNumber();
            let column = callSite.getColumnNumber() - 1;
            // Fix position in Node where some (internal) code is prepended.
            // See https://github.com/evanw/node-source-map-support/issues/36
            // Header removed in node at ^10.16 || >=11.11.0
            // v11 is not an LTS candidate, we can just test the one version with it.
            // Test node versions for: 10.16-19, 10.20+, 12-19, 20-99, 100+, or 11.11
            const noHeader = /^v(10\.1[6-9]|10\.[2-9][0-9]|10\.[0-9]{3,}|1[2-9]\d*|[2-9]\d|\d{3,}|11\.11)/;
            const headerLength = noHeader.test(process.version) ? 0 : 62;
            if (line === 1 && column > headerLength /* && !isInBrowser()*/ && !callSite.isEval()) {
                column -= headerLength;
            }
            const mappedPosition = this._mapSourcePosition({ source, line, column });
            if (mappedPosition) {
                state.current = mappedPosition;
                const wrappedCallSite = cloneCallSite(callSite);
                wrappedCallSite.getFileName = () => mappedPosition.source;
                wrappedCallSite.getLineNumber = () => mappedPosition.line;
                wrappedCallSite.getColumnNumber = () => mappedPosition.column + 1;
                const nextName = (_b = state.next) === null || _b === void 0 ? void 0 : _b.name;
                if (nextName) {
                    wrappedCallSite.getFunctionName = () => nextName;
                }
                return wrappedCallSite;
            }
        }
        else if (callSite.isEval()) {
            const origin = callSite.getEvalOrigin();
            if (origin) {
                this._mapEvalOrigin(origin);
            }
        }
    }
    _callSiteToString(callSite) {
        var _a;
        let fileName;
        let fileLocation = "";
        if (callSite.isNative()) {
            fileLocation = "native";
        }
        else {
            fileName = callSite.getFileName();
            if (!fileName && callSite.isEval()) {
                fileLocation = (_a = callSite.getEvalOrigin()) !== null && _a !== void 0 ? _a : '';
                fileLocation += ", "; // Expecting source position to follow.
            }
            if (fileName) {
                fileLocation += fileName;
            }
            else {
                // Source code does not originate from a file and is not native, but we
                // can still get the source position inside the source string, e.g. in
                // an eval string.
                fileLocation += "<anonymous>";
            }
            const lineNumber = callSite.getLineNumber();
            if (lineNumber !== null) {
                fileLocation += ":" + lineNumber;
                const columnNumber = callSite.getColumnNumber();
                if (columnNumber) {
                    fileLocation += ":" + columnNumber;
                }
            }
        }
        let line = "";
        const functionName = callSite.getFunctionName();
        let addSuffix = true;
        const isConstructor = callSite.isConstructor();
        const isMethodCall = !(callSite.isToplevel() || isConstructor);
        if (isMethodCall) {
            let typeName = callSite.getTypeName();
            // Fixes shim to be backward compatable with Node v0 to v4
            if (typeName === "[object Object]") {
                typeName = "null";
            }
            const methodName = callSite.getMethodName();
            if (functionName) {
                if (typeName && functionName.indexOf(typeName) !== 0) {
                    line += typeName + ".";
                }
                line += functionName;
                if (methodName && functionName.indexOf("." + methodName) !== functionName.length - methodName.length - 1) {
                    line += " [as " + methodName + "]";
                }
            }
            else {
                line += typeName + "." + (methodName || "<anonymous>");
            }
        }
        else if (isConstructor) {
            line += "new " + (functionName || "<anonymous>");
        }
        else if (functionName) {
            line += functionName;
        }
        else {
            line += fileLocation;
            addSuffix = false;
        }
        if (addSuffix) {
            line += " (" + fileLocation + ")";
        }
        return line;
    }
    _mapSourcePosition(position) {
        var _a;
        const sourceMapRecord = this._getSourceMap(position.source);
        if (!(sourceMapRecord === null || sourceMapRecord === void 0 ? void 0 : sourceMapRecord.map) ||
            typeof sourceMapRecord.map.originalPositionFor !== 'function') {
            return;
        }
        // Resolve the source URL relative to the URL of the source map.
        // Only return the original position if a matching line was found. If no
        // matching line is found then we return position instead, which will cause
        // the stack trace to print the path and line for the compiled file. It is
        // better to give a precise location in the compiled file than a vague
        // location in the original file.
        const originalPosition = sourceMapRecord.map.originalPositionFor(position);
        if (originalPosition.source === null || originalPosition.source === 'null') {
            return;
        }
        const resolved = this._resolveUrl(originalPosition.source, sourceMapRecord.url);
        if (resolved) {
            originalPosition.source = (_a = convertFileUrlToPath(resolved)) !== null && _a !== void 0 ? _a : resolved.href;
        }
        return originalPosition;
    }
    _mapEvalOrigin(origin) {
    }
    _getSourceMap(source) {
        var _a;
        const sourceUrl = this._resolveUrl(source);
        if (!sourceUrl) {
            return;
        }
        const { href } = sourceUrl;
        const sourceMapRecord = this._sourceMapCache[href];
        if (sourceMapRecord === undefined) {
            const fetchedSourceMap = this._fetchSourceMap(sourceUrl);
            if (!fetchedSourceMap) {
                this._sourceMapCache[href] = null;
            }
            else {
                const sourceMapUrl = fetchedSourceMap.url;
                // Load all sources stored inline with the source map into the file cache
                // to pretend like they are already loaded. They may not exist on disk.
                if (fetchedSourceMap.map.sourcesContent) {
                    fetchedSourceMap.map.sourcesContent.forEach((sourceContent, iSource) => {
                        var _a, _b;
                        if (sourceContent) {
                            const inlineSource = fetchedSourceMap.map.sources[iSource];
                            const inlineSourceUrl = (_b = (_a = this._resolveUrl(inlineSource, sourceMapUrl)) === null || _a === void 0 ? void 0 : _a.href) !== null && _b !== void 0 ? _b : inlineSource;
                            this._fileContentsCache[inlineSourceUrl] = sourceContent;
                        }
                    });
                }
                const sourceMapConsumer = new source_map_1.SourceMapConsumer(fetchedSourceMap.map);
                this._sourceMapCache[href] = { map: sourceMapConsumer, url: sourceMapUrl };
            }
        }
        return (_a = this._sourceMapCache[href]) !== null && _a !== void 0 ? _a : undefined;
    }
    _tryFetchSourceMap(source) {
        try {
            return this._fetchSourceMap(source);
        }
        catch (err) {
            console.debug(`Failed to fetch source map for '${source}': ${err}`);
            return;
        }
    }
    _fetchSourceMap(source) {
        const sourceMappingUri = this._fetchSourceMapUrl(source);
        if (!sourceMappingUri) {
            return;
        }
        // Read the contents of the source map
        let sourceMapData;
        let sourceMapUrl;
        if (reSourceMappingDataUrl.test(sourceMappingUri)) {
            // Support source map URL as a data url
            const rawData = sourceMappingUri.slice(sourceMappingUri.indexOf(',') + 1);
            sourceMapData = JSON.parse(Buffer.from(rawData, "base64").toString());
            sourceMapUrl = source;
        }
        else {
            // Support source map URLs relative to the source URL
            const resolved = this._resolveUrl(sourceMappingUri, source);
            if (!resolved) {
                return;
            }
            sourceMapUrl = resolved;
            const file = this._fetchFileSync(sourceMapUrl);
            if (!file) {
                return;
            }
            sourceMapData = JSON.parse(file);
        }
        if (!sourceMapData) {
            return;
        }
        return {
            url: sourceMapUrl,
            map: sourceMapData,
        };
    }
    _fetchSourceMapUrl(source) {
        const file = this._fetchFileSync(source);
        if (!file) {
            return;
        }
        const reg = /(?:\/\/[@#][\s]*sourceMappingURL=([^\s'"]+)[\s]*$)|(?:\/\*[@#][\s]*sourceMappingURL=([^\s*'"]+)[\s]*(?:\*\/)[\s]*$)/mg;
        // Keep executing the search to find the *last* sourceMappingURL to avoid
        // picking up sourceMappingURLs from comments, strings, etc.
        let lastMatch;
        let match;
        while ((match = reg.exec(file))) {
            lastMatch = match;
        }
        if (!lastMatch) {
            return;
        }
        return lastMatch[1];
    }
    _fetchFileSync(url) {
        var _a, _b;
        const { href } = url;
        if (!(href in this._fileContentsCache)) {
            this._fileContentsCache[href] = (_a = this._doFetchFileSync(url)) !== null && _a !== void 0 ? _a : null;
        }
        return (_b = this._fileContentsCache[href]) !== null && _b !== void 0 ? _b : undefined;
    }
    _doFetchFileSync(url) {
        let path;
        try {
            path = url_1.fileURLToPath(url);
        }
        catch (err) {
            console.warn(`${url.href} is not a valid file URL. We can only fetch source map in file system.`);
            return;
        }
        return fs_extra_1.default.readFileSync(path, { encoding: 'utf8' });
    }
    _resolveUrl(url, base) {
        if (path_1.default.isAbsolute(url)) {
            try {
                return url_1.pathToFileURL(url);
            }
            catch (_a) { }
        }
        try {
            return new url_1.URL(url, base);
        }
        catch (_b) {
            return;
        }
    }
}
exports.SourceMapSupport = SourceMapSupport;
// Regex for detecting source maps
const reSourceMappingDataUrl = /^data:application\/json[^,]+base64,/;
function cloneCallSite(callSite) {
    const object = {};
    const names = Object.getOwnPropertyNames(Object.getPrototypeOf(callSite));
    names.forEach(function (name) {
        object[name] = /^(?:is|get)/.test(name) ? function () { return callSite[name].call(callSite); } : callSite[name];
    });
    return object;
}
function convertFileUrlToPath(url) {
    if (url.protocol === 'file:') {
        try {
            return url_1.fileURLToPath(url);
        }
        catch (_a) { }
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvc291cmNlLW1hcC1zdXBwb3J0L2luZGV4LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7OztBQUNBLDJDQUF1RjtBQUN2Riw2QkFBd0Q7QUFDeEQsd0RBQTBCO0FBQzFCLGdEQUFzQjtBQXVCdEI7O0dBRUc7QUFDSCxNQUFhLGdCQUFnQjtJQUE3QjtRQTRXWSxvQkFBZSxHQUEyQyxFQUFFLENBQUM7UUFDN0QsdUJBQWtCLEdBQWtDLEVBQUUsQ0FBQztRQUV2RCxxQkFBZ0IsR0FBRyxNQUFNLENBQUMsb0JBQW9CLENBQUMsQ0FBQztJQUM1RCxDQUFDO0lBL1dHLE9BQU87UUFDSCxJQUFJLElBQUksQ0FBQyx3QkFBd0IsRUFBRTtZQUMvQixPQUFPO1NBQ1Y7UUFDRCxJQUFJLENBQUMsd0JBQXdCLEdBQUcsS0FBSyxDQUFDLGlCQUFpQixDQUFDO1FBQ3hELEtBQUssQ0FBQyxpQkFBaUI7WUFDbkIsQ0FBQyxHQUFHLElBQW1DLEVBQUUsRUFBRSxDQUFDLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxHQUFHLElBQUksQ0FBQyxDQUFDO0lBQ3JGLENBQUM7SUFFRCxTQUFTO1FBQ0wsSUFBSSxDQUFDLElBQUksQ0FBQyx3QkFBd0IsRUFBRTtZQUNoQyxPQUFPO1NBQ1Y7UUFDRCxLQUFLLENBQUMsaUJBQWlCLEdBQUcsSUFBSSxDQUFDLHdCQUF3QixDQUFDO0lBQzVELENBQUM7SUFFRCxnQkFBZ0IsQ0FBQyxLQUFVO1FBQ3ZCLE9BQU8sSUFBSSxDQUFDLGdCQUFnQixJQUFJLEtBQUssQ0FBQztJQUMxQyxDQUFDO0lBRUQsZ0JBQWdCLENBQUMsS0FBVTtRQUN2QixPQUFPLEtBQUssQ0FBQyxJQUFJLENBQUMsZ0JBQWdCLENBQVUsQ0FBQztJQUNqRCxDQUFDO0lBRU8sa0JBQWtCLENBQUMsR0FBVSxFQUFFLFdBQThCO1FBQ2pFLElBQUksWUFBaUIsQ0FBQztRQUN0QixJQUFJLElBQUks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ckUsU0FBUyxhQUFhLENBQUMsUUFBeUI7SUFDNUMsTUFBTSxNQUFNLEdBQVEsRUFBRSxDQUFDO0lBQ3ZCLE1BQU0sS0FBSyxHQUFHLE1BQU0sQ0FBQyxtQkFBbUIsQ0FBQyxNQUFNLENBQUMsY0FBYyxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUM7SUFDekUsS0FBbUMsQ0FBQyxPQUFPLENBQUMsVUFBUyxJQUFJO1FBQ3RELE1BQU0sQ0FBQyxJQUFJLENBQUMsR0FBRyxhQUFhLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxjQUFhLE9BQU8sUUFBUSxDQUFDLElBQUksQ0FBQyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxDQUFDO0lBQ3BILENBQUMsQ0FBQyxDQUFDO0lBQ0gsT0FBTyxNQUFNLENBQUM7QUFDbEIsQ0FBQztBQUVELFNBQVMsb0JBQW9CLENBQUMsR0FBUTtJQUNsQyxJQUFJLEdBQUcsQ0FBQyxRQUFRLEtBQUssT0FBTyxFQUFFO1FBQzFCLElBQUk7WUFDQSxPQUFPLG1CQUFhLENBQUMsR0FBRyxDQUFDLENBQUM7U0FDN0I7UUFBQyxXQUFNLEdBQUc7S0FDZDtBQUNMLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJcbmltcG9ydCB7IE1hcHBlZFBvc2l0aW9uLCBQb3NpdGlvbiwgUmF3U291cmNlTWFwLCBTb3VyY2VNYXBDb25zdW1lciB9IGZyb20gJ3NvdXJjZS1tYXAnO1xuaW1wb3J0IHsgVVJMLCBmaWxlVVJMVG9QYXRoLCBwYXRoVG9GaWxlVVJMIH0gZnJvbSAndXJsJztcbmltcG9ydCBmcyBmcm9tICdmcy1leHRyYSc7XG5pbXBvcnQgcHMgZnJvbSAncGF0aCc7XG5cbi8qIGVzbGludC1kaXNhYmxlIGNvbnNpc3RlbnQtcmV0dXJuICovXG5cbnR5cGUgUHJlcGFyZVN0YWNrVHJhY2UgPSBOb25OdWxsYWJsZTxFcnJvckNvbnN0cnVjdG9yWydwcmVwYXJlU3RhY2tUcmFjZSddPjtcblxudHlwZSBTdGFjayA9IHN0cmluZztcblxudHlwZSBXcmFwcGVkQ2FsbFNpdGUgPSBOb2RlSlMuQ2FsbFNpdGU7XG5cbmludGVyZmFjZSBTb3VyY2VNYXBSZWNvcmQge1xuICAgIG1hcDogU291cmNlTWFwQ29uc3VtZXI7XG4gICAgdXJsOiBVUkw7XG59XG5cbi8qKlxuICogaHR0cHM6Ly9naXRodWIuY29tL2V2YW53L25vZGUtc291cmNlLW1hcC1zdXBwb3J0L3B1bGwvMjUzXG4gKi9cbmludGVyZmFjZSBTdGF0ZSB7XG4gICAgY3VycmVudDogTWFwcGVkUG9zaXRpb24gfCBudWxsO1xuICAgIG5leHQ6IE1hcHBlZFBvc2l0aW9uIHwgbnVsbDtcbn1cblxuLyoqXG4gKiDlj4LogIMgaHR0cHM6Ly9naXRodWIuY29tL2V2YW53L25vZGUtc291cmNlLW1hcC1zdXBwb3J0L2Jsb2IvbWFzdGVyL3NvdXJjZS1tYXAtc3VwcG9ydC5qc1xuICovXG5leHBvcnQgY2xhc3MgU291cmNlTWFwU3VwcG9ydCB7XG4gICAgaW5zdGFsbCgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3ZlbmRvclByZXBhcmVTdGFja1RyYWNlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fdmVuZG9yUHJlcGFyZVN0YWNrVHJhY2UgPSBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZTtcbiAgICAgICAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPVxuICAgICAgICAgICAgKC4uLmFyZ3M6IFBhcmFtZXRlcnM8UHJlcGFyZVN0YWNrVHJhY2U+KSA9PiB0aGlzLl9wcmVwYXJlU3RhY2tUcmFjZSguLi5hcmdzKTtcbiAgICB9XG5cbiAgICB1bmluc3RhbGwoKSB7XG4gICAgICAgIGlmICghdGhpcy5fdmVuZG9yUHJlcGFyZVN0YWNrVHJhY2UpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZSA9IHRoaXMuX3ZlbmRvclByZXBhcmVTdGFja1RyYWNlO1xuICAgIH1cblxuICAgIGhhc1N0YWNrUHJvcGVydHkodmFsdWU6IGFueSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbXlTdGFja1Byb3BlcnR5IGluIHZhbHVlO1xuICAgIH1cblxuICAgIGdldFN0YWNrUHJvcGVydHkodmFsdWU6IGFueSkge1xuICAgICAgICByZXR1cm4gdmFsdWVbdGhpcy5fbXlTdGFja1Byb3BlcnR5XSBhcyBTdGFjaztcbiAgICB9XG5cbiAgICBwcml2YXRlIF9wcmVwYXJlU3RhY2tUcmFjZShlcnI6IEVycm9yLCBzdGFja1RyYWNlczogTm9kZUpTLkNhbGxTaXRlW10pIHtcbiAgICAgICAgbGV0IHZlbmRvclJlc3VsdDogYW55O1xuICAgICAgICBpZiAodGhpcy5fdmVuZG9yUHJlcGFyZVN0YWNrVHJhY2UpIHtcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIHZlbmRvclJlc3VsdCA9IHRoaXMuX3ZlbmRvclByZXBhcmVTdGFja1RyYWNlLmFwcGx5KHVuZGVmaW5lZCwgYXJndW1lbnRzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZlbmRvclJlc3VsdCA9IHN0YWNrVHJhY2VzLm1hcChjYWxsU2l0ZSA9PiB0aGlzLl9jYWxsU2l0ZVRvU3RyaW5nKGNhbGxTaXRlKSkuam9pbignXFxuJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbXlSZXN1bHQgPSB0aGlzLl9wcmVwYXJlU3RhY2tUcmFjZVBvc3RWZW5kb3IoZXJyLCBzdGFja1RyYWNlcywgdmVuZG9yUmVzdWx0KTtcbiAgICAgICAgaWYgKG15UmVzdWx0KSB7XG4gICAgICAgICAgICByZXR1cm4gbXlSZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZlbmRvclJlc3VsdDtcbiAgICB9XG5cbiAgICBwcml2YXRlIF9wcmVwYXJlU3RhY2tUcmFjZVBvc3RWZW5kb3IoXG4gICAgICAgIGVycjogRXJyb3IsXG4gICAgICAgIHN0YWNrVHJhY2VzOiBOb2RlSlMuQ2FsbFNpdGVbXSxcbiAgICAgICAgX3ZlbmRvclJlc3VsdDogYW55LFxuICAgICk6IGFueSB7XG4gICAgICAgIGlmICh0eXBlb2YgZXJyICE9PSAnb2JqZWN0JyB8fCBlcnIgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNvbnN0IHdyYXBwZWRDYWxsU2l0ZXM6IFdyYXBwZWRDYWxsU2l0ZVtdID0gW107XG4gICAgICAgIC8vIGZvciAoY29uc3QgY2FsbFNpdGUgb2Ygc3RhY2tUcmFjZXMpIHtcbiAgICAgICAgLy8gICAgIGNvbnN0IHdyYXBwZWQgPSB0aGlzLl93cmFwQ2FsbFNpdGUoY2FsbFNpdGUpO1xuICAgICAgICAvLyAgICAgaWYgKHdyYXBwZWQpIHtcbiAgICAgICAgLy8gICAgICAgICB3cmFwcGVkQ2FsbFNpdGVzLnB1c2god3JhcHBlZCk7XG4gICAgICAgIC8vICAgICB9XG4gICAgICAgIC8vIH1cbiAgICAgICAgLy8gaWYgKHdyYXBwZWRDYWxsU2l0ZXMubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgIC8vICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXJyLCB0aGlzLl9teVN0YWNrUHJvcGVydHksIHtcbiAgICAgICAgLy8gICAgICAgICB2YWx1ZTogd3JhcHBlZENhbGxTaXRlcyxcbiAgICAgICAgLy8gICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgLy8gICAgIH0pO1xuICAgICAgICAvLyAgICAgcmV0dXJuIHRoaXMuX2Zvcm1hdFN0YWNrKGVyciwgd3JhcHBlZENhbGxTaXRlcyk7XG4gICAgICAgIC8vIH1cbiAgICAgICAgY29uc3Qgc3RhdGU6IFN0YXRlID0geyBjdXJyZW50OiBudWxsLCBuZXh0OiBudWxsIH07XG4gICAgICAgIGNvbnN0IHdyYXBwZWRDYWxsU2l0ZXMgPSBzdGFja1RyYWNlcy5tYXAoKGNhbGxTaXRlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB3cmFwcGVkID0gdGhpcy5fdHJ5V3JhcENhbGxTaXRlKGNhbGxTaXRlLCBzdGF0ZSkgPz8gY2FsbFNpdGU7XG4gICAgICAgICAgICBzdGF0ZS5uZXh0ID0gc3RhdGUuY3VycmVudDtcbiAgICAgICAgICAgIHJldHVybiB3cmFwcGVkO1xuICAgICAgICB9KTtcbiAgICAgICAgc3RhdGUuY3VycmVudCA9IHN0YXRlLm5leHQgPSBudWxsO1xuICAgICAgICByZXR1cm4gdGhpcy5fZm9ybWF0U3RhY2soZXJyLCB3cmFwcGVkQ2FsbFNpdGVzKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIF9mb3JtYXRTdGFjayhlcnI6IEVycm9yLCB3cmFwcGVkQ2FsbFNpdGVzOiBXcmFwcGVkQ2FsbFNpdGVbXSkge1xuICAgICAgICBjb25zdCBzdGFjayA9IHdyYXBwZWRDYWxsU2l0ZXMubWFwKGNhbGxTaXRlID0+IGBcXG4gICAgYXQgJHt0aGlzLl9jYWxsU2l0ZVRvU3RyaW5nKGNhbGxTaXRlKX1gKS5qb2luKCcnKTtcbiAgICAgICAgcmV0dXJuIGAke2Vyci5uYW1lID8/ICdFcnJvcid9OiAke2Vyci5tZXNzYWdlID8/ICcnfSR7c3RhY2t9YDtcbiAgICB9XG5cbiAgICBwcml2YXRlIF90cnlXcmFwQ2FsbFNpdGUoY2FsbFNpdGU6IE5vZGVKUy5DYWxsU2l0ZSwgc3RhdGU6IFN0YXRlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fd3JhcENhbGxTaXRlKGNhbGxTaXRlLCBzdGF0ZSk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgY29uc29sZS5kZWJ1ZyhlcnIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBfd3JhcENhbGxTaXRlKGNhbGxTaXRlOiBOb2RlSlMuQ2FsbFNpdGUsIHN0YXRlOiBTdGF0ZSk6IFdyYXBwZWRDYWxsU2l0ZSB8IHVuZGVmaW5lZCB7XG4gICAgICAgIHN0YXRlLmN1cnJlbnQgPSBudWxsO1xuXG4gICAgICAgIGlmIChjYWxsU2l0ZS5pc05hdGl2ZSgpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBNb3N0IGNhbGwgc2l0ZXMgd2lsbCByZXR1cm4gdGhlIHNvdXJjZSBmaWxlIGZyb20gZ2V0RmlsZU5hbWUoKSwgYnV0IGNvZGVcbiAgICAgICAgLy8gcGFzc2VkIHRvIGV2YWwoKSBlbmRpbmcgaW4gXCIvLyMgc291cmNlVVJMPS4uLlwiIHdpbGwgcmV0dXJuIHRoZSBzb3VyY2UgZmlsZVxuICAgICAgICAvLyBmcm9tIGdldFNjcmlwdE5hbWVPclNvdXJjZVVSTCgpIGluc3RlYWRcbiAgICAgICAgY29uc3Qgc291cmNlID0gY2FsbFNpdGUuZ2V0RmlsZU5hbWUoKSA/PyAoKGNhbGxTaXRlIGFzIGFueSkuZ2V0U2NyaXB0TmFtZU9yU291cmNlVVJMKCkgYXMgc3RyaW5nIHwgdW5kZWZpbmVkKTtcbiAgICAgICAgaWYgKHNvdXJjZSkge1xuICAgICAgICAgICAgY29uc3QgbGluZSA9IGNhbGxTaXRlLmdldExpbmVOdW1iZXIoKSE7XG4gICAgICAgICAgICBsZXQgY29sdW1uID0gY2FsbFNpdGUuZ2V0Q29sdW1uTnVtYmVyKCkhIC0gMTtcbiAgICAgICAgICAgIC8vIEZpeCBwb3NpdGlvbiBpbiBOb2RlIHdoZXJlIHNvbWUgKGludGVybmFsKSBjb2RlIGlzIHByZXBlbmRlZC5cbiAgICAgICAgICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZXZhbncvbm9kZS1zb3VyY2UtbWFwLXN1cHBvcnQvaXNzdWVzLzM2XG4gICAgICAgICAgICAvLyBIZWFkZXIgcmVtb3ZlZCBpbiBub2RlIGF0IF4xMC4xNiB8fCA+PTExLjExLjBcbiAgICAgICAgICAgIC8vIHYxMSBpcyBub3QgYW4gTFRTIGNhbmRpZGF0ZSwgd2UgY2FuIGp1c3QgdGVzdCB0aGUgb25lIHZlcnNpb24gd2l0aCBpdC5cbiAgICAgICAgICAgIC8vIFRlc3Qgbm9kZSB2ZXJzaW9ucyBmb3I6IDEwLjE2LTE5LCAxMC4yMCssIDEyLTE5LCAyMC05OSwgMTAwKywgb3IgMTEuMTFcbiAgICAgICAgICAgIGNvbnN0IG5vSGVhZGVyID0gL152KDEwXFwuMVs2LTldfDEwXFwuWzItOV1bMC05XXwxMFxcLlswLTldezMsfXwxWzItOV1cXGQqfFsyLTldXFxkfFxcZHszLH18MTFcXC4xMSkvO1xuICAgICAgICAgICAgY29uc3QgaGVhZGVyTGVuZ3RoID0gbm9IZWFkZXIudGVzdChwcm9jZXNzLnZlcnNpb24pID8gMCA6IDYyO1xuICAgICAgICAgICAgaWYgKGxpbmUgPT09IDEgJiYgY29sdW1uID4gaGVhZGVyTGVuZ3RoIC8qICYmICFpc0luQnJvd3NlcigpKi8gJiYgIWNhbGxTaXRlLmlzRXZhbCgpKSB7XG4gICAgICAgICAgICAgICAgY29sdW1uIC09IGhlYWRlckxlbmd0aDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgbWFwcGVkUG9zaXRpb24gPSB0aGlzLl9tYXBTb3VyY2VQb3NpdGlvbih7IHNvdXJjZSwgbGluZSwgY29sdW1uIH0pO1xuICAgICAgICAgICAgaWYgKG1hcHBlZFBvc2l0aW9uKSB7XG4gICAgICAgICAgICAgICAgc3RhdGUuY3VycmVudCA9IG1hcHBlZFBvc2l0aW9uO1xuICAgICAgICAgICAgICAgIGNvbnN0IHdyYXBwZWRDYWxsU2l0ZSA9IGNsb25lQ2FsbFNpdGUoY2FsbFNpdGUpO1xuICAgICAgICAgICAgICAgIHdyYXBwZWRDYWxsU2l0ZS5nZXRGaWxlTmFtZSA9ICgpID0+IG1hcHBlZFBvc2l0aW9uLnNvdXJjZTtcbiAgICAgICAgICAgICAgICB3cmFwcGVkQ2FsbFNpdGUuZ2V0TGluZU51bWJlciA9ICgpID0+IG1hcHBlZFBvc2l0aW9uLmxpbmU7XG4gICAgICAgICAgICAgICAgd3JhcHBlZENhbGxTaXRlLmdldENvbHVtbk51bWJlciA9ICgpID0+IG1hcHBlZFBvc2l0aW9uLmNvbHVtbiArIDE7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV4dE5hbWUgPSBzdGF0ZS5uZXh0Py5uYW1lO1xuICAgICAgICAgICAgICAgIGlmIChuZXh0TmFtZSkge1xuICAgICAgICAgICAgICAgICAgICB3cmFwcGVkQ2FsbFNpdGUuZ2V0RnVuY3Rpb25OYW1lID0gKCkgPT4gbmV4dE5hbWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB3cmFwcGVkQ2FsbFNpdGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoY2FsbFNpdGUuaXNFdmFsKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IG9yaWdpbiA9IGNhbGxTaXRlLmdldEV2YWxPcmlnaW4oKTtcbiAgICAgICAgICAgIGlmIChvcmlnaW4pIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9tYXBFdmFsT3JpZ2luKG9yaWdpbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIF9jYWxsU2l0ZVRvU3RyaW5nKGNhbGxTaXRlOiBXcmFwcGVkQ2FsbFNpdGUpIHtcbiAgICAgICAgbGV0IGZpbGVOYW1lO1xuICAgICAgICBsZXQgZmlsZUxvY2F0aW9uID0gXCJcIjtcbiAgICAgICAgaWYgKGNhbGxTaXRlLmlzTmF0aXZlKCkpIHtcbiAgICAgICAgICAgIGZpbGVMb2NhdGlvbiA9IFwibmF0aXZlXCI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmaWxlTmFtZSA9IGNhbGxTaXRlLmdldEZpbGVOYW1lKCk7XG4gICAgICAgICAgICBpZiAoIWZpbGVOYW1lICYmIGNhbGxTaXRlLmlzRXZhbCgpKSB7XG4gICAgICAgICAgICAgICAgZmlsZUxvY2F0aW9uID0gY2FsbFNpdGUuZ2V0RXZhbE9yaWdpbigpID8/ICcnO1xuICAgICAgICAgICAgICAgIGZpbGVMb2NhdGlvbiArPSBcIiwgXCI7ICAvLyBFeHBlY3Rpbmcgc291cmNlIHBvc2l0aW9uIHRvIGZvbGxvdy5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGZpbGVOYW1lKSB7XG4gICAgICAgICAgICAgICAgZmlsZUxvY2F0aW9uICs9IGZpbGVOYW1lO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBTb3VyY2UgY29kZSBkb2VzIG5vdCBvcmlnaW5hdGUgZnJvbSBhIGZpbGUgYW5kIGlzIG5vdCBuYXRpdmUsIGJ1dCB3ZVxuICAgICAgICAgICAgICAgIC8vIGNhbiBzdGlsbCBnZXQgdGhlIHNvdXJjZSBwb3NpdGlvbiBpbnNpZGUgdGhlIHNvdXJjZSBzdHJpbmcsIGUuZy4gaW5cbiAgICAgICAgICAgICAgICAvLyBhbiBldmFsIHN0cmluZy5cbiAgICAgICAgICAgICAgICBmaWxlTG9jYXRpb24gKz0gXCI8YW5vbnltb3VzPlwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbGluZU51bWJlciA9IGNhbGxTaXRlLmdldExpbmVOdW1iZXIoKTtcbiAgICAgICAgICAgIGlmIChsaW5lTnVtYmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZmlsZUxvY2F0aW9uICs9IFwiOlwiICsgbGluZU51bWJlcjtcbiAgICAgICAgICAgICAgICBjb25zdCBjb2x1bW5OdW1iZXIgPSBjYWxsU2l0ZS5nZXRDb2x1bW5OdW1iZXIoKTtcbiAgICAgICAgICAgICAgICBpZiAoY29sdW1uTnVtYmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpbGVMb2NhdGlvbiArPSBcIjpcIiArIGNvbHVtbk51bWJlcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgbGluZSA9IFwiXCI7XG4gICAgICAgIGNvbnN0IGZ1bmN0aW9uTmFtZSA9IGNhbGxTaXRlLmdldEZ1bmN0aW9uTmFtZSgpO1xuICAgICAgICBsZXQgYWRkU3VmZml4ID0gdHJ1ZTtcbiAgICAgICAgY29uc3QgaXNDb25zdHJ1Y3RvciA9IGNhbGxTaXRlLmlzQ29uc3RydWN0b3IoKTtcbiAgICAgICAgY29uc3QgaXNNZXRob2RDYWxsID0gIShjYWxsU2l0ZS5pc1RvcGxldmVsKCkgfHwgaXNDb25zdHJ1Y3Rvcik7XG4gICAgICAgIGlmIChpc01ldGhvZENhbGwpIHtcbiAgICAgICAgICAgIGxldCB0eXBlTmFtZSA9IGNhbGxTaXRlLmdldFR5cGVOYW1lKCk7XG4gICAgICAgICAgICAvLyBGaXhlcyBzaGltIHRvIGJlIGJhY2t3YXJkIGNvbXBhdGFibGUgd2l0aCBOb2RlIHYwIHRvIHY0XG4gICAgICAgICAgICBpZiAodHlwZU5hbWUgPT09IFwiW29iamVjdCBPYmplY3RdXCIpIHtcbiAgICAgICAgICAgICAgICB0eXBlTmFtZSA9IFwibnVsbFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbWV0aG9kTmFtZSA9IGNhbGxTaXRlLmdldE1ldGhvZE5hbWUoKTtcbiAgICAgICAgICAgIGlmIChmdW5jdGlvbk5hbWUpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZU5hbWUgJiYgZnVuY3Rpb25OYW1lLmluZGV4T2YodHlwZU5hbWUpICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGxpbmUgKz0gdHlwZU5hbWUgKyBcIi5cIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGluZSArPSBmdW5jdGlvbk5hbWU7XG4gICAgICAgICAgICAgICAgaWYgKG1ldGhvZE5hbWUgJiYgZnVuY3Rpb25OYW1lLmluZGV4T2YoXCIuXCIgKyBtZXRob2ROYW1lKSAhPT0gZnVuY3Rpb25OYW1lLmxlbmd0aCAtIG1ldGhvZE5hbWUubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICBsaW5lICs9IFwiIFthcyBcIiArIG1ldGhvZE5hbWUgKyBcIl1cIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGxpbmUgKz0gdHlwZU5hbWUgKyBcIi5cIiArIChtZXRob2ROYW1lIHx8IFwiPGFub255bW91cz5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoaXNDb25zdHJ1Y3Rvcikge1xuICAgICAgICAgICAgbGluZSArPSBcIm5ldyBcIiArIChmdW5jdGlvbk5hbWUgfHwgXCI8YW5vbnltb3VzPlwiKTtcbiAgICAgICAgfSBlbHNlIGlmIChmdW5jdGlvbk5hbWUpIHtcbiAgICAgICAgICAgIGxpbmUgKz0gZnVuY3Rpb25OYW1lO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGluZSArPSBmaWxlTG9jYXRpb247XG4gICAgICAgICAgICBhZGRTdWZmaXggPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYWRkU3VmZml4KSB7XG4gICAgICAgICAgICBsaW5lICs9IFwiIChcIiArIGZpbGVMb2NhdGlvbiArIFwiKVwiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsaW5lO1xuICAgIH1cblxuICAgIHByaXZhdGUgX21hcFNvdXJjZVBvc2l0aW9uKHBvc2l0aW9uOiBQb3NpdGlvbiAmIHsgc291cmNlOiBzdHJpbmcgfSk6IE1hcHBlZFBvc2l0aW9uIHwgdW5kZWZpbmVkIHtcbiAgICAgICAgY29uc3Qgc291cmNlTWFwUmVjb3JkID0gdGhpcy5fZ2V0U291cmNlTWFwKHBvc2l0aW9uLnNvdXJjZSk7XG4gICAgICAgIGlmICghc291cmNlTWFwUmVjb3JkPy5tYXAgfHxcbiAgICAgICAgICAgIHR5cGVvZiBzb3VyY2VNYXBSZWNvcmQubWFwLm9yaWdpbmFsUG9zaXRpb25Gb3IgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFJlc29sdmUgdGhlIHNvdXJjZSBVUkwgcmVsYXRpdmUgdG8gdGhlIFVSTCBvZiB0aGUgc291cmNlIG1hcC5cbiAgICAgICAgLy8gT25seSByZXR1cm4gdGhlIG9yaWdpbmFsIHBvc2l0aW9uIGlmIGEgbWF0Y2hpbmcgbGluZSB3YXMgZm91bmQuIElmIG5vXG4gICAgICAgIC8vIG1hdGNoaW5nIGxpbmUgaXMgZm91bmQgdGhlbiB3ZSByZXR1cm4gcG9zaXRpb24gaW5zdGVhZCwgd2hpY2ggd2lsbCBjYXVzZVxuICAgICAgICAvLyB0aGUgc3RhY2sgdHJhY2UgdG8gcHJpbnQgdGhlIHBhdGggYW5kIGxpbmUgZm9yIHRoZSBjb21waWxlZCBmaWxlLiBJdCBpc1xuICAgICAgICAvLyBiZXR0ZXIgdG8gZ2l2ZSBhIHByZWNpc2UgbG9jYXRpb24gaW4gdGhlIGNvbXBpbGVkIGZpbGUgdGhhbiBhIHZhZ3VlXG4gICAgICAgIC8vIGxvY2F0aW9uIGluIHRoZSBvcmlnaW5hbCBmaWxlLlxuICAgICAgICBjb25zdCBvcmlnaW5hbFBvc2l0aW9uID0gc291cmNlTWFwUmVjb3JkLm1hcC5vcmlnaW5hbFBvc2l0aW9uRm9yKHBvc2l0aW9uKTtcbiAgICAgICAgaWYgKG9yaWdpbmFsUG9zaXRpb24uc291cmNlID09PSBudWxsIHx8IG9yaWdpbmFsUG9zaXRpb24uc291cmNlID09PSAnbnVsbCcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHJlc29sdmVkID0gdGhpcy5fcmVzb2x2ZVVybChvcmlnaW5hbFBvc2l0aW9uLnNvdXJjZSwgc291cmNlTWFwUmVjb3JkLnVybCk7XG4gICAgICAgIGlmIChyZXNvbHZlZCkge1xuICAgICAgICAgICAgb3JpZ2luYWxQb3NpdGlvbi5zb3VyY2UgPSBjb252ZXJ0RmlsZVVybFRvUGF0aChyZXNvbHZlZCkgPz8gcmVzb2x2ZWQuaHJlZjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBvcmlnaW5hbFBvc2l0aW9uO1xuICAgIH1cblxuICAgIHByaXZhdGUgX21hcEV2YWxPcmlnaW4ob3JpZ2luOiBzdHJpbmcpIHtcblxuICAgIH1cblxuICAgIHByaXZhdGUgX2dldFNvdXJjZU1hcChzb3VyY2U6IHN0cmluZyk6IFNvdXJjZU1hcFJlY29yZCB8IHVuZGVmaW5lZCB7XG4gICAgICAgIGNvbnN0IHNvdXJjZVVybCA9IHRoaXMuX3Jlc29sdmVVcmwoc291cmNlKTtcbiAgICAgICAgaWYgKCFzb3VyY2VVcmwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IGhyZWYgfSA9IHNvdXJjZVVybDtcbiAgICAgICAgY29uc3Qgc291cmNlTWFwUmVjb3JkID0gdGhpcy5fc291cmNlTWFwQ2FjaGVbaHJlZl07XG4gICAgICAgIGlmIChzb3VyY2VNYXBSZWNvcmQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3QgZmV0Y2hlZFNvdXJjZU1hcCA9IHRoaXMuX2ZldGNoU291cmNlTWFwKHNvdXJjZVVybCk7XG4gICAgICAgICAgICBpZiAoIWZldGNoZWRTb3VyY2VNYXApIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zb3VyY2VNYXBDYWNoZVtocmVmXSA9IG51bGw7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNvdXJjZU1hcFVybCA9IGZldGNoZWRTb3VyY2VNYXAudXJsO1xuXG4gICAgICAgICAgICAgICAgLy8gTG9hZCBhbGwgc291cmNlcyBzdG9yZWQgaW5saW5lIHdpdGggdGhlIHNvdXJjZSBtYXAgaW50byB0aGUgZmlsZSBjYWNoZVxuICAgICAgICAgICAgICAgIC8vIHRvIHByZXRlbmQgbGlrZSB0aGV5IGFyZSBhbHJlYWR5IGxvYWRlZC4gVGhleSBtYXkgbm90IGV4aXN0IG9uIGRpc2suXG4gICAgICAgICAgICAgICAgaWYgKGZldGNoZWRTb3VyY2VNYXAubWFwLnNvdXJjZXNDb250ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGZldGNoZWRTb3VyY2VNYXAubWFwLnNvdXJjZXNDb250ZW50LmZvckVhY2goKHNvdXJjZUNvbnRlbnQsIGlTb3VyY2UpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzb3VyY2VDb250ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaW5saW5lU291cmNlID0gZmV0Y2hlZFNvdXJjZU1hcC5tYXAuc291cmNlc1tpU291cmNlXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpbmxpbmVTb3VyY2VVcmwgPSB0aGlzLl9yZXNvbHZlVXJsKGlubGluZVNvdXJjZSwgc291cmNlTWFwVXJsKT8uaHJlZiA/PyBpbmxpbmVTb3VyY2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZmlsZUNvbnRlbnRzQ2FjaGVbaW5saW5lU291cmNlVXJsXSA9IHNvdXJjZUNvbnRlbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNvbnN0IHNvdXJjZU1hcENvbnN1bWVyID0gbmV3IFNvdXJjZU1hcENvbnN1bWVyKGZldGNoZWRTb3VyY2VNYXAubWFwKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9zb3VyY2VNYXBDYWNoZVtocmVmXSA9IHsgbWFwOiBzb3VyY2VNYXBDb25zdW1lciwgdXJsOiBzb3VyY2VNYXBVcmwgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fc291cmNlTWFwQ2FjaGVbaHJlZl0gPz8gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIHByaXZhdGUgX3RyeUZldGNoU291cmNlTWFwKHNvdXJjZTogVVJMKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZmV0Y2hTb3VyY2VNYXAoc291cmNlKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBjb25zb2xlLmRlYnVnKGBGYWlsZWQgdG8gZmV0Y2ggc291cmNlIG1hcCBmb3IgJyR7c291cmNlfSc6ICR7ZXJyfWApO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBfZmV0Y2hTb3VyY2VNYXAoc291cmNlOiBVUkwpOiB1bmRlZmluZWQgfCB7IG1hcDogUmF3U291cmNlTWFwLCB1cmw6IFVSTCB9IHtcbiAgICAgICAgY29uc3Qgc291cmNlTWFwcGluZ1VyaSA9IHRoaXMuX2ZldGNoU291cmNlTWFwVXJsKHNvdXJjZSk7XG4gICAgICAgIGlmICghc291cmNlTWFwcGluZ1VyaSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUmVhZCB0aGUgY29udGVudHMgb2YgdGhlIHNvdXJjZSBtYXBcbiAgICAgICAgbGV0IHNvdXJjZU1hcERhdGE6IFJhd1NvdXJjZU1hcDtcbiAgICAgICAgbGV0IHNvdXJjZU1hcFVybDogVVJMO1xuICAgICAgICBpZiAocmVTb3VyY2VNYXBwaW5nRGF0YVVybC50ZXN0KHNvdXJjZU1hcHBpbmdVcmkpKSB7XG4gICAgICAgICAgICAvLyBTdXBwb3J0IHNvdXJjZSBtYXAgVVJMIGFzIGEgZGF0YSB1cmxcbiAgICAgICAgICAgIGNvbnN0IHJhd0RhdGEgPSBzb3VyY2VNYXBwaW5nVXJpLnNsaWNlKHNvdXJjZU1hcHBpbmdVcmkuaW5kZXhPZignLCcpICsgMSk7XG4gICAgICAgICAgICBzb3VyY2VNYXBEYXRhID0gSlNPTi5wYXJzZShCdWZmZXIuZnJvbShyYXdEYXRhLCBcImJhc2U2NFwiKS50b1N0cmluZygpKTtcbiAgICAgICAgICAgIHNvdXJjZU1hcFVybCA9IHNvdXJjZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIFN1cHBvcnQgc291cmNlIG1hcCBVUkxzIHJlbGF0aXZlIHRvIHRoZSBzb3VyY2UgVVJMXG4gICAgICAgICAgICBjb25zdCByZXNvbHZlZCA9IHRoaXMuX3Jlc29sdmVVcmwoc291cmNlTWFwcGluZ1VyaSwgc291cmNlKTtcbiAgICAgICAgICAgIGlmICghcmVzb2x2ZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzb3VyY2VNYXBVcmwgPSByZXNvbHZlZDtcbiAgICAgICAgICAgIGNvbnN0IGZpbGUgPSB0aGlzLl9mZXRjaEZpbGVTeW5jKHNvdXJjZU1hcFVybCk7XG4gICAgICAgICAgICBpZiAoIWZpbGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzb3VyY2VNYXBEYXRhID0gSlNPTi5wYXJzZShmaWxlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghc291cmNlTWFwRGF0YSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHVybDogc291cmNlTWFwVXJsLFxuICAgICAgICAgICAgbWFwOiBzb3VyY2VNYXBEYXRhLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIHByaXZhdGUgX2ZldGNoU291cmNlTWFwVXJsKHNvdXJjZTogVVJMKTogc3RyaW5nIHwgdW5kZWZpbmVkIHtcbiAgICAgICAgY29uc3QgZmlsZSA9IHRoaXMuX2ZldGNoRmlsZVN5bmMoc291cmNlKTtcbiAgICAgICAgaWYgKCFmaWxlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCByZWcgPSAvKD86XFwvXFwvW0AjXVtcXHNdKnNvdXJjZU1hcHBpbmdVUkw9KFteXFxzJ1wiXSspW1xcc10qJCl8KD86XFwvXFwqW0AjXVtcXHNdKnNvdXJjZU1hcHBpbmdVUkw9KFteXFxzKidcIl0rKVtcXHNdKig/OlxcKlxcLylbXFxzXSokKS9tZztcbiAgICAgICAgLy8gS2VlcCBleGVjdXRpbmcgdGhlIHNlYXJjaCB0byBmaW5kIHRoZSAqbGFzdCogc291cmNlTWFwcGluZ1VSTCB0byBhdm9pZFxuICAgICAgICAvLyBwaWNraW5nIHVwIHNvdXJjZU1hcHBpbmdVUkxzIGZyb20gY29tbWVudHMsIHN0cmluZ3MsIGV0Yy5cbiAgICAgICAgbGV0IGxhc3RNYXRjaDogUmVnRXhwTWF0Y2hBcnJheSB8IHVuZGVmaW5lZDtcbiAgICAgICAgbGV0IG1hdGNoOiBSZWdFeHBFeGVjQXJyYXkgfCBudWxsO1xuICAgICAgICB3aGlsZSAoKG1hdGNoID0gcmVnLmV4ZWMoZmlsZSkpKSB7XG4gICAgICAgICAgICBsYXN0TWF0Y2ggPSBtYXRjaDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghbGFzdE1hdGNoKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbGFzdE1hdGNoWzFdO1xuICAgIH1cblxuICAgIHByaXZhdGUgX2ZldGNoRmlsZVN5bmModXJsOiBVUkwpOiBzdHJpbmcgfCB1bmRlZmluZWQge1xuICAgICAgICBjb25zdCB7IGhyZWYgfSA9IHVybDtcbiAgICAgICAgaWYgKCEoaHJlZiBpbiB0aGlzLl9maWxlQ29udGVudHNDYWNoZSkpIHtcbiAgICAgICAgICAgIHRoaXMuX2ZpbGVDb250ZW50c0NhY2hlW2hyZWZdID0gdGhpcy5fZG9GZXRjaEZpbGVTeW5jKHVybCkgPz8gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fZmlsZUNvbnRlbnRzQ2FjaGVbaHJlZl0gPz8gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIHByaXZhdGUgX2RvRmV0Y2hGaWxlU3luYyh1cmw6IFVSTCk6IHN0cmluZyB8IHVuZGVmaW5lZCB7XG4gICAgICAgIGxldCBwYXRoOiBzdHJpbmc7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBwYXRoID0gZmlsZVVSTFRvUGF0aCh1cmwpO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgJHt1cmwuaHJlZn0gaXMgbm90IGEgdmFsaWQgZmlsZSBVUkwuIFdlIGNhbiBvbmx5IGZldGNoIHNvdXJjZSBtYXAgaW4gZmlsZSBzeXN0ZW0uYCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZzLnJlYWRGaWxlU3luYyhwYXRoLCB7IGVuY29kaW5nOiAndXRmOCcgfSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBfcmVzb2x2ZVVybCh1cmw6IHN0cmluZywgYmFzZT86IFVSTCk6IFVSTCB8IHVuZGVmaW5lZCB7XG4gICAgICAgIGlmIChwcy5pc0Fic29sdXRlKHVybCkpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhdGhUb0ZpbGVVUkwodXJsKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggeyB9XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgVVJMKHVybCwgYmFzZSk7XG4gICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBfc291cmNlTWFwQ2FjaGU6IFJlY29yZDxzdHJpbmcsIFNvdXJjZU1hcFJlY29yZCB8IG51bGw+ID0ge307XG4gICAgcHJpdmF0ZSBfZmlsZUNvbnRlbnRzQ2FjaGU6IFJlY29yZDxzdHJpbmcsIHN0cmluZyB8IG51bGw+ID0ge307XG4gICAgcHJpdmF0ZSBfdmVuZG9yUHJlcGFyZVN0YWNrVHJhY2U6IHVuZGVmaW5lZCB8IFByZXBhcmVTdGFja1RyYWNlO1xuICAgIHByaXZhdGUgX215U3RhY2tQcm9wZXJ0eSA9IFN5bWJvbCgnW1tDcmVhdG9yOjpzdGFja11dJyk7XG59XG5cbi8vIFJlZ2V4IGZvciBkZXRlY3Rpbmcgc291cmNlIG1hcHNcbmNvbnN0IHJlU291cmNlTWFwcGluZ0RhdGFVcmwgPSAvXmRhdGE6YXBwbGljYXRpb25cXC9qc29uW14sXStiYXNlNjQsLztcblxuZnVuY3Rpb24gY2xvbmVDYWxsU2l0ZShjYWxsU2l0ZTogTm9kZUpTLkNhbGxTaXRlKTogTm9kZUpTLkNhbGxTaXRlIHtcbiAgICBjb25zdCBvYmplY3Q6IGFueSA9IHt9O1xuICAgIGNvbnN0IG5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoT2JqZWN0LmdldFByb3RvdHlwZU9mKGNhbGxTaXRlKSk7XG4gICAgKG5hbWVzIGFzIChrZXlvZiBOb2RlSlMuQ2FsbFNpdGUpW10pLmZvckVhY2goZnVuY3Rpb24obmFtZSkge1xuICAgICAgICBvYmplY3RbbmFtZV0gPSAvXig/OmlzfGdldCkvLnRlc3QobmFtZSkgPyBmdW5jdGlvbigpIHsgcmV0dXJuIGNhbGxTaXRlW25hbWVdLmNhbGwoY2FsbFNpdGUpOyB9IDogY2FsbFNpdGVbbmFtZV07XG4gICAgfSk7XG4gICAgcmV0dXJuIG9iamVjdDtcbn1cblxuZnVuY3Rpb24gY29udmVydEZpbGVVcmxUb1BhdGgodXJsOiBVUkwpIHtcbiAgICBpZiAodXJsLnByb3RvY29sID09PSAnZmlsZTonKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gZmlsZVVSTFRvUGF0aCh1cmwpO1xuICAgICAgICB9IGNhdGNoIHsgfVxuICAgIH1cbn1cbiJdfQ==