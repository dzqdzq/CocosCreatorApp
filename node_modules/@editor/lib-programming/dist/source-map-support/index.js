"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SourceMapSupport = void 0;
const source_map_1 = require("source-map");
const url_1 = require("url");
const fs_extra_1 = __importDefault(require("fs-extra"));
const path_1 = __importDefault(require("path"));
/**
 * 参考 https://github.com/evanw/node-source-map-support/blob/master/source-map-support.js
 */
class SourceMapSupport {
    constructor() {
        this._sourceMapCache = {};
        this._fileContentsCache = {};
        this._myStackProperty = Symbol('[[Creator::stack]]');
    }
    install() {
        if (this._vendorPrepareStackTrace) {
            return;
        }
        this._vendorPrepareStackTrace = Error.prepareStackTrace;
        Error.prepareStackTrace =
            (...args) => this._prepareStackTrace(...args);
    }
    uninstall() {
        if (!this._vendorPrepareStackTrace) {
            return;
        }
        Error.prepareStackTrace = this._vendorPrepareStackTrace;
    }
    hasStackProperty(value) {
        return this._myStackProperty in value;
    }
    getStackProperty(value) {
        return value[this._myStackProperty];
    }
    _prepareStackTrace(err, stackTraces) {
        let vendorResult;
        if (this._vendorPrepareStackTrace) {
            // @ts-ignore
            vendorResult = this._vendorPrepareStackTrace.apply(undefined, arguments);
        }
        else {
            vendorResult = stackTraces.map(callSite => this._callSiteToString(callSite)).join('\n');
        }
        const myResult = this._prepareStackTracePostVendor(err, stackTraces, vendorResult);
        if (myResult) {
            return myResult;
        }
        return vendorResult;
    }
    _prepareStackTracePostVendor(err, stackTraces, _vendorResult) {
        if (typeof err !== 'object' || err === null) {
            return;
        }
        // const wrappedCallSites: WrappedCallSite[] = [];
        // for (const callSite of stackTraces) {
        //     const wrapped = this._wrapCallSite(callSite);
        //     if (wrapped) {
        //         wrappedCallSites.push(wrapped);
        //     }
        // }
        // if (wrappedCallSites.length !== 0) {
        //     Object.defineProperty(err, this._myStackProperty, {
        //         value: wrappedCallSites,
        //         enumerable: false,
        //     });
        //     return this._formatStack(err, wrappedCallSites);
        // }
        const state = { current: null, next: null };
        const wrappedCallSites = stackTraces.map((callSite) => {
            var _a;
            const wrapped = (_a = this._tryWrapCallSite(callSite, state)) !== null && _a !== void 0 ? _a : callSite;
            state.next = state.current;
            return wrapped;
        });
        state.current = state.next = null;
        return this._formatStack(err, wrappedCallSites);
    }
    _formatStack(err, wrappedCallSites) {
        var _a, _b;
        const stack = wrappedCallSites.map(callSite => `\n    at ${this._callSiteToString(callSite)}`).join('');
        return `${(_a = err.name) !== null && _a !== void 0 ? _a : 'Error'}: ${(_b = err.message) !== null && _b !== void 0 ? _b : ''}${stack}`;
    }
    _tryWrapCallSite(callSite, state) {
        try {
            return this._wrapCallSite(callSite, state);
        }
        catch (err) {
            console.debug(err);
            return;
        }
    }
    _wrapCallSite(callSite, state) {
        var _a, _b;
        state.current = null;
        if (callSite.isNative()) {
            return;
        }
        // Most call sites will return the source file from getFileName(), but code
        // passed to eval() ending in "//# sourceURL=..." will return the source file
        // from getScriptNameOrSourceURL() instead
        const source = (_a = callSite.getFileName()) !== null && _a !== void 0 ? _a : callSite.getScriptNameOrSourceURL();
        if (source) {
            const line = callSite.getLineNumber();
            let column = callSite.getColumnNumber() - 1;
            // Fix position in Node where some (internal) code is prepended.
            // See https://github.com/evanw/node-source-map-support/issues/36
            // Header removed in node at ^10.16 || >=11.11.0
            // v11 is not an LTS candidate, we can just test the one version with it.
            // Test node versions for: 10.16-19, 10.20+, 12-19, 20-99, 100+, or 11.11
            const noHeader = /^v(10\.1[6-9]|10\.[2-9][0-9]|10\.[0-9]{3,}|1[2-9]\d*|[2-9]\d|\d{3,}|11\.11)/;
            const headerLength = noHeader.test(process.version) ? 0 : 62;
            if (line === 1 && column > headerLength /* && !isInBrowser()*/ && !callSite.isEval()) {
                column -= headerLength;
            }
            const mappedPosition = this._mapSourcePosition({ source, line, column });
            if (mappedPosition) {
                state.current = mappedPosition;
                const wrappedCallSite = cloneCallSite(callSite);
                wrappedCallSite.getFileName = () => mappedPosition.source;
                wrappedCallSite.getLineNumber = () => mappedPosition.line;
                wrappedCallSite.getColumnNumber = () => mappedPosition.column + 1;
                const nextName = (_b = state.next) === null || _b === void 0 ? void 0 : _b.name;
                if (nextName) {
                    wrappedCallSite.getFunctionName = () => nextName;
                }
                return wrappedCallSite;
            }
        }
        else if (callSite.isEval()) {
            const origin = callSite.getEvalOrigin();
            if (origin) {
                this._mapEvalOrigin(origin);
            }
        }
    }
    _callSiteToString(callSite) {
        var _a;
        let fileName;
        let fileLocation = "";
        if (callSite.isNative()) {
            fileLocation = "native";
        }
        else {
            fileName = callSite.getFileName();
            if (!fileName && callSite.isEval()) {
                fileLocation = (_a = callSite.getEvalOrigin()) !== null && _a !== void 0 ? _a : '';
                fileLocation += ", "; // Expecting source position to follow.
            }
            if (fileName) {
                fileLocation += fileName;
            }
            else {
                // Source code does not originate from a file and is not native, but we
                // can still get the source position inside the source string, e.g. in
                // an eval string.
                fileLocation += "<anonymous>";
            }
            const lineNumber = callSite.getLineNumber();
            if (lineNumber !== null) {
                fileLocation += ":" + lineNumber;
                const columnNumber = callSite.getColumnNumber();
                if (columnNumber) {
                    fileLocation += ":" + columnNumber;
                }
            }
        }
        let line = "";
        const functionName = callSite.getFunctionName();
        let addSuffix = true;
        const isConstructor = callSite.isConstructor();
        const isMethodCall = !(callSite.isToplevel() || isConstructor);
        if (isMethodCall) {
            let typeName = callSite.getTypeName();
            // Fixes shim to be backward compatable with Node v0 to v4
            if (typeName === "[object Object]") {
                typeName = "null";
            }
            const methodName = callSite.getMethodName();
            if (functionName) {
                if (typeName && functionName.indexOf(typeName) !== 0) {
                    line += typeName + ".";
                }
                line += functionName;
                if (methodName && functionName.indexOf("." + methodName) !== functionName.length - methodName.length - 1) {
                    line += " [as " + methodName + "]";
                }
            }
            else {
                line += typeName + "." + (methodName || "<anonymous>");
            }
        }
        else if (isConstructor) {
            line += "new " + (functionName || "<anonymous>");
        }
        else if (functionName) {
            line += functionName;
        }
        else {
            line += fileLocation;
            addSuffix = false;
        }
        if (addSuffix) {
            line += " (" + fileLocation + ")";
        }
        return line;
    }
    _mapSourcePosition(position) {
        var _a;
        const sourceMapRecord = this._getSourceMap(position.source);
        if (!(sourceMapRecord === null || sourceMapRecord === void 0 ? void 0 : sourceMapRecord.map) ||
            typeof sourceMapRecord.map.originalPositionFor !== 'function') {
            return;
        }
        // Resolve the source URL relative to the URL of the source map.
        // Only return the original position if a matching line was found. If no
        // matching line is found then we return position instead, which will cause
        // the stack trace to print the path and line for the compiled file. It is
        // better to give a precise location in the compiled file than a vague
        // location in the original file.
        const originalPosition = sourceMapRecord.map.originalPositionFor(position);
        if (originalPosition.source === null || originalPosition.source === 'null') {
            return;
        }
        const resolved = this._resolveUrl(originalPosition.source, sourceMapRecord.url);
        if (resolved) {
            originalPosition.source = (_a = convertFileUrlToPath(resolved)) !== null && _a !== void 0 ? _a : resolved.href;
        }
        return originalPosition;
    }
    _mapEvalOrigin(origin) {
    }
    _getSourceMap(source) {
        var _a;
        const sourceUrl = this._resolveUrl(source);
        if (!sourceUrl) {
            return;
        }
        const { href } = sourceUrl;
        const sourceMapRecord = this._sourceMapCache[href];
        if (sourceMapRecord === undefined) {
            const fetchedSourceMap = this._fetchSourceMap(sourceUrl);
            if (!fetchedSourceMap) {
                this._sourceMapCache[href] = null;
            }
            else {
                const sourceMapUrl = fetchedSourceMap.url;
                // Load all sources stored inline with the source map into the file cache
                // to pretend like they are already loaded. They may not exist on disk.
                if (fetchedSourceMap.map.sourcesContent) {
                    fetchedSourceMap.map.sourcesContent.forEach((sourceContent, iSource) => {
                        var _a, _b;
                        if (sourceContent) {
                            const inlineSource = fetchedSourceMap.map.sources[iSource];
                            const inlineSourceUrl = (_b = (_a = this._resolveUrl(inlineSource, sourceMapUrl)) === null || _a === void 0 ? void 0 : _a.href) !== null && _b !== void 0 ? _b : inlineSource;
                            this._fileContentsCache[inlineSourceUrl] = sourceContent;
                        }
                    });
                }
                const sourceMapConsumer = new source_map_1.SourceMapConsumer(fetchedSourceMap.map);
                this._sourceMapCache[href] = { map: sourceMapConsumer, url: sourceMapUrl };
            }
        }
        return (_a = this._sourceMapCache[href]) !== null && _a !== void 0 ? _a : undefined;
    }
    _tryFetchSourceMap(source) {
        try {
            return this._fetchSourceMap(source);
        }
        catch (err) {
            console.debug(`Failed to fetch source map for '${source}': ${err}`);
            return;
        }
    }
    _fetchSourceMap(source) {
        const sourceMappingUri = this._fetchSourceMapUrl(source);
        if (!sourceMappingUri) {
            return;
        }
        // Read the contents of the source map
        let sourceMapData;
        let sourceMapUrl;
        if (reSourceMappingDataUrl.test(sourceMappingUri)) {
            // Support source map URL as a data url
            const rawData = sourceMappingUri.slice(sourceMappingUri.indexOf(',') + 1);
            sourceMapData = JSON.parse(Buffer.from(rawData, "base64").toString());
            sourceMapUrl = source;
        }
        else {
            // Support source map URLs relative to the source URL
            const resolved = this._resolveUrl(sourceMappingUri, source);
            if (!resolved) {
                return;
            }
            sourceMapUrl = resolved;
            const file = this._fetchFileSync(sourceMapUrl);
            if (!file) {
                return;
            }
            sourceMapData = JSON.parse(file);
        }
        if (!sourceMapData) {
            return;
        }
        return {
            url: sourceMapUrl,
            map: sourceMapData,
        };
    }
    _fetchSourceMapUrl(source) {
        const file = this._fetchFileSync(source);
        if (!file) {
            return;
        }
        const reg = /(?:\/\/[@#][\s]*sourceMappingURL=([^\s'"]+)[\s]*$)|(?:\/\*[@#][\s]*sourceMappingURL=([^\s*'"]+)[\s]*(?:\*\/)[\s]*$)/mg;
        // Keep executing the search to find the *last* sourceMappingURL to avoid
        // picking up sourceMappingURLs from comments, strings, etc.
        let lastMatch;
        let match;
        while ((match = reg.exec(file))) {
            lastMatch = match;
        }
        if (!lastMatch) {
            return;
        }
        return lastMatch[1];
    }
    _fetchFileSync(url) {
        var _a, _b;
        const { href } = url;
        if (!(href in this._fileContentsCache)) {
            this._fileContentsCache[href] = (_a = this._doFetchFileSync(url)) !== null && _a !== void 0 ? _a : null;
        }
        return (_b = this._fileContentsCache[href]) !== null && _b !== void 0 ? _b : undefined;
    }
    _doFetchFileSync(url) {
        let path;
        try {
            path = url_1.fileURLToPath(url);
        }
        catch (err) {
            console.warn(`${url.href} is not a valid file URL. We can only fetch source map in file system.`);
            return;
        }
        return fs_extra_1.default.readFileSync(path, { encoding: 'utf8' });
    }
    _resolveUrl(url, base) {
        if (path_1.default.isAbsolute(url)) {
            try {
                return url_1.pathToFileURL(url);
            }
            catch (_a) { }
        }
        try {
            return new url_1.URL(url, base);
        }
        catch (_b) {
            return;
        }
    }
}
exports.SourceMapSupport = SourceMapSupport;
// Regex for detecting source maps
const reSourceMappingDataUrl = /^data:application\/json[^,]+base64,/;
function cloneCallSite(callSite) {
    const object = {};
    const names = Object.getOwnPropertyNames(Object.getPrototypeOf(callSite));
    names.forEach(function (name) {
        object[name] = /^(?:is|get)/.test(name) ? function () { return callSite[name].call(callSite); } : callSite[name];
    });
    return object;
}
function convertFileUrlToPath(url) {
    if (url.protocol === 'file:') {
        try {
            return url_1.fileURLToPath(url);
        }
        catch (_a) { }
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvc291cmNlLW1hcC1zdXBwb3J0L2luZGV4LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7OztBQUNBLDJDQUF1RjtBQUN2Riw2QkFBd0Q7QUFDeEQsd0RBQTBCO0FBQzFCLGdEQUFzQjtBQXVCdEI7O0dBRUc7QUFDSCxNQUFhLGdCQUFnQjtJQUE3QjtRQTRXWSxvQkFBZSxHQUEyQyxFQUFFLENBQUM7UUFDN0QsdUJBQWtCLEdBQWtDLEVBQUUsQ0FBQztRQUV2RCxxQkFBZ0IsR0FBRyxNQUFNLENBQUMsb0JBQW9CLENBQUMsQ0FBQztJQUM1RCxDQUFDO0lBL1dHLE9BQU87UUFDSCxJQUFJLElBQUksQ0FBQyx3QkFBd0IsRUFBRTtZQUMvQixPQUFPO1NBQ1Y7UUFDRCxJQUFJLENBQUMsd0JBQXdCLEdBQUcsS0FBSyxDQUFDLGlCQUFpQixDQUFDO1FBQ3hELEtBQUssQ0FBQyxpQkFBaUI7WUFDbkIsQ0FBQyxHQUFHLElBQW1DLEVBQUUsRUFBRSxDQUFDLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxHQUFHLElBQUksQ0FBQyxDQUFDO0lBQ3JGLENBQUM7SUFFRCxTQUFTO1FBQ0wsSUFBSSxDQUFDLElBQUksQ0FBQyx3QkFBd0IsRUFBRTtZQUNoQyxPQUFPO1NBQ1Y7UUFDRCxLQUFLLENBQUMsaUJBQWlCLEdBQUcsSUFBSSxDQUFDLHdCQUF3QixDQUFDO0lBQzVELENBQUM7SUFFRCxnQkFBZ0IsQ0FBQyxLQUFVO1FBQ3ZCLE9BQU8sSUFBSSxDQUFDLGdCQUFnQixJQUFJLEtBQUssQ0FBQztJQUMxQyxDQUFDO0lBRUQsZ0JBQWdCLENBQUMsS0FBVTtRQUN2QixPQUFPLEtBQUssQ0FBQyxJQUFJLENBQUMsZ0JBQWdCLENBQVUsQ0FBQztJQUNqRCxDQUFDO0lBRU8sa0JBQWtCLENBQUMsR0FBVSxFQUFFLFdBQThCO1FBQ2pFLElBQUksWUFBaUIsQ0FBQztRQUN0QixJQUFJLElBQUks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ckUsU0FBUyxhQUFhLENBQUMsUUFBeUI7SUFDNUMsTUFBTSxNQUFNLEdBQVEsRUFBRSxDQUFDO0lBQ3ZCLE1BQU0sS0FBSyxHQUFHLE1BQU0sQ0FBQyxtQkFBbUIsQ0FBQyxNQUFNLENBQUMsY0FBYyxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUM7SUFDekUsS0FBbUMsQ0FBQyxPQUFPLENBQUMsVUFBUyxJQUFJO1FBQ3RELE1BQU0sQ0FBQyxJQUFJLENBQUMsR0FBRyxhQUFhLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxjQUFhLE9BQU8sUUFBUSxDQUFDLElBQUksQ0FBQyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxDQUFDO0lBQ3BILENBQUMsQ0FBQyxDQUFDO0lBQ0gsT0FBTyxNQUFNLENBQUM7QUFDbEIsQ0FBQztBQUVELFNBQVMsb0JBQW9CLENBQUMsR0FBUTtJQUNsQyxJQUFJLEdBQUcsQ0FBQyxRQUFRLEtBQUssT0FBTyxFQUFFO1FBQzFCLElBQUk7WUFDQSxPQUFPLG1CQUFhLENBQUMsR0FBRyxDQUFDLENBQUM7U0FDN0I7UUFBQyxXQUFNLEdBQUc7S0FDZDtBQUNMLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJcclxuaW1wb3J0IHsgTWFwcGVkUG9zaXRpb24sIFBvc2l0aW9uLCBSYXdTb3VyY2VNYXAsIFNvdXJjZU1hcENvbnN1bWVyIH0gZnJvbSAnc291cmNlLW1hcCc7XHJcbmltcG9ydCB7IFVSTCwgZmlsZVVSTFRvUGF0aCwgcGF0aFRvRmlsZVVSTCB9IGZyb20gJ3VybCc7XHJcbmltcG9ydCBmcyBmcm9tICdmcy1leHRyYSc7XHJcbmltcG9ydCBwcyBmcm9tICdwYXRoJztcclxuXHJcbi8qIGVzbGludC1kaXNhYmxlIGNvbnNpc3RlbnQtcmV0dXJuICovXHJcblxyXG50eXBlIFByZXBhcmVTdGFja1RyYWNlID0gTm9uTnVsbGFibGU8RXJyb3JDb25zdHJ1Y3RvclsncHJlcGFyZVN0YWNrVHJhY2UnXT47XHJcblxyXG50eXBlIFN0YWNrID0gc3RyaW5nO1xyXG5cclxudHlwZSBXcmFwcGVkQ2FsbFNpdGUgPSBOb2RlSlMuQ2FsbFNpdGU7XHJcblxyXG5pbnRlcmZhY2UgU291cmNlTWFwUmVjb3JkIHtcclxuICAgIG1hcDogU291cmNlTWFwQ29uc3VtZXI7XHJcbiAgICB1cmw6IFVSTDtcclxufVxyXG5cclxuLyoqXHJcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9ldmFudy9ub2RlLXNvdXJjZS1tYXAtc3VwcG9ydC9wdWxsLzI1M1xyXG4gKi9cclxuaW50ZXJmYWNlIFN0YXRlIHtcclxuICAgIGN1cnJlbnQ6IE1hcHBlZFBvc2l0aW9uIHwgbnVsbDtcclxuICAgIG5leHQ6IE1hcHBlZFBvc2l0aW9uIHwgbnVsbDtcclxufVxyXG5cclxuLyoqXHJcbiAqIOWPguiAgyBodHRwczovL2dpdGh1Yi5jb20vZXZhbncvbm9kZS1zb3VyY2UtbWFwLXN1cHBvcnQvYmxvYi9tYXN0ZXIvc291cmNlLW1hcC1zdXBwb3J0LmpzXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgU291cmNlTWFwU3VwcG9ydCB7XHJcbiAgICBpbnN0YWxsKCkge1xyXG4gICAgICAgIGlmICh0aGlzLl92ZW5kb3JQcmVwYXJlU3RhY2tUcmFjZSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX3ZlbmRvclByZXBhcmVTdGFja1RyYWNlID0gRXJyb3IucHJlcGFyZVN0YWNrVHJhY2U7XHJcbiAgICAgICAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPVxyXG4gICAgICAgICAgICAoLi4uYXJnczogUGFyYW1ldGVyczxQcmVwYXJlU3RhY2tUcmFjZT4pID0+IHRoaXMuX3ByZXBhcmVTdGFja1RyYWNlKC4uLmFyZ3MpO1xyXG4gICAgfVxyXG5cclxuICAgIHVuaW5zdGFsbCgpIHtcclxuICAgICAgICBpZiAoIXRoaXMuX3ZlbmRvclByZXBhcmVTdGFja1RyYWNlKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSB0aGlzLl92ZW5kb3JQcmVwYXJlU3RhY2tUcmFjZTtcclxuICAgIH1cclxuXHJcbiAgICBoYXNTdGFja1Byb3BlcnR5KHZhbHVlOiBhbnkpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fbXlTdGFja1Byb3BlcnR5IGluIHZhbHVlO1xyXG4gICAgfVxyXG5cclxuICAgIGdldFN0YWNrUHJvcGVydHkodmFsdWU6IGFueSkge1xyXG4gICAgICAgIHJldHVybiB2YWx1ZVt0aGlzLl9teVN0YWNrUHJvcGVydHldIGFzIFN0YWNrO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgX3ByZXBhcmVTdGFja1RyYWNlKGVycjogRXJyb3IsIHN0YWNrVHJhY2VzOiBOb2RlSlMuQ2FsbFNpdGVbXSkge1xyXG4gICAgICAgIGxldCB2ZW5kb3JSZXN1bHQ6IGFueTtcclxuICAgICAgICBpZiAodGhpcy5fdmVuZG9yUHJlcGFyZVN0YWNrVHJhY2UpIHtcclxuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxyXG4gICAgICAgICAgICB2ZW5kb3JSZXN1bHQgPSB0aGlzLl92ZW5kb3JQcmVwYXJlU3RhY2tUcmFjZS5hcHBseSh1bmRlZmluZWQsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdmVuZG9yUmVzdWx0ID0gc3RhY2tUcmFjZXMubWFwKGNhbGxTaXRlID0+IHRoaXMuX2NhbGxTaXRlVG9TdHJpbmcoY2FsbFNpdGUpKS5qb2luKCdcXG4nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgbXlSZXN1bHQgPSB0aGlzLl9wcmVwYXJlU3RhY2tUcmFjZVBvc3RWZW5kb3IoZXJyLCBzdGFja1RyYWNlcywgdmVuZG9yUmVzdWx0KTtcclxuICAgICAgICBpZiAobXlSZXN1bHQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG15UmVzdWx0O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdmVuZG9yUmVzdWx0O1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgX3ByZXBhcmVTdGFja1RyYWNlUG9zdFZlbmRvcihcclxuICAgICAgICBlcnI6IEVycm9yLFxyXG4gICAgICAgIHN0YWNrVHJhY2VzOiBOb2RlSlMuQ2FsbFNpdGVbXSxcclxuICAgICAgICBfdmVuZG9yUmVzdWx0OiBhbnksXHJcbiAgICApOiBhbnkge1xyXG4gICAgICAgIGlmICh0eXBlb2YgZXJyICE9PSAnb2JqZWN0JyB8fCBlcnIgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gY29uc3Qgd3JhcHBlZENhbGxTaXRlczogV3JhcHBlZENhbGxTaXRlW10gPSBbXTtcclxuICAgICAgICAvLyBmb3IgKGNvbnN0IGNhbGxTaXRlIG9mIHN0YWNrVHJhY2VzKSB7XHJcbiAgICAgICAgLy8gICAgIGNvbnN0IHdyYXBwZWQgPSB0aGlzLl93cmFwQ2FsbFNpdGUoY2FsbFNpdGUpO1xyXG4gICAgICAgIC8vICAgICBpZiAod3JhcHBlZCkge1xyXG4gICAgICAgIC8vICAgICAgICAgd3JhcHBlZENhbGxTaXRlcy5wdXNoKHdyYXBwZWQpO1xyXG4gICAgICAgIC8vICAgICB9XHJcbiAgICAgICAgLy8gfVxyXG4gICAgICAgIC8vIGlmICh3cmFwcGVkQ2FsbFNpdGVzLmxlbmd0aCAhPT0gMCkge1xyXG4gICAgICAgIC8vICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXJyLCB0aGlzLl9teVN0YWNrUHJvcGVydHksIHtcclxuICAgICAgICAvLyAgICAgICAgIHZhbHVlOiB3cmFwcGVkQ2FsbFNpdGVzLFxyXG4gICAgICAgIC8vICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXHJcbiAgICAgICAgLy8gICAgIH0pO1xyXG4gICAgICAgIC8vICAgICByZXR1cm4gdGhpcy5fZm9ybWF0U3RhY2soZXJyLCB3cmFwcGVkQ2FsbFNpdGVzKTtcclxuICAgICAgICAvLyB9XHJcbiAgICAgICAgY29uc3Qgc3RhdGU6IFN0YXRlID0geyBjdXJyZW50OiBudWxsLCBuZXh0OiBudWxsIH07XHJcbiAgICAgICAgY29uc3Qgd3JhcHBlZENhbGxTaXRlcyA9IHN0YWNrVHJhY2VzLm1hcCgoY2FsbFNpdGUpID0+IHtcclxuICAgICAgICAgICAgY29uc3Qgd3JhcHBlZCA9IHRoaXMuX3RyeVdyYXBDYWxsU2l0ZShjYWxsU2l0ZSwgc3RhdGUpID8/IGNhbGxTaXRlO1xyXG4gICAgICAgICAgICBzdGF0ZS5uZXh0ID0gc3RhdGUuY3VycmVudDtcclxuICAgICAgICAgICAgcmV0dXJuIHdyYXBwZWQ7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgc3RhdGUuY3VycmVudCA9IHN0YXRlLm5leHQgPSBudWxsO1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9mb3JtYXRTdGFjayhlcnIsIHdyYXBwZWRDYWxsU2l0ZXMpO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgX2Zvcm1hdFN0YWNrKGVycjogRXJyb3IsIHdyYXBwZWRDYWxsU2l0ZXM6IFdyYXBwZWRDYWxsU2l0ZVtdKSB7XHJcbiAgICAgICAgY29uc3Qgc3RhY2sgPSB3cmFwcGVkQ2FsbFNpdGVzLm1hcChjYWxsU2l0ZSA9PiBgXFxuICAgIGF0ICR7dGhpcy5fY2FsbFNpdGVUb1N0cmluZyhjYWxsU2l0ZSl9YCkuam9pbignJyk7XHJcbiAgICAgICAgcmV0dXJuIGAke2Vyci5uYW1lID8/ICdFcnJvcid9OiAke2Vyci5tZXNzYWdlID8/ICcnfSR7c3RhY2t9YDtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIF90cnlXcmFwQ2FsbFNpdGUoY2FsbFNpdGU6IE5vZGVKUy5DYWxsU2l0ZSwgc3RhdGU6IFN0YXRlKSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dyYXBDYWxsU2l0ZShjYWxsU2l0ZSwgc3RhdGUpO1xyXG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xyXG4gICAgICAgICAgICBjb25zb2xlLmRlYnVnKGVycik7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBfd3JhcENhbGxTaXRlKGNhbGxTaXRlOiBOb2RlSlMuQ2FsbFNpdGUsIHN0YXRlOiBTdGF0ZSk6IFdyYXBwZWRDYWxsU2l0ZSB8IHVuZGVmaW5lZCB7XHJcbiAgICAgICAgc3RhdGUuY3VycmVudCA9IG51bGw7XHJcblxyXG4gICAgICAgIGlmIChjYWxsU2l0ZS5pc05hdGl2ZSgpKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIE1vc3QgY2FsbCBzaXRlcyB3aWxsIHJldHVybiB0aGUgc291cmNlIGZpbGUgZnJvbSBnZXRGaWxlTmFtZSgpLCBidXQgY29kZVxyXG4gICAgICAgIC8vIHBhc3NlZCB0byBldmFsKCkgZW5kaW5nIGluIFwiLy8jIHNvdXJjZVVSTD0uLi5cIiB3aWxsIHJldHVybiB0aGUgc291cmNlIGZpbGVcclxuICAgICAgICAvLyBmcm9tIGdldFNjcmlwdE5hbWVPclNvdXJjZVVSTCgpIGluc3RlYWRcclxuICAgICAgICBjb25zdCBzb3VyY2UgPSBjYWxsU2l0ZS5nZXRGaWxlTmFtZSgpID8/ICgoY2FsbFNpdGUgYXMgYW55KS5nZXRTY3JpcHROYW1lT3JTb3VyY2VVUkwoKSBhcyBzdHJpbmcgfCB1bmRlZmluZWQpO1xyXG4gICAgICAgIGlmIChzb3VyY2UpIHtcclxuICAgICAgICAgICAgY29uc3QgbGluZSA9IGNhbGxTaXRlLmdldExpbmVOdW1iZXIoKSE7XHJcbiAgICAgICAgICAgIGxldCBjb2x1bW4gPSBjYWxsU2l0ZS5nZXRDb2x1bW5OdW1iZXIoKSEgLSAxO1xyXG4gICAgICAgICAgICAvLyBGaXggcG9zaXRpb24gaW4gTm9kZSB3aGVyZSBzb21lIChpbnRlcm5hbCkgY29kZSBpcyBwcmVwZW5kZWQuXHJcbiAgICAgICAgICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZXZhbncvbm9kZS1zb3VyY2UtbWFwLXN1cHBvcnQvaXNzdWVzLzM2XHJcbiAgICAgICAgICAgIC8vIEhlYWRlciByZW1vdmVkIGluIG5vZGUgYXQgXjEwLjE2IHx8ID49MTEuMTEuMFxyXG4gICAgICAgICAgICAvLyB2MTEgaXMgbm90IGFuIExUUyBjYW5kaWRhdGUsIHdlIGNhbiBqdXN0IHRlc3QgdGhlIG9uZSB2ZXJzaW9uIHdpdGggaXQuXHJcbiAgICAgICAgICAgIC8vIFRlc3Qgbm9kZSB2ZXJzaW9ucyBmb3I6IDEwLjE2LTE5LCAxMC4yMCssIDEyLTE5LCAyMC05OSwgMTAwKywgb3IgMTEuMTFcclxuICAgICAgICAgICAgY29uc3Qgbm9IZWFkZXIgPSAvXnYoMTBcXC4xWzYtOV18MTBcXC5bMi05XVswLTldfDEwXFwuWzAtOV17Myx9fDFbMi05XVxcZCp8WzItOV1cXGR8XFxkezMsfXwxMVxcLjExKS87XHJcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlckxlbmd0aCA9IG5vSGVhZGVyLnRlc3QocHJvY2Vzcy52ZXJzaW9uKSA/IDAgOiA2MjtcclxuICAgICAgICAgICAgaWYgKGxpbmUgPT09IDEgJiYgY29sdW1uID4gaGVhZGVyTGVuZ3RoIC8qICYmICFpc0luQnJvd3NlcigpKi8gJiYgIWNhbGxTaXRlLmlzRXZhbCgpKSB7XHJcbiAgICAgICAgICAgICAgICBjb2x1bW4gLT0gaGVhZGVyTGVuZ3RoO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBjb25zdCBtYXBwZWRQb3NpdGlvbiA9IHRoaXMuX21hcFNvdXJjZVBvc2l0aW9uKHsgc291cmNlLCBsaW5lLCBjb2x1bW4gfSk7XHJcbiAgICAgICAgICAgIGlmIChtYXBwZWRQb3NpdGlvbikge1xyXG4gICAgICAgICAgICAgICAgc3RhdGUuY3VycmVudCA9IG1hcHBlZFBvc2l0aW9uO1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgd3JhcHBlZENhbGxTaXRlID0gY2xvbmVDYWxsU2l0ZShjYWxsU2l0ZSk7XHJcbiAgICAgICAgICAgICAgICB3cmFwcGVkQ2FsbFNpdGUuZ2V0RmlsZU5hbWUgPSAoKSA9PiBtYXBwZWRQb3NpdGlvbi5zb3VyY2U7XHJcbiAgICAgICAgICAgICAgICB3cmFwcGVkQ2FsbFNpdGUuZ2V0TGluZU51bWJlciA9ICgpID0+IG1hcHBlZFBvc2l0aW9uLmxpbmU7XHJcbiAgICAgICAgICAgICAgICB3cmFwcGVkQ2FsbFNpdGUuZ2V0Q29sdW1uTnVtYmVyID0gKCkgPT4gbWFwcGVkUG9zaXRpb24uY29sdW1uICsgMTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG5leHROYW1lID0gc3RhdGUubmV4dD8ubmFtZTtcclxuICAgICAgICAgICAgICAgIGlmIChuZXh0TmFtZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHdyYXBwZWRDYWxsU2l0ZS5nZXRGdW5jdGlvbk5hbWUgPSAoKSA9PiBuZXh0TmFtZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiB3cmFwcGVkQ2FsbFNpdGU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2UgaWYgKGNhbGxTaXRlLmlzRXZhbCgpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG9yaWdpbiA9IGNhbGxTaXRlLmdldEV2YWxPcmlnaW4oKTtcclxuICAgICAgICAgICAgaWYgKG9yaWdpbikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbWFwRXZhbE9yaWdpbihvcmlnaW4pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgX2NhbGxTaXRlVG9TdHJpbmcoY2FsbFNpdGU6IFdyYXBwZWRDYWxsU2l0ZSkge1xyXG4gICAgICAgIGxldCBmaWxlTmFtZTtcclxuICAgICAgICBsZXQgZmlsZUxvY2F0aW9uID0gXCJcIjtcclxuICAgICAgICBpZiAoY2FsbFNpdGUuaXNOYXRpdmUoKSkge1xyXG4gICAgICAgICAgICBmaWxlTG9jYXRpb24gPSBcIm5hdGl2ZVwiO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGZpbGVOYW1lID0gY2FsbFNpdGUuZ2V0RmlsZU5hbWUoKTtcclxuICAgICAgICAgICAgaWYgKCFmaWxlTmFtZSAmJiBjYWxsU2l0ZS5pc0V2YWwoKSkge1xyXG4gICAgICAgICAgICAgICAgZmlsZUxvY2F0aW9uID0gY2FsbFNpdGUuZ2V0RXZhbE9yaWdpbigpID8/ICcnO1xyXG4gICAgICAgICAgICAgICAgZmlsZUxvY2F0aW9uICs9IFwiLCBcIjsgIC8vIEV4cGVjdGluZyBzb3VyY2UgcG9zaXRpb24gdG8gZm9sbG93LlxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoZmlsZU5hbWUpIHtcclxuICAgICAgICAgICAgICAgIGZpbGVMb2NhdGlvbiArPSBmaWxlTmFtZTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIFNvdXJjZSBjb2RlIGRvZXMgbm90IG9yaWdpbmF0ZSBmcm9tIGEgZmlsZSBhbmQgaXMgbm90IG5hdGl2ZSwgYnV0IHdlXHJcbiAgICAgICAgICAgICAgICAvLyBjYW4gc3RpbGwgZ2V0IHRoZSBzb3VyY2UgcG9zaXRpb24gaW5zaWRlIHRoZSBzb3VyY2Ugc3RyaW5nLCBlLmcuIGluXHJcbiAgICAgICAgICAgICAgICAvLyBhbiBldmFsIHN0cmluZy5cclxuICAgICAgICAgICAgICAgIGZpbGVMb2NhdGlvbiArPSBcIjxhbm9ueW1vdXM+XCI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgbGluZU51bWJlciA9IGNhbGxTaXRlLmdldExpbmVOdW1iZXIoKTtcclxuICAgICAgICAgICAgaWYgKGxpbmVOdW1iZXIgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIGZpbGVMb2NhdGlvbiArPSBcIjpcIiArIGxpbmVOdW1iZXI7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBjb2x1bW5OdW1iZXIgPSBjYWxsU2l0ZS5nZXRDb2x1bW5OdW1iZXIoKTtcclxuICAgICAgICAgICAgICAgIGlmIChjb2x1bW5OdW1iZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICBmaWxlTG9jYXRpb24gKz0gXCI6XCIgKyBjb2x1bW5OdW1iZXI7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGxldCBsaW5lID0gXCJcIjtcclxuICAgICAgICBjb25zdCBmdW5jdGlvbk5hbWUgPSBjYWxsU2l0ZS5nZXRGdW5jdGlvbk5hbWUoKTtcclxuICAgICAgICBsZXQgYWRkU3VmZml4ID0gdHJ1ZTtcclxuICAgICAgICBjb25zdCBpc0NvbnN0cnVjdG9yID0gY2FsbFNpdGUuaXNDb25zdHJ1Y3RvcigpO1xyXG4gICAgICAgIGNvbnN0IGlzTWV0aG9kQ2FsbCA9ICEoY2FsbFNpdGUuaXNUb3BsZXZlbCgpIHx8IGlzQ29uc3RydWN0b3IpO1xyXG4gICAgICAgIGlmIChpc01ldGhvZENhbGwpIHtcclxuICAgICAgICAgICAgbGV0IHR5cGVOYW1lID0gY2FsbFNpdGUuZ2V0VHlwZU5hbWUoKTtcclxuICAgICAgICAgICAgLy8gRml4ZXMgc2hpbSB0byBiZSBiYWNrd2FyZCBjb21wYXRhYmxlIHdpdGggTm9kZSB2MCB0byB2NFxyXG4gICAgICAgICAgICBpZiAodHlwZU5hbWUgPT09IFwiW29iamVjdCBPYmplY3RdXCIpIHtcclxuICAgICAgICAgICAgICAgIHR5cGVOYW1lID0gXCJudWxsXCI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgbWV0aG9kTmFtZSA9IGNhbGxTaXRlLmdldE1ldGhvZE5hbWUoKTtcclxuICAgICAgICAgICAgaWYgKGZ1bmN0aW9uTmFtZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVOYW1lICYmIGZ1bmN0aW9uTmFtZS5pbmRleE9mKHR5cGVOYW1lKSAhPT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxpbmUgKz0gdHlwZU5hbWUgKyBcIi5cIjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGxpbmUgKz0gZnVuY3Rpb25OYW1lO1xyXG4gICAgICAgICAgICAgICAgaWYgKG1ldGhvZE5hbWUgJiYgZnVuY3Rpb25OYW1lLmluZGV4T2YoXCIuXCIgKyBtZXRob2ROYW1lKSAhPT0gZnVuY3Rpb25OYW1lLmxlbmd0aCAtIG1ldGhvZE5hbWUubGVuZ3RoIC0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxpbmUgKz0gXCIgW2FzIFwiICsgbWV0aG9kTmFtZSArIFwiXVwiO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgbGluZSArPSB0eXBlTmFtZSArIFwiLlwiICsgKG1ldGhvZE5hbWUgfHwgXCI8YW5vbnltb3VzPlwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSBpZiAoaXNDb25zdHJ1Y3Rvcikge1xyXG4gICAgICAgICAgICBsaW5lICs9IFwibmV3IFwiICsgKGZ1bmN0aW9uTmFtZSB8fCBcIjxhbm9ueW1vdXM+XCIpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoZnVuY3Rpb25OYW1lKSB7XHJcbiAgICAgICAgICAgIGxpbmUgKz0gZnVuY3Rpb25OYW1lO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGxpbmUgKz0gZmlsZUxvY2F0aW9uO1xyXG4gICAgICAgICAgICBhZGRTdWZmaXggPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGFkZFN1ZmZpeCkge1xyXG4gICAgICAgICAgICBsaW5lICs9IFwiIChcIiArIGZpbGVMb2NhdGlvbiArIFwiKVwiO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbGluZTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIF9tYXBTb3VyY2VQb3NpdGlvbihwb3NpdGlvbjogUG9zaXRpb24gJiB7IHNvdXJjZTogc3RyaW5nIH0pOiBNYXBwZWRQb3NpdGlvbiB8IHVuZGVmaW5lZCB7XHJcbiAgICAgICAgY29uc3Qgc291cmNlTWFwUmVjb3JkID0gdGhpcy5fZ2V0U291cmNlTWFwKHBvc2l0aW9uLnNvdXJjZSk7XHJcbiAgICAgICAgaWYgKCFzb3VyY2VNYXBSZWNvcmQ/Lm1hcCB8fFxyXG4gICAgICAgICAgICB0eXBlb2Ygc291cmNlTWFwUmVjb3JkLm1hcC5vcmlnaW5hbFBvc2l0aW9uRm9yICE9PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFJlc29sdmUgdGhlIHNvdXJjZSBVUkwgcmVsYXRpdmUgdG8gdGhlIFVSTCBvZiB0aGUgc291cmNlIG1hcC5cclxuICAgICAgICAvLyBPbmx5IHJldHVybiB0aGUgb3JpZ2luYWwgcG9zaXRpb24gaWYgYSBtYXRjaGluZyBsaW5lIHdhcyBmb3VuZC4gSWYgbm9cclxuICAgICAgICAvLyBtYXRjaGluZyBsaW5lIGlzIGZvdW5kIHRoZW4gd2UgcmV0dXJuIHBvc2l0aW9uIGluc3RlYWQsIHdoaWNoIHdpbGwgY2F1c2VcclxuICAgICAgICAvLyB0aGUgc3RhY2sgdHJhY2UgdG8gcHJpbnQgdGhlIHBhdGggYW5kIGxpbmUgZm9yIHRoZSBjb21waWxlZCBmaWxlLiBJdCBpc1xyXG4gICAgICAgIC8vIGJldHRlciB0byBnaXZlIGEgcHJlY2lzZSBsb2NhdGlvbiBpbiB0aGUgY29tcGlsZWQgZmlsZSB0aGFuIGEgdmFndWVcclxuICAgICAgICAvLyBsb2NhdGlvbiBpbiB0aGUgb3JpZ2luYWwgZmlsZS5cclxuICAgICAgICBjb25zdCBvcmlnaW5hbFBvc2l0aW9uID0gc291cmNlTWFwUmVjb3JkLm1hcC5vcmlnaW5hbFBvc2l0aW9uRm9yKHBvc2l0aW9uKTtcclxuICAgICAgICBpZiAob3JpZ2luYWxQb3NpdGlvbi5zb3VyY2UgPT09IG51bGwgfHwgb3JpZ2luYWxQb3NpdGlvbi5zb3VyY2UgPT09ICdudWxsJykge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCByZXNvbHZlZCA9IHRoaXMuX3Jlc29sdmVVcmwob3JpZ2luYWxQb3NpdGlvbi5zb3VyY2UsIHNvdXJjZU1hcFJlY29yZC51cmwpO1xyXG4gICAgICAgIGlmIChyZXNvbHZlZCkge1xyXG4gICAgICAgICAgICBvcmlnaW5hbFBvc2l0aW9uLnNvdXJjZSA9IGNvbnZlcnRGaWxlVXJsVG9QYXRoKHJlc29sdmVkKSA/PyByZXNvbHZlZC5ocmVmO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIG9yaWdpbmFsUG9zaXRpb247XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBfbWFwRXZhbE9yaWdpbihvcmlnaW46IHN0cmluZykge1xyXG5cclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIF9nZXRTb3VyY2VNYXAoc291cmNlOiBzdHJpbmcpOiBTb3VyY2VNYXBSZWNvcmQgfCB1bmRlZmluZWQge1xyXG4gICAgICAgIGNvbnN0IHNvdXJjZVVybCA9IHRoaXMuX3Jlc29sdmVVcmwoc291cmNlKTtcclxuICAgICAgICBpZiAoIXNvdXJjZVVybCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHsgaHJlZiB9ID0gc291cmNlVXJsO1xyXG4gICAgICAgIGNvbnN0IHNvdXJjZU1hcFJlY29yZCA9IHRoaXMuX3NvdXJjZU1hcENhY2hlW2hyZWZdO1xyXG4gICAgICAgIGlmIChzb3VyY2VNYXBSZWNvcmQgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBjb25zdCBmZXRjaGVkU291cmNlTWFwID0gdGhpcy5fZmV0Y2hTb3VyY2VNYXAoc291cmNlVXJsKTtcclxuICAgICAgICAgICAgaWYgKCFmZXRjaGVkU291cmNlTWFwKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zb3VyY2VNYXBDYWNoZVtocmVmXSA9IG51bGw7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzb3VyY2VNYXBVcmwgPSBmZXRjaGVkU291cmNlTWFwLnVybDtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBMb2FkIGFsbCBzb3VyY2VzIHN0b3JlZCBpbmxpbmUgd2l0aCB0aGUgc291cmNlIG1hcCBpbnRvIHRoZSBmaWxlIGNhY2hlXHJcbiAgICAgICAgICAgICAgICAvLyB0byBwcmV0ZW5kIGxpa2UgdGhleSBhcmUgYWxyZWFkeSBsb2FkZWQuIFRoZXkgbWF5IG5vdCBleGlzdCBvbiBkaXNrLlxyXG4gICAgICAgICAgICAgICAgaWYgKGZldGNoZWRTb3VyY2VNYXAubWFwLnNvdXJjZXNDb250ZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZmV0Y2hlZFNvdXJjZU1hcC5tYXAuc291cmNlc0NvbnRlbnQuZm9yRWFjaCgoc291cmNlQ29udGVudCwgaVNvdXJjZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc291cmNlQ29udGVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaW5saW5lU291cmNlID0gZmV0Y2hlZFNvdXJjZU1hcC5tYXAuc291cmNlc1tpU291cmNlXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGlubGluZVNvdXJjZVVybCA9IHRoaXMuX3Jlc29sdmVVcmwoaW5saW5lU291cmNlLCBzb3VyY2VNYXBVcmwpPy5ocmVmID8/IGlubGluZVNvdXJjZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2ZpbGVDb250ZW50c0NhY2hlW2lubGluZVNvdXJjZVVybF0gPSBzb3VyY2VDb250ZW50O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgY29uc3Qgc291cmNlTWFwQ29uc3VtZXIgPSBuZXcgU291cmNlTWFwQ29uc3VtZXIoZmV0Y2hlZFNvdXJjZU1hcC5tYXApO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fc291cmNlTWFwQ2FjaGVbaHJlZl0gPSB7IG1hcDogc291cmNlTWFwQ29uc3VtZXIsIHVybDogc291cmNlTWFwVXJsIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NvdXJjZU1hcENhY2hlW2hyZWZdID8/IHVuZGVmaW5lZDtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIF90cnlGZXRjaFNvdXJjZU1hcChzb3VyY2U6IFVSTCkge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9mZXRjaFNvdXJjZU1hcChzb3VyY2UpO1xyXG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xyXG4gICAgICAgICAgICBjb25zb2xlLmRlYnVnKGBGYWlsZWQgdG8gZmV0Y2ggc291cmNlIG1hcCBmb3IgJyR7c291cmNlfSc6ICR7ZXJyfWApO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgX2ZldGNoU291cmNlTWFwKHNvdXJjZTogVVJMKTogdW5kZWZpbmVkIHwgeyBtYXA6IFJhd1NvdXJjZU1hcCwgdXJsOiBVUkwgfSB7XHJcbiAgICAgICAgY29uc3Qgc291cmNlTWFwcGluZ1VyaSA9IHRoaXMuX2ZldGNoU291cmNlTWFwVXJsKHNvdXJjZSk7XHJcbiAgICAgICAgaWYgKCFzb3VyY2VNYXBwaW5nVXJpKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFJlYWQgdGhlIGNvbnRlbnRzIG9mIHRoZSBzb3VyY2UgbWFwXHJcbiAgICAgICAgbGV0IHNvdXJjZU1hcERhdGE6IFJhd1NvdXJjZU1hcDtcclxuICAgICAgICBsZXQgc291cmNlTWFwVXJsOiBVUkw7XHJcbiAgICAgICAgaWYgKHJlU291cmNlTWFwcGluZ0RhdGFVcmwudGVzdChzb3VyY2VNYXBwaW5nVXJpKSkge1xyXG4gICAgICAgICAgICAvLyBTdXBwb3J0IHNvdXJjZSBtYXAgVVJMIGFzIGEgZGF0YSB1cmxcclxuICAgICAgICAgICAgY29uc3QgcmF3RGF0YSA9IHNvdXJjZU1hcHBpbmdVcmkuc2xpY2Uoc291cmNlTWFwcGluZ1VyaS5pbmRleE9mKCcsJykgKyAxKTtcclxuICAgICAgICAgICAgc291cmNlTWFwRGF0YSA9IEpTT04ucGFyc2UoQnVmZmVyLmZyb20ocmF3RGF0YSwgXCJiYXNlNjRcIikudG9TdHJpbmcoKSk7XHJcbiAgICAgICAgICAgIHNvdXJjZU1hcFVybCA9IHNvdXJjZTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBTdXBwb3J0IHNvdXJjZSBtYXAgVVJMcyByZWxhdGl2ZSB0byB0aGUgc291cmNlIFVSTFxyXG4gICAgICAgICAgICBjb25zdCByZXNvbHZlZCA9IHRoaXMuX3Jlc29sdmVVcmwoc291cmNlTWFwcGluZ1VyaSwgc291cmNlKTtcclxuICAgICAgICAgICAgaWYgKCFyZXNvbHZlZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHNvdXJjZU1hcFVybCA9IHJlc29sdmVkO1xyXG4gICAgICAgICAgICBjb25zdCBmaWxlID0gdGhpcy5fZmV0Y2hGaWxlU3luYyhzb3VyY2VNYXBVcmwpO1xyXG4gICAgICAgICAgICBpZiAoIWZpbGUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBzb3VyY2VNYXBEYXRhID0gSlNPTi5wYXJzZShmaWxlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICghc291cmNlTWFwRGF0YSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB1cmw6IHNvdXJjZU1hcFVybCxcclxuICAgICAgICAgICAgbWFwOiBzb3VyY2VNYXBEYXRhLFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBfZmV0Y2hTb3VyY2VNYXBVcmwoc291cmNlOiBVUkwpOiBzdHJpbmcgfCB1bmRlZmluZWQge1xyXG4gICAgICAgIGNvbnN0IGZpbGUgPSB0aGlzLl9mZXRjaEZpbGVTeW5jKHNvdXJjZSk7XHJcbiAgICAgICAgaWYgKCFmaWxlKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IHJlZyA9IC8oPzpcXC9cXC9bQCNdW1xcc10qc291cmNlTWFwcGluZ1VSTD0oW15cXHMnXCJdKylbXFxzXSokKXwoPzpcXC9cXCpbQCNdW1xcc10qc291cmNlTWFwcGluZ1VSTD0oW15cXHMqJ1wiXSspW1xcc10qKD86XFwqXFwvKVtcXHNdKiQpL21nO1xyXG4gICAgICAgIC8vIEtlZXAgZXhlY3V0aW5nIHRoZSBzZWFyY2ggdG8gZmluZCB0aGUgKmxhc3QqIHNvdXJjZU1hcHBpbmdVUkwgdG8gYXZvaWRcclxuICAgICAgICAvLyBwaWNraW5nIHVwIHNvdXJjZU1hcHBpbmdVUkxzIGZyb20gY29tbWVudHMsIHN0cmluZ3MsIGV0Yy5cclxuICAgICAgICBsZXQgbGFzdE1hdGNoOiBSZWdFeHBNYXRjaEFycmF5IHwgdW5kZWZpbmVkO1xyXG4gICAgICAgIGxldCBtYXRjaDogUmVnRXhwRXhlY0FycmF5IHwgbnVsbDtcclxuICAgICAgICB3aGlsZSAoKG1hdGNoID0gcmVnLmV4ZWMoZmlsZSkpKSB7XHJcbiAgICAgICAgICAgIGxhc3RNYXRjaCA9IG1hdGNoO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCFsYXN0TWF0Y2gpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGxhc3RNYXRjaFsxXTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIF9mZXRjaEZpbGVTeW5jKHVybDogVVJMKTogc3RyaW5nIHwgdW5kZWZpbmVkIHtcclxuICAgICAgICBjb25zdCB7IGhyZWYgfSA9IHVybDtcclxuICAgICAgICBpZiAoIShocmVmIGluIHRoaXMuX2ZpbGVDb250ZW50c0NhY2hlKSkge1xyXG4gICAgICAgICAgICB0aGlzLl9maWxlQ29udGVudHNDYWNoZVtocmVmXSA9IHRoaXMuX2RvRmV0Y2hGaWxlU3luYyh1cmwpID8/IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLl9maWxlQ29udGVudHNDYWNoZVtocmVmXSA/PyB1bmRlZmluZWQ7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBfZG9GZXRjaEZpbGVTeW5jKHVybDogVVJMKTogc3RyaW5nIHwgdW5kZWZpbmVkIHtcclxuICAgICAgICBsZXQgcGF0aDogc3RyaW5nO1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHBhdGggPSBmaWxlVVJMVG9QYXRoKHVybCk7XHJcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgJHt1cmwuaHJlZn0gaXMgbm90IGEgdmFsaWQgZmlsZSBVUkwuIFdlIGNhbiBvbmx5IGZldGNoIHNvdXJjZSBtYXAgaW4gZmlsZSBzeXN0ZW0uYCk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZzLnJlYWRGaWxlU3luYyhwYXRoLCB7IGVuY29kaW5nOiAndXRmOCcgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBfcmVzb2x2ZVVybCh1cmw6IHN0cmluZywgYmFzZT86IFVSTCk6IFVSTCB8IHVuZGVmaW5lZCB7XHJcbiAgICAgICAgaWYgKHBzLmlzQWJzb2x1dGUodXJsKSkge1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhdGhUb0ZpbGVVUkwodXJsKTtcclxuICAgICAgICAgICAgfSBjYXRjaCB7IH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBVUkwodXJsLCBiYXNlKTtcclxuICAgICAgICB9IGNhdGNoIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIF9zb3VyY2VNYXBDYWNoZTogUmVjb3JkPHN0cmluZywgU291cmNlTWFwUmVjb3JkIHwgbnVsbD4gPSB7fTtcclxuICAgIHByaXZhdGUgX2ZpbGVDb250ZW50c0NhY2hlOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmcgfCBudWxsPiA9IHt9O1xyXG4gICAgcHJpdmF0ZSBfdmVuZG9yUHJlcGFyZVN0YWNrVHJhY2U6IHVuZGVmaW5lZCB8IFByZXBhcmVTdGFja1RyYWNlO1xyXG4gICAgcHJpdmF0ZSBfbXlTdGFja1Byb3BlcnR5ID0gU3ltYm9sKCdbW0NyZWF0b3I6OnN0YWNrXV0nKTtcclxufVxyXG5cclxuLy8gUmVnZXggZm9yIGRldGVjdGluZyBzb3VyY2UgbWFwc1xyXG5jb25zdCByZVNvdXJjZU1hcHBpbmdEYXRhVXJsID0gL15kYXRhOmFwcGxpY2F0aW9uXFwvanNvblteLF0rYmFzZTY0LC87XHJcblxyXG5mdW5jdGlvbiBjbG9uZUNhbGxTaXRlKGNhbGxTaXRlOiBOb2RlSlMuQ2FsbFNpdGUpOiBOb2RlSlMuQ2FsbFNpdGUge1xyXG4gICAgY29uc3Qgb2JqZWN0OiBhbnkgPSB7fTtcclxuICAgIGNvbnN0IG5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoT2JqZWN0LmdldFByb3RvdHlwZU9mKGNhbGxTaXRlKSk7XHJcbiAgICAobmFtZXMgYXMgKGtleW9mIE5vZGVKUy5DYWxsU2l0ZSlbXSkuZm9yRWFjaChmdW5jdGlvbihuYW1lKSB7XHJcbiAgICAgICAgb2JqZWN0W25hbWVdID0gL14oPzppc3xnZXQpLy50ZXN0KG5hbWUpID8gZnVuY3Rpb24oKSB7IHJldHVybiBjYWxsU2l0ZVtuYW1lXS5jYWxsKGNhbGxTaXRlKTsgfSA6IGNhbGxTaXRlW25hbWVdO1xyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gb2JqZWN0O1xyXG59XHJcblxyXG5mdW5jdGlvbiBjb252ZXJ0RmlsZVVybFRvUGF0aCh1cmw6IFVSTCkge1xyXG4gICAgaWYgKHVybC5wcm90b2NvbCA9PT0gJ2ZpbGU6Jykge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmaWxlVVJMVG9QYXRoKHVybCk7XHJcbiAgICAgICAgfSBjYXRjaCB7IH1cclxuICAgIH1cclxufVxyXG4iXX0=