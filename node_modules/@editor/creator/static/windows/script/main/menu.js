'use strict';

function legalData(path, menuObject) {
    const menus = [];

    for (const key in menuObject) {
        const menu = menuObject[key];

        if (menu.type === 'separator') {
            // 容错处理，上一个是 'separator' 这个就跳过
            const lastIndex = menus.length - 1;
            if (lastIndex >= 0 && menus[lastIndex].type === 'separator') {
                continue;
            }

            menus.push(menu);
            continue;
        }

        /**
         * 编辑器的 menu 系统根据 path 存储
         * 这样拼接不仅能避免和主进程注册的 path 重合
         * 也能作为后续调用主进程 menu 的入参
         */
        menu.path = `${path}/${key}`;

        if (menu.submenu) {
            menu.submenu = legalData(menu.path, menu.submenu);
        } else {
            menu.click = click.bind(menu);
        }

        menus.push(menu);
    }

    return menus;
}

function click() {
    Editor.Menu.clickMain(this.path);
}

exports.init = async function init() {
    const isNative = await Editor.Profile.getConfig('scene', 'scene.native');
    if (!isNative) {
        return
    }

    document.body.setAttribute('mode', 'native');

    if (process.platform === 'win32') {
        const $menu = document.getElementById('menu');
        $menu.style.display = 'block';
    }
}

exports.update = async function update() {
    if (process.platform !== 'win32') {
        return;
    }

    const isNative = await Editor.Profile.getConfig('scene', 'scene.native');
    if (!isNative) {
        return;
    }

    const menus = await Editor.Menu.queryMain();
    if (!menus) {
        return;
    }

    const $menu = document.getElementById('menu');
    $menu.innerHTML = "";

    let activeElement = null;
    for (let key in menus) {
        const $item = document.createElement('ui-label');
        $item.setAttribute('class', 'item');
        $item.value = key;
        $menu.appendChild($item);

        $item.addEventListener('mousedown', async (e) => {
            const latestData = await Editor.Menu.queryMain();

            activeElement && activeElement.classList.remove('active');
            activeElement = e.target;
            activeElement.classList.add('active');

            const menu = legalData(key, latestData[key].submenu);
            const rect = activeElement.getBoundingClientRect();
            Editor.Menu.popup({
                menu,
                x: Math.round(rect.x),
                y: Math.round(rect.bottom) + 2,
                callback() {
                    // TODO: 这个事件本来是 closePopup 对应的回调，现在无效了
                    activeElement.classList.remove('active');
                },
            });
        });
    }
}

Editor.Package.on('register', () => {
    exports.update();
});