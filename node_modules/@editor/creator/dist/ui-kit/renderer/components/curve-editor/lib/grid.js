"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.Grid=void 0;const linear_ticks_1=require("./linear-ticks"),utils_1=require("./utils"),Chroma=require("chroma-js");class Grid{constructor(i,s){this.multi=1,this.axisMargin=20,this.negative=!1,this.lineWidth=1,this.showX=!1,this.showY=!1,this.xAxisScale=1,this.yAxisScale=1,this.axisXConfig={lods:[5,2],minScale:1,maxScale:100,startOffset:0,showLine:!0,showLabel:!0,lineWidth:.5,lineColor:"#333846",precision:2,minStep:1},this.axisYConfig={lods:[5,2],minScale:1,maxScale:100,startOffset:0,showLine:!0,showLabel:!0,lineWidth:.5,lineColor:"#333846",precision:2,minStep:1},this.xAxisOffset=0,this.xAnchor=.5,this.yAxisOffset=0,this.yAnchor=.5,this.xAxisMinStep=50,this.yAxisMinStep=50,this.xMaxValue=0,this.xMinValue=0,this.yMaxValue=0,this.yMinValue=0,this.canvas=i,this.ctx=i.getContext("2d"),this.ctx.strokeStyle="#333846c",this.initConfig(s)}get height(){return this.negative?this.canvas.height/2:this.canvas.height}get xRange(){return{left:0,right:this.canvas.width}}get anchorInfo(){return{x:0+this.axisMargin-this.lineWidth-.5,y:0+this.axisMargin-this.lineWidth-.5,w:this.canvas.width-2*this.axisMargin+2*this.lineWidth+.5,h:this.canvas.height-2*this.axisMargin+2*this.lineWidth+.5}}initConfig(i){if(!i.axisXConfig&&!i.axisYConfig)throw new Error("至少显示一种坐标轴");this.axisMargin=i.axisMargin||0,this.showX=!!i.axisXConfig,this.showY=!!i.axisYConfig,this.negative=i.negative||i.axisYConfig&&i.axisYConfig.minValue<0,i.axisXConfig&&Object.assign(this.axisXConfig,i.axisXConfig),i.axisYConfig&&Object.assign(this.axisYConfig,i.axisYConfig),this._initXAxios(),this._initYAxios()}resize(i,s){if(!i||!s){const t=this.canvas.getBoundingClientRect();i=i||t.width,s=s||t.height,i=Math.round(i),s=Math.round(s)}this.canvas.width===i&&this.canvas.height===s||(this.canvas.width=i,this.canvas.height=s,this.render())}render(){this.clear(),this.updateGrids(),this.updateLabels()}transfer(i,s){return{x:this.transferX&&this.transferX(i)||0,y:this.transferY&&this.transferY(s)}}updateLabels(){this.renderLabelX&&this.axisXConfig.showLabel&&this.renderLabelX(),this.renderLabelY&&this.axisYConfig.showLabel&&this.renderLabelY()}clear(){var i;null===(i=this.ctx)||void 0===i||i.clearRect(-10,-10,this.canvas.width+10,this.canvas.height+10)}updateGrids(){this.ctx.save(),this.ctx.rect(this.anchorInfo.x,this.anchorInfo.y,this.anchorInfo.w,this.anchorInfo.h),this.ctx.clip();const i=this.pixelToValueX(0+this.axisMargin),s=this.pixelToValueX(this.canvas.width-2*this.axisMargin);this.xTicks.range(i,s,this.canvas.width-2*this.axisMargin),this.renderX&&this.renderX();const t=this.pixelToValueY(0+this.axisMargin),a=this.pixelToValueY(this.canvas.height-2*this.axisMargin);this.yTicks.range(t,a,this.canvas.height-2*this.axisMargin),this.renderY&&this.renderY(),this.ctx.restore()}valueToPixel(i){var s,t;return{x:null!==(s=this.valueToPixelX&&this.valueToPixelX(i.x))&&void 0!==s?s:i.x,y:null!==(t=this.valueToPixelY&&this.valueToPixelY(i.y))&&void 0!==t?t:i.y}}pixelToValue(i){var s,t;return{x:null!==(s=this.pixelToValueX&&this.pixelToValueX(i.x))&&void 0!==s?s:i.x,y:null!==(t=this.pixelToValueY&&this.pixelToValueY(i.y))&&void 0!==t?t:i.y}}formatValue(i){return{x:this.xFormat&&this.xFormat(i.x),y:this.yFormat&&this.yFormat(i.y)}}valueToFormat(i){var s,t;return{x:null!==(s=this.xDefaultFormat&&this.xDefaultFormat(i.x))&&void 0!==s?s:i.x,y:null!==(t=this.yDefaultFormat&&this.yDefaultFormat(i.y))&&void 0!==t?t:i.y}}patchPointInRange(i){const s=this.pixelToValue(i);let t=!1;if(this.axisXConfig&&(this.axisXConfig.maxValue<s.x||s.x<this.axisXConfig.minValue)){const{maxValue:a,minValue:e}=this.axisXConfig;s.x=s.x>a?a:e,i.x=this.valueToPixelX(s.x*this.xMaxValue),t=!0}if(this.axisYConfig&&(this.axisYConfig.maxValue<s.y||s.y<this.axisYConfig.minValue)){const{maxValue:a,minValue:e}=this.axisYConfig;s.y=s.y>a?a:e,i.y=this.valueToPixelY(s.y*this.yMaxValue),t=!0}return t?s:null}checkXInRange(i){if(this.axisXConfig&&(this.axisXConfig.realMaxValue<i||i<this.axisXConfig.realMaxValue))return this.xAxisScale;return this.xAxisOffset=0,(this.canvas.width-2*this.axisMargin)/this.axisXConfig.realMaxValue}checkYInRange(i){if(this.axisYConfig&&(this.axisYConfig.realMaxValue<i||i<this.axisYConfig.minValue))return this.yAxisScale;let s=1;return this.negative?(this.yAxisOffset=this.axisMargin,s=(this.height-this.axisMargin)/this.axisYConfig.realMaxValue):(this.yAxisOffset=0,s=(this.canvas.height-2*this.axisMargin)/this.axisYConfig.realMaxValue),s}setDisplayRange(i,s){const[t,a]=i,[e,h]=s;this.xAxisScale=(this.canvas.width-2*this.axisMargin)/(a-t),this.xAxisOffset=-t*this.xAxisScale,this.yAxisScale=(this.height-this.axisMargin)/(h-e),this.yAxisOffset=h*this.yAxisScale-this.height,this.yAxisOffset=0}resetScale(){this.xAxisScale=this.checkXInRange(this.axisXConfig.realMaxValue),this.yAxisScale=this.checkYInRange(this.axisYConfig.realMaxValue)}_initXAxios(){const{lods:i,startOffset:s,showLine:t,lineColor:a,$container:e,format:h,maxValue:n,precision:l,showLabel:x,minStep:o}=this.axisXConfig,r=n===1/0?this.canvas.width:n||this.canvas.width;this.axisXConfig.realMaxValue=r,this.xAxisOffset=null!==s&&void 0!==s?s:0,this.xTicks=new linear_ticks_1.default,this.xTicks.initTicks(i,1/Math.pow(10,l||2),r).spacing(10,100),this.xAxisScale=(0,utils_1.clamp)(this.xAxisScale,this.xTicks.minValueScale,this.xTicks.maxValueScale),this.xAxisMinStep=40,this.pixelToValueX=(i=>((i-=this.axisMargin)-this.xAxisOffset)/this.xAxisScale),this.valueToPixelX=(i=>i*this.xAxisScale+this.xAxisOffset+this.axisMargin);const c=this.pixelToValueX(0+this.axisMargin),f=this.pixelToValueX(this.canvas.width-2*this.axisMargin);if(this.xTicks.range(c,f,this.canvas.width-2*this.axisMargin),this.xMaxValue=this.xTicks.maxValue,this.transferX=(i=>{const{startOffset:s}=this.axisXConfig;if(this.xAxisOffset===s&&i>0)return 0;let t=this.xAxisOffset+i;return t>s&&(t=s),i=t-this.xAxisOffset,this.xAxisOffset=t,i}),n){const i=this.checkXInRange(this.axisXConfig.maxValue);this.xTicks.minValueScale=i,this.xAxisScale=i}if(this.xAxisScaleAt=((i,s)=>{const t=this.pixelToValueX(i);this.xAxisScale=(0,utils_1.clamp)(s,this.xTicks.minValueScale,this.xTicks.maxValueScale);const a=i-this.valueToPixelX(t);return this.transferX(a),this.xAxisScale}),this.xDefaultFormat=(i=>parseFloat(i.toFixed(l))),this.xFormat=h||this.xDefaultFormat,e&&x&&(this.renderLabelX=(()=>{const i=this.xTicks.levelForStep(this.xAxisMinStep);let s="";this.xTicks.ticksAtLevel(i,!1).forEach(i=>{const t=Math.floor(this.valueToPixelX(i))-5,a=this.xFormat(i);s+=`<span style="transform: translateX(${Math.floor(t)}px);">${a}</span>`}),this.axisXConfig.$container.innerHTML=s})),t){const i=Chroma(a).rgb();this.renderX=(()=>{let s,t,a;const e=this.ctx,h=i=>{e.beginPath(),a=this.valueToPixelX(i),e.moveTo(Math.floor(a)+.5,0),e.lineTo(Math.floor(a)+.5,this.canvas.height),e.stroke()};for(let a=this.xTicks.minTickLevel;a<=this.xTicks.maxTickLevel;++a)if((t=this.xTicks.tickRatios[a])>0){e.strokeStyle=`rgba(${i.toString()}, ${3*t})`,s=this.xTicks.ticksAtLevel(a,!0);for(const i of s)h(i)}})}}_initYAxios(){const{lods:i,minScale:s,maxScale:t,lineColor:a,startOffset:e,showLine:h,$container:n,format:l,maxValue:x,precision:o,showLabel:r,minStep:c}=this.axisYConfig,f=x===1/0?this.canvas.height:x||this.canvas.height;this.axisYConfig.realMaxValue=f,this.yAxisOffset=e||0,this.yAxisMinStep=30,this.yTicks=new linear_ticks_1.default,this.yTicks.initTicks(i,.01,f).spacing(10,100),this.yAxisScale=(0,utils_1.clamp)(this.yAxisScale,this.yTicks.minValueScale,this.yTicks.maxValueScale),this.pixelToValueY=(i=>(this.height-i-this.axisMargin+this.yAxisOffset)/this.yAxisScale),this.valueToPixelY=(i=>-i*this.yAxisScale+this.height+this.yAxisOffset-this.axisMargin);const u=this.pixelToValueY(0+this.axisMargin),g=this.pixelToValueY(this.canvas.height-2*this.axisMargin);if(this.yTicks.range(u,g,this.canvas.height-2*this.axisMargin),this.yMaxValue=this.yTicks.maxValue,this.yDefaultFormat=(i=>parseFloat(i.toFixed(o))),this.yFormat=l||this.yDefaultFormat,x){const i=this.checkYInRange(this.axisYConfig.maxValue);this.yTicks.minValueScale=i,this.yAxisScale=i}if(this.transferY=(i=>{if(!this.showY)return 0;const s=this.yAxisOffset+i;return!this.negative&&s<0?0:this.yAxisOffset=s}),n&&r&&(this.renderLabelY=(()=>{const i=this.yTicks.levelForStep(this.yAxisMinStep);let s="";this.yTicks.ticksAtLevel(i,!1).forEach(i=>{const t=Math.floor(this.valueToPixelY(i))-10,a=this.yFormat(i);s+=`<span style="transform: translateY(${Math.floor(t)}px);">${a}</span>`}),this.axisYConfig.$container.innerHTML=s})),h){const i=Chroma(a).rgb();this.renderY=(()=>{let s,t,a;const e=this.ctx,h=i=>{e.beginPath(),a=this.valueToPixelY(i),e.moveTo(0,Math.floor(a)+.5),e.lineTo(this.canvas.width,Math.floor(a)+.5),e.stroke()};for(let a=this.yTicks.minTickLevel;a<=this.yTicks.maxTickLevel;++a)if((t=this.yTicks.tickRatios[a])>0){e.strokeStyle=`rgba(${i.toString()}, ${3*t})`,s=this.yTicks.ticksAtLevel(a,!0);for(const i of s)h(i)}})}this.yAxisScaleAt=function(i,s){const t=this.pixelToValueY(i);this.yAxisScale=(0,utils_1.clamp)(s,this.yTicks.minValueScale,this.yTicks.maxValueScale);const a=this.valueToPixelY(t);return this.transferY(i-a),this.yAxisScale}}}exports.Grid=Grid;