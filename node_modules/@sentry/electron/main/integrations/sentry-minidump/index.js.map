{"version":3,"file":"index.js","sources":["../../../src/src/main/integrations/sentry-minidump/index.ts"],"sourcesContent":["import {\n  applyScopeDataToEvent,\n  captureEvent,\n  defineIntegration,\n  Event,\n  logger,\n  Scope,\n  ScopeData,\n  Session,\n} from '@sentry/core';\nimport { NodeClient } from '@sentry/node';\nimport { app, crashReporter } from 'electron';\n\nimport { addScopeListener, getScopeData } from '../../../common/scope';\nimport { getEventDefaults } from '../../context';\nimport { EXIT_REASONS, getSentryCachePath } from '../../electron-normalize';\nimport { getRendererProperties, trackRendererProperties } from '../../renderers';\nimport { ElectronMainOptions } from '../../sdk';\nimport { previousSessionWasAbnormal, restorePreviousSession, setPreviousSessionAsCurrent } from '../../sessions';\nimport { BufferedWriteStore } from '../../store';\nimport { getMinidumpLoader, MinidumpLoader } from './minidump-loader';\n\ninterface PreviousRun {\n  scope: ScopeData;\n  event?: Event;\n}\n\ninterface Options {\n  /**\n   * Maximum number of minidumps to send per session\n   * Once this number has been reached, no more minidumps will be sent\n   *\n   * default: 10\n   */\n  maxMinidumpsPerSession?: number;\n}\n\n/**\n * Sends minidumps via the Sentry uploader\n */\nexport const sentryMinidumpIntegration = defineIntegration((options: Options = {}) => {\n  // The remaining number of minidumps that can be sent in this session\n  let minidumpsRemaining = options.maxMinidumpsPerSession || 10;\n  // Store to persist context information beyond application crashes.\n  let scopeStore: BufferedWriteStore<PreviousRun> | undefined;\n  // We need to store the scope in a variable here so it can be attached to minidumps\n  let scopeLastRun: Promise<PreviousRun> | undefined;\n  let minidumpLoader: MinidumpLoader | undefined;\n\n  function startCrashReporter(): void {\n    logger.log('Starting Electron crashReporter');\n\n    crashReporter.start({\n      companyName: '',\n      ignoreSystemCrashHandler: true,\n      productName: app.name || app.getName(),\n      // Empty string doesn't work for Linux Crashpad and no submitURL doesn't work for older versions of Electron\n      submitURL: 'https://f.a.k/e',\n      uploadToServer: false,\n      compress: true,\n    });\n  }\n\n  function setupScopeListener(client: NodeClient): void {\n    function scopeChanged(scope: ScopeData): void {\n      // Since the initial scope read is async, we need to ensure that any writes do not beat that\n      // https://github.com/getsentry/sentry-electron/issues/585\n      setImmediate(async () =>\n        scopeStore?.set({\n          scope,\n          event: await getEventDefaults(client),\n        }),\n      );\n    }\n\n    addScopeListener((scope) => {\n      scopeChanged(scope);\n    });\n\n    scopeChanged(getScopeData());\n  }\n\n  async function sendNativeCrashes(\n    client: NodeClient,\n    getEvent: (minidumpProcess: string | undefined) => Event | Promise<Event>,\n  ): Promise<boolean> {\n    // Whenever we are called, assume that the crashes we are going to load down\n    // below have occurred recently. This means, we can use the same event data\n    // for all minidumps that we load now. There are two conditions:\n    //\n    //  1. The application crashed and we are just starting up. The stored\n    //     breadcrumbs and context reflect the state during the application\n    //     crash.\n    //\n    //  2. A renderer process crashed recently and we have just been notified\n    //     about it. Just use the breadcrumbs and context information we have\n    //     right now and hope that the delay was not too long.\n\n    if (minidumpsRemaining <= 0) {\n      logger.log('Not sending minidumps because the limit has been reached');\n    }\n\n    // If the SDK is not enabled, or we've already reached the minidump limit, tell the loader to delete all minidumps\n    const deleteAll = client.getOptions().enabled === false || minidumpsRemaining <= 0;\n\n    let minidumpFound = false;\n\n    await minidumpLoader?.(deleteAll, async (minidumpResult, attachment) => {\n      minidumpFound = true;\n\n      let minidumpProcess = minidumpResult.crashpadAnnotations?.process_type;\n\n      // For backwards compatibility, we need to map 'gpu-process' to 'GPU'\n      // TODO (v7): Remove this\n      if (minidumpProcess === 'gpu-process') {\n        minidumpProcess = 'GPU';\n      }\n\n      const event = await getEvent(minidumpProcess);\n\n      if (minidumpResult.crashpadAnnotations) {\n        // If we have crashpad annotations, we need to prepend their keys with 'crashpad.'\n        // and add them to the Electron context\n        const prependedAnnotations = Object.entries(minidumpResult.crashpadAnnotations).reduce(\n          (acc, [key, val]) => ((acc[`crashpad.${key}`] = val), acc),\n          {} as Record<string, string>,\n        );\n\n        event.contexts = {\n          ...event.contexts,\n          electron: {\n            ...event.contexts?.electron,\n            ...prependedAnnotations,\n          },\n        };\n      }\n\n      if (minidumpsRemaining > 0) {\n        minidumpsRemaining -= 1;\n        captureEvent(event, { attachments: [attachment] });\n      }\n    });\n\n    return minidumpFound;\n  }\n\n  async function sendRendererCrash(\n    client: NodeClient,\n    options: ElectronMainOptions,\n    contents: Electron.WebContents,\n    details: Partial<Electron.RenderProcessGoneDetails>,\n  ): Promise<void> {\n    const { getRendererName } = options;\n\n    await sendNativeCrashes(client, (minidumpProcess) => {\n      // We only call 'getRendererName' if this was in fact a renderer crash\n      const crashedProcess =\n        (minidumpProcess === 'renderer' && getRendererName ? getRendererName(contents) : minidumpProcess) || 'unknown';\n\n      logger.log(`'${crashedProcess}' process '${details.reason}'`);\n\n      return {\n        contexts: {\n          electron: {\n            crashed_url: getRendererProperties(contents.id)?.url || 'unknown',\n            details,\n          },\n        },\n        level: 'fatal',\n        // The default is javascript\n        platform: 'native',\n        tags: {\n          'event.environment': 'native',\n          'event.process': crashedProcess,\n          'exit.reason': details.reason,\n        },\n      };\n    });\n  }\n\n  async function sendChildProcessCrash(client: NodeClient, details: Omit<Electron.Details, 'exitCode'>): Promise<void> {\n    logger.log(`${details.type} process has ${details.reason}`);\n\n    await sendNativeCrashes(client, (minidumpProcess) => ({\n      contexts: {\n        electron: { details },\n      },\n      level: 'fatal',\n      // The default is javascript\n      platform: 'native',\n      tags: {\n        'event.environment': 'native',\n        'event.process': minidumpProcess || details.type,\n        'exit.reason': details.reason,\n        event_type: 'native',\n      },\n    }));\n  }\n\n  return {\n    name: 'SentryMinidump',\n    setup(client: NodeClient): void {\n      // Mac AppStore builds cannot run the crash reporter due to the sandboxing\n      // requirements. In this case, we prevent enabling native crashes entirely.\n      // https://electronjs.org/docs/tutorial/mac-app-store-submission-guide#limitations-of-mas-build\n      if (process.mas) {\n        return;\n      }\n\n      startCrashReporter();\n\n      scopeStore = new BufferedWriteStore<PreviousRun>(getSentryCachePath(), 'scope_v3', {\n        scope: new Scope().getScopeData(),\n      });\n      scopeLastRun = scopeStore.get();\n\n      try {\n        minidumpLoader = getMinidumpLoader();\n      } catch (error) {\n        // This is rare but we've seen reports:\n        // https://github.com/getsentry/sentry-electron/issues/1102\n        logger.error('Failed to create minidump loader', error);\n      }\n\n      const options = client.getOptions();\n\n      setupScopeListener(client);\n\n      if (!options?.dsn) {\n        throw new Error('Attempted to enable Electron native crash reporter but no DSN was supplied');\n      }\n\n      trackRendererProperties();\n\n      app.on('render-process-gone', async (_, contents, details) => {\n        if (EXIT_REASONS.includes(details.reason)) {\n          await sendRendererCrash(client, options, contents, details);\n        }\n      });\n      app.on('child-process-gone', async (_, details) => {\n        if (EXIT_REASONS.includes(details.reason)) {\n          await sendChildProcessCrash(client, details);\n        }\n      });\n\n      let sessionToRestore: Session | undefined;\n\n      // Start to submit recent minidump crashes. This will load breadcrumbs and\n      // context information that was cached on disk in the previous app run, prior to the crash.\n      sendNativeCrashes(client, async (minidumpProcess) => {\n        const event: Event = {\n          level: 'fatal',\n          platform: 'native',\n          tags: {\n            'event.environment': 'native',\n            'event.process': minidumpProcess || 'unknown',\n          },\n        };\n\n        // This crash was found at startup, we need to apply the scope and context from the previous run\n        const previousRun = await scopeLastRun;\n        if (previousRun) {\n          if (previousRun.scope) {\n            applyScopeDataToEvent(event, previousRun.scope);\n          }\n\n          event.release = previousRun.event?.release;\n          event.environment = previousRun.event?.environment;\n          event.contexts = previousRun.event?.contexts;\n        }\n\n        sessionToRestore = await setPreviousSessionAsCurrent();\n\n        return event;\n      })\n        .then(async (minidumpsFound) => {\n          if (!minidumpsFound) {\n            await previousSessionWasAbnormal();\n          } else if (sessionToRestore) {\n            restorePreviousSession(sessionToRestore);\n          }\n        })\n        .catch((error) => logger.error(error));\n    },\n  };\n});\n"],"names":["defineIntegration","minidumpLoader","logger","crashReporter","app","getEventDefaults","addScopeListener","getScopeData","captureEvent","getRendererProperties","BufferedWriteStore","getSentryCachePath","Scope","getMinidumpLoader","trackRendererProperties","EXIT_REASONS","applyScopeDataToEvent","setPreviousSessionAsCurrent","previousSessionWasAbnormal","restorePreviousSession"],"mappings":"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"}