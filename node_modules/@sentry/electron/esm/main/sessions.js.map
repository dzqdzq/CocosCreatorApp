{"version":3,"file":"sessions.js","sources":["../../src/main/sessions.ts"],"sourcesContent":["import {\n  captureSession,\n  endSession as endSessionCore,\n  getClient,\n  getIsolationScope,\n  logger,\n  makeSession,\n  SerializedSession,\n  Session,\n  SessionContext,\n  SessionStatus,\n  startSession as startSessionCore,\n  updateSession,\n} from '@sentry/core';\nimport { flush, NodeClient } from '@sentry/node';\nimport { app } from 'electron';\n\nimport { getSentryCachePath } from './electron-normalize';\nimport { Store } from './store';\n\nconst PERSIST_INTERVAL_MS = 60_000;\n\n/** Stores the app session in case of termination due to main process crash or app killed */\nlet sessionStore: Store<SessionContext | undefined> | undefined;\n/** Previous session if it did not exit cleanly */\nlet previousSession: Promise<Partial<Session> | undefined> | undefined;\n\nfunction getSessionStore(): Store<SessionContext | undefined> {\n  if (!sessionStore) {\n    sessionStore = new Store<SessionContext | undefined>(getSentryCachePath(), 'session', undefined);\n    previousSession = sessionStore.get().then((sesh) => (sesh ? makeSession(sesh) : sesh));\n  }\n\n  return sessionStore;\n}\n\n/** Copies a session and removes the toJSON function so it can be serialised without conversion */\nfunction makeSessionSafeToSerialize(session: Session): Session {\n  const copy = { ...session };\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n  delete (copy as any).toJSON;\n  return copy;\n}\n\nlet persistTimer: ReturnType<typeof setInterval> | undefined;\n\n/** Starts a session */\nexport function startSession(sendOnCreate: boolean): void {\n  const session = startSessionCore();\n\n  if (sendOnCreate) {\n    captureSession();\n  }\n\n  getSessionStore()\n    .set(makeSessionSafeToSerialize(session))\n    .catch(() => {\n      // Does not throw\n    });\n\n  // Every PERSIST_INTERVAL, write the session to disk\n  persistTimer = setInterval(async () => {\n    const currentSession = getIsolationScope().getSession();\n    // Only bother saving if it hasn't already ended\n    if (currentSession && currentSession.status === 'ok') {\n      await getSessionStore().set(makeSessionSafeToSerialize(currentSession));\n    }\n  }, PERSIST_INTERVAL_MS);\n}\n\n/** Cleanly ends a session */\nexport async function endSession(): Promise<void> {\n  // Once the session had ended there is no point persisting it\n  if (persistTimer) {\n    clearInterval(persistTimer);\n  }\n\n  const session = getIsolationScope().getSession();\n\n  if (session) {\n    if (session.status === 'ok') {\n      logger.log('Ending session');\n      endSessionCore();\n    } else {\n      logger.log('Session was already ended');\n    }\n  } else {\n    logger.log('No session');\n  }\n\n  await getSessionStore().clear();\n\n  await flush(2_000);\n}\n\n/** Determines if a Date is likely to have occurred in the previous uncompleted session */\nexport async function unreportedDuringLastSession(crashDate: Date | undefined): Promise<boolean> {\n  if (!crashDate) {\n    return false;\n  }\n\n  const previousSessionModified = await getSessionStore().getModifiedDate();\n  // There is no previous session\n  if (previousSessionModified === undefined) {\n    return false;\n  }\n\n  const previousSessionModifiedTime = previousSessionModified.getTime();\n  const crashTime = crashDate.getTime();\n\n  // Session could have run until modified time + persist interval\n  const prevSessionEnd = previousSessionModifiedTime + PERSIST_INTERVAL_MS;\n\n  // Event cannot have occurred before last persist time, We add a 2 second overlap to be sure\n  const lastPersist = previousSessionModifiedTime - 2_000;\n\n  // If the crash occurred between the last persist and estimated end of session\n  return crashTime > lastPersist && crashTime < prevSessionEnd;\n}\n\n/** Sets the previous session as the current session and returns any existing session */\nexport async function setPreviousSessionAsCurrent(): Promise<Session | undefined> {\n  const previous = await previousSession;\n\n  const scope = getIsolationScope();\n  const currentSession = scope.getSession();\n\n  if (previous) {\n    previousSession = undefined;\n\n    if (previous.status === 'ok') {\n      scope.setSession(makeSession(previous));\n    }\n  }\n\n  return currentSession;\n}\n\n/** Restores a session */\nexport function restorePreviousSession(session: Session): void {\n  getIsolationScope().setSession(session);\n}\n\n/** Report the previous session as abnormal */\nexport async function previousSessionWasAbnormal(): Promise<void> {\n  const client = getClient<NodeClient>();\n\n  const previous = await previousSession;\n\n  if (previous && client) {\n    // Ignore if the previous session is already ended\n    if (previous.status !== 'ok') {\n      previousSession = undefined;\n      return;\n    }\n\n    logger.log(`Found previous abnormal session`);\n\n    const sesh = makeSession(previous);\n\n    updateSession(sesh, {\n      status: 'abnormal',\n      errors: (sesh.errors || 0) + 1,\n      release: (previous as unknown as SerializedSession).attrs?.release,\n      environment: (previous as unknown as SerializedSession).attrs?.environment,\n    });\n\n    await client.sendSession(sesh);\n\n    previousSession = undefined;\n  }\n}\n\n/** Checks if the previous session needs sending as crashed or abnormal  */\nexport async function checkPreviousSession(crashed: boolean): Promise<void> {\n  const client = getClient<NodeClient>();\n\n  const previous = await previousSession;\n\n  if (previous && client) {\n    // Ignore if the previous session is already ended\n    if (previous.status !== 'ok') {\n      previousSession = undefined;\n      return;\n    }\n\n    const status: SessionStatus = crashed ? 'crashed' : 'abnormal';\n\n    logger.log(`Found previous ${status} session`);\n\n    const sesh = makeSession(previous);\n\n    updateSession(sesh, {\n      status,\n      errors: (sesh.errors || 0) + 1,\n      release: (previous as unknown as SerializedSession).attrs?.release,\n      environment: (previous as unknown as SerializedSession).attrs?.environment,\n    });\n\n    await client.sendSession(sesh);\n\n    previousSession = undefined;\n  }\n}\n\n/** Sets the current session as crashed */\nexport function sessionCrashed(): void {\n  // stop persisting session\n  if (persistTimer) {\n    clearInterval(persistTimer);\n  }\n\n  logger.log('Session Crashed');\n  const session = getIsolationScope().getSession();\n\n  if (!session) {\n    logger.log('No session to update');\n    return;\n  }\n\n  if (session.status === 'ok') {\n    logger.log('Setting session as crashed');\n    const errors = session.errors + 1;\n    updateSession(session, { status: 'crashed', errors });\n    captureSession();\n  } else {\n    logger.log('Session already ended');\n  }\n}\n\n/** Sets the current session as ANR */\nexport function sessionAnr(): void {\n  // stop persisting session\n  if (persistTimer) {\n    clearInterval(persistTimer);\n  }\n\n  const session = getIsolationScope().getSession();\n\n  if (!session) {\n    return;\n  }\n\n  if (session.status === 'ok') {\n    logger.log('Setting session as abnormal ANR');\n    updateSession(session, { status: 'abnormal', abnormal_mechanism: 'anr_foreground' });\n    captureSession();\n  }\n}\n\n/**\n * End the current session on app exit\n */\nexport function endSessionOnExit(): void {\n  // 'before-quit' is always called before 'will-quit' so we listen there and ensure our 'will-quit' handler is still\n  // the last listener\n  app.on('before-quit', () => {\n    // We track the end of sessions via the 'will-quit' event which is the last event emitted before close.\n    //\n    // We need to be the last 'will-quit' listener so as not to interfere with any user defined listeners which may\n    // call `event.preventDefault()` to abort the exit.\n    app.removeListener('will-quit', exitHandler);\n    app.on('will-quit', exitHandler);\n  });\n}\n\n/** Handles the exit */\nconst exitHandler: (event: Electron.Event) => Promise<void> = async (event: Electron.Event) => {\n  if (event.defaultPrevented) {\n    return;\n  }\n\n  logger.log('[Session] Exit Handler');\n\n  // Stop the exit so we have time to send the session\n  event.preventDefault();\n\n  try {\n    // End the session\n    await endSession();\n  } catch (e) {\n    // Ignore and log any errors which would prevent app exit\n    logger.warn('[Session] Error ending session:', e);\n  }\n\n  app.exit();\n};\n"],"names":["startSessionCore","endSessionCore"],"mappings":"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"}