'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var url = require('url');
var smob = require('smob');
var jestWorker = require('jest-worker');
var serializeJavascript = require('serialize-javascript');
var terser$1 = require('terser');

var _documentCurrentScript = typeof document !== 'undefined' ? document.currentScript : null;
// eslint-disable-next-line no-eval
const eval2 = eval;
async function transform(code, options) {
    const result = await terser$1.minify(code, options);
    const output = {
        code: result.code || code,
        nameCache: options.nameCache
    };
    if (typeof result.map === 'string') {
        output.sourceMap = JSON.parse(result.map);
    }
    if (smob.isObject(result.map)) {
        output.sourceMap = result.map;
    }
    return output;
}
async function runWorker(code, optionsString) {
    const options = eval2(`(${optionsString})`);
    return transform(code, options);
}

/* eslint-disable no-console */
function terser(input = {}) {
    const { maxWorkers, ...options } = input;
    const useWorker = maxWorkers === undefined || maxWorkers > 0;
    let worker;
    let numOfChunks = 0;
    const currentScriptURL = typeof __filename !== 'undefined' ? url.pathToFileURL(__filename) : (typeof document === 'undefined' ? require('u' + 'rl').pathToFileURL(__filename).href : (_documentCurrentScript && _documentCurrentScript.tagName.toUpperCase() === 'SCRIPT' && _documentCurrentScript.src || new URL('index.js', document.baseURI).href));
    return {
        name: 'terser',
        async renderChunk(code, chunk, outputOptions) {
            if (!worker && useWorker) {
                worker = new jestWorker.Worker(url.fileURLToPath(currentScriptURL), {
                    numWorkers: maxWorkers
                });
                const stdout = worker.getStdout();
                const stderr = worker.getStderr();
                stdout.on('data', (data) => {
                    console.log(`[Terser Worker stdout]: ${data}`);
                });
                stderr.on('data', (data) => {
                    console.error(`[Terser Worker stderr]: ${data}`);
                });
                numOfChunks = 0;
            }
            numOfChunks += 1;
            const defaultOptions = {
                sourceMap: outputOptions.sourcemap === true || typeof outputOptions.sourcemap === 'string'
            };
            if (outputOptions.format === 'es') {
                defaultOptions.module = true;
            }
            if (outputOptions.format === 'cjs') {
                defaultOptions.toplevel = true;
            }
            try {
                let output;
                const mergedOptions = smob.merge({}, options || {}, defaultOptions);
                if (useWorker && worker) {
                    output = await worker.runWorker(code, serializeJavascript(mergedOptions));
                }
                else {
                    output = await transform(code, mergedOptions);
                }
                const { code: result, nameCache, sourceMap } = output;
                if (options.nameCache && nameCache) {
                    let vars = {
                        props: {}
                    };
                    if (smob.hasOwnProperty(options.nameCache, 'vars') && smob.isObject(options.nameCache.vars)) {
                        vars = smob.merge({}, options.nameCache.vars || {}, vars);
                    }
                    if (smob.hasOwnProperty(nameCache, 'vars') && smob.isObject(nameCache.vars)) {
                        vars = smob.merge({}, nameCache.vars, vars);
                    }
                    // eslint-disable-next-line no-param-reassign
                    options.nameCache.vars = vars;
                    let props = {};
                    if (smob.hasOwnProperty(options.nameCache, 'props') && smob.isObject(options.nameCache.props)) {
                        // eslint-disable-next-line prefer-destructuring
                        props = options.nameCache.props;
                    }
                    if (smob.hasOwnProperty(nameCache, 'props') && smob.isObject(nameCache.props)) {
                        props = smob.merge({}, nameCache.props, props);
                    }
                    // eslint-disable-next-line no-param-reassign
                    options.nameCache.props = props;
                }
                if ((!!defaultOptions.sourceMap || !!options.sourceMap) && smob.isObject(sourceMap)) {
                    return {
                        code: result,
                        map: sourceMap
                    };
                }
                return result;
            }
            catch (e) {
                return Promise.reject(e);
            }
            finally {
                numOfChunks -= 1;
                if (numOfChunks === 0 && worker) {
                    const { forceExited } = await worker.end();
                    if (forceExited) {
                        console.error('Workers failed to exit gracefully');
                    }
                    worker = null;
                }
            }
        }
    };
}

exports.default = terser;
exports.runWorker = runWorker;
exports.transform = transform;
module.exports = Object.assign(exports.default, exports);
//# sourceMappingURL=index.js.map
