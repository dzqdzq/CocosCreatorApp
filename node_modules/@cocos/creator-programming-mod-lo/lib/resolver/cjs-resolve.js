"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.cjsResolve = void 0;
const resolve_1 = __importDefault(require("resolve"));
const url_1 = require("url");
const path_1 = __importDefault(require("path"));
const url_2 = require("@cocos/creator-programming-common/lib/url");
const resolve_error_1 = require("./resolve-error");
const asserts_1 = require("@cocos/creator-programming-common/lib/asserts");
const node_builtins_1 = require("../utils/node-builtins");
function cjsResolve(specifier, parentURL) {
    if (!(0, url_2.hasFileProtocol)(parentURL)) {
        throw new resolve_error_1.CjsModuleNotFileError(parentURL);
    }
    const parentPath = (0, url_1.fileURLToPath)(parentURL);
    const basedir = path_1.default.dirname(parentPath);
    const resolveOpts = {
        basedir,
        includeCoreModules: false,
    };
    let resolvedUrl;
    try {
        const resolvedId = resolve_1.default.sync(specifier, resolveOpts);
        (0, asserts_1.asserts)(resolvedId);
        resolvedUrl = (0, url_1.pathToFileURL)(resolvedId);
    }
    catch (err) {
        if ((0, node_builtins_1.isNodeJsBuiltinModule)(specifier)) {
            resolvedUrl = new url_1.URL((0, node_builtins_1.toNodeProtocolUrl)(specifier));
        }
        else {
            throw new resolve_error_1.ModuleNotFoundError(specifier, parentURL);
        }
    }
    return resolvedUrl;
}
exports.cjsResolve = cjsResolve;
//# sourceMappingURL=cjs-resolve.js.map