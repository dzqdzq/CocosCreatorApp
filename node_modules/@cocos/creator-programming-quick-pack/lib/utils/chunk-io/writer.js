"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ChunkWriter = void 0;
const base_1 = require("./base");
const path_1 = __importDefault(require("path"));
const fs_extra_1 = __importDefault(require("fs-extra"));
const asserts_1 = require("@cocos/creator-programming-common/lib/asserts");
const crypto_1 = __importDefault(require("crypto"));
const fs_utils_1 = require("../fs-utils");
const { QUICK_PACK_TEST_MODULE_URL_HASH_TRANSFORMER } = globalThis;
class ChunkWriter extends base_1.ChunkIOBase {
    constructor({ chunkHomePath: sourceCacheDir, importMapPath, resolutionDetailMapPath, logger, }) {
        super({ chunkHomePath: sourceCacheDir });
        this._logger = logger;
        this._importMapPath = importMapPath;
        this._importMapPathTemp = importMapPath + '.tmp';
        this._resolutionDetailMapPath = resolutionDetailMapPath;
        this._resolutionDetailMapPathTemp = resolutionDetailMapPath + '.tmp';
    }
    async persistToTempFiles() {
        // Remove temp files if they exist.
        this.deleteTempFiles();
        return this._writeMapsToTempFiles();
    }
    renameTempFiles() {
        try {
            if (fs_extra_1.default.statSync(this._importMapPathTemp).isFile()) {
                fs_extra_1.default.renameSync(this._importMapPathTemp, this._importMapPath);
            }
            else {
                console.error(`[ChunkWriter.renameTempFiles], temp file (${this._importMapPathTemp}) doesn't exist`);
            }
            if (fs_extra_1.default.statSync(this._resolutionDetailMapPathTemp).isFile()) {
                fs_extra_1.default.renameSync(this._resolutionDetailMapPathTemp, this._resolutionDetailMapPath);
            }
            else {
                console.error(`[ChunkWriter.renameTempFiles], temp file (${this._resolutionDetailMapPathTemp}) doesn't exist`);
            }
            return true;
        }
        catch (e) {
            console.error(`[ChunkWriter.renameTempFiles] failed: ${e}, ${e.stack}`);
        }
        return false;
    }
    deleteTempFiles() {
        try {
            if (fs_extra_1.default.pathExistsSync(this._importMapPathTemp)) {
                fs_extra_1.default.unlinkSync(this._importMapPathTemp);
            }
            if (fs_extra_1.default.pathExistsSync(this._resolutionDetailMapPathTemp)) {
                fs_extra_1.default.unlinkSync(this._resolutionDetailMapPathTemp);
            }
            return true;
        }
        catch (e) {
            console.error(`[ChunkWriter.deleteTempFiles] failed: ${e}, ${e.stack}`);
        }
        return false;
    }
    clear() {
        const importMapPath = this._importMapPath;
        try {
            fs_extra_1.default.unlinkSync(importMapPath);
        }
        catch (err) {
            this._logger.debug(`Failed to delete import map at ${importMapPath}: ${err}`);
        }
        super.clear();
    }
    getChunk(id) {
        return this._build.chunks[id];
    }
    addChunk(moduleURL, code, map) {
        const chunkId = this._generateChunkId(moduleURL, code);
        const chunkCodeFilePath = this._calculateChunkCodeFileName(chunkId);
        const timestamp = Date.now();
        this._build.chunks[chunkId] = {
            imports: {},
            timestamp,
        };
        // const metadataCacheFile = this._getMetadataCacheFile(qpLocation);
        let sourceMappingURL;
        let serializedMap;
        if (map) {
            serializedMap = typeof map === 'string'
                ? map
                : JSON.stringify(map);
            sourceMappingURL = `${path_1.default.basename(chunkCodeFilePath)}.map`;
        }
        const codeWithMap = sourceMappingURL
            ? `${code}\n//# sourceMappingURL=${sourceMappingURL}`
            : code;
        // Write metadata
        // fs.outputFile(metadataCacheFile, JSON.stringify(metadata, undefined, 2), { encoding: 'utf8' }),
        // Write code
        fs_extra_1.default.outputFileSync(chunkCodeFilePath, codeWithMap, { encoding: 'utf8' });
        // Write map
        if (serializedMap) {
            fs_extra_1.default.outputFileSync(`${chunkCodeFilePath}.map`, serializedMap, { encoding: 'utf8' });
        }
        return chunkId;
    }
    removeChunk(id) {
        delete this._build.chunks[id];
    }
    setEntryChunks(entryChunks) {
        this._build.entries = entryChunks;
    }
    _generateChunkId(moduleURL, code) {
        const shasum = crypto_1.default.createHash('sha1');
        let hashInput = moduleURL.href;
        if (typeof QUICK_PACK_TEST_MODULE_URL_HASH_TRANSFORMER === 'function') {
            hashInput = QUICK_PACK_TEST_MODULE_URL_HASH_TRANSFORMER(hashInput);
        }
        shasum.update(hashInput);
        const hash = shasum.digest('hex');
        (0, asserts_1.asserts)(hash.length === 40);
        return hash;
    }
    async _writeMapsToTempFiles() {
        const { importMap, resolutionDetailMap: resolutionDetailMap, } = this._buildMaps(this._importMapPath, this._resolutionDetailMapPath);
        return Promise.all([
            (0, fs_utils_1.outputJson)(this._importMapPathTemp, importMap, { spaces: 2, encoding: 'utf8', }),
            (0, fs_utils_1.outputJson)(this._resolutionDetailMapPathTemp, resolutionDetailMap, { spaces: 2, encoding: 'utf8', })
        ]);
    }
    _buildMaps(importMapFilePath, resolutionDetailMapFilePath) {
        const { chunks, entries, } = this._build;
        const resolutionDetailMap = {};
        const importMapRelate = path_1.default.dirname(importMapFilePath);
        const relativeChunkHome = path_1.default.relative(importMapRelate, this._chunkHomePath);
        const resolutionDetailMapRelate = path_1.default.dirname(resolutionDetailMapFilePath);
        const relativeDetailMapHome = path_1.default.relative(resolutionDetailMapRelate, this._chunkHomePath);
        const getChunkRelativePathFromImportMap = (chunkId) => {
            // Can happen when reload A -> B
            // A is unchanged, but can not load B(since `forceAll: true`)
            // A's dep records are not clear
            (0, asserts_1.asserts)(chunkId in chunks, 'Something went wrong: module A depends on B, but B is not correctly generated.');
            const chunkSourcePath = this.calculateChunkCodeFileRelativePath(chunkId);
            const relativePath = relativeChunkHome + '/' + chunkSourcePath;
            return `./${relativePath}`;
        };
        const getChunkRelativePathFromResolutionDetailMap = (chunkId) => {
            // Can happen when reload A -> B
            // A is unchanged, but can not load B(since `forceAll: true`)
            // A's dep records are not clear
            (0, asserts_1.asserts)(chunkId in chunks, 'Something went wrong: module A depends on B, but B is not correctly generated.');
            const chunkSourcePath = this.calculateChunkCodeFileRelativePath(chunkId);
            const relativePath = relativeDetailMapHome + '/' + chunkSourcePath;
            return `./${relativePath}`;
        };
        const importMap = {};
        importMap.imports = {};
        const imports = importMap.imports;
        const entriesArr = Object.entries(entries);
        const entriesLength = entriesArr.length;
        const involvedModules = new Array(entriesLength);
        let entryIndex = 0;
        for (const [alias, chunkId] of entriesArr) {
            imports[alias] = getChunkRelativePathFromImportMap(chunkId);
            involvedModules[entryIndex] = chunkId;
            ++entryIndex;
        }
        importMap.scopes = {};
        const scopes = importMap.scopes;
        const visited = new Set();
        while (involvedModules.length !== 0) {
            const chunkId = involvedModules.pop();
            if (visited.has(chunkId)) {
                continue;
            }
            visited.add(chunkId);
            if (!(chunkId in chunks)) {
                this._logger.debug(`Chunk ${chunkId} is absent. Skipped it.`);
                continue;
            }
            const chunk = chunks[chunkId];
            const importsEntries = Object.entries(chunk.imports);
            if (importsEntries.length === 0) {
                continue;
            }
            const chunkPathFromImportMap = getChunkRelativePathFromImportMap(chunkId);
            const specifierMap = scopes[chunkPathFromImportMap] = {};
            const chunkPathFromResolutionDetailMap = getChunkRelativePathFromResolutionDetailMap(chunkId);
            for (const [specifier, { resolved, messages }] of importsEntries) {
                const getOrCreateResolutionDetail = () => { var _a, _b; var _c; return (_b = (_c = ((_a = resolutionDetailMap[chunkPathFromResolutionDetailMap]) !== null && _a !== void 0 ? _a : (resolutionDetailMap[chunkPathFromResolutionDetailMap] = {})))[specifier]) !== null && _b !== void 0 ? _b : (_c[specifier] = {}); };
                if (resolved.type === 'chunk') {
                    specifierMap[specifier] = getChunkRelativePathFromImportMap(resolved.id);
                    involvedModules.push(resolved.id);
                }
                else if (resolved.type === 'external') {
                    specifierMap[specifier] = resolved.specifierOrURL;
                }
                else if (resolved.type === 'error') {
                    getOrCreateResolutionDetail().error = resolved.text;
                }
                if (messages.length !== 0) {
                    getOrCreateResolutionDetail().messages = messages.slice();
                }
            }
        }
        return {
            importMap,
            resolutionDetailMap,
        };
    }
}
exports.ChunkWriter = ChunkWriter;
//# sourceMappingURL=writer.js.map