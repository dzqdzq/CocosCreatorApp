"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.EngineBuilder = void 0;
const fs = __importStar(require("fs-extra"));
const ps = __importStar(require("path"));
const babel = __importStar(require("@babel/core"));
// @ts-ignore
const plugin_syntax_typescript_1 = __importDefault(require("@babel/plugin-syntax-typescript"));
// @ts-ignore
const plugin_syntax_decorators_1 = __importDefault(require("@babel/plugin-syntax-decorators"));
const traverse_1 = __importDefault(require("@babel/traverse"));
const stats_query_1 = require("../../stats-query");
const path_utils_1 = require("../../stats-query/path-utils");
const json5 = __importStar(require("json5"));
const eslint_1 = require("eslint");
const dedent_1 = __importDefault(require("dedent"));
const glob_1 = require("glob");
var t = babel.types;
const field_decorator_helper_1 = require("./field-decorator-helper");
const external_wasm_loader_1 = require("./plugins/external-wasm-loader");
class EngineBuilder {
    constructor() {
        this._entries = [];
        this._entriesForPass2 = new Set();
        this._virtual2code = {};
        this._feature2NodeModule = {
            'dragon-bones': '@cocos/dragonbones-js',
            'physics-2d-box2d': '@cocos/box2d',
            'physics-cannon': '@cocos/cannon',
            'physics-physx': '@cocos/physx',
            'physics-ammo': '@cocos/bullet',
        };
        this._nodeModules = [];
        this._virtualOverrides = {};
        this._buildResult = {};
        this._resolveExtension = ['.ts', '.js', '.json']; // not an option
        // TODO: for now OH global interface conflict with Rect and Path, struct
        // so we need to rename them.
        this._renameMap = {
            Rect: 'RectAlias',
            Path: 'PathAlias',
            struct: 'structAlias',
        };
        this._filedDecoratorHelper = new field_decorator_helper_1.FiledDecoratorHelper();
        this._plugins = [];
        this._excludeTransform = [
            /external\:/
        ];
    }
    build(options) {
        return __awaiter(this, void 0, void 0, function* () {
            const { root } = options;
            this._buildResult = {};
            const handleIdList = (idList) => {
                for (let id of idList) {
                    const handleResult = this._handleId(id);
                    this._buildResult[handleResult.file] = handleResult;
                }
            };
            // pass1: build ts for native engine
            console.log('[Build Engine]: pass1 - traverse and compile modules');
            console.time('pass1');
            this._initPlugins(options);
            yield this._initOptions(options);
            handleIdList(this._entries);
            console.timeEnd('pass1');
            // pass2: build web version for jsb type declarations
            console.log('[Build Engine]: pass2 - apply jsb interface info');
            console.time('pass2');
            while (this._entriesForPass2.size !== 0) {
                const entries2 = Array.from(this._entriesForPass2);
                this._entriesForPass2.clear();
                this._moduleOverrides = Object.entries(this._moduleOverrides).reduce((result, [k, v]) => {
                    if (!fs.existsSync(k) || !entries2.includes(k)) {
                        result[k] = v;
                    }
                    return result;
                }, {});
                handleIdList(entries2);
            }
            console.timeEnd('pass2');
            if (options.outDir) {
                for (let file in this._buildResult) {
                    const res = this._buildResult[file];
                    const output = ps.join(options.outDir, ps.relative(root, file));
                    fs.outputFileSync(output, res.code, 'utf8');
                }
                // pass3: post handle to lint import
                console.log('[Build Engine]: pass3 - linting import statement');
                console.time('pass3');
                yield this._lintImport([
                    (0, path_utils_1.normalizePath)(ps.join(options.outDir, '**/*.ts'))
                ]);
                console.timeEnd('pass3');
                this._buildIndex();
                yield this._copyTypes();
                // this._addNodeModulesDeps();  // TODO: support node modules building
            }
            return this._buildResult;
        });
    }
    _initPlugins(options) {
        this._plugins.push((0, external_wasm_loader_1.externalWasmLoaderFactory)({
            engineRoot: options.root,
        }));
    }
    _initOptions(options) {
        return __awaiter(this, void 0, void 0, function* () {
            this._options = options;
            const { root, flagConfig, platform, mode } = options;
            const statsQuery = yield stats_query_1.StatsQuery.create(root);
            const constantManager = statsQuery.constantManager;
            if (options.features) {
                const featureUnits = statsQuery.getUnitsOfFeatures(options.features);
                this._entries = featureUnits.map(fu => (0, path_utils_1.normalizePath)(statsQuery.getFeatureUnitFile(fu)));
                options.features.forEach(feature => {
                    const nodeModule = this._feature2NodeModule[feature];
                    nodeModule && this._nodeModules.push(nodeModule);
                });
            }
            else {
                const featureUnits = statsQuery.getFeatureUnits();
                this._entries = featureUnits.map(fu => (0, path_utils_1.normalizePath)(statsQuery.getFeatureUnitFile(fu)));
                this._nodeModules.push(...Object.values(this._feature2NodeModule));
            }
            this._buildTimeConstants = constantManager.genBuildTimeConstants({
                platform,
                mode,
                flags: flagConfig,
            });
            this._moduleOverrides = statsQuery.evaluateModuleOverrides({
                mode: options.mode,
                platform: options.platform,
                buildTimeConstants: this._buildTimeConstants,
            });
            this._moduleOverrides = Object.entries(this._moduleOverrides).reduce((result, [k, v]) => {
                result[(0, path_utils_1.normalizePath)(k)] = (0, path_utils_1.normalizePath)(v);
                return result;
            }, {});
            // paths in tsconfig.json 
            const tsconfigFile = ps.join(root, './tsconfig.json');
            if (fs.existsSync(tsconfigFile)) {
                const tsconfigContent = fs.readFileSync(tsconfigFile, 'utf8');
                const tsconfig = json5.parse(tsconfigContent);
                const compilerOptions = tsconfig.compilerOptions;
                if (compilerOptions && compilerOptions.baseUrl && compilerOptions.paths) {
                    for (let [key, paths] of Object.entries(compilerOptions.paths)) {
                        this._moduleOverrides[key] = (0, path_utils_1.normalizePath)(ps.join(ps.dirname(tsconfigFile), compilerOptions.baseUrl, paths[0]));
                    }
                }
            }
            this._virtual2code['internal:constants'] = constantManager.exportStaticConstants({
                platform,
                mode,
                flags: flagConfig,
            });
            this._virtual2code[this._filedDecoratorHelper.getModuleName()] = this._filedDecoratorHelper.genModuleSource();
            // TODO: resolve node modules
            this._virtual2code['@cocos/box2d'] = 'export {}';
            this._virtual2code['@cocos/bullet'] = 'export {}';
            this._virtual2code['@cocos/cannon'] = 'export {}';
            for (let virtualName in this._virtual2code) {
                this._virtualOverrides[virtualName] = (0, path_utils_1.normalizePath)(ps.join(root, '__virtual__', virtualName.replace(/:/g, '_'))) + '.ts';
            }
        });
    }
    _handleId(id, importer) {
        const resolvedId = this._resolve(id, importer);
        if (typeof resolvedId === 'undefined') {
            throw new Error(`Cannot resolve module id: ${id} ${importer ? `in file ${importer}` : ''}`);
        }
        const code = this._load(resolvedId);
        if (typeof code === 'undefined') {
            throw new Error(`Cannot load module: ${resolvedId} ${importer ? `in file ${importer}` : ''}`);
        }
        let overrideId = this._getOverrideId(id, importer);
        // handle output file
        let file = overrideId || resolvedId;
        if (file.endsWith('.json')) {
            file = file.slice(0, -5) + '.ts';
        }
        if (this._buildResult[file]) {
            // skip cached file
            return this._buildResult[file];
        }
        const transformResult = this._transform(resolvedId, code);
        const handleResult = this._buildResult[file] = {
            code: transformResult.code,
            file,
            originalId: id,
            resolvedId,
            map: transformResult.map,
        };
        transformResult.depIdList.forEach(id => {
            const handleResult = this._handleId(id, file);
            this._buildResult[handleResult.file] = handleResult;
        });
        return handleResult;
    }
    _getOverrideId(id, importer) {
        var _a;
        let overrideId;
        for (let p of this._plugins) {
            overrideId = (_a = p.transformId) === null || _a === void 0 ? void 0 : _a.call(p, id, importer);
            if (overrideId) {
                return overrideId;
            }
        }
        if (id in this._virtualOverrides) {
            overrideId = this._virtualOverrides[id];
        }
        else if (id in this._moduleOverrides) {
            overrideId = this._moduleOverrides[id];
        }
        else if (!ps.isAbsolute(id) && importer) {
            const absolutePath = this._resolveRelative(id, importer);
            if (absolutePath && this._moduleOverrides[absolutePath] === importer) {
                this._entriesForPass2.add(absolutePath); // for next pass
                return;
            }
            if (absolutePath && absolutePath in this._moduleOverrides) {
                overrideId = this._moduleOverrides[absolutePath];
            }
        }
        return overrideId;
    }
    _resolve(id, importer) {
        var _a, _b;
        for (let p of this._plugins) {
            const resolvedId = (_a = p.resolve) === null || _a === void 0 ? void 0 : _a.call(p, id, importer);
            if (resolvedId) {
                return resolvedId;
            }
        }
        if (!importer) {
            return id; // entry
        }
        else if (id in this._virtualOverrides) {
            return id; // virtual module does not have real fs path
        }
        else if (id in this._moduleOverrides) {
            return this._moduleOverrides[id];
        }
        else if (this._nodeModules.includes(id)) {
            return id; // node module only use bare specifier as module id
        }
        else if (ps.isAbsolute(id)) {
            return id;
        }
        else {
            const resolved = this._resolveRelative(id, importer);
            if (resolved) {
                return (_b = this._moduleOverrides[resolved]) !== null && _b !== void 0 ? _b : resolved;
            }
        }
    }
    _resolveRelative(id, importer) {
        const file = (0, path_utils_1.normalizePath)(ps.join(ps.dirname(importer), id));
        if (ps.extname(file) && fs.existsSync(file)) {
            return file;
        }
        // resolve extension less
        for (const ext of this._resolveExtension) {
            const fileExt = file + ext;
            const indexExt = (0, path_utils_1.normalizePath)(ps.join(file, 'index')) + ext;
            if (fs.existsSync(fileExt)) {
                return fileExt;
            }
            else if (fs.existsSync(indexExt)) {
                return indexExt;
            }
        }
    }
    _load(id) {
        var _a;
        for (let p of this._plugins) {
            const loadedCode = (_a = p.load) === null || _a === void 0 ? void 0 : _a.call(p, id);
            if (loadedCode) {
                return loadedCode;
            }
        }
        if (fs.existsSync(id)) {
            let code = fs.readFileSync(id, 'utf8');
            if (id.endsWith('.json')) {
                code = `export default ${code};`;
            }
            return code;
        }
        else if (this._virtualOverrides[id]) {
            return this._virtual2code[id];
        }
    }
    _transform(file, code) {
        file = (0, path_utils_1.normalizePath)(file);
        for (let ex of this._excludeTransform) {
            if (ex.test(file)) {
                return {
                    code,
                    depIdList: [],
                };
            }
        }
        const depIdList = [];
        if (ps.extname(file) === '.js') {
            const dtsFile = (0, path_utils_1.toExtensionLess)(file) + '.d.ts';
            if (fs.existsSync(dtsFile)) {
                depIdList.push(dtsFile); // emit the .d.ts file
            }
        }
        const importExportVisitor = (path) => {
            // @ts-ignore
            const source = path.node.source;
            if (source) {
                const specifier = source.value;
                // add dependency
                if (!this._nodeModules.includes(specifier)) {
                    // don't load node modules, we post install the modules in OH project
                    depIdList.push(specifier);
                }
                // transform import/export declaration if needed
                const overrideId = this._getOverrideId(specifier, file);
                if (overrideId) {
                    let relativePath = (0, path_utils_1.normalizePath)(ps.relative(ps.dirname(file), overrideId));
                    if (!relativePath.startsWith('.')) {
                        relativePath = './' + relativePath;
                    }
                    if (ps.extname(relativePath) === '.ts') {
                        relativePath = relativePath.slice(0, -3); // remove '.ts'
                    }
                    // traverse to transform specifier
                    (0, traverse_1.default)(path.node, {
                        StringLiteral(path) {
                            path.replaceWith(babel.types.stringLiteral(relativePath));
                            path.skip();
                        },
                    }, path.scope);
                }
            }
            const importExportSpecifier = (path) => {
                const name = path.node.local.name;
                const alias = this._renameMap[name];
                if (alias) {
                    path.replaceWith(babel.types.exportSpecifier(babel.types.identifier(alias), babel.types.identifier(alias)));
                }
            };
            path.traverse({
                ExportSpecifier: importExportSpecifier,
                ImportSpecifier: importExportSpecifier,
            });
        };
        const self = this;
        const transformResult = babel.transformSync(code, {
            configFile: false,
            plugins: [
                [plugin_syntax_typescript_1.default],
                [plugin_syntax_decorators_1.default, {
                        version: '2018-09',
                        decoratorsBeforeExport: true,
                    }],
                [
                    () => {
                        return {
                            name: 'custom-transform',
                            pre(file) {
                                const pluginPass = this;
                                (0, traverse_1.default)(file.ast, {
                                    ClassProperty(path) {
                                        const decoratorsPath = path.get('decorators');
                                        if (Array.isArray(decoratorsPath)) {
                                            const propertyValuePath = path.get('value');
                                            const helperIdentifier = self._filedDecoratorHelper.addHelper(pluginPass.file);
                                            decoratorsPath.forEach(decPath => {
                                                const expPath = decPath.get('expression');
                                                const type = expPath.node.type;
                                                if (type === 'CallExpression') {
                                                    const decName = expPath.node.callee.name;
                                                    const args = expPath.node.arguments;
                                                    decPath.replaceWith(t.decorator(t.callExpression(helperIdentifier, [
                                                        t.identifier(decName),
                                                        (propertyValuePath.node ?
                                                            t.arrowFunctionExpression([], propertyValuePath.node) :
                                                            t.nullLiteral()),
                                                        ...args
                                                    ])));
                                                }
                                                else if (type === 'Identifier') {
                                                    const decName = expPath.node.name;
                                                    decPath.replaceWith(t.decorator(t.callExpression(helperIdentifier, [
                                                        t.identifier(decName),
                                                        (propertyValuePath.node ?
                                                            t.arrowFunctionExpression([], propertyValuePath.node) :
                                                            t.nullLiteral())
                                                    ])));
                                                }
                                            });
                                        }
                                    },
                                });
                            },
                            visitor: {
                                ImportDeclaration: importExportVisitor,
                                ExportDeclaration: importExportVisitor,
                                // TODO: here we rename class Rect and Path
                                CallExpression(path) {
                                    if (path.node.callee.type === 'MemberExpression') {
                                        const memberExpressionPath = path.get('callee');
                                        const objectPath = memberExpressionPath.get('object');
                                        const name = objectPath.node.name;
                                        const alias = self._renameMap[name];
                                        if (typeof alias === 'string' && path.node.callee.object.type === 'Identifier') {
                                            objectPath.replaceWith(t.identifier(alias));
                                        }
                                        // TODO: for now, OH doesn't support standard console interface,
                                        // so we need to ignore the type checking for console call expressions.
                                        else if (name === 'console') {
                                            path.node.leadingComments = [{
                                                    type: 'CommentLine',
                                                    value: ' @ts-ignore',
                                                }];
                                        }
                                    }
                                    else if (path.node.callee.type === 'Import') {
                                        // TODO: for now, we transform `import('./xxx/xxx.js')` into `window.__cc_module_context__.import('./xxx/xxx.js')`
                                        // we need to support import(`project://xxx`) in the future.
                                        path.replaceWith(t.callExpression(t.memberExpression(t.memberExpression(t.identifier('window'), t.identifier('__cc_module_context__')), t.identifier('import')), path.node.arguments));
                                    }
                                },
                                ClassDeclaration(path) {
                                    const idPath = path.get('id');
                                    const name = idPath.node.name;
                                    const alias = self._renameMap[name];
                                    if (typeof alias === 'string') {
                                        idPath.replaceWith(t.identifier(alias));
                                    }
                                },
                                NewExpression(path) {
                                    const calleePath = path.get('callee');
                                    // @ts-ignore
                                    const name = calleePath.node.name;
                                    if (name) {
                                        const alias = self._renameMap[name];
                                        if (typeof alias === 'string') {
                                            calleePath.replaceWith(t.identifier(alias));
                                        }
                                    }
                                },
                                TSTypeAnnotation(path) {
                                    // @ts-ignore
                                    const typeName = path.node.typeAnnotation.typeName;
                                    const childPath = path.get('typeAnnotation');
                                    if (typeName) {
                                        const name = typeName.name;
                                        const alias = self._renameMap[name];
                                        if (typeof alias === 'string') {
                                            path.replaceWith(t.tsTypeAnnotation({
                                                type: 'TSExpressionWithTypeArguments',
                                                expression: t.identifier(alias),
                                            }));
                                        }
                                    }
                                    else if (childPath.type === 'TSLiteralType') {
                                        const literalPath = childPath.get('literal');
                                        if (literalPath.type === 'TemplateLiteral') {
                                            path.replaceWith(t.tsTypeAnnotation(t.tsStringKeyword()));
                                        }
                                    }
                                },
                                Identifier(path) {
                                    const name = path.node.name;
                                    const alias = self._renameMap[name];
                                    if (typeof alias === 'string') {
                                        if (path.parent.type === 'ObjectProperty' || path.parent.type === 'TSPropertySignature') {
                                            if (path.parent.key !== path.node) {
                                                path.replaceWith(t.identifier(alias));
                                            }
                                        }
                                        else if (path.parent.type === 'MemberExpression' || path.parent.type === 'OptionalMemberExpression') {
                                            if (path.parent.property !== path.node) {
                                                path.replaceWith(t.identifier(alias));
                                            }
                                        }
                                        else if (!(path.parent.type === 'ClassMethod' && (path.parent.kind === 'get' || path.parent.kind === 'set' || path.parent.key === path.node))
                                            && path.parent.type !== 'ClassProperty') {
                                            const newIdentifier = t.identifier(alias);
                                            if (path.node.typeAnnotation) {
                                                newIdentifier.typeAnnotation = path.node.typeAnnotation;
                                            }
                                            path.replaceWith(newIdentifier);
                                        }
                                    }
                                },
                            }
                        };
                    }
                ]
            ],
        });
        return {
            code: transformResult === null || transformResult === void 0 ? void 0 : transformResult.code,
            depIdList,
        };
    }
    _lintImport(lintFiles, verbose = false) {
        return __awaiter(this, void 0, void 0, function* () {
            const eslint = new eslint_1.ESLint({ fix: true,
                cwd: __dirname,
                resolvePluginsRelativeTo: __dirname,
                useEslintrc: false,
                baseConfig: {
                    parser: "@typescript-eslint/parser",
                    plugins: ["@typescript-eslint", "unused-imports"],
                    rules: {
                        "@typescript-eslint/consistent-type-imports": "error",
                        "unused-imports/no-unused-imports": "error",
                    },
                } });
            const results = yield eslint.lintFiles(lintFiles);
            yield eslint_1.ESLint.outputFixes(results);
            if (verbose) {
                const formatter = yield eslint.loadFormatter();
                const resultText = formatter.format(results);
                console.log(resultText);
            }
        });
    }
    _buildIndex() {
        const { outDir, root } = this._options;
        if (outDir) {
            const indexFile = (0, path_utils_1.normalizePath)(ps.join(outDir, 'index.ts'));
            const ccFile = (0, path_utils_1.normalizePath)(ps.join(outDir, 'cc.ts'));
            const systemCCFile = (0, path_utils_1.normalizePath)(ps.join(outDir, 'system-cc.js'));
            let indexContent = '';
            this._entries.forEach(item => {
                const relative = (0, path_utils_1.normalizePath)(ps.relative(root, (0, path_utils_1.toExtensionLess)(item)));
                indexContent += `export * from './${relative}';\n`;
            });
            const ccContent = (0, dedent_1.default) `import * as cc from './index';
            // @ts-ignore
            window.cc_module = cc;`;
            const systemCCContent = (0, dedent_1.default) `System.register([], function (exports, module) {
                return {
                    execute: function () {
                        window.__cc_module_context__ = module;
            
                        exports(window.cc_module);
                    }
                };
            });
            `;
            fs.outputFileSync(indexFile, indexContent, 'utf8');
            fs.outputFileSync(ccFile, ccContent, 'utf8');
            fs.outputFileSync(systemCCFile, systemCCContent, 'utf8');
        }
    }
    _copyTypes() {
        return __awaiter(this, void 0, void 0, function* () {
            const { root, outDir } = this._options;
            if (!outDir) {
                return;
            }
            const dtsFiles = glob_1.glob.sync((0, path_utils_1.normalizePath)(ps.join(root, './@types/**/*.d.ts')));
            for (let file of dtsFiles) {
                const code = fs.readFileSync(file, 'utf8');
                const relativePath = ps.relative(root, file);
                const targetPath = (0, path_utils_1.normalizePath)(ps.join(outDir, relativePath));
                fs.outputFileSync(targetPath, code, 'utf8');
            }
            // copy lib.dom.d.ts
            // we use 4.2 version of typescript
            const originalDomDts = (0, path_utils_1.normalizePath)(ps.join(__dirname, '../../../static/lib.dom.d.ts'));
            const targetDomDts = (0, path_utils_1.normalizePath)(ps.join(outDir, '@types/lib.dom.d.ts'));
            const code = fs.readFileSync(originalDomDts, 'utf8');
            fs.outputFileSync(targetDomDts, code, 'utf8');
        });
    }
    _addNodeModulesDeps() {
        const { outDir } = this._options;
        if (!outDir) {
            return;
        }
        const pkgFile = (0, path_utils_1.normalizePath)(ps.join(outDir, '..', // src
        '..', // cocos
        '..', // ets
        '..', // main
        '..', // src
        '..', // entry
        'package.json'));
        if (!fs.existsSync(pkgFile)) {
            return;
        }
        const jsonObj = fs.readJSONSync(pkgFile);
        console.log(jsonObj);
        // TODO
    }
}
exports.EngineBuilder = EngineBuilder;
//# sourceMappingURL=engine-builder.js.map