"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.buildJsEngine = void 0;
const fs_extra_1 = __importDefault(require("fs-extra"));
const path_1 = __importDefault(require("path"));
const plugin_babel_1 = __importDefault(require("@rollup/plugin-babel"));
const plugin_json_1 = __importDefault(require("@rollup/plugin-json"));
const plugin_node_resolve_1 = __importDefault(require("@rollup/plugin-node-resolve"));
const plugin_commonjs_1 = __importDefault(require("@rollup/plugin-commonjs"));
const rollup_plugin_terser_1 = require("rollup-plugin-terser");
const preset_env_1 = __importDefault(require("@babel/preset-env"));
const creator_programming_babel_preset_cc_1 = require("@cocos/creator-programming-babel-preset-cc");
// @ts-expect-error: No typing
const plugin_transform_for_of_1 = __importDefault(require("@babel/plugin-transform-for-of"));
const rollup = __importStar(require("rollup"));
// import rpProgress from 'rollup-plugin-progress';
const plugin_virtual_1 = __importDefault(require("@rollup/plugin-virtual"));
const babel_plugin_dynamic_import_vars_1 = __importDefault(require("@cocos/babel-plugin-dynamic-import-vars"));
const fs_1 = __importDefault(require("fs"));
const ts_paths_1 = __importDefault(require("./rollup-plugins/ts-paths"));
const remove_deprecated_features_1 = __importDefault(require("./rollup-plugins/remove-deprecated-features"));
const stats_query_1 = require("../../stats-query");
const utils_1 = require("../../utils");
const external_wasm_loader_1 = require("./rollup-plugins/external-wasm-loader");
// import * as decoratorRecorder from './babel-plugins/decorator-parser';
const realPath = (function () {
    const realpath = typeof fs_1.default.realpath.native === 'function' ? fs_1.default.realpath.native : fs_1.default.realpath;
    return (file) => new Promise((resolve, reject) => {
        realpath(file, (err, path) => {
            if (err && err.code !== 'ENOENT') {
                reject(err);
            }
            else {
                resolve(err ? file : path);
            }
        });
    });
})();
function makePathEqualityKey(path) {
    return process.platform === 'win32' ? path.toLocaleLowerCase() : path;
}
function buildJsEngine(options) {
    var _a, _b, _c, _d, _e;
    return __awaiter(this, void 0, void 0, function* () {
        const doUglify = !!options.compress;
        const engineRoot = path_1.default.resolve(options.engine);
        const rollupFormat = (_a = options.moduleFormat) !== null && _a !== void 0 ? _a : 'iife';
        const statsQuery = yield stats_query_1.StatsQuery.create(engineRoot);
        if (options.features) {
            for (const feature of options.features) {
                if (!statsQuery.hasFeature(feature)) {
                    console.warn(`'${feature}' is not a valid feature.`);
                }
            }
        }
        let features;
        let split = (_b = options.split) !== null && _b !== void 0 ? _b : false;
        if (options.features && options.features.length !== 0) {
            features = options.features;
        }
        else {
            features = statsQuery.getFeatures();
            if (split !== true) {
                split = true;
                console.warn(`You did not specify features which implies 'split: true'. `
                    + `Explicitly set 'split: true' to suppress this warning.`);
            }
        }
        let { ammoJsWasm } = options;
        ammoJsWasm !== null && ammoJsWasm !== void 0 ? ammoJsWasm : (ammoJsWasm = true); // default is true
        const forceBanningBulletWasm = !ammoJsWasm;
        const flags = (_c = options.flags) !== null && _c !== void 0 ? _c : {};
        flags.FORCE_BANNING_BULLET_WASM = forceBanningBulletWasm;
        const intrinsicFlags = statsQuery.getIntrinsicFlagsOfFeatures(features);
        let buildTimeConstants = statsQuery.constantManager.genBuildTimeConstants({
            mode: options.mode,
            platform: options.platform,
            flags,
        });
        buildTimeConstants = Object.assign(Object.assign({}, intrinsicFlags), buildTimeConstants);
        // if (typeof options.forceJitValue !== undefined) {
        //     buildTimeConstants['SUPPORT_JIT'] = options.forceJitValue as boolean;
        // }
        const moduleOverrides = Object.entries(statsQuery.evaluateModuleOverrides({
            mode: options.mode,
            platform: options.platform,
            buildTimeConstants,
        })).reduce((result, [k, v]) => {
            result[makePathEqualityKey(k)] = v;
            return result;
        }, {});
        const featureUnits = statsQuery.getUnitsOfFeatures(features);
        const rpVirtualOptions = {};
        const vmInternalConstants = statsQuery.constantManager.exportStaticConstants({
            platform: options.platform,
            mode: options.mode,
            flags,
        });
        console.debug(`Module source "internal-constants":\n${vmInternalConstants}`);
        rpVirtualOptions['internal:constants'] = vmInternalConstants;
        rpVirtualOptions[creator_programming_babel_preset_cc_1.helpers.CC_HELPER_MODULE] = creator_programming_babel_preset_cc_1.helpers.generateHelperModuleSource();
        // for some modules that we need to instantiate before cc module
        // const forceStandaloneModules = ['wait-for-ammo-instantiation'];
        const forceStandaloneModules = [];
        let rollupEntries;
        if (split) {
            rollupEntries = featureUnits.reduce((result, featureUnit) => {
                result[featureUnit] = statsQuery.getFeatureUnitFile(featureUnit);
                return result;
            }, {});
        }
        else {
            rollupEntries = {
                cc: 'cc',
            };
            const selectedFeatureUnits = [];
            for (const featureUnit of featureUnits) {
                if (forceStandaloneModules.includes(featureUnit)) {
                    rollupEntries[featureUnit] = statsQuery.getFeatureUnitFile(featureUnit);
                }
                else {
                    selectedFeatureUnits.push(featureUnit);
                }
            }
            rpVirtualOptions.cc = statsQuery.evaluateIndexModuleSource(selectedFeatureUnits, (featureUnit) => (0, utils_1.filePathToModuleRequest)(statsQuery.getFeatureUnitFile(featureUnit)));
            rollupEntries.cc = 'cc';
            console.debug(`Module source "cc":\n${rpVirtualOptions.cc}`);
        }
        const presetEnvOptions = {
            loose: (_d = options.loose) !== null && _d !== void 0 ? _d : true,
            // We need explicitly specified targets.
            // Ignore it to avoid the engine's parent dirs contain unexpected config.
            ignoreBrowserslistConfig: true,
        };
        if (options.targets !== undefined) {
            presetEnvOptions.targets = options.targets;
        }
        const babelPlugins = [];
        if (options.targets === undefined) {
            babelPlugins.push([plugin_transform_for_of_1.default, {
                    loose: true,
                }]);
        }
        babelPlugins.push([babel_plugin_dynamic_import_vars_1.default, {
                resolve: {
                    forwardExt: 'resolved',
                },
            }]);
        const { fieldDecorators, editorDecorators } = statsQuery.getOptimizeDecorators();
        const babelOptions = {
            babelHelpers: 'bundled',
            extensions: ['.js', '.ts'],
            exclude: [
                /node_modules[/\\]@cocos[/\\]ammo/,
                /node_modules[/\\]@cocos[/\\]cannon/,
                /node_modules[/\\]@cocos[/\\]physx/,
                /\.asm\.js/,
            ],
            comments: false,
            overrides: [{
                    // Eliminates the babel compact warning:
                    // 'The code generator has deoptimised the styling of ...'
                    // that came from node_modules/@cocos
                    test: /node_modules[/\\]@cocos[/\\]/,
                    compact: true,
                }],
            plugins: babelPlugins,
            presets: [
                [preset_env_1.default, presetEnvOptions],
                [creator_programming_babel_preset_cc_1.babelPresetCC, {
                        allowDeclareFields: true,
                        ccDecoratorHelpers: 'external',
                        fieldDecorators,
                        editorDecorators,
                    }],
            ],
        };
        // if (options.generateDecoratorsForJSB) {
        //     if (!process.env.ENGINE_PATH) {
        //         throw new Error('ENGINE_PATH environment variable not set');
        //     }
        //     babelOptions.presets?.push([() => ({ plugins: [[decoratorRecorder]] })]);
        // }
        const rollupPlugins = [];
        if (options.noDeprecatedFeatures) {
            rollupPlugins.push((0, remove_deprecated_features_1.default)(typeof options.noDeprecatedFeatures === 'string' ? options.noDeprecatedFeatures : undefined));
        }
        rollupPlugins.push((0, external_wasm_loader_1.externalWasmLoader)({
            externalRoot: path_1.default.join(engineRoot, 'native/external'),
            wasmSupportMode: buildTimeConstants.WASM_SUPPORT_MODE,
            forceBanningBulletWasm,
            cullAsmJsModule: buildTimeConstants.CULL_ASM_JS_MODULE,
            format: 'relative-from-chunk',
            wasmFallback: buildTimeConstants.WASM_FALLBACK,
            wasmSubpackage: buildTimeConstants.WASM_SUBPACKAGE,
        }), {
            name: '@cocos/ccbuild|module-overrides',
            resolveId(source, importer) {
                if (moduleOverrides[source]) {
                    return source;
                }
                else {
                    return null;
                }
            },
            load(id) {
                const key = makePathEqualityKey(id);
                if (!(key in moduleOverrides)) {
                    return null;
                }
                const replacement = moduleOverrides[key];
                console.debug(`Redirect module ${id} to ${replacement}`);
                return `export * from '${(0, utils_1.filePathToModuleRequest)(replacement)}';`;
            },
        }, (0, plugin_virtual_1.default)(rpVirtualOptions), (0, ts_paths_1.default)({
            configFileName: path_1.default.resolve(options.engine, 'tsconfig.json'),
        }), (0, plugin_node_resolve_1.default)({
            extensions: ['.js', '.ts', '.json'],
            jail: yield realPath(engineRoot),
            rootDir: engineRoot,
        }), (0, plugin_json_1.default)({
            preferConst: true,
        }), (0, plugin_commonjs_1.default)({
            include: [
                /node_modules[/\\]/,
                /asm\.js/,
            ],
            sourceMap: false,
        }), (0, plugin_babel_1.default)(Object.assign({ skipPreflightCheck: true }, babelOptions)));
        // if (options.progress) {
        //     rollupPlugins.unshift(rpProgress());
        // }
        if (doUglify) { // TODO: tree-shaking not clear!
            rollupPlugins.push((0, rollup_plugin_terser_1.terser)({
                // see https://github.com/terser/terser#compress-options
                compress: {
                    reduce_funcs: false,
                    keep_fargs: false,
                    unsafe_Function: true,
                    unsafe_math: true,
                    unsafe_methods: true,
                    passes: 2, // first: remove deadcodes and const objects, second: drop variables
                },
                mangle: doUglify,
                keep_fnames: !doUglify,
                output: {
                    beautify: !doUglify,
                },
                // https://github.com/rollup/rollup/issues/3315
                // We only do this for CommonJS.
                // Especially, we cannot do this for IIFE.
                toplevel: rollupFormat === 'cjs',
            }));
        }
        // const visualizeOptions = typeof options.visualize === 'object'
        //     ? options.visualize
        //     : (options.visualize ? {} : undefined);
        // if (visualizeOptions) {
        //     let rpVisualizer;
        //     try {
        //         // @ts-expect-error: No typing
        //         rpVisualizer = await import('rollup-plugin-visualizer');
        //     } catch {
        //         console.warn('Visualizing needs \'rollup-plugin-visualizer\' to be installed. It\'s installed as dev-dependency.');
        //     }
        //     if (rpVisualizer) {
        //         const visualizeFile = visualizeOptions.file ?? ps.join(options.out, 'visualize.html');
        //         rollupPlugins.push(rpVisualizer({
        //             filename: visualizeFile,
        //             title: 'Cocos Creator build visualizer',
        //             template: 'treemap',
        //         }));
        //     }
        // }
        let hasCriticalWarns = false;
        const rollupWarningHandler = (warning, defaultHandler) => {
            var _a;
            if (typeof warning !== 'string') {
                if (warning.code === 'CIRCULAR_DEPENDENCY') {
                    hasCriticalWarns = true;
                }
                else if (warning.code === 'THIS_IS_UNDEFINED') {
                    // TODO: It's really inappropriate to do this...
                    // Let's fix these files instead of suppressing rollup.
                    if ((_a = warning.id) === null || _a === void 0 ? void 0 : _a.match(/(?:spine-core\.js$)|(?:dragonBones\.js$)/)) {
                        console.debug(`Rollup warning 'THIS_IS_UNDEFINED' is omitted for ${warning.id}`);
                        return;
                    }
                }
            }
            defaultHandler(warning);
        };
        const rollupOptions = {
            input: rollupEntries,
            plugins: rollupPlugins,
            cache: false,
            onwarn: rollupWarningHandler,
        };
        const perf = true;
        if (perf) {
            rollupOptions.perf = true;
        }
        const rollupBuild = yield rollup.rollup(rollupOptions);
        const timing = (_e = rollupBuild.getTimings) === null || _e === void 0 ? void 0 : _e.call(rollupBuild);
        if (timing) {
            console.debug(`==== Performance ====`);
            console.debug(JSON.stringify(timing));
            console.debug(`====             ====`);
        }
        const { incremental: incrementalFile } = options;
        if (incrementalFile) {
            const watchFiles = {};
            const files = rollupBuild.watchFiles;
            yield Promise.all(files.map((watchFile) => __awaiter(this, void 0, void 0, function* () {
                try {
                    const stat = yield fs_extra_1.default.stat(watchFile);
                    watchFiles[watchFile] = stat.mtimeMs;
                }
                catch (_f) {
                    // the `watchFiles` may contain non-fs modules.
                }
            })));
            yield fs_extra_1.default.ensureDir(path_1.default.dirname(incrementalFile));
            yield fs_extra_1.default.writeFile(incrementalFile, JSON.stringify(watchFiles, undefined, 2));
        }
        const result = {
            chunkAliases: {},
            exports: {},
            chunkDepGraph: {},
            assetDepGraph: {},
            hasCriticalWarns: false,
        };
        const rollupOutputOptions = {
            format: rollupFormat,
            sourcemap: options.sourceMap,
            sourcemapFile: options.sourceMapFile,
            name: (rollupFormat === 'iife' ? 'ccm' : undefined),
            dir: options.out,
            // NOTE: parallel dynamic import has some issue on SystemJS, especially on OH platform
            // see: https://github.com/systemjs/systemjs/issues/2297
            inlineDynamicImports: options.platform === 'OPEN_HARMONY',
            // minifyInternalExports: false,
            // preserveEntrySignatures: "allow-extension",
        };
        const rollupOutput = yield rollupBuild.write(rollupOutputOptions);
        const validEntryChunks = {};
        for (const output of rollupOutput.output) {
            if (output.type === 'chunk') {
                if (output.isEntry) {
                    const chunkName = output.name;
                    if (chunkName in rollupEntries || chunkName === 'cc') {
                        validEntryChunks[chunkName] = output.fileName;
                    }
                }
            }
        }
        Object.assign(result.exports, validEntryChunks);
        result.dependencyGraph = {};
        for (const output of rollupOutput.output) {
            if (output.type === 'chunk') {
                const depList = output.imports.concat(output.dynamicImports);
                result.dependencyGraph[output.fileName] = depList;
                result.chunkDepGraph[output.fileName] = depList;
                result.assetDepGraph[output.fileName] = output.referencedFiles.slice();
            }
        }
        result.hasCriticalWarns = hasCriticalWarns;
        return result;
    });
}
exports.buildJsEngine = buildJsEngine;
//# sourceMappingURL=index.js.map