"use strict";

var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ModuleQuery = void 0;
const fs_extra_1 = __importDefault(require("fs-extra"));
const platform_config_1 = require("./platform-config");
const glob_1 = __importDefault(require("glob"));
const utils_1 = require("../../utils/lib/index.js");
/**
 * The module info manager.
 */
class ModuleQuery {
  constructor(context) {
    this._resolvedCache = {}; // module name to module entry file path
    this._cachedHasEditorSpecificExport = {};
    this._context = context;
  }
  /**
   * Get all modules' name defined in engine workspaces.
   */
  getAllModules() {
    return __awaiter(this, void 0, void 0, function* () {
      if (this._cachedAllModules) {
        return this._cachedAllModules;
      }
      const enginePkg = yield fs_extra_1.default.readJson(utils_1.ps.join(this._context.engine, 'package.json'));
      let pkgFiles = [];
      if (enginePkg.workspaces) {
        for (const ws of enginePkg.workspaces) {
          pkgFiles.push(...glob_1.default.sync(utils_1.ps.join(this._context.engine, ws), {
            ignore: '**/node_modules/**/*'
          }));
        }
      }
      pkgFiles = pkgFiles.map(file => {
        if (fs_extra_1.default.statSync(file).isDirectory()) {
          const pkgFile = utils_1.ps.join(file, 'package.json');
          if (fs_extra_1.default.existsSync(pkgFile)) {
            return pkgFile;
          }
        }
        return file;
      });
      pkgFiles = pkgFiles.filter(file => file.endsWith('package.json'));
      pkgFiles = pkgFiles.filter((file, index) => pkgFiles.indexOf(file) === index);
      pkgFiles = pkgFiles.filter(file => {
        var _a;
        const pkgJson = fs_extra_1.default.readJSONSync(file);
        return ((_a = pkgJson.exports) === null || _a === void 0 ? void 0 : _a['.'].node) === './package.json';
      });
      const moduleNames = [];
      for (const pkg of pkgFiles) {
        const name = (yield fs_extra_1.default.readJson(pkg)).name;
        moduleNames.push(name);
      }
      return this._cachedAllModules = moduleNames;
    });
  }
  /**
   * Resolve module package.json path by module name.
   */
  resolvePackageJson(moduleName) {
    return require.resolve(moduleName, {
      paths: [this._context.engine]
    });
  }
  /**
   * Get module config by module name.
   */
  getConfig(moduleName) {
    return __awaiter(this, void 0, void 0, function* () {
      const modulePath = this.resolvePackageJson(moduleName);
      return yield fs_extra_1.default.readJson(modulePath);
    });
  }
  /**
   * Resolve module entry path by import source.
   */
  resolveExport(source) {
    return __awaiter(this, void 0, void 0, function* () {
      if (this._resolvedCache[source]) {
        return this._resolvedCache[source];
      }
      if (source.startsWith('.')) {
        // no relative path resolve
        return;
      }
      const allModules = yield this.getAllModules();
      const moduleName = allModules.find(moduleName => source.startsWith(moduleName));
      if (!moduleName) {
        return;
      }
      let exportPort = '.';
      if (utils_1.ps.relative(moduleName, source) !== '') {
        exportPort = './' + utils_1.ps.relative(moduleName, source);
      }
      const moduleRootDir = utils_1.ps.dirname(this.resolvePackageJson(moduleName));
      const config = yield this.getConfig(moduleName);
      // NOTE: '.' export port can cover all export ports.
      const rootExport = config.exports[exportPort];
      if (!rootExport) {
        return;
      }
      // custom condition
      if (this._context.customExportConditions) {
        for (const condition of this._context.customExportConditions) {
          if (typeof rootExport[condition] === 'string') {
            return this._resolvedCache[source] = utils_1.ps.join(moduleRootDir, rootExport[condition]);
          }
        }
      }
      // platform condition
      const platform = this._context.platform.toLowerCase();
      if (this._isWebPlatform(platform)) {
        if (typeof rootExport.web === 'string') {
          return this._resolvedCache[source] = utils_1.ps.join(moduleRootDir, rootExport.web);
        } else if (typeof rootExport.web === 'object') {
          if (typeof rootExport.web[platform] === 'string') {
            return this._resolvedCache[source] = utils_1.ps.join(moduleRootDir, rootExport.web[platform]);
          } else if (typeof rootExport.web.default === 'string') {
            return this._resolvedCache[source] = utils_1.ps.join(moduleRootDir, rootExport.web.default);
          }
        }
      } else if (this._isMiniGamePlatform(platform)) {
        if (typeof rootExport.minigame === 'string') {
          return this._resolvedCache[source] = utils_1.ps.join(moduleRootDir, rootExport.minigame);
        } else if (typeof rootExport.minigame === 'object') {
          if (typeof rootExport.minigame[platform] === 'string') {
            return this._resolvedCache[source] = utils_1.ps.join(moduleRootDir, rootExport.minigame[platform]);
          } else if (typeof rootExport.minigame.default === 'string') {
            return this._resolvedCache[source] = utils_1.ps.join(moduleRootDir, rootExport.minigame.default);
          }
        }
      } else if (this._isNativePlatform(platform)) {
        if (typeof rootExport.native === 'string') {
          return this._resolvedCache[source] = utils_1.ps.join(moduleRootDir, rootExport.native);
        } else if (typeof rootExport.native === 'object') {
          if (typeof rootExport.native[platform] === 'string') {
            return this._resolvedCache[source] = utils_1.ps.join(moduleRootDir, rootExport.native[platform]);
          } else if (typeof rootExport.native.default === 'string') {
            return this._resolvedCache[source] = utils_1.ps.join(moduleRootDir, rootExport.native.default);
          }
        }
      }
      // types condition
      if (typeof rootExport.types === 'string') {
        return this._resolvedCache[source] = utils_1.ps.join(moduleRootDir, rootExport.types);
      } else {
        throw new Error(`Please specify a least a types export for module: '${source}'.`);
      }
    });
  }
  /**
   * To detect whether the module has a './editor' export.
   * @param moduleName
   */
  hasEditorSpecificExport(moduleName) {
    var _a;
    return __awaiter(this, void 0, void 0, function* () {
      if (typeof this._cachedHasEditorSpecificExport[moduleName] === 'boolean') {
        return this._cachedHasEditorSpecificExport[moduleName];
      }
      const pkgJson = this.resolvePackageJson(moduleName);
      const pkg = yield fs_extra_1.default.readJson(pkgJson);
      return this._cachedHasEditorSpecificExport[moduleName] = typeof ((_a = pkg.exports) === null || _a === void 0 ? void 0 : _a['./editor']) !== 'undefined';
    });
  }
  _isWebPlatform(platform) {
    return platform.toUpperCase() in platform_config_1.WebPlatform || platform.toUpperCase() === 'HTML5';
  }
  _isMiniGamePlatform(platform) {
    return platform.toUpperCase() in platform_config_1.MinigamePlatform;
  }
  _isNativePlatform(platform) {
    return platform.toUpperCase() in platform_config_1.NativePlatform || platform.toUpperCase() === 'NATIVE';
  }
}
exports.ModuleQuery = ModuleQuery;