"use strict";

// This code was modified from https://github.com/timocov/ts-transformer-minify-privates
var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  var desc = Object.getOwnPropertyDescriptor(m, k);
  if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
    desc = {
      enumerable: true,
      get: function () {
        return m[k];
      }
    };
  }
  Object.defineProperty(o, k2, desc);
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});
var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});
var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
  __setModuleDefault(result, mod);
  return result;
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.minifyPrivatePropertiesTransformer = exports.PropertiesMinifier = void 0;
const ts = __importStar(require("@cocos/typescript"));
const MANGLE_JSDOC_TAG_NAME = 'mangle';
const DONT_MANGLE_JSDOC_TAG_NAME = 'dontmangle';
const defaultOptions = {
  prefix: '_ccprivate$',
  mangleList: [],
  dontMangleList: [],
  mangleGetterSetter: false,
  mangleProtected: false,
  ignoreJsDocTag: false
};
class PropertiesMinifier {
  constructor(context, options) {
    this._currentProgram = null;
    this._currentSourceFile = null;
    this._context = context;
    this._options = Object.assign(Object.assign({}, defaultOptions), options);
  }
  visitSourceFile(node, program, context) {
    this._currentProgram = program;
    this._currentSourceFile = node;
    this._typeChecker = program.getTypeChecker();
    const result = this.visitNodeAndChildren(node, program, context);
    this._currentProgram = null;
    this._currentSourceFile = null;
    return result;
  }
  visitNodeAndChildren(node, program, context) {
    return ts.visitEachChild(this.visitNode(node, program), childNode => this.visitNodeAndChildren(childNode, program, context), context);
  }
  visitNode(node, program) {
    if (this.isAccessExpression(node)) {
      return this.createNewAccessExpression(node, program);
    } else if (ts.isBindingElement(node)) {
      return this.createNewBindingElement(node, program);
    } else if (this.isConstructorParameterReference(node, program)) {
      return this.createNewNode(program, node, undefined, this._context.factory.createIdentifier);
    } else if (this.isPropertyInInterfaceNotShorthand(node.parent) && (this.isIdentifierInVariableDeclaration(node, program) || this.isIdentifierInBinaryExpression(node, program) || this.isIdentifierInArrayLiteralExpression(node, program))) {
      return this.createNewNode(program, node, undefined, this._context.factory.createIdentifier);
    } else if (ts.isShorthandPropertyAssignment(node)) {
      if (this.isIdentifierInVariableDeclaration(node.name, program) || this.isIdentifierInBinaryExpression(node.name, program) || this.isIdentifierInArrayLiteralExpression(node.name, program)) {
        return ts.factory.createPropertyAssignment(this.createNewNode(program, node.name, undefined, this._context.factory.createIdentifier), ts.factory.createIdentifier(node.name.text));
      }
    }
    return node;
  }
  getSymbolForElementAccessExpressionWithQuestionDot(node) {
    if (ts.isStringLiteral(node.argumentExpression)) {
      const getMemberSymbol = (symbol, key) => {
        if (symbol && symbol.members) {
          return symbol.members.get(key);
        }
        return undefined;
      };
      const key = node.argumentExpression.text;
      const type = this._typeChecker.getTypeAtLocation(node.expression);
      let ret;
      if (type.isUnion()) {
        for (const t of type.types) {
          if (!t.symbol || !t.symbol.members) continue;
          ret = getMemberSymbol(t.symbol, key);
          if (ret) return ret;
        }
      } else {
        return getMemberSymbol(type.symbol, key);
      }
    }
    return undefined;
  }
  createNewAccessExpression(node, program) {
    const typeChecker = program.getTypeChecker();
    const accessName = ts.isPropertyAccessExpression(node) ? node.name : node.argumentExpression;
    let symbol = typeChecker.getSymbolAtLocation(accessName);
    if (symbol === undefined && ts.isElementAccessExpression(node)) {
      symbol = this.getSymbolForElementAccessExpressionWithQuestionDot(node);
    }
    if (!this.isPrivateNonStaticClassMember(symbol)) {
      return node;
    }
    const hasQuestionToken = !!node.questionDotToken;
    const questionTokenNode = hasQuestionToken ? this._context.factory.createToken(ts.SyntaxKind.QuestionDotToken) : undefined;
    let isFirstChildOptinalChain = false;
    if (node.getChildCount() > 0 && ts.isOptionalChain(node.getChildAt(0))) {
      isFirstChildOptinalChain = true;
    }
    let propName;
    let creator;
    if (ts.isPropertyAccessExpression(node)) {
      propName = node.name;
      creator = newName => {
        return hasQuestionToken || isFirstChildOptinalChain ? this._context.factory.createPropertyAccessChain(node.expression, questionTokenNode, newName) : this._context.factory.createPropertyAccessExpression(node.expression, newName);
      };
    } else {
      if (!ts.isStringLiteral(node.argumentExpression)) {
        return node;
      }
      propName = node.argumentExpression;
      creator = newName => {
        return hasQuestionToken || isFirstChildOptinalChain ? this._context.factory.createElementAccessChain(node.expression, questionTokenNode, this._context.factory.createStringLiteral(newName)) : this._context.factory.createElementAccessExpression(node.expression, this._context.factory.createStringLiteral(newName));
      };
    }
    return this.createNewNode(program, propName, symbol, creator);
  }
  createNewBindingElement(node, program) {
    const typeChecker = program.getTypeChecker();
    let propName;
    let symbol;
    if (node.propertyName === undefined) {
      // if no property name is set (const { a } = foo)
      // then node.propertyName is undefined and we need to find this property by yourself
      // so let's use go-to-definition algorithm from TSServer
      // see https://github.com/microsoft/TypeScript/blob/672b0e3e16ad18b422dbe0cec5a98fce49881b76/src/services/goToDefinition.ts#L58-L77
      if (!ts.isObjectBindingPattern(node.parent)) {
        return node;
      }
      const type = typeChecker.getTypeAtLocation(node.parent);
      if (type.isUnion()) {
        return node;
      }
      if (!ts.isIdentifier(node.name)) {
        return node;
      }
      propName = node.name;
      symbol = type.getProperty(ts.idText(propName));
    } else {
      propName = node.propertyName;
      symbol = typeChecker.getSymbolAtLocation(node.propertyName);
    }
    if (!this.isPrivateNonStaticClassMember(symbol)) {
      return node;
    }
    return this.createNewNode(program, propName, undefined, newName => {
      return this._context.factory.createBindingElement(node.dotDotDotToken, newName, node.name, node.initializer);
    });
  }
  createNewNode(program, oldProperty, symbol, createNode) {
    if (symbol === undefined) {
      const typeChecker = program.getTypeChecker();
      symbol = typeChecker.getSymbolAtLocation(oldProperty);
    }
    if (symbol === undefined) {
      throw new Error(`Cannot get symbol for node "${oldProperty.getText()}"`);
    }
    const oldPropertyName = symbol.escapedName;
    const newPropertyName = this.getNewName(oldPropertyName);
    const newProperty = createNode(newPropertyName);
    return newProperty;
  }
  getNewName(originalName) {
    return `${this._options.prefix}${originalName}`;
  }
  isPrivateNonStatic(node, parentSymbol) {
    return this.isPrivate(node, parentSymbol); // && !this.hasModifier(node, ts.SyntaxKind.StaticKeyword);
  }

  hasJsDocTag(jsDocNode, tagNameToSearch) {
    if (jsDocNode.jsDoc) {
      for (const jsDoc of jsDocNode.jsDoc) {
        if (jsDoc.tags) {
          for (const tag of jsDoc.tags) {
            const tagName = tag.tagName.escapedText;
            if (tagName === tagNameToSearch) {
              return true;
            }
          }
        }
      }
    }
    return false;
  }
  isPrivate(node, parentSymbol) {
    var _a, _b;
    let isPrivate = this.hasModifier(node, ts.SyntaxKind.PrivateKeyword);
    if (!isPrivate && this._options.mangleProtected) {
      isPrivate = this.hasModifier(node, ts.SyntaxKind.ProtectedKeyword);
    }
    if (!this._options.ignoreJsDocTag) {
      if (!isPrivate && this.hasJsDocTag(node, MANGLE_JSDOC_TAG_NAME)) {
        isPrivate = true;
      }
      if (isPrivate && this.hasJsDocTag(node, DONT_MANGLE_JSDOC_TAG_NAME)) {
        isPrivate = false;
      }
    }
    let parentName;
    if (ts.isParameter(node) && node.parent && node.parent.kind === ts.SyntaxKind.Constructor && node.parent.parent && ts.isClassDeclaration(node.parent.parent)) {
      parentName = (_a = node.parent.parent.name) === null || _a === void 0 ? void 0 : _a.escapedText;
    } else {
      parentName = (_b = node.parent.name) === null || _b === void 0 ? void 0 : _b.escapedText;
    }
    if (!parentName) return isPrivate;
    const name = node.name.getText();
    const isParentSymbolPrivate = parentSymbol && this.isParentSymbolPrivate(parentSymbol, name);
    if (isParentSymbolPrivate !== undefined) {
      // Ignore current private description and use parent's one
      isPrivate = isParentSymbolPrivate;
    } else {
      isPrivate = this.updatePrivateByOptions(isPrivate, parentName, name);
    }
    return isPrivate;
  }
  updatePrivateByOptions(isPrivate, parentName, propertyName) {
    if (parentName === undefined) return isPrivate;
    let fullName = parentName;
    if (propertyName) {
      fullName = fullName + '.' + propertyName;
    }
    // Check the mangleList option
    if (!isPrivate) {
      if (this._options.mangleList.includes(fullName) || this._options.mangleList.includes(parentName)) {
        isPrivate = true;
      }
    }
    // Check the dontMangleList option
    if (isPrivate) {
      if (this._options.dontMangleList.includes(fullName) || this._options.dontMangleList.includes(parentName)) {
        isPrivate = false;
      }
    }
    return isPrivate;
  }
  isParentSymbolPrivate(parentSymbol, name) {
    if (this._options.ignoreJsDocTag) {
      return undefined;
    }
    let valueDecl = parentSymbol.valueDeclaration;
    if (!valueDecl) {
      const decls = parentSymbol.declarations;
      if (decls) {
        valueDecl = decls[0];
      }
    }
    if (valueDecl) {
      if (ts.isClassDeclaration(valueDecl) || ts.isInterfaceDeclaration(valueDecl)) {
        if (valueDecl.heritageClauses) {
          for (const heritageClause of valueDecl.heritageClauses) {
            for (const type of heritageClause.types) {
              const classOrInterfaceSymbol = this._typeChecker.getSymbolAtLocation(type.expression);
              if (classOrInterfaceSymbol && parentSymbol !== classOrInterfaceSymbol) {
                const classOrInterfaceType = this._typeChecker.getDeclaredTypeOfSymbol(classOrInterfaceSymbol);
                const members = classOrInterfaceType.getProperties();
                for (const member of members) {
                  if (member.name === name) {
                    const jsDocTags = classOrInterfaceSymbol.getJsDocTags(this._typeChecker);
                    if (jsDocTags.some(tag => tag.name === MANGLE_JSDOC_TAG_NAME)) {
                      return true;
                    } else if (jsDocTags.some(tag => tag.name === DONT_MANGLE_JSDOC_TAG_NAME)) {
                      return false;
                    } else {
                      return this.isPrivateNonStaticClassMember(member);
                    }
                  }
                }
              }
            }
          }
        }
        let found;
        // Check wether the parent class or interface has @mangle tag
        if (parentSymbol.members) {
          parentSymbol.members.forEach(member => {
            if (member.name === name) {
              found = member;
            }
          });
        }
        // exports stores static properties those don't exist in members.
        if (!found && parentSymbol.exports) {
          parentSymbol.exports.forEach(export_ => {
            if (export_.name === name) {
              found = export_;
            }
          });
        }
        if (found) {
          const parentJsDocTags = parentSymbol.getJsDocTags(this._typeChecker);
          if (parentJsDocTags.some(tag => tag.name === MANGLE_JSDOC_TAG_NAME)) {
            return true;
          } else if (parentJsDocTags.some(tag => tag.name === DONT_MANGLE_JSDOC_TAG_NAME)) {
            return false;
          }
        }
      }
    }
    return undefined;
  }
  hasModifier(node, modifier) {
    return this.getModifiers(node).some(mod => mod.kind === modifier);
  }
  isAccessExpression(node) {
    return ts.isPropertyAccessExpression(node) || ts.isElementAccessExpression(node);
  }
  isClassMember(node) {
    let ret = ts.isMethodDeclaration(node) || ts.isPropertyDeclaration(node);
    if (!ret && this._options.mangleGetterSetter) {
      ret = ts.isGetAccessor(node) || ts.isSetAccessor(node);
    }
    if (!ret) {
      if (ts.isParameter(node) && node.parent.kind === ts.SyntaxKind.Constructor && node.getChildCount() > 0) {
        const modifiers = ts.getModifiers(node);
        if (modifiers && modifiers.length > 0) {
          ret = modifiers.some(mod => mod.kind === ts.SyntaxKind.PublicKeyword || mod.kind === ts.SyntaxKind.ProtectedKeyword || mod.kind === ts.SyntaxKind.PrivateKeyword);
        }
      }
    }
    return ret;
  }
  isInterfaceMember(node) {
    let ret = ts.isMethodSignature(node) || ts.isPropertySignature(node);
    if (!ret && this._options.mangleGetterSetter) {
      ret = ts.isGetAccessor(node) || ts.isSetAccessor(node);
    }
    return ret;
  }
  isConstructorParameter(node) {
    return ts.isParameter(node) && ts.isConstructorDeclaration(node.parent);
  }
  isConstructorParameterReference(node, program) {
    if (!ts.isIdentifier(node)) {
      return false;
    }
    const typeChecker = program.getTypeChecker();
    const symbol = typeChecker.getSymbolAtLocation(node);
    return this.isPrivateNonStaticClassMember(symbol);
  }
  isPropertyInInterfaceNotShorthand(node) {
    if (!node) return false;
    let isPropertyInInterface = ts.isPropertyAssignment(node) || ts.isMethodDeclaration(node);
    if (!isPropertyInInterface && this._options.mangleGetterSetter) {
      isPropertyInInterface = ts.isGetAccessor(node) || ts.isSetAccessor(node);
    }
    return isPropertyInInterface;
  }
  getTypeSymbol(interfaceType, propertyName) {
    let typeSymbol;
    if (interfaceType.isUnion()) {
      for (const t of interfaceType.types) {
        if (!t.symbol || !t.symbol.members) continue;
        if (t.symbol.members.has(propertyName)) {
          typeSymbol = t.symbol;
          break;
        }
      }
    } else {
      typeSymbol = interfaceType.symbol;
    }
    return typeSymbol;
  }
  isInterfacePropertyHasMangleTag(typeSymbol, propertyName) {
    if (this._options.ignoreJsDocTag) {
      return false;
    }
    const checker = this._typeChecker;
    let isPrivate = false;
    // interface definition has @mangle tag
    if (typeSymbol.getJsDocTags(checker).some(tag => tag.name === MANGLE_JSDOC_TAG_NAME)) {
      isPrivate = true;
    } else {
      if (typeSymbol.getJsDocTags(checker).some(tag => tag.name === MANGLE_JSDOC_TAG_NAME)) {
        isPrivate = true;
      } else {
        if (typeSymbol.members) {
          const members = typeSymbol.members.values();
          let result = members.next();
          while (!result.done) {
            const member = result.value;
            if (member && member.valueDeclaration) {
              for (const child of member.valueDeclaration.getChildren()) {
                const symbol = checker.getSymbolAtLocation(child);
                if (symbol && symbol.escapedName === propertyName) {
                  for (const tag of symbol.getJsDocTags(checker)) {
                    if (tag.name === MANGLE_JSDOC_TAG_NAME) {
                      isPrivate = true;
                      break;
                    }
                  }
                }
                if (isPrivate) {
                  break;
                }
              }
              if (isPrivate) {
                break;
              }
            }
            result = members.next();
          }
        }
      }
    }
    return isPrivate;
  }
  isIdentifierInVariableDeclaration(node, program) {
    var _a;
    if (!ts.isIdentifier(node)) {
      return false;
    }
    const parent = node.parent;
    if (!parent) {
      return false;
    }
    const prev3Node = (_a = parent.parent) === null || _a === void 0 ? void 0 : _a.parent;
    if (!prev3Node) return false;
    if (ts.isVariableDeclaration(prev3Node)) {
      if (parent.name !== node) {
        return false;
      }
      const checker = program.getTypeChecker();
      const propertyName = node.text;
      const type = checker.getTypeAtLocation(prev3Node.name);
      const typeSymbol = this.getTypeSymbol(type, propertyName);
      if (!typeSymbol) {
        return false;
      }
      const isPrivate = this.isInterfacePropertyHasMangleTag(typeSymbol, propertyName);
      const parentName = typeSymbol.escapedName;
      return this.updatePrivateByOptions(isPrivate, parentName, propertyName);
    }
    return false;
  }
  isIdentifierInArrayLiteralExpression(node, program) {
    var _a;
    if (!ts.isIdentifier(node)) {
      return false;
    }
    const parent = node.parent;
    if (!parent) {
      return false;
    }
    const prev3Node = (_a = parent.parent) === null || _a === void 0 ? void 0 : _a.parent;
    if (!prev3Node) return false;
    if (ts.isArrayLiteralExpression(prev3Node)) {
      const checker = this._typeChecker;
      const contextualType = checker.getContextualType(prev3Node);
      if (!contextualType) {
        return false;
      }
      if (contextualType.symbol && contextualType.symbol.name === 'Array') {
        const typeArguments = checker.getTypeArguments(contextualType);
        const elementType = typeArguments[0];
        const propertyName = node.text;
        const typeSymbol = this.getTypeSymbol(elementType, propertyName);
        if (!typeSymbol) {
          return false;
        }
        const isPrivate = this.isInterfacePropertyHasMangleTag(typeSymbol, propertyName);
        const parentName = typeSymbol.escapedName;
        return this.updatePrivateByOptions(isPrivate, parentName, propertyName);
      }
    }
    return false;
  }
  isIdentifierInBinaryExpression(node, program) {
    var _a;
    if (!ts.isIdentifier(node)) {
      return false;
    }
    const parent = node.parent;
    if (!parent) {
      return false;
    }
    const prev3Node = (_a = parent.parent) === null || _a === void 0 ? void 0 : _a.parent;
    if (!prev3Node) return false;
    if (ts.isBinaryExpression(prev3Node)) {
      if (parent.name !== node) {
        return false;
      }
      const checker = program.getTypeChecker();
      const propertyName = node.text;
      const type = checker.getTypeAtLocation(prev3Node.left);
      const typeSymbol = this.getTypeSymbol(type, propertyName);
      if (!typeSymbol) {
        return false;
      }
      const isPrivate = this.isInterfacePropertyHasMangleTag(typeSymbol, propertyName);
      const parentName = typeSymbol.escapedName;
      return this.updatePrivateByOptions(isPrivate, parentName, propertyName);
    }
    return false;
  }
  isPropertyAssignment(node) {
    return ts.isPropertyAssignment(node);
  }
  isPrivateNonStaticClassMember(symbol) {
    // for some reason ts.Symbol.declarations can be undefined (for example in order to accessing to proto member)
    if (symbol === undefined || symbol.declarations === undefined) {
      return false;
    }
    const parentSymbol = symbol.parent;
    const ret = symbol.declarations.some(x => {
      // terser / uglify property minifiers aren't able to handle decorators
      return ((this.isClassMember(x) || this.isInterfaceMember(x) || this.isPropertyAssignment(x)) && !this.hasDecorators(x) || this.isConstructorParameter(x)) && this.isPrivateNonStatic(x, parentSymbol);
    });
    return ret;
  }
  hasDecorators(node) {
    if (this.isBreakingTypeScriptApi(ts)) {
      return ts.canHaveDecorators(node) && !!ts.getDecorators(node);
    }
    return !!node.decorators;
  }
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  getModifiers(node) {
    if (this.isBreakingTypeScriptApi(ts)) {
      if (!ts.canHaveModifiers(node)) {
        return [];
      }
      return ts.getModifiers(node) || [];
    }
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    return node.modifiers || [];
  }
  isBreakingTypeScriptApi(compiler) {
    return 'canHaveDecorators' in ts;
  }
}
exports.PropertiesMinifier = PropertiesMinifier;
function minifyPrivatePropertiesTransformer(program, config) {
  return context => {
    const minifier = new PropertiesMinifier(context, config);
    return file => {
      return minifier.visitSourceFile(file, program, context);
    };
  };
}
exports.minifyPrivatePropertiesTransformer = minifyPrivatePropertiesTransformer;