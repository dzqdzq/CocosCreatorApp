"use strict";

// This code was modified from https://github.com/timocov/ts-transformer-minify-privates
var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  var desc = Object.getOwnPropertyDescriptor(m, k);
  if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
    desc = {
      enumerable: true,
      get: function () {
        return m[k];
      }
    };
  }
  Object.defineProperty(o, k2, desc);
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});
var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});
var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
  __setModuleDefault(result, mod);
  return result;
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.warningPrinterTransformer = exports.WarningPrinter = void 0;
const ts = __importStar(require("@cocos/typescript"));
const defaultOptions = {
  warnThisDotThreshold: 0,
  warnNoConstructorFound: false
};
class WarningPrinter {
  constructor(context, options) {
    this._currentProgram = null;
    this._currentSourceFile = null;
    this._context = context;
    this._options = Object.assign(Object.assign({}, defaultOptions), options);
  }
  visitSourceFile(node, program, context) {
    this._currentProgram = program;
    this._currentSourceFile = node;
    this._typeChecker = program.getTypeChecker();
    const result = this.visitNodeAndChildren(node, program, context);
    this._currentProgram = null;
    this._currentSourceFile = null;
    return result;
  }
  visitNodeAndChildren(node, program, context) {
    return ts.visitEachChild(this.visitNode(node, program), childNode => this.visitNodeAndChildren(childNode, program, context), context);
  }
  getNodeByKind(children, kind) {
    for (const child of children) {
      if (child.kind === kind) {
        return child;
      }
      if (child.kind === ts.SyntaxKind.SyntaxList) {
        const foundNode = this.getNodeByKind(child.getChildren(), kind);
        if (foundNode) {
          return foundNode;
        }
      }
    }
    return null;
  }
  visitNode(node, program) {
    if (ts.isClassDeclaration(node)) {
      if (this._options.warnNoConstructorFound) {
        this.checkHaveConstructor(node);
      }
    } else if (ts.isBlock(node)) {
      if (this._options.warnThisDotThreshold > 0) {
        this.checkThisDotCountInBlock(node);
      }
    }
    return node;
  }
  checkHaveConstructor(node) {
    var _a, _b;
    const children = node.getChildren(this._currentSourceFile);
    const foundConstructor = this.getNodeByKind(children, ts.SyntaxKind.Constructor);
    if (!foundConstructor && (!node.parent || !ts.isBlock(node.parent))) {
      const heritageClause = this.getNodeByKind(children, ts.SyntaxKind.HeritageClause);
      if (heritageClause) {
        if (heritageClause.token !== ts.SyntaxKind.ExtendsKeyword) {
          return;
        }
        const filePath = ((_a = this._currentSourceFile) === null || _a === void 0 ? void 0 : _a.fileName) || '';
        if (!filePath.includes('node_modules')) {
          console.warn(`[OPTIMIZE ME] Class ( ${(_b = node.name) === null || _b === void 0 ? void 0 : _b.getText()} ) doesn't have a default constructor, ${filePath}`);
        }
      }
    }
  }
  checkThisDotCountInBlock(node) {
    var _a;
    if (!this._currentSourceFile) {
      return;
    }
    const blockParent = node.parent;
    if (!blockParent) {
      console.warn('[WARN] blockParent is undefined, sourceFile:', this._currentSourceFile.fileName);
      return;
    }
    const text = node.getText();
    const thisDotCount = (text.match(/this\./g) || []).length;
    if (thisDotCount > this._options.warnThisDotThreshold) {
      const sourceFileName = this._currentSourceFile.fileName;
      if (sourceFileName.includes('node_modules')) {
        return;
      }
      if (blockParent && ts.isMethodDeclaration(blockParent) || ts.isFunctionDeclaration(blockParent) || ts.isGetAccessor(blockParent) || ts.isSetAccessor(blockParent) || ts.isArrowFunction(blockParent)) {
        const parentName = (_a = blockParent.name) === null || _a === void 0 ? void 0 : _a.getText();
        console.warn(`[OPTIMIZE ME] Found ${thisDotCount} 'this.' in block: ${parentName}, sourceFile: ${sourceFileName}`);
      }
    }
  }
}
exports.WarningPrinter = WarningPrinter;
function warningPrinterTransformer(program, config) {
  return context => {
    const warningPrinter = new WarningPrinter(context, config);
    return file => {
      return warningPrinter.visitSourceFile(file, program, context);
    };
  };
}
exports.warningPrinterTransformer = warningPrinterTransformer;