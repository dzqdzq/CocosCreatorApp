"use strict";

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.buildJsEngine = void 0;
const fs_extra_1 = __importDefault(require("fs-extra"));
const path_1 = __importDefault(require("path"));
const transformer_1 = require("../../../transformer/lib/index.js");
const bundler_1 = require("../../../bundler/lib/index.js");
const utils_1 = require("../../../utils/lib/index.js");
const fs_1 = __importDefault(require("fs"));
const ts_paths_1 = __importDefault(require("./rollup-plugins/ts-paths"));
const module_query_plugin_1 = __importDefault(require("./rollup-plugins/module-query-plugin"));
const remove_deprecated_features_1 = __importDefault(require("./rollup-plugins/remove-deprecated-features"));
const external_wasm_loader_1 = require("./rollup-plugins/external-wasm-loader");
const stats_query_1 = require("../../../stats-query/lib/index.js");
const utils_2 = require("../../../utils/lib/index.js");
const systemjs_named_register_plugin_1 = require("./rollup-plugins/systemjs-named-register-plugin");
const enum_scanner_1 = require("./rollup-plugins/enum-scanner");
const rollup_plugin_typescript_1 = __importDefault(require("@cocos/rollup-plugin-typescript"));
const properties_minifier_1 = require("./ts-plugins/properties-minifier");
const warning_printer_1 = require("./ts-plugins/warning-printer");
const inline_enum_1 = require("./ts-plugins/inline-enum");
const export_controller_1 = require("./ts-plugins/export-controller");
var babelPluginTransformForOf = transformer_1.babel.plugins.transformForOf;
var babelPluginProposalOptionalChaining = transformer_1.babel.plugins.proposalOptionalChaining;
var babelPresetEnv = transformer_1.babel.presets.presetEnv;
var babelPluginDynamicImportVars = transformer_1.babel.plugins.cocosDynamicImportVars;
var babelPresetCC = transformer_1.babel.presets.presetCC.babelPresetCC;
var helpers = transformer_1.babel.presets.presetCC.helpers;
// import rollup
var rollup = bundler_1.rollup.core;
var rpBabel = bundler_1.rollup.plugins.babel.babel;
var json = bundler_1.rollup.plugins.json;
var nodeResolve = bundler_1.rollup.plugins.nodeResolve;
var commonjs = bundler_1.rollup.plugins.commonjs;
var rpTerser = bundler_1.rollup.plugins.terser;
var rpVirtual = bundler_1.rollup.plugins.virtual;
const modularize_1 = require("../../../modularize/lib/index.js");
// import rpProgress = Bundler.plugins.progress;
const decorator_parser_1 = require("./babel-plugins/decorator-parser");
const realPath = function () {
  const realpath = typeof fs_1.default.realpath.native === 'function' ? fs_1.default.realpath.native : fs_1.default.realpath;
  return file => new Promise((resolve, reject) => {
    realpath(file, (err, path) => {
      if (err && err.code !== 'ENOENT') {
        reject(err);
      } else {
        resolve(err ? file : path);
      }
    });
  });
}();
async function buildJsEngine(options) {
  var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o;
  const doUglify = !!options.compress;
  const engineRoot = path_1.default.resolve(options.engine);
  const rollupFormat = (_a = options.moduleFormat) !== null && _a !== void 0 ? _a : 'iife';
  const statsQuery = await stats_query_1.StatsQuery.create(engineRoot);
  const moduleQuery = new modularize_1.ModuleQuery({
    engine: engineRoot,
    platform: options.platform
  });
  if (options.features) {
    for (const feature of options.features) {
      if (!statsQuery.hasFeature(feature)) {
        console.warn(`'${feature}' is not a valid feature.`);
      }
    }
  }
  let features;
  let split = (_b = options.split) !== null && _b !== void 0 ? _b : false;
  if (options.features && options.features.length !== 0) {
    features = options.features;
  } else {
    features = statsQuery.getFeatures();
    if (split !== true) {
      split = true;
      console.warn(`You did not specify features which implies 'split: true'. ` + `Explicitly set 'split: true' to suppress this warning.`);
    }
  }
  let {
    nativeCodeBundleMode
  } = options;
  nativeCodeBundleMode !== null && nativeCodeBundleMode !== void 0 ? nativeCodeBundleMode : nativeCodeBundleMode = 'both'; // default is true
  const flags = (_c = options.flags) !== null && _c !== void 0 ? _c : {};
  const overriddenConstants = statsQuery.getOverriddenConstantsOfFeatures(features);
  const flagsWithOverriddenConstants = Object.assign(Object.assign({}, overriddenConstants), flags);
  const intrinsicFlags = statsQuery.getIntrinsicFlagsOfFeatures(features);
  let buildTimeConstants = statsQuery.constantManager.genBuildTimeConstants({
    mode: options.mode,
    platform: options.platform,
    flags: flagsWithOverriddenConstants
  });
  buildTimeConstants = Object.assign(Object.assign({}, intrinsicFlags), buildTimeConstants);
  // if (typeof options.forceJitValue !== undefined) {
  //     buildTimeConstants['SUPPORT_JIT'] = options.forceJitValue as boolean;
  // }
  const context = {
    mode: options.mode,
    platform: options.platform,
    buildTimeConstants
  };
  const moduleOverrides = Object.entries(statsQuery.evaluateModuleOverrides(context)).reduce((result, [k, v]) => {
    result[utils_1.ps.makePathEqualityKey(k)] = v;
    return result;
  }, {});
  const featureUnits = statsQuery.getUnitsOfFeatures(features);
  const rpVirtualOptions = {};
  const vmInternalConstants = statsQuery.constantManager.exportStaticConstants({
    platform: options.platform,
    mode: options.mode,
    flags: flagsWithOverriddenConstants
  });
  console.debug(`Module source "internal-constants":\n${vmInternalConstants}`);
  rpVirtualOptions['internal:constants'] = vmInternalConstants;
  rpVirtualOptions[helpers.CC_HELPER_MODULE] = helpers.generateHelperModuleSource();
  // for some modules that we need to instantiate before cc module
  // const forceStandaloneModules = ['wait-for-ammo-instantiation'];
  const forceStandaloneModules = [];
  let rollupEntries;
  if (split) {
    rollupEntries = featureUnits.reduce((result, featureUnit) => {
      result[featureUnit] = statsQuery.getFeatureUnitFile(featureUnit);
      return result;
    }, {});
  } else {
    rollupEntries = {
      cc: 'cc'
    };
    const selectedFeatureUnits = [];
    for (const featureUnit of featureUnits) {
      if (forceStandaloneModules.includes(featureUnit)) {
        rollupEntries[featureUnit] = statsQuery.getFeatureUnitFile(featureUnit);
      } else {
        selectedFeatureUnits.push(featureUnit);
      }
    }
    rpVirtualOptions.cc = statsQuery.evaluateIndexModuleSource(selectedFeatureUnits, featureUnit => (0, utils_2.filePathToModuleRequest)(statsQuery.getFeatureUnitFile(featureUnit)));
    rollupEntries.cc = 'cc';
    console.debug(`Module source "cc":\n${rpVirtualOptions.cc}`);
  }
  const presetEnvOptions = {
    loose: (_d = options.loose) !== null && _d !== void 0 ? _d : true,
    // We need explicitly specified targets.
    // Ignore it to avoid the engine's parent dirs contain unexpected config.
    ignoreBrowserslistConfig: true
  };
  if (options.targets) {
    presetEnvOptions.targets = options.targets;
  }
  const babelPlugins = [];
  if (!options.targets) {
    babelPlugins.push([babelPluginTransformForOf, {
      loose: true
    }]);
  }
  babelPlugins.push([babelPluginProposalOptionalChaining, {
    loose: true
  }]);
  babelPlugins.push([babelPluginDynamicImportVars, {
    resolve: {
      forwardExt: 'resolved'
    }
  }]);
  const {
    fieldDecorators,
    editorDecorators
  } = statsQuery.getOptimizeDecorators();
  const babelOptions = {
    babelHelpers: 'bundled',
    extensions: ['.js', '.ts'],
    exclude: [/node_modules[/\\]@cocos[/\\]ammo/, /node_modules[/\\]@cocos[/\\]cannon/, /node_modules[/\\]@cocos[/\\]physx/, /\.asm\.js/],
    comments: false,
    overrides: [{
      // Eliminates the babel compact warning:
      // 'The code generator has deoptimised the styling of ...'
      // that came from node_modules/@cocos
      test: /node_modules[/\\]@cocos[/\\]/,
      compact: true
    }],
    plugins: babelPlugins,
    presets: [[babelPresetEnv, presetEnvOptions], [babelPresetCC, {
      allowDeclareFields: true,
      ccDecoratorHelpers: 'external',
      fieldDecorators,
      editorDecorators
    }]]
  };
  if (options.generateDecoratorsForJSB) {
    if (!process.env.ENGINE_PATH) {
      throw new Error('ENGINE_PATH environment variable not set');
    }
    (_e = babelOptions.presets) === null || _e === void 0 ? void 0 : _e.push([() => ({
      plugins: [[decorator_parser_1.recordDecorators]]
    })]);
  }
  const rollupPlugins = [];
  if (options.noDeprecatedFeatures) {
    rollupPlugins.push((0, remove_deprecated_features_1.default)(typeof options.noDeprecatedFeatures === 'string' ? options.noDeprecatedFeatures : undefined));
  }
  const rpEnumScannerPlugin = await (0, enum_scanner_1.rpEnumScanner)({
    scanDir: path_1.default.join(engineRoot, 'cocos'),
    moduleOverrides
  });
  rollupPlugins.push((0, external_wasm_loader_1.externalWasmLoader)({
    externalRoot: path_1.default.join(engineRoot, 'native/external'),
    nativeCodeBundleMode,
    wasmCompressionMode: options.wasmCompressionMode,
    cullMeshopt: buildTimeConstants.CULL_MESHOPT,
    format: 'relative-from-chunk',
    wasmSubpackage: buildTimeConstants.WASM_SUBPACKAGE
  }), {
    name: '@cocos/ccbuild|module-overrides',
    resolveId(source, importer) {
      if (moduleOverrides[source]) {
        return source;
      } else {
        return null;
      }
    },
    load(id) {
      const key = utils_1.ps.makePathEqualityKey(id);
      if (!(key in moduleOverrides)) {
        return null;
      }
      const replacement = moduleOverrides[key];
      console.debug(`Redirect module ${id} to ${replacement}`);
      return `export * from '${(0, utils_2.filePathToModuleRequest)(replacement)}';`;
    }
  }, rpVirtual(rpVirtualOptions), (0, module_query_plugin_1.default)(moduleQuery), (0, ts_paths_1.default)({
    configFileName: path_1.default.resolve(options.engine, 'tsconfig.json')
  }), nodeResolve({
    extensions: ['.js', '.ts', '.json'],
    jail: await realPath(engineRoot),
    rootDir: engineRoot
  }), json({
    preferConst: true
  }), commonjs({
    include: [/node_modules[/\\]/, /asm\.js/],
    sourceMap: false
  }));
  const inlineEnum = (_f = options.inlineEnum) !== null && _f !== void 0 ? _f : false;
  const mangleProperties = (_g = options.mangleProperties) !== null && _g !== void 0 ? _g : false;
  const warnNoConstructorFound = (_j = (_h = options.warn) === null || _h === void 0 ? void 0 : _h.noConstructorFound) !== null && _j !== void 0 ? _j : false;
  const warnThisDotThreshold = (_l = (_k = options.warn) === null || _k === void 0 ? void 0 : _k.thisDotThreshold) !== null && _l !== void 0 ? _l : 0;
  if (inlineEnum) {
    rollupPlugins.push(...rpEnumScannerPlugin);
  }
  rollupPlugins.push((0, rollup_plugin_typescript_1.default)({
    tsconfig: path_1.default.join(engineRoot, 'tsconfig.json'),
    compilerOptions: {
      noEmit: false,
      target: undefined,
      sourceMap: undefined,
      outDir: undefined,
      module: 'NodeNext',
      skipBuiltinTransformers: true
    },
    transformers: program => {
      const tsTransformers = [];
      // The order of ts transformers is important, don't change the order if you don't know what you are doing.
      // warningPrinterTransformer should be the first one to avoid 'undefined' parent after minify private properties.
      if (warnNoConstructorFound || warnThisDotThreshold) {
        const config = {
          warnNoConstructorFound,
          warnThisDotThreshold
        };
        tsTransformers.push((0, warning_printer_1.warningPrinterTransformer)(program, config));
      }
      if (inlineEnum) {
        const enumData = (0, enum_scanner_1.getEnumData)();
        if (enumData) {
          tsTransformers.push((0, inline_enum_1.inlineEnumTransformer)(program, enumData));
        } else {
          console.error(`Enum data is not available for inline enum.`);
        }
      }
      tsTransformers.push((0, export_controller_1.exportControllerTransformer)(program, {
        context,
        statsQuery
      }));
      if (mangleProperties) {
        const config = {};
        if (typeof mangleProperties === 'object') {
          Object.assign(config, mangleProperties);
        }
        tsTransformers.push((0, properties_minifier_1.minifyPrivatePropertiesTransformer)(program, config));
      }
      return {
        before: tsTransformers
      };
    }
  }));
  rollupPlugins.push(rpBabel(Object.assign({
    skipPreflightCheck: true
  }, babelOptions)));
  // The named-registered format of `System.register('cocos-js/cc.js', [], function() {...})` needs to be generated when the feature of preloading JS list is enabled.
  // Otherwise, we will generate the default register code without name like `System.register([], function() {...})`.
  if (options.enableNamedRegisterForSystemJSModuleFormat && options.moduleFormat === 'system') {
    rollupPlugins.push((0, systemjs_named_register_plugin_1.rpNamedChunk)());
  }
  // if (options.progress) {
  //     rollupPlugins.unshift(rpProgress());
  // }
  if (doUglify) {
    // TODO: tree-shaking not clear!
    rollupPlugins.push(rpTerser({
      // see https://github.com/terser/terser#compress-options
      compress: {
        reduce_funcs: false,
        keep_fargs: false,
        unsafe_Function: true,
        unsafe_math: true,
        unsafe_methods: true,
        passes: 2 // first: remove deadcodes and const objects, second: drop variables
      },

      mangle: {
        properties: options.mangleProperties ? {
          regex: /^_ccprivate\$/
        } : false
      },
      keep_fnames: false,
      output: {
        beautify: false
      },
      // https://github.com/rollup/rollup/issues/3315
      // We only do this for CommonJS.
      // Especially, we cannot do this for IIFE.
      toplevel: rollupFormat === 'cjs',
      // Enabling 'split' will have more than one entry, nameCache will not be able to be shared by different workers in rollup-plugin-terser.
      // So disable worker if 'split' mode is enabled.
      maxWorkers: split ? 0 : undefined,
      // Use name cache if it's in 'split' mode.
      nameCache: split ? {} : undefined
    }));
  }
  const visualizeOptions = typeof options.visualize === 'object' ? options.visualize : options.visualize ? {} : undefined;
  if (visualizeOptions) {
    let rpVisualizer;
    try {
      // eslint-disable-next-line import/no-extraneous-dependencies
      rpVisualizer = await import('rollup-plugin-visualizer');
    } catch (_p) {
      console.warn('Visualizing needs \'rollup-plugin-visualizer\' to be installed. It\'s installed as dev-dependency.');
    }
    if (rpVisualizer) {
      const visualizeFile = (_m = visualizeOptions.file) !== null && _m !== void 0 ? _m : path_1.default.join(options.out, 'visualize.html');
      rollupPlugins.push(rpVisualizer.visualizer({
        filename: visualizeFile,
        title: 'Cocos Creator build visualizer',
        template: 'treemap'
      }));
    }
  }
  let hasCriticalWarns = false;
  const rollupWarningHandler = (warning, defaultHandler) => {
    var _a;
    if (typeof warning !== 'string') {
      if (warning.code === 'CIRCULAR_DEPENDENCY') {
        hasCriticalWarns = true;
      } else if (warning.code === 'THIS_IS_UNDEFINED') {
        // TODO: It's really inappropriate to do this...
        // Let's fix these files instead of suppressing rollup.
        if ((_a = warning.id) === null || _a === void 0 ? void 0 : _a.match(/(?:spine-core\.js$)|(?:dragonBones\.js$)/)) {
          console.debug(`Rollup warning 'THIS_IS_UNDEFINED' is omitted for ${warning.id}`);
          return;
        }
      }
    }
    defaultHandler(warning);
  };
  const rollupOptions = {
    input: rollupEntries,
    plugins: rollupPlugins,
    cache: false,
    onwarn: rollupWarningHandler
  };
  const treeshakeConfig = statsQuery.getTreeShakeConfig();
  const noSideEffectFiles = treeshakeConfig === null || treeshakeConfig === void 0 ? void 0 : treeshakeConfig.noSideEffectFiles;
  if (noSideEffectFiles && noSideEffectFiles.length > 0) {
    for (const noSideEffectFile of noSideEffectFiles) {
      const absolutePath = path_1.default.join(engineRoot, noSideEffectFile);
      if (!fs_extra_1.default.pathExistsSync(absolutePath)) {
        console.error(`>>> ERROR: noSideEffectFile: ( ${noSideEffectFile} ) doesn't exist!`);
      }
    }
    rollupOptions.treeshake = {
      moduleSideEffects: id => {
        const relativePath = (0, utils_2.formatPath)(path_1.default.relative(engineRoot, id));
        if (noSideEffectFiles.includes(relativePath)) {
          // console.info(`>>> Found no side-effect path: ${relativePath}`);
          return false;
        }
        return true;
      }
    };
  } else {
    console.info(`>>> No treeshake config found!`);
  }
  const perf = true;
  if (perf) {
    rollupOptions.perf = true;
  }
  const rollupBuild = await rollup.rollup(rollupOptions);
  const timing = (_o = rollupBuild.getTimings) === null || _o === void 0 ? void 0 : _o.call(rollupBuild);
  if (timing) {
    console.debug(`==== Performance ====`);
    console.debug(JSON.stringify(timing));
    console.debug(`====             ====`);
  }
  const {
    incremental: incrementalFile
  } = options;
  if (incrementalFile) {
    const watchFiles = {};
    const files = rollupBuild.watchFiles;
    await Promise.all(files.map(async watchFile => {
      try {
        const stat = await fs_extra_1.default.stat(watchFile);
        watchFiles[watchFile] = stat.mtimeMs;
      } catch (_a) {
        // the `watchFiles` may contain non-fs modules.
      }
    }));
    await fs_extra_1.default.ensureDir(path_1.default.dirname(incrementalFile));
    await fs_extra_1.default.writeFile(incrementalFile, JSON.stringify(watchFiles, undefined, 2));
  }
  const result = {
    chunkAliases: {},
    exports: {},
    chunkDepGraph: {},
    assetDepGraph: {},
    hasCriticalWarns: false
  };
  const rollupOutputOptions = {
    format: rollupFormat,
    sourcemap: options.sourceMap,
    sourcemapFile: options.sourceMapFile,
    name: rollupFormat === 'iife' ? 'ccm' : undefined,
    dir: options.out,
    // NOTE: parallel dynamic import has some issue on SystemJS, especially on OH platform
    // see: https://github.com/systemjs/systemjs/issues/2297
    inlineDynamicImports: options.platform === 'OPEN_HARMONY'
    // minifyInternalExports: false,
    // preserveEntrySignatures: "allow-extension",
  };

  const rollupOutput = await rollupBuild.write(rollupOutputOptions);
  const validEntryChunks = {};
  for (const output of rollupOutput.output) {
    if (output.type === 'chunk') {
      if (output.isEntry) {
        const chunkName = output.name;
        if (chunkName in rollupEntries || chunkName === 'cc') {
          validEntryChunks[chunkName] = output.fileName;
        }
      }
    }
  }
  Object.assign(result.exports, validEntryChunks);
  result.dependencyGraph = {};
  for (const output of rollupOutput.output) {
    if (output.type === 'chunk') {
      const depList = output.imports.concat(output.dynamicImports);
      result.dependencyGraph[output.fileName] = depList;
      result.chunkDepGraph[output.fileName] = depList;
      result.assetDepGraph[output.fileName] = output.referencedFiles.slice();
    }
  }
  result.hasCriticalWarns = hasCriticalWarns;
  return result;
}
exports.buildJsEngine = buildJsEngine;