"use strict";

// Inspired by https://github.com/unplugin/unplugin-inline-enum
var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.rpInlineEnum = void 0;
const pluginutils_1 = require("@rollup/pluginutils");
const magic_string_1 = __importDefault(require("magic-string"));
const plugin_replace_1 = __importDefault(require("@rollup/plugin-replace"));
const options_1 = require("./core/options");
const enum_1 = require("./core/enum");
const utils_1 = require("../../../../../utils/lib/index.js");
const convertNumberValuesToString = obj => {
  return Object.entries(obj).reduce((acc, [key, value]) => {
    acc[key] = JSON.stringify(value); // + ` /* _.${key} */ `;
    return acc;
  }, {});
};
/**
 * The main unplugin instance.
 */
async function rpInlineEnum(rawOptions, meta) {
  const options = (0, options_1.resolveOptions)(rawOptions);
  const filter = (0, pluginutils_1.createFilter)(options.include, options.exclude);
  const {
    declarations,
    defines
  } = await (0, enum_1.scanEnums)(options);
  const strDefines = convertNumberValuesToString(defines);
  strDefines['Float32Array.BYTES_PER_ELEMENT'] = '4';
  strDefines['Float64Array.BYTES_PER_ELEMENT'] = '8';
  strDefines['Uint8Array.BYTES_PER_ELEMENT'] = '1';
  strDefines['Uint8ClampedArray.BYTES_PER_ELEMENT'] = '1';
  strDefines['Uint16Array.BYTES_PER_ELEMENT'] = '2';
  strDefines['Uint32Array.BYTES_PER_ELEMENT'] = '4';
  strDefines['Int8Array.BYTES_PER_ELEMENT'] = '1';
  strDefines['Int16Array.BYTES_PER_ELEMENT'] = '2';
  strDefines['Int32Array.BYTES_PER_ELEMENT'] = '4';
  const replacePlugin = (0, plugin_replace_1.default)({
    include: options.include,
    exclude: options.exclude,
    values: strDefines,
    delimiters: ['(?<!\\.)\\b', '\\b(?!\\.)'],
    preventAssignment: true
  });
  const name = 'cc-inline-enum';
  return [{
    name,
    //   enforce: options.enforce,
    async resolveId(source, importer) {
      return filter(source) ? source : null;
    },
    transform(code, moduleId) {
      // Don't transform a module that is overrode
      const cacheKey = utils_1.ps.makePathEqualityKey(moduleId);
      if (options.moduleOverrides && cacheKey in options.moduleOverrides) {
        return;
      }
      let s;
      if (moduleId in declarations) {
        s || (s = new magic_string_1.default(code));
        for (const declaration of declarations[moduleId]) {
          const {
            range: [start, end],
            id,
            members,
            exported
          } = declaration;
          const prefix = exported ? 'export' : '';
          s.update(start, end, `${prefix} const ${id} = {${members.flatMap(({
            name,
            value
          }) => {
            const forwardMapping = `${JSON.stringify(name)}: ${JSON.stringify(value)}`;
            const reverseMapping = `${JSON.stringify(value.toString())}: ${JSON.stringify(name)}`;
            // see https://www.typescriptlang.org/docs/handbook/enums.html#reverse-mappings
            return typeof value === 'string' ? [forwardMapping
            // string enum members do not get a reverse mapping generated at all
            ] : [forwardMapping
            // other enum members should support enum reverse mapping
            // reverseMapping,
            ];
          }).join(',\n')}}`);
        }
      }
      if (s) {
        return {
          code: s.toString(),
          map: s.generateMap()
        };
      }
    }
  }, replacePlugin];
}
exports.rpInlineEnum = rpInlineEnum;