"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.buildIndexModule = exports.build = void 0;
const path_1 = __importDefault(require("path"));
const fs_extra_1 = __importDefault(require("fs-extra"));
const typescript_1 = __importDefault(require("typescript"));
const gift = __importStar(require("tfig"));
const stats_query_1 = require("../stats-query");
const DEBUG = false;
const REMOVE_TMP = true;
const REMOVE_OLD = !DEBUG;
const RECOMPILE = !DEBUG;
async function build(options) {
    var _a;
    console.log(`Typescript version: ${typescript_1.default.version}`);
    const { engine, outDir, withIndex = true, withExports = false, withEditorExports = false, } = options;
    await fs_extra_1.default.ensureDir(outDir);
    console.debug(`With index: ${withIndex}`);
    console.debug(`With exports: ${withExports}`);
    console.debug(`With editor exports: ${withEditorExports}`);
    const statsQuery = await stats_query_1.StatsQuery.create(engine);
    const tsConfigPath = statsQuery.tsConfigPath;
    const unbundledOutFile = path_1.default.join(outDir, `cc-before-rollup.js`);
    const parsedCommandLine = typescript_1.default.getParsedCommandLineOfConfigFile(tsConfigPath, {
        declaration: true,
        noEmit: false,
        emitDeclarationOnly: true,
        outFile: unbundledOutFile,
        outDir: undefined,
    }, {
        onUnRecoverableConfigFileDiagnostic: () => { },
        useCaseSensitiveFileNames: typescript_1.default.sys.useCaseSensitiveFileNames,
        readDirectory: typescript_1.default.sys.readDirectory,
        getCurrentDirectory: typescript_1.default.sys.getCurrentDirectory,
        fileExists: typescript_1.default.sys.fileExists,
        readFile: typescript_1.default.sys.readFile,
    });
    if (!parsedCommandLine) {
        throw new Error(`Can not get 'parsedCommandLine'.`);
    }
    const outputJSPath = path_1.default.join(path_1.default.dirname(tsConfigPath), unbundledOutFile);
    // console.log(outputJSPath);
    const extName = path_1.default.extname(outputJSPath);
    if (extName !== '.js') {
        console.error(`Unexpected output extension ${extName}, please check it.`);
        return undefined;
    }
    const dirName = path_1.default.dirname(outputJSPath);
    const baseName = path_1.default.basename(outputJSPath, extName);
    const destExtensions = [
        '.d.ts',
        '.d.ts.map',
    ];
    if (REMOVE_OLD) {
        for (const destExtension of destExtensions) {
            const destFile = path_1.default.join(dirName, baseName + destExtension);
            if (await fs_extra_1.default.pathExists(destFile)) {
                console.log(`Delete old ${destFile}.`);
                await fs_extra_1.default.unlink(destFile);
            }
        }
    }
    console.log(`Generating...`);
    const featureUnits = statsQuery.getFeatureUnits().filter((m) => m !== 'wait-for-ammo-instantiation');
    const editorExportModules = statsQuery.getEditorPublicModules();
    if (RECOMPILE) {
        let fileNames = parsedCommandLine.fileNames;
        if (withEditorExports) {
            fileNames = fileNames.concat(editorExportModules.map((e) => statsQuery.getEditorPublicModuleFile(e)));
        }
        const program = typescript_1.default.createProgram(fileNames, parsedCommandLine.options);
        const emitResult = program.emit(undefined, // targetSourceFile
        undefined, // writeFile
        undefined, // cancellationToken,
        true, // emitOnlyDtsFiles
        undefined);
        const allDiagnostics = typescript_1.default.getPreEmitDiagnostics(program).concat(emitResult.diagnostics);
        for (const diagnostic of allDiagnostics) {
            let printer;
            switch (diagnostic.category) {
                case typescript_1.default.DiagnosticCategory.Error:
                    printer = console.error;
                    break;
                case typescript_1.default.DiagnosticCategory.Warning:
                    printer = console.warn;
                    break;
                case typescript_1.default.DiagnosticCategory.Message:
                case typescript_1.default.DiagnosticCategory.Suggestion:
                default:
                    printer = console.log;
                    break;
            }
            if (!printer) {
                continue;
            }
            if (diagnostic.file && diagnostic.start !== undefined) {
                const { line, character } = diagnostic.file.getLineAndCharacterOfPosition(diagnostic.start);
                const message = typescript_1.default.flattenDiagnosticMessageText(diagnostic.messageText, typescript_1.default.sys.newLine);
                printer(`${diagnostic.file.fileName} (${line + 1},${character + 1}): ${message}`);
            }
            else {
                printer(`${typescript_1.default.flattenDiagnosticMessageText(diagnostic.messageText, '\n')}`);
            }
        }
    }
    const tscOutputDtsFile = path_1.default.join(dirName, `${baseName}.d.ts`);
    if (!await fs_extra_1.default.pathExists(tscOutputDtsFile)) {
        console.error(`Failed to compile.`);
        return false;
    }
    const types = (_a = parsedCommandLine.options.types) === null || _a === void 0 ? void 0 : _a.map((typeFile) => `${typeFile}.d.ts`);
    if (types) {
        for (const file of types) {
            const destPath = path_1.default.join(outDir, path_1.default.isAbsolute(file) ? path_1.default.basename(file) : file);
            await fs_extra_1.default.ensureDir(path_1.default.dirname(destPath));
            await fs_extra_1.default.copyFile(file, destPath);
        }
    }
    const giftInputs = [tscOutputDtsFile];
    const giftEntries = {};
    const cleanupFiles = [tscOutputDtsFile];
    if (withExports) {
        for (const exportEntry of featureUnits) {
            giftEntries[exportEntry] = getModuleNameInTsOutFile(statsQuery.getFeatureUnitFile(exportEntry), statsQuery);
        }
    }
    if (withEditorExports) {
        for (const editorExportModule of editorExportModules) {
            giftEntries[editorExportModule] = getModuleNameInTsOutFile(statsQuery.getEditorPublicModuleFile(editorExportModule), statsQuery);
        }
    }
    if (withIndex && !withExports) {
        giftEntries.cc = 'cc';
        const ccDtsFile = path_1.default.join(dirName, 'virtual-cc.d.ts');
        giftInputs.push(ccDtsFile);
        cleanupFiles.push(ccDtsFile);
        const code = `declare module "cc" {\n${statsQuery.evaluateIndexModuleSource(featureUnits, (featureUnit) => getModuleNameInTsOutFile(statsQuery.getFeatureUnitFile(featureUnit), statsQuery))}\n}`;
        await fs_extra_1.default.writeFile(ccDtsFile, code, { encoding: 'utf8' });
    }
    console.log(`Bundling...`);
    try {
        const indexOutputPath = path_1.default.join(dirName, 'cc.d.ts');
        const giftResult = gift.bundle({
            input: giftInputs,
            name: 'cc',
            rootModule: 'index',
            entries: giftEntries,
            priority: [
                'cc', // Things should be exported to 'cc' as far as possible.
            ],
            groups: [
                { test: /^cc\/editor.*$/, path: path_1.default.join(dirName, 'cc.editor.d.ts') },
                { test: /^cc\/.*$/, path: path_1.default.join(dirName, 'index.d.ts') },
                { test: /^cc.*$/, path: indexOutputPath },
            ],
            nonExportedSymbolDistribution: [{
                    sourceModule: /cocos\/core\/animation\/marionette/,
                    targetModule: 'cc/editor/new-gen-anim',
                }, {
                    sourceModule: /.*/,
                    targetModule: 'cc',
                }],
        });
        await Promise.all(giftResult.groups.map(async (group) => {
            await fs_extra_1.default.outputFile(group.path, group.code, { encoding: 'utf8' });
        }));
        if (withIndex && withExports) {
            await fs_extra_1.default.outputFile(indexOutputPath, buildIndexModule(featureUnits, statsQuery), { encoding: 'utf8' });
        }
    }
    catch (error) {
        console.error(error);
        return false;
    }
    finally {
        if (REMOVE_TMP) {
            await Promise.all((cleanupFiles.map(async (file) => fs_extra_1.default.unlink(file))));
        }
    }
    return true;
}
exports.build = build;
function buildIndexModule(featureUnits, statsQuery) {
    return `declare module "cc" {\n${statsQuery.evaluateIndexModuleSource(featureUnits)
        .split('\n')
        .map((line) => `    ${line}`)
        .join('\n')}\n}`;
}
exports.buildIndexModule = buildIndexModule;
function getModuleNameInTsOutFile(moduleFile, statsQuery) {
    const path = path_1.default.relative(statsQuery.path, moduleFile);
    const tsOutFileModuleName = path_1.default.join(path_1.default.dirname(path), path_1.default.basename(path, path_1.default.extname(path))).replace(/\\/g, '/');
    return tsOutFileModuleName;
}
//# sourceMappingURL=index.js.map