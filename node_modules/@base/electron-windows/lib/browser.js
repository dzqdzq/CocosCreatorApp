'use strict';

const ipc = require('@base/electron-base-ipc');
const { v4: uuidV4 } = require('uuid');
const { EventEmitter } = require('events');
const { app, BrowserWindow, shell } = require('electron');
const { join, isAbsolute, normalize } = require('path');

const pkg = require('../package.json');
const ipcFlag = `${pkg.name}@${pkg.version}`;

function awaitAppReady() {
    if (app.isReady()) {
        return;
    }
    return new Promise((resolve) => {
        app.once('ready', resolve);
    });
}

class WindowManager extends EventEmitter {

    constructor () {
        super();
        this._waitClosedWindows = Object.create(null);
        this._waitClosedMain = false;
        this._allowClosedMain = false;
        this._defaultZoomLevel = 0;

        this.uuids = [];
        this.uuid2win = Object.create(null);
        this.uuid2info = Object.create(null);

        this._focusWindow = null;
    }

    focus(uuid) {
        const win = this.uuid2win[uuid];
        win && win.focus();
    }

    _close (uuid) {
        return new Promise((resolve) => {
            this._waitClosedWindows[uuid] = function (isClosed) {
                resolve(isClosed);
            };
            let win = this.uuid2win[uuid];
            let info = this.uuid2info[uuid];

            // 如果窗口已经是被销毁的，则不管这个窗口
            if (!win || win.isDestroyed()) {
                resolve();
                return;
            }

            info.options.fullscreen = win.isFullScreen();
            win.close();
        });
    }

    /**
     * 关闭除了主窗口以外的所有的窗口
     * 因为关闭第一个窗口会自动关闭全部窗口，并缓存数据
     * 所以这里会从最后一个窗口开始关闭
     */
    async _closedOthers () {
        let allowClosed = true;

        // 关闭除了主窗口的其他窗口
        for (let i=this.uuids.length-1; i>0; i--) {
            const uuid = this.uuids[i];
            if (!await this._close(uuid)) {
                allowClosed = false;
            }
        }

        // 如果某个窗口终止了关闭，则需要删除已经被关闭的窗口缓存
        if (allowClosed === false) {
            this.uuids = this.uuids.filter((uuid) => {
                let win = this.uuid2win[uuid];
                if (!win || win.isDestroyed()) {
                    delete this.uuid2win[uuid];
                    delete this.uuid2info[uuid];
                    return false;
                }
                return true;
            });
        }
        
        return allowClosed;
    }

    normalizeURL(url, uuid) {
        const encodeURL = encodeURI(url).replace(/[!'()#\?*]/g, function(c) {
            return '%' + c.charCodeAt(0).toString(16);
        }).replace(/%5C/ig, '/');
        return `file://${encodeURL}#${uuid}`;
    }

    /**
     * 打开一个新窗口
     * @param {string} url 窗口加载的页面地址
     * @param {object} options electron 窗口的参数
     * @param {object} userData 窗口携带的自定义数据
     * @param injection
     */
    async open (url, options, userData, injection = {}) {
        await awaitAppReady();

        if (/^file\:\//.test(url)) {
            url = url.substr(6);
        }
        if (!isAbsolute(url)) {
            url = join(process.cwd(), url);
        }

        options = options || {};
        userData = userData || {};

        let uuid = uuidV4();

        // 打开窗口
        let restoreShow = false;
        if (!('show' in options) || options.show) {
            restoreShow = true;
            options.show = false;
        }

        for (let key in options) {
            if (!(key in injection)) {
                injection[key] = options[key];
            }
        }

        // injection['useContentSize'] = true;

        if (injection.x !== undefined && injection.y !== undefined) {
            // 判断当前窗口是否超出窗口位置
            let screen = require('electron').screen;
            let displays = screen.getAllDisplays();
            let inBound = false;
            for (let i = 0; i < displays.length; i++) {
                const display = displays[i];
                if (
                    display.bounds.x <= injection.x &&
                    display.bounds.x + display.bounds.width >= injection.x &&
                    display.bounds.y <= injection.y &&
                    display.bounds.y + display.bounds.height >= injection.y
                ) {
                    inBound = true;
                    break;
                }
            }
            if (!inBound) {
                let bounds = screen.getPrimaryDisplay().bounds;
                injection.x = bounds.x;
                injection.y = bounds.y;
    
                if (injection.width > bounds.width) {
                    injection.width = bounds.width;
                }
                if (injection.height > bounds.height) {
                    injection.height = bounds.height;
                }
            }
        }

        if (!injection.webPreferences) {
            injection.webPreferences = {};
        }
        // 根据默认的 zoom level 去设置 zoom factor
        injection.webPreferences.zoomFactor = Math.pow(1.2, this.getDefaultZoomLevel());

        let win = new BrowserWindow(injection);

        // 缓存信息
        let info = {
            uuid, url, userData,
            options: JSON.parse(JSON.stringify(options)),
            bounds: win.getBounds(),
        };

        win.webContents.on('will-navigate', (event, jump) => {
            // 刷新窗口时，还原成 default zoom level 的比例
            win.webContents.setZoomLevel(this.getDefaultZoomLevel());

            jump = jump.replace(/^file\:\/+/, '');
            jump = jump.replace(/#.*/, '');
            jump = normalize(jump);

            if (process.platform === 'darwin') {
                jump = `/${jump}`;
            }

            if (info.url !== jump) {
                event.preventDefault();
                shell.openExternal(jump);
            }
            // TODO: can have more protocol for navigate
        });

        if (options.menuBarVisibility === false) {
            // windows 上要隐藏菜单，必须将自动隐藏设置为 false
            win.setAutoHideMenuBar(false);
            win.setMenuBarVisibility(false);
        }

        // 缓存信息
        this.uuid2win[uuid] = win;
        this.uuid2info[uuid] = info;
        this.uuids.push(uuid);

        // 监听事件
        let _boundsTimer = null;
        let changeBounds = () => {
            if (_boundsTimer !== null) {
                return;
            }
            _boundsTimer = setTimeout(() => {
                _boundsTimer = null;
                if (!win || win.isDestroyed()) {
                    return;
                }
                info.bounds = win.getBounds();
                this.emit('change');
            }, 500);
        };

        // 窗口移动的时候记录 bounds
        win.on('move', () => {
            changeBounds();
        });

        // 窗口缩放的时候记录 bounds
        win.on('resize', () => {
            changeBounds();
        });

        // 窗口关闭流程触发
        //   1. 点击关闭窗口按钮
        //   2. 在窗口内执行 window.close();
        //   3. 在主进程执行 BrowserWindow.close();
        win.on('close', async (event) => {
            let index = this.uuids.indexOf(uuid);

            // 如果关闭的是主窗口
            // 先暂停关闭流程，关闭所有的子窗口
            // 判断子窗口是否全部关闭，如果全关了，更改 allowCloseMain 标记，重新执行关闭操作
            if (index === 0) {
                if (this._allowClosedMain) {
                    // 通知窗口正在执行关闭
                    win.send(`${ipcFlag}:close`);
                    return;
                }

                this._waitClosedMain = true;
                event.preventDefault();
                this._allowClosedMain = await this._closedOthers();
                if (this._allowClosedMain) {
                    win.close();
                } else {
                    // 如果不继续执行关闭流程，才需要重置标记
                    this._waitClosedMain = false;
                }
                this.emit('change');
                return;
            }

            // 通知窗口正在执行关闭
            win.send(`${ipcFlag}:close`);
        });

        const _closed = () => {
            let index = this.uuids.indexOf(uuid);
            if (this._waitClosedMain) {
                if (index === 0) {
                    try {
                        this.emit('clear');
                    } catch(error) {
                        console.error(error);
                    }
                }
                return;
            }
            if (index === 0) {
                try {
                    this.emit('change');
                } catch(error) {
                    console.error(error);
                }
                return;
            }
            delete this.uuid2info[uuid];
            delete this.uuid2win[uuid];
            if (index !== -1) {
                this.uuids.splice(index, 1);
            }
            try {
                this.emit('change');
            } catch(error) {
                console.error(error);
            }
        }

        win.on('destroy', _closed);
        win.on('closed', _closed);

        this.emit('change');

        ///////////
        // 焦点管理
        win.on('focus', () => {
            if (this._focusWindow === null) {
                this._focusWindow = win;
                this.emit('focus');
            } else {
                this._focusWindow = win;
            }
        });

        win.on('blur', () => {
            setImmediate(() => {
                if (this._focusWindow !== win) {
                    return;
                }
                this._focusWindow = null;
                this.emit('blur');
            });
        });

        return new Promise((resolve) => {
            const encodeURL = this.normalizeURL(url, uuid);
            win.loadURL(encodeURL);
            let finish = false;
            setTimeout(() => {
                if (finish) {
                    return;
                }
                finish = true;

                if (restoreShow) {
                    win.show();
                }
                resolve(uuid);
            }, 2000);
            win.once('dom-ready', () => {
                // 启动窗口有一个缩放过程，会导致第一帧的页面大小错误
                // 延迟可以暂时解决这个问题
                setTimeout(() => {
                    if (finish) {
                        return;
                    }
                    finish = true;
                    if (restoreShow) {
                        win.show();
                    }
                    resolve(uuid);
                }, 100);
            });
        });
    }

    /**
     * 从一个 json 文件恢复被关闭的窗口
     * @param {Object} json dump 出去的数据
     */
    async restore (json) {
        await awaitAppReady();

        this.setDefaultZoomLevel(json.defaultZoomLevel || 0);
        const windows = json.windows;
        const uuids = [];
        for (let i=0; i < windows.length; i++) {
            const info = windows[i];
            const uuid = await this.open(info.url, info.options, info.userData, {
                x: info.bounds.x,
                y: info.bounds.y,
                width: info.bounds.width,
                height: info.bounds.height,
            });
            uuids.push(uuid);
        }
        return uuids;
    }

    /**
     * 将当前的窗口状态以及数据，转储成一个 json 文件
     * @return {Object}
     */
    dump () {
        const json = {
            version: 1,
            defaultZoomLevel: this.getDefaultZoomLevel(),
            windows: this.uuids.map((uuid) => {
                return this.uuid2info[uuid];
            }),
        };

        return json;
    }

    /**
     * 设置默认 zoom level
     * @param level
     */
    setDefaultZoomLevel (level) {
        this._defaultZoomLevel = level;
    }

    /**
     * 获取默认 zoom level
     * @return {number}
     */
    getDefaultZoomLevel() {
        return this._defaultZoomLevel;
    }

    /**
     * 主动关闭所有窗口
     */
    async quit() {
        // 关闭主窗口的时候，就会尝试关闭其他子窗口
        await this._close(this.uuids[0]);
    }
}

let manager = module.exports = new WindowManager();

// 窗口查询当前窗口的数据
ipc.on(`${ipcFlag}:query-user-data`, (event, uuid) => {
    let info = manager.uuid2info[uuid];
    if (!info) {
        return {};
    }
    return info.userData || {};
});

// 窗口更改数据之后，同步到管理器
ipc.on(`${ipcFlag}:sync-user-date`, (event, uuid, data) => {
    let info = manager.uuid2info[uuid];
    if (!info) {
        return;
    }
    if (JSON.stringify(info.userData) !== JSON.stringify(data)) {
        info.userData = data;
        manager.emit('change');
    }
});

// 同步关闭状态
ipc.on(`${ipcFlag}:sync-closed`, (event, uuid, isClosed) => {
    let callback = manager._waitClosedWindows[uuid];
    if (callback) {
        callback.call(manager, isClosed);
    }
});

// 询问窗口是否允许关闭
ipc.on(`${ipcFlag}:ask-win`, (event) => {
    let win = BrowserWindow.fromWebContents(event.sender);
    let uuids = manager.uuids;

    let allow = uuids.some((uuid) => {
        return win === manager.uuid2win[uuid];
    });
    event.reply(null, allow);
});

// 设置窗口的最小宽高
ipc.on(`${ipcFlag}:set-min-size`, (event, width, height) => {
    width = Math.round(width);
    height = Math.round(height);

    const win = BrowserWindow.fromWebContents(event.sender);
    if (!win || win.isDestroyed()) {
        return;
    }
    const size = win.getSize();
    const contentSize = win.getContentSize();

    if (contentSize[0] === 0 && contentSize[1] === 0) {
        return;
    }

    // 检查最小宽高是否小于当前的宽高
    if (width > contentSize[0] || height > contentSize[1]) {
        win.setContentSize(Math.max(contentSize[0], width), Math.max(contentSize[1], height));
    }

    // 设置最小宽高
    const minSize = win.getMinimumSize();
    height += size[1] - contentSize[1];
    if (minSize[0] !== width || minSize[1] !== height) {
        win.setMinimumSize(width, height);
    }
});
