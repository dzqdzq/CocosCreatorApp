'use strict';

const ipc = require('@base/electron-base-ipc');
const { ipcRenderer } = require('electron');
const { EventEmitter } = require('events');

const pkg = require('../package.json');
const ipcFlag = `${pkg.name}@${pkg.version}`;

// 主进程通知渲染进程，用户点击了关闭按钮，beforeunload 需要切换为 close 模式，默认为 refresh
let _action = 'refresh';
ipcRenderer.on(`${ipcFlag}:close`, () => {
    _action = 'close';
});

class WindowManager extends EventEmitter {

    constructor () {
        super();
        this.uuid = window.location.hash.substr(1);
        this.userData = ipc.sendSync(`${ipcFlag}:query-user-data`, this.uuid);
    }

    /**
     * 设置窗口的最小宽高
     * @param {number} width 
     * @param {number} height 
     */
    setMinSize (width, height) {
        ipc.send(`${ipcFlag}:set-min-size`, width, height);
    }

    /**
     * 与主进程同步窗口的 userData 数据
     */
    sync () {
        ipc.send(`${ipcFlag}:sync-user-date`, this.uuid, this.userData);
    }

    close() {
        _action = 'close';
        window.close();
    }
}

module.exports = new WindowManager();

// 判断是否用了 windows 管理窗口，如果没有管理，则忽略中断 close 的行为
// 监听 window 关闭事件，并直接阻断
// 判断完成是否允许关闭后，再继续关闭或者继续刷新
console.time('ask-win');
ipc
    .send(`${ipcFlag}:ask-win`)
    .callback((error, allow) => {
        console.timeEnd('ask-win');
        if (error || !allow) {
            return;
        }
        let _skipInspection = false;
        window.addEventListener('beforeunload', (event) => {
            // 取出注册的 close 事件
            let events = module.exports._events['close'];
        
            if (_skipInspection || !events) {
                ipc.send(`${ipcFlag}:sync-closed`, module.exports.uuid, true);
                return true;
            }

            // 如果注册了 close 事件，则阻断默认操作
            event.returnValue = true;

            if (!Array.isArray(events)) {
                events = [events];
            }
            process.nextTick(async () => {
                for (let i=0; i<events.length; i++) {
                    let allow = await events[i]();
                    if (allow === false) {
                        // 如果有东西不允许关闭或者刷新，则把阻断标记重置，并且跳出处理
                        // _stopUnload = false;
                        _action = 'refresh';
                        ipc.send(`${ipcFlag}:sync-closed`, module.exports.uuid, false);
                        return;
                    }
                }

                // 跳过检查标记改为 true，下一次进入则是直接执行默认动作
                _skipInspection = true;
                if (_action === 'refresh') {
                    window.location.reload();
                } else {
                    ipc.send(`${ipcFlag}:sync-closed`, module.exports.uuid, true);
                    window.close();
                }
            });
        });
    })
    .timeout(3000);
