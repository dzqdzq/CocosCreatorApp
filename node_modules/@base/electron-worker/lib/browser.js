'use strict';

const ipc = require('@base/electron-base-ipc');
const { EventEmitter } = require('events');
const { BrowserWindow } = require('electron');
const { join } = require('path');
const vStacks = require('v-stacks');

const pkg = require('../package.json');
const ipcFlag = `${pkg.name}@${pkg.version}`;

const name2worker = {};

class Worker extends EventEmitter {

    get isReady() {
        return !!this.win;
    }

    constructor (name) {
        super();
        this.name = name;
        this.files = [];
        this.ipc = new EventEmitter;
    }

    /**
     * 初始化 worker
     */
    async init (options) {
        this.win = new BrowserWindow({
            width: 300, height: 300,
            show: false,
            autoHideMenuBar: true,

            //electron 5.0.0 开始需要手动开启渲染进程的 node集成和允许使用
            webPreferences: {
                nodeIntegration: true,
                contextIsolation: false,
                preload: options.preload,
                enableRemoteModule: true,
            },
        });
        return new Promise((resolve, reject) => {
            this.win.webContents.on('dom-ready', () => {
                // this.win.openDevTools();
                ipc.sendToWin(this.win, `${ipcFlag}:init`, {
                    name: this.name,
                    files: this.files,
                });
                resolve();
            });
            const file = 'file://' + join(__dirname, '../static/worker.html');
            const url = encodeURI(file).replace(/[!'()#\?*]/g, function(c) {
                return '%' + c.charCodeAt(0).toString(16);
            }).replace(/%5C/ig, '/');
            this.win.loadURL(url);

            // 监听如果页面开始刷新
            this.win.webContents.on('did-start-loading', () => {
                this.emit('refresh');
            });

            // 渲染器进程意外消失时触发。这种情况通常因为进程崩溃或被杀死。
            // API: https://www.electronjs.org/zh/docs/latest/api/web-contents
            this.win.webContents.on('render-process-gone', (event, details) => {
                this.emit('render-process-gone', event, details);
            });

            // 崩溃的时候
            this.win.webContents.on('crashed', (event, options) => {
                // if (options.reason === 'crashed') {
                this.emit('crashed', -1);
                // }
            });

            this.win.on('close', (event) => {
                if (this._allowClose) {
                    return;
                }
                event.preventDefault();
                this.win.hide();
            });

            // 监听窗口如果被关闭
            this.win.on('closed', () => {
                this.win = null;
                this.emit('closed');
            });
        });
    }

    /**
     * 是否开启调试模式
     * @param {*} bool
     */
    debug(bool) {
        if (bool) {
            this.win.show();
            this.win.openDevTools();
        } else {
            this.win.hide();
            this.win.closeDevTools();
        }
    }

    /**
     * 关闭一个 worker
     * @param force - 强制关闭
     * @returns {Promise<boolean>}
     */
    async close (force = false) {
        let skipToClose = false;
        const handlers = this.listeners('before-close');
        for (const handler of handlers) {
            const result = await handler();
            if (result === false) {
                skipToClose = true;
            }
        }

        if ((!force && skipToClose) || !this.win) {
            return false;
        }

        this._allowClose = true;
        this.win.close();
        return true;
    }

    /**
     * 发送消息给 worker
     * @param {*} message
     * @param  {...any} args
     */
    send (message, ...args) {
        return new Promise((resolve, reject) => {
            ipc
                .sendToWin(this.win, `${ipcFlag}:message`, message, args)
                .callback((error, data) => {
                    if (error) {
                        return reject(error);
                    }
                    resolve(data);
                });
        });
    }

    /**
     * 在 worker 环境内加载这个文件
     * @param {*} file
     */
    require (file) {
        this.files.push(file);
        ipc.sendToWin(this.win, `${ipcFlag}:require`, file);
    }
}

class Manager {

    /**
     * 创建一个新的 worker
     * @param {*} name
     */
    create (name) {
        return name2worker[name] = new Worker(name);
    }

    /**
     * 删除一个 worker
     * @param {*} name
     * @param force - 是否强制关闭，默认是 false
     */
    close (name, force = false) {
        let worker = name2worker[name];
        delete name2worker[name];
        worker && worker.close(force);
    }

    /**
     * 清空所有的 worker
     * @param force - 是否强制关闭，默认是 false
     */
    clear (force = false) {
        for (const name in name2worker) {
            this.close(name, force);
        }
    }

    /**
     * 查询一个已经存在的 worker
     * @param {*} name
     */
    query (name) {
        return name2worker[name] || null;
    }

    /**
     * 查询所有 worker
     * @returns {[]}
     */
    queryAll() {
        let workers = [];
        for (const name in name2worker) {
            const worker = name2worker[name];
            worker && workers.push(worker);
        }
        return workers;
    }

    /**
     * 循环所有的 worker
     * @param {*} handle
     */
    async forEach(handle) {
        for (let name in name2worker) {
            await handle(name2worker[name]);
        }
    }
}

module.exports = new Manager();

// worker 进程发送的消息
ipc.on(`${ipcFlag}:message`, (event, name, message, args) => {
    let worker = module.exports.query(name);
    if (!worker) {
        return;
    }
    worker.ipc.emit(message, event, ...args);
});
