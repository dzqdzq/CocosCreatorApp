'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
exports.recursiveAsync = exports.recursiveSync = exports.parallel = void 0;
const fs_extra_1 = require("fs-extra");
const path_1 = require("path");
/**
 * 接收一个数据队列和一个 generate 函数, 通过将数据传递给 generate 拿到一个 promise 对象
 * 根据 num 传入的并行个数进行适当任务的并发
 *
 * @param tasks[any[]]
 * @param generate[Function]
 * @param num[Number]
 */
function parallel(tasks, generate, num = 1) {
    return new Promise((resolve) => {
        const results = [];
        let i = 0;
        let j = 0;
        async function step() {
            const task = tasks[i];
            if (task) {
                j++;
                try {
                    const result = await generate(task);
                    results[i] = result;
                }
                catch (error) {
                    results[i] = error;
                }
                j--;
                i++;
                step();
            }
            else if (j === 0) {
                resolve(results);
            }
        }
        for (; i < num && i < tasks.length; i++) {
            step();
        }
        i--;
    });
}
exports.parallel = parallel;
/**
 * 同步版递归查询所有的文件夹
 * @param dir 搜索的文件夹的父文件夹路径
 * @param name 文件夹内的名字
 * @param fileHandle 文件处理函数
 * @param dirHandle 文件夹处理函数
 */
function recursiveSync(dir, name, fileHandle, dirHandle) {
    const path = path_1.join(dir, name);
    let info;
    try {
        info = fs_extra_1.statSync(path);
    }
    catch (error) {
        return;
    }
    if (info.isFile()) {
        fileHandle(path, info, name);
        return;
    }
    // 当返回的是 false 的时候，不再递归文件夹
    if (dirHandle(path, info, name) === false) {
        return;
    }
    const list = fs_extra_1.readdirSync(path);
    for (let i = 0; i < list.length; i++) {
        const name = list[i];
        recursiveSync(path, name, fileHandle, dirHandle);
    }
}
exports.recursiveSync = recursiveSync;
/**
 * 异步版递归查询所有的文件夹，速度比同步慢，但是在扫描过程中，可以响应其他的 js 操作
 * @param dir 搜索的文件夹的父文件夹路径
 * @param name 文件夹内的名字
 * @param fileHandle 文件处理函数
 * @param dirHandle 文件夹处理函数
 */
async function recursiveAsync(dir, name, fileHandle, dirHandle) {
    const path = path_1.join(dir, name);
    let info;
    try {
        info = await fs_extra_1.stat(path);
    }
    catch (error) {
        return;
    }
    if (info.isFile()) {
        return await fileHandle(path, info, name);
    }
    // 当返回的是 false 的时候，不再递归文件夹
    if (await dirHandle(path, info, name) === false) {
        return;
    }
    const list = await fs_extra_1.readdir(path);
    await Promise.all(list.map((name) => {
        return recursiveAsync(path, name, fileHandle, dirHandle);
    }));
}
exports.recursiveAsync = recursiveAsync;
