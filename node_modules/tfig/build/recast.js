"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.recastTopLevelModule = void 0;
const typescript_1 = __importDefault(require("typescript"));
const tsUtils = __importStar(require("./ts-utils"));
function recastTopLevelModule({ program, typeChecker, rModule, nameResolver, exportPrivates, resolveEntity, registerNonExportedSymbol, }) {
    const moduleDeclaration = recastRModule(rModule);
    return [moduleDeclaration];
    function pushIfNonNull(target, source) {
        if (source) {
            target.push(source);
        }
    }
    function pushMultiIfNonNull(target, source) {
        if (source) {
            target.push(...source);
        }
    }
    function tryEmplaceModifier(modifiers, kind) {
        if (modifiers.every((m) => m.kind !== kind)) {
            modifiers.unshift(typescript_1.default.createModifier(kind));
        }
    }
    function recastRModule(rModule) {
        const statements = recastNamespaceTraits(rModule.entity.namespaceTraits);
        Object.entries(rModule.imports).map(([specifier, detail]) => {
            const importSymbols = Object.entries(detail.namedImports);
            if (importSymbols.length === 0) {
                return;
            }
            const importSpecifiers = importSymbols.map(([importId, localId]) => {
                const lId = typescript_1.default.createIdentifier(localId);
                if (importId === localId) {
                    return typescript_1.default.createImportSpecifier(undefined, lId);
                }
                else {
                    return typescript_1.default.createImportSpecifier(typescript_1.default.createIdentifier(importId), lId);
                }
            });
            statements.push(typescript_1.default.createImportDeclaration(undefined, // decorators
            undefined, // modifiers
            typescript_1.default.createImportClause(undefined, typescript_1.default.createNamedImports(importSpecifiers)), typescript_1.default.createStringLiteral(specifier)));
        });
        rModule.interopRecord.forEach((interop) => {
            if (interop.exports.length !== 0) {
                statements.push(typescript_1.default.createExportDeclaration(undefined, // decorators
                undefined, // modifiers
                typescript_1.default.createNamedExports(interop.exports.map(({ importName, asName }) => asName === importName ?
                    typescript_1.default.createExportSpecifier(undefined, typescript_1.default.createIdentifier(importName)) :
                    typescript_1.default.createExportSpecifier(typescript_1.default.createIdentifier(importName), typescript_1.default.createIdentifier(asName)))), typescript_1.default.createStringLiteral(interop.specifier)));
            }
            if (interop.imports.length !== 0) {
                statements.push(typescript_1.default.createImportDeclaration(undefined, // decorators
                undefined, // modifiers
                typescript_1.default.createImportClause(undefined, // default import name
                typescript_1.default.createNamedImports(interop.imports.map(({ importName, asName }) => asName === importName ?
                    typescript_1.default.createImportSpecifier(undefined, typescript_1.default.createIdentifier(importName)) :
                    typescript_1.default.createImportSpecifier(typescript_1.default.createIdentifier(importName), typescript_1.default.createIdentifier(asName))))), typescript_1.default.createStringLiteral(interop.specifier)));
            }
        });
        // ts treat all things in .d.ts as public exports
        // except it contains at least one `export {}` or `export default`.
        // See:
        // https://github.com/microsoft/TypeScript/issues/19545
        statements.push(typescript_1.default.factory.createExportDeclaration(undefined, // decorators
        undefined, // modifiers
        false, // isTypeOnly,
        typescript_1.default.factory.createNamedExports([])));
        const moduleDeclaration = typescript_1.default.createModuleDeclaration(undefined, // decorators
        [typescript_1.default.createModifier(typescript_1.default.SyntaxKind.DeclareKeyword)], typescript_1.default.createStringLiteral(rModule.entity.name), typescript_1.default.createModuleBlock(statements));
        return moduleDeclaration;
    }
    function recastREntity(rEntity) {
        if (!rEntity.symbol) {
            // For example: the `__private` namespace
            return null;
        }
        const namespaceTraits = rEntity.namespaceTraits;
        const declarations = rEntity.symbol.getDeclarations();
        if (!declarations || declarations.length === 0) {
            return null;
        }
        const statements = [];
        for (const declaration of declarations) {
            pushIfNonNull(statements, recastDeclaration(declaration, rEntity.name, true));
        }
        if (namespaceTraits) {
            const childrenEntityStatements = recastNamespaceTraits(namespaceTraits);
            const namespaceDeclaration = typescript_1.default.createModuleDeclaration(undefined, // decorators
            [typescript_1.default.createModifier(typescript_1.default.SyntaxKind.ExportKeyword)], // TODO: recastModifiers(moduleDeclaration.modifiers),
            typescript_1.default.createIdentifier(rEntity.name), typescript_1.default.createModuleBlock(childrenEntityStatements), typescript_1.default.NodeFlags.Namespace);
            statements.push(namespaceDeclaration);
        }
        return statements;
    }
    function recastNamespaceTraits(namespaceTraits) {
        const statements = [];
        nameResolver.enter(namespaceTraits);
        for (const childEntity of namespaceTraits.children) {
            pushMultiIfNonNull(statements, recastREntity(childEntity));
        }
        namespaceTraits.transformAliasExports();
        if (namespaceTraits.selfExports.length !== 0) {
            statements.push(typescript_1.default.createExportDeclaration(undefined, // decorators
            undefined, // modifiers
            typescript_1.default.createNamedExports(namespaceTraits.selfExports.map(({ importName, asName }) => asName === importName ?
                typescript_1.default.createExportSpecifier(undefined, typescript_1.default.createIdentifier(importName)) :
                typescript_1.default.createExportSpecifier(typescript_1.default.createIdentifier(importName), typescript_1.default.createIdentifier(asName)))), undefined));
        }
        for (const { where, importName, asName } of namespaceTraits.selfExportsFromNamespaces) {
            statements.push(typescript_1.default.createImportEqualsDeclaration(undefined, // decorators
            [typescript_1.default.createModifier(typescript_1.default.SyntaxKind.ExportKeyword)], // modifiers
            typescript_1.default.createIdentifier(asName), typescript_1.default.createQualifiedName(tsUtils.createEntityName(where), importName)));
        }
        nameResolver.leave();
        if (namespaceTraits.neNamespace) {
            const neNsDeclaration = typescript_1.default.createModuleDeclaration(undefined, // decorators,
            [typescript_1.default.createModifier(typescript_1.default.SyntaxKind.ExportKeyword)], typescript_1.default.createIdentifier(namespaceTraits.neNamespace.trait.entity.name), typescript_1.default.createModuleBlock(namespaceTraits.neNamespace.statements), typescript_1.default.NodeFlags.Namespace);
            statements.push(neNsDeclaration);
        }
        return statements;
    }
    function optimizeModuleSpecifierTo(from, to) {
        return to;
    }
    function recastStatement(statement) {
        if (typescript_1.default.isClassDeclaration(statement)) {
            return !statement.name ? null : recastClassDeclaration(statement, statement.name.text, false);
        }
        else if (typescript_1.default.isFunctionDeclaration(statement)) {
            return !statement.name ? null : recastFunctionDeclaration(statement, statement.name.text, false);
        }
        else if (typescript_1.default.isInterfaceDeclaration(statement)) {
            return !statement.name ? null : recastInterfaceDeclaration(statement, statement.name.text, false);
        }
        else if (typescript_1.default.isEnumDeclaration(statement)) {
            return !statement.name ? null : recastEnumDeclaration(statement, statement.name.text, false);
        }
        else if (typescript_1.default.isTypeAliasDeclaration(statement)) {
            return !statement.name ? null : recastTypeAliasDeclaration(statement, statement.name.text, false);
        }
        else if (typescript_1.default.isVariableStatement(statement)) {
            return typescript_1.default.createVariableStatement(recastDeclarationModifiers(statement, false), typescript_1.default.createVariableDeclarationList(statement.declarationList.declarations.map((declaration) => recastVariableDeclaration(declaration, declaration.name.getText(), false)), statement.declarationList.flags));
        }
        else if (typescript_1.default.isImportDeclaration(statement)) {
            return recastImportDeclaration(statement);
        }
        else {
            return null;
        }
    }
    function recastStatements(statements) {
        const result = [];
        for (const statement of statements) {
            const newStatement = recastStatement(statement);
            if (Array.isArray(newStatement)) {
                result.push(...newStatement);
            }
            else if (newStatement) {
                result.push(newStatement);
            }
        }
        return result;
    }
    function recastDeclaration(declaration, newName, forceExport) {
        const result = recastDeclarationNoComment(declaration, newName, forceExport);
        if (result) {
            copyComments(declaration, result);
        }
        return result;
    }
    function copyComments(src, dst) {
        if (typescript_1.default.isVariableDeclaration(src) &&
            typescript_1.default.isVariableDeclarationList(src.parent) &&
            typescript_1.default.isVariableStatement(src.parent.parent)) {
            // https://github.com/microsoft/TypeScript/issues/35620
            return copyComments(src.parent.parent, dst);
        }
        const sourceFileText = src.getSourceFile().text;
        typescript_1.default.forEachLeadingCommentRange(sourceFileText, src.pos, (pos, end, kind) => {
            let tex = sourceFileText.substring(pos, end);
            if (tex.startsWith('/*')) {
                tex = tex.substr(2, tex.length - 4);
                tex = tex.split('\n').map((line, lineIndex, lines) => {
                    const noHeadSpace = line.trimLeft();
                    if (lineIndex === lines.length - 1 && noHeadSpace.length === 0) {
                        return ' ';
                    }
                    else if (!noHeadSpace.startsWith('*')) {
                        return line;
                    }
                    else if (lineIndex === 0) {
                        return noHeadSpace;
                    }
                    else {
                        return ` ${noHeadSpace}`;
                    }
                }).join('\n');
            }
            else if (tex.startsWith('//')) {
                tex = tex.substr(2);
            }
            typescript_1.default.addSyntheticLeadingComment(dst, kind, tex, true);
        });
        return dst;
    }
    function recastDeclarationNoComment(declaration, newName, forceExport) {
        if (typescript_1.default.isClassDeclaration(declaration)) {
            return recastClassDeclaration(declaration, newName, forceExport);
        }
        else if (typescript_1.default.isFunctionDeclaration(declaration)) {
            return recastFunctionDeclaration(declaration, newName, forceExport);
        }
        else if (typescript_1.default.isInterfaceDeclaration(declaration)) {
            return recastInterfaceDeclaration(declaration, newName, forceExport);
        }
        else if (typescript_1.default.isEnumDeclaration(declaration)) {
            return recastEnumDeclaration(declaration, newName, forceExport);
        }
        else if (typescript_1.default.isTypeAliasDeclaration(declaration)) {
            return recastTypeAliasDeclaration(declaration, newName, forceExport);
        }
        else if (typescript_1.default.isVariableDeclaration(declaration)) {
            return typescript_1.default.createVariableStatement(recastDeclarationModifiers(declaration, forceExport), typescript_1.default.createVariableDeclarationList([recastVariableDeclaration(declaration, newName, forceExport)], declaration.parent.flags));
        }
        else if (typescript_1.default.isModuleDeclaration(declaration)) {
            // return recastModuleDeclaration(declaration, newName);
        }
        return null;
    }
    function recastModuleDeclarationAsNamespaceDeclaration(moduleDeclaration, newName) {
        const body = moduleDeclaration.body;
        let newBody;
        if (!body) {
            // Fall through
        }
        else if (typescript_1.default.isIdentifier(body)) {
            newBody = typescript_1.default.createIdentifier(body.text);
        }
        else if (typescript_1.default.isModuleBlock(body)) {
            newBody = typescript_1.default.createModuleBlock(recastStatements(body.statements));
        }
        else {
            console.warn(`Unknown module declaration type ${tsUtils.stringifyNode(body)}`);
        }
        return typescript_1.default.createModuleDeclaration(undefined, // decorators
        recastDeclarationModifiers(moduleDeclaration, true), typescript_1.default.createIdentifier(newName), newBody, typescript_1.default.NodeFlags.Namespace);
    }
    function recastFunctionDeclaration(functionDeclaration, newName, forceExport) {
        return typescript_1.default.createFunctionDeclaration(undefined, recastModifiers(functionDeclaration.modifiers), functionDeclaration.asteriskToken, newName, recastTypeParameterArray(functionDeclaration.typeParameters), recastParameterArray(functionDeclaration.parameters), // parameters
        recastTypeNode(functionDeclaration.type), undefined);
    }
    function recastVariableDeclaration(variableDeclaration, newName, forceExport) {
        return typescript_1.default.createVariableDeclaration(newName, recastTypeNode(variableDeclaration.type), recastExpression(variableDeclaration.initializer));
    }
    function recastPropertySignature(propertySignature) {
        return copyComments(propertySignature, typescript_1.default.createPropertySignature(undefined, recastPropertyName(propertySignature.name), recastToken(propertySignature.questionToken), recastTypeNode(propertySignature.type), undefined));
    }
    function recastMethodSignature(methodSignature) {
        return copyComments(methodSignature, typescript_1.default.createMethodSignature(recastTypeParameterArray(methodSignature.typeParameters), recastParameterArray(methodSignature.parameters), // parameters
        recastTypeNode(methodSignature.type), recastPropertyName(methodSignature.name), recastToken(methodSignature.questionToken)));
    }
    function recastIndexSignatureDeclaration(indexSignature) {
        return copyComments(indexSignature, typescript_1.default.createIndexSignature(undefined, // decorators
        recastModifiers(indexSignature.modifiers), // modifiers
        recastParameterArray(indexSignature.parameters), // parameters
        recastTypeNode(indexSignature.type) || typescript_1.default.createKeywordTypeNode(typescript_1.default.SyntaxKind.UndefinedKeyword)));
    }
    function recastCallSignatureDeclaration(callSignature) {
        return copyComments(callSignature, typescript_1.default.createCallSignature(recastTypeParameterArray(callSignature.typeParameters), // typeParameters
        recastParameterArray(callSignature.parameters), // parameters
        recastTypeNode(callSignature.type)));
    }
    function recastConstructorSignatureDeclaration(constructSignature) {
        return copyComments(constructSignature, typescript_1.default.createConstructSignature(recastTypeParameterArray(constructSignature.typeParameters), recastParameterArray(constructSignature.parameters), // parameters
        recastTypeNode(constructSignature.type)));
    }
    function recastPropertyDeclaration(propertyDeclaration) {
        return copyComments(propertyDeclaration, typescript_1.default.createProperty(undefined, recastModifiers(propertyDeclaration.modifiers), recastPropertyName(propertyDeclaration.name), recastToken(propertyDeclaration.questionToken), recastTypeNode(propertyDeclaration.type), recastExpression(propertyDeclaration.initializer)));
    }
    function recastMethodDeclaration(methodDeclaration) {
        return copyComments(methodDeclaration, (typescript_1.default.createMethod(undefined, recastModifiers(methodDeclaration.modifiers), recastToken(methodDeclaration.asteriskToken), recastPropertyName(methodDeclaration.name), recastToken(methodDeclaration.questionToken), recastTypeParameterArray(methodDeclaration.typeParameters), recastParameterArray(methodDeclaration.parameters), // parameters
        recastTypeNode(methodDeclaration.type), undefined)));
    }
    function recastConstructorDeclaration(constructorDeclaration) {
        return copyComments(constructorDeclaration, (typescript_1.default.createConstructor(undefined, recastModifiers(constructorDeclaration.modifiers), recastParameterArray(constructorDeclaration.parameters), // parameters
        undefined)));
    }
    function recastParameter(parameter) {
        return typescript_1.default.createParameter(undefined, recastModifiers(parameter.modifiers), recastToken(parameter.dotDotDotToken), parameter.name.getText(), recastToken(parameter.questionToken), recastTypeNode(parameter.type));
    }
    function recastParameterArray(parameters) {
        const lambda = (p) => copyComments(p, (recastParameter(p)));
        if (parameters) {
            return parameters.map(lambda);
        }
        else {
            return undefined;
        }
    }
    function recastTypeParameter(typeParameter) {
        return typescript_1.default.createTypeParameterDeclaration(typeParameter.name.getText(), recastTypeNode(typeParameter.constraint), recastTypeNode(typeParameter.default));
    }
    function recastTypeParameterArray(typeParameters) {
        const lambda = (tp) => copyComments(tp, (recastTypeParameter(tp)));
        if (typeParameters) {
            return typeParameters.map(lambda);
        }
        else {
            return undefined;
        }
    }
    function recastImportDeclaration(importDeclaration) {
        // if (!ts.isStringLiteral(importDeclaration.moduleSpecifier) ||
        //     !importDeclaration.importClause) {
        //     return null;
        // }
        // const moduleRegistry = this._getOrCreateModuleRegistry(importDeclaration.moduleSpecifier.text);
        // const moduleFullName = getModuleRegistryFullNameArray(moduleRegistry);
        // const moduleEntity = createEntityName(moduleFullName);
        // const { namedBindings } = importDeclaration.importClause;
        // if (namedBindings) {
        //     if (ts.isNamespaceImport(namedBindings)) {
        //         return [ts.createVariableStatement(
        //             undefined,
        //             [ts.createVariableDeclaration(
        //                 ts.createIdentifier(
        //                     namedBindings.name.text,
        //                 ),
        //                 ts.createTypeQueryNode(
        //                     moduleEntity,
        //                 ))])];
        //     } else {
        //         for (const element of namedBindings.elements) {
        //         }
        //     }
        // }
        return [];
    }
    function recastExportDeclaration(exportDeclaration) {
        // if (exportDeclaration.moduleSpecifier) {
        //     if (!ts.isStringLiteral(exportDeclaration.moduleSpecifier)) {
        //         return null;
        //     }
        //     const moduleRegistry = this._getOrCreateModuleRegistry(exportDeclaration.moduleSpecifier.text);
        //     const moduleFullName = getModuleRegistryFullNameArray(moduleRegistry);
        //     const moduleEntity = createEntityName(moduleFullName);
        //     if (!exportDeclaration.exportClause) {
        //     }
        // }
        return null;
    }
    function recastClassDeclaration(classDeclaration, newName, forceExport) {
        var _a;
        const classElements = [];
        // console.log(`Dump class ${newName}`);
        for (const element of classDeclaration.members) {
            if (!exportPrivates && isPrivateMember(element)) {
                continue;
            }
            // const name = typeof element.name === 'string' ? typeof element.name :
            //     (element.name ? element.name.getText() : '');
            // console.log(`  Dump member ${name}`);
            if (typescript_1.default.isMethodDeclaration(element)) {
                classElements.push(recastMethodDeclaration(element));
            }
            else if (typescript_1.default.isConstructorDeclaration(element)) {
                classElements.push(recastConstructorDeclaration(element));
            }
            else if (typescript_1.default.isPropertyDeclaration(element)) {
                classElements.push(recastPropertyDeclaration(element));
            }
            else if (typescript_1.default.isIndexSignatureDeclaration(element)) {
                classElements.push(recastIndexSignatureDeclaration(element));
            }
            else if (typescript_1.default.isSemicolonClassElement(element)) {
                classElements.push(typescript_1.default.createSemicolonClassElement());
            }
            else if (typescript_1.default.isGetAccessor(element)) {
                // Since TS 3.7
                classElements.push(typescript_1.default.createGetAccessor(undefined, // decorators
                recastModifiers(element.modifiers), // modifiers
                recastPropertyName(element.name), // name
                recastParameterArray(element.parameters), // parameters
                recastTypeNode(element.type), // type
                undefined));
            }
            else if (typescript_1.default.isSetAccessor(element)) {
                // Since TS 3.7
                classElements.push(typescript_1.default.createSetAccessor(undefined, // decorators
                recastModifiers(element.modifiers), // modifiers
                recastPropertyName(element.name), // name
                recastParameterArray(element.parameters), // parameters
                undefined));
            }
            else {
                console.warn(`Don't know how to handle element ${(_a = element.name) === null || _a === void 0 ? void 0 : _a.getText()} of class ${newName}`);
            }
        }
        return typescript_1.default.createClassDeclaration(undefined, recastDeclarationModifiers(classDeclaration, forceExport), newName, recastTypeParameterArray(classDeclaration.typeParameters), recastHeritageClauses(classDeclaration.heritageClauses), classElements);
    }
    function isPrivateMember(classElement) {
        if (!classElement.modifiers) {
            return false;
        }
        return classElement.modifiers.some((modifier) => modifier.kind === typescript_1.default.SyntaxKind.PrivateKeyword);
    }
    function recastInterfaceDeclaration(interfaceDeclaration, newName, forceExport) {
        return typescript_1.default.createInterfaceDeclaration(undefined, recastDeclarationModifiers(interfaceDeclaration, forceExport), newName, recastTypeParameterArray(interfaceDeclaration.typeParameters), recastHeritageClauses(interfaceDeclaration.heritageClauses), recastTypeElements(interfaceDeclaration.members));
    }
    function recastTypeElement(typeElement) {
        if (typescript_1.default.isMethodSignature(typeElement)) {
            return recastMethodSignature(typeElement);
        }
        else if (typescript_1.default.isPropertySignature(typeElement)) {
            return recastPropertySignature(typeElement);
        }
        else if (typescript_1.default.isIndexSignatureDeclaration(typeElement)) {
            return recastIndexSignatureDeclaration(typeElement);
        }
        else if (typescript_1.default.isCallSignatureDeclaration(typeElement)) {
            return recastCallSignatureDeclaration(typeElement);
        }
        else if (typescript_1.default.isConstructSignatureDeclaration(typeElement)) {
            return recastConstructorSignatureDeclaration(typeElement);
        }
    }
    function recastTypeElements(typeElements) {
        var _a;
        const result = [];
        for (const typeElement of typeElements) {
            const d = recastTypeElement(typeElement);
            if (d) {
                result.push(d);
            }
            else {
                console.warn(`Don't know how to handle element ${(_a = typeElement.name) === null || _a === void 0 ? void 0 : _a.getText()} of interface`);
            }
        }
        return result;
    }
    function recastHeritageClause(heritageClause) {
        const validClauses = [];
        for (const type of heritageClause.types) {
            validClauses.push(typescript_1.default.createExpressionWithTypeArguments(type.typeArguments ? type.typeArguments.map((ta) => recastTypeNode(ta)) : undefined, recastExpression(type.expression)));
        }
        return typescript_1.default.createHeritageClause(heritageClause.token, validClauses);
    }
    function recastHeritageClauses(heritageClauses) {
        if (!heritageClauses) {
            return undefined;
        }
        const lambda = (heritageClause) => recastHeritageClause(heritageClause);
        if (heritageClauses) {
            return heritageClauses.map(lambda);
        }
        else {
            return undefined;
        }
    }
    function recastEnumDeclaration(enumDeclaration, newName, forceExport) {
        return typescript_1.default.createEnumDeclaration(undefined, recastDeclarationModifiers(enumDeclaration, forceExport), newName, enumDeclaration.members.map((enumerator) => {
            return copyComments(enumerator, typescript_1.default.createEnumMember(enumerator.name.getText(), recastExpression(enumerator.initializer)));
        }));
    }
    function recastTypeAliasDeclaration(typeAliasDeclaration, newName, forceExport) {
        return typescript_1.default.createTypeAliasDeclaration(undefined, recastDeclarationModifiers(typeAliasDeclaration, forceExport), newName, recastTypeParameterArray(typeAliasDeclaration.typeParameters), recastTypeNode(typeAliasDeclaration.type));
    }
    function recastModifiers(modifiers) {
        if (!modifiers) {
            return;
        }
        const result = [];
        for (const modifier of modifiers) {
            if (modifier.kind !== typescript_1.default.SyntaxKind.DefaultKeyword) {
                result.push(modifier);
            }
        }
        return result;
    }
    function recastDeclarationModifiers(declaration, forceExport) {
        var _a;
        let modifiers = (_a = recastModifiers(declaration.modifiers)) === null || _a === void 0 ? void 0 : _a.filter((m) => m.kind !== typescript_1.default.SyntaxKind.DeclareKeyword);
        if (forceExport) {
            if (!modifiers) {
                modifiers = [];
            }
            tryEmplaceModifier(modifiers, typescript_1.default.SyntaxKind.ExportKeyword);
        }
        return modifiers;
    }
    function recastTypeNode(type) {
        if (!type) {
            return undefined;
        }
        const fallthrough = () => {
            return typescript_1.default.createTypeReferenceNode(type.getText(), undefined);
        };
        switch (type.kind) {
            case typescript_1.default.SyntaxKind.AnyKeyword:
            case typescript_1.default.SyntaxKind.BigIntKeyword:
            case typescript_1.default.SyntaxKind.BooleanKeyword:
            case typescript_1.default.SyntaxKind.NeverKeyword:
            case typescript_1.default.SyntaxKind.NumberKeyword:
            case typescript_1.default.SyntaxKind.ObjectKeyword:
            case typescript_1.default.SyntaxKind.StringKeyword:
            case typescript_1.default.SyntaxKind.SymbolKeyword:
            case typescript_1.default.SyntaxKind.UndefinedKeyword:
            case typescript_1.default.SyntaxKind.UnknownKeyword:
            case typescript_1.default.SyntaxKind.VoidKeyword:
                return typescript_1.default.createKeywordTypeNode(type.kind);
        }
        if (typescript_1.default.isTypeReferenceNode(type)) {
            return recastEntityNameAsTypeNode(type.typeName, type.typeArguments ? type.typeArguments.map((ta) => recastTypeNode(ta)) : undefined);
        }
        else if (typescript_1.default.isUnionTypeNode(type)) {
            return typescript_1.default.createUnionTypeNode(type.types.map((t) => recastTypeNode(t)));
        }
        else if (typescript_1.default.isTypeLiteralNode(type)) {
            return typescript_1.default.createTypeLiteralNode(recastTypeElements(type.members));
        }
        else if (typescript_1.default.isArrayTypeNode(type)) {
            return typescript_1.default.createArrayTypeNode(recastTypeNode(type.elementType));
        }
        else if (typescript_1.default.isParenthesizedTypeNode(type)) {
            return typescript_1.default.createParenthesizedType(recastTypeNode(type.type));
        }
        else if (typescript_1.default.isTypeQueryNode(type)) {
            // typeof Entity
            return typescript_1.default.createTypeQueryNode(recastEntityName(type.exprName));
        }
        else if (typescript_1.default.isTypeOperatorNode(type)) {
            return typescript_1.default.createTypeOperatorNode(type.operator, recastTypeNode(type.type));
        }
        else if (typescript_1.default.isFunctionTypeNode(type)) {
            return typescript_1.default.createFunctionTypeNode(recastTypeParameterArray(type.typeParameters), recastParameterArray(type.parameters), // parameters
            recastTypeNode(type.type));
        }
        else if (typescript_1.default.isConstructorTypeNode(type)) {
            return typescript_1.default.createConstructorTypeNode(recastTypeParameterArray(type.typeParameters), recastParameterArray(type.parameters), // parameters
            recastTypeNode(type.type));
        }
        else if (typescript_1.default.isImportTypeNode(type)) {
            // import(ImportSpecifier)
            const resolvedTypeName = resolveImportTypeOrTypeQueryNode(type);
            if (resolvedTypeName) {
                if (type.isTypeOf) {
                    // Note: `typeof import("")` is treated as a single importType with `isTypeOf` set to true
                    if (type.typeArguments) {
                        console.error(`Unexpected: typeof import("...") should not have arguments.`);
                    }
                    return typescript_1.default.createTypeQueryNode(resolvedTypeName);
                }
                else {
                    return typescript_1.default.createTypeReferenceNode(resolvedTypeName, type.typeArguments ? type.typeArguments.map((ta) => recastTypeNode(ta)) : undefined);
                }
            }
        }
        else if (typescript_1.default.isIntersectionTypeNode(type)) {
            return typescript_1.default.createIntersectionTypeNode(type.types.map((t) => recastTypeNode(t)));
        }
        else if (typescript_1.default.isIndexedAccessTypeNode(type)) {
            return typescript_1.default.createIndexedAccessTypeNode(recastTypeNode(type.objectType), recastTypeNode(type.indexType));
        }
        else if (typescript_1.default.isThisTypeNode(type)) {
            return typescript_1.default.createThisTypeNode();
        }
        else if (typescript_1.default.isTypePredicateNode(type)) {
            return typescript_1.default.createTypePredicateNodeWithModifier(type.assertsModifier ? typescript_1.default.createToken(typescript_1.default.SyntaxKind.AssertsKeyword) : undefined, typescript_1.default.isIdentifier(type.parameterName) ?
                typescript_1.default.createIdentifier(type.parameterName.text) :
                typescript_1.default.createThisTypeNode(), recastTypeNode(type.type));
        }
        else if (typescript_1.default.isConditionalTypeNode(type)) {
            return typescript_1.default.createConditionalTypeNode(recastTypeNode(type.checkType), recastTypeNode(type.extendsType), recastTypeNode(type.trueType), recastTypeNode(type.falseType));
        }
        else if (typescript_1.default.isTupleTypeNode(type)) {
            return typescript_1.default.createTupleTypeNode(type.elements.map((elementType) => recastTypeNode(elementType)));
        }
        else if (typescript_1.default.isLiteralTypeNode(type)) {
            const literal = type.literal;
            let dumpedLiteral;
            if (typescript_1.default.isStringLiteral(literal)) {
                dumpedLiteral = typescript_1.default.createStringLiteral(literal.text);
            }
            else if (literal.kind === typescript_1.default.SyntaxKind.TrueKeyword) {
                dumpedLiteral = typescript_1.default.createTrue();
            }
            else if (literal.kind === typescript_1.default.SyntaxKind.FalseKeyword) {
                dumpedLiteral = typescript_1.default.createFalse();
            }
            else if (literal.kind === typescript_1.default.SyntaxKind.NullKeyword) {
                dumpedLiteral = typescript_1.default.createNull();
            }
            else if (typescript_1.default.isNumericLiteral(literal)) {
                dumpedLiteral = typescript_1.default.createNumericLiteral(literal.text);
            }
            else if (typescript_1.default.isBigIntLiteral(literal)) {
                dumpedLiteral = typescript_1.default.createBigIntLiteral(literal.text);
            }
            else if (typescript_1.default.isRegularExpressionLiteral(literal)) {
                dumpedLiteral = typescript_1.default.createRegularExpressionLiteral(literal.text);
            }
            else if (typescript_1.default.isNoSubstitutionTemplateLiteral(literal)) {
                dumpedLiteral = typescript_1.default.createNoSubstitutionTemplateLiteral(literal.text);
            }
            else if (typescript_1.default.isPrefixUnaryExpression(literal)) {
                dumpedLiteral = typescript_1.default.createPrefix(literal.operator, recastExpression(literal.operand));
            }
            else {
                console.warn(`Don't know how to handle literal type ${type.getText()}(${tsUtils.stringifyNode(literal)})`);
            }
            if (dumpedLiteral) {
                return typescript_1.default.createLiteralTypeNode(dumpedLiteral);
            }
        }
        else if (typescript_1.default.isMappedTypeNode(type)) {
            return typescript_1.default.createMappedTypeNode(recastToken(type.readonlyToken), recastTypeParameter(type.typeParameter), recastTypeNode(type.nameType), recastToken(type.questionToken), recastTypeNode(type.type));
        }
        else if (typescript_1.default.isInferTypeNode(type)) {
            return typescript_1.default.createInferTypeNode(recastTypeParameter(type.typeParameter));
        }
        else if (type.kind === typescript_1.default.SyntaxKind.RestType) {
            return typescript_1.default.createRestTypeNode(recastTypeNode(type.type));
        }
        else if (typescript_1.default.isOptionalTypeNode(type)) {
            return typescript_1.default.createOptionalTypeNode(type.type);
        }
        else {
            console.warn(`Don't know how to handle type ${type.getText()}(${tsUtils.stringifyNode(type)})`);
        }
        return type ? typescript_1.default.createTypeReferenceNode(type.getText(), undefined) : undefined;
    }
    function recastToken(token) {
        return token ? typescript_1.default.createToken(token.kind) : undefined;
    }
    function recastEntityName(name) {
        const identifiers = [];
        let n = name;
        while (typescript_1.default.isQualifiedName(n)) {
            identifiers.unshift(n.right);
            n = n.left;
        }
        identifiers.unshift(n);
        let result = null;
        for (let i = identifiers.length - 1; i >= 0; --i) {
            const id = identifiers[i];
            const resolveResult = resolveIdentifier(id);
            if (resolveResult) {
                const following = identifiers.slice(i + 1).map((id) => id.text);
                // TODO
                result = tsUtils.createEntityName(following, createEntityNameFromNameResolveResult(resolveResult));
            }
        }
        return result || tsUtils.createEntityName(identifiers.map((id) => id.text));
    }
    function recastEntityNameAsTypeNode(name, typeArguments) {
        const { leftmost, rights } = tsUtils.splitLeftmost(name);
        const resolved = resolveIdentifier(leftmost);
        if (resolved) {
            return createTypeNodeFromNameResolveResult(resolved, rights.map((right) => right.text), typeArguments);
        }
        else {
            return typescript_1.default.createTypeReferenceNode(recastEntityNameTrivially(name), typeArguments);
        }
    }
    function recastEntityNameTrivially(name) {
        if (typescript_1.default.isIdentifier(name)) {
            return recastIdentifier(name);
        }
        else {
            return typescript_1.default.createQualifiedName(recastEntityNameTrivially(name.left), recastIdentifier(name.right));
        }
    }
    function recastIdentifier(id) {
        return typescript_1.default.createIdentifier(id.text);
    }
    function recastPropertyName(propertyName) {
        if (typescript_1.default.isIdentifier(propertyName)) {
            return typescript_1.default.createIdentifier(propertyName.text);
        }
        else if (typescript_1.default.isStringLiteral(propertyName)) {
            return typescript_1.default.createStringLiteral(propertyName.text);
        }
        else if (typescript_1.default.isNumericLiteral(propertyName)) {
            return typescript_1.default.createNumericLiteral(propertyName.text);
        }
        else if (typescript_1.default.isPrivateIdentifier(propertyName)) {
            return typescript_1.default.createPrivateIdentifier(propertyName.text);
        }
        else {
            return typescript_1.default.createComputedPropertyName(recastExpression(propertyName.expression));
        }
    }
    function recastBooleanLiteral(node) {
        return typescript_1.default.createToken(node.kind);
    }
    function recastStringLiteral(node) {
        return typescript_1.default.createStringLiteral(node.text);
    }
    // Only literals are supported
    function recastExpression(expression) {
        if (!expression) {
            return undefined;
        }
        if (typescript_1.default.isStringLiteral(expression)) {
            return typescript_1.default.createStringLiteral(expression.text);
        }
        else if (typescript_1.default.isNumericLiteral(expression)) {
            return typescript_1.default.createNumericLiteral(expression.text);
        }
        else if (expression.kind === typescript_1.default.SyntaxKind.TrueKeyword) {
            return typescript_1.default.createTrue();
        }
        else if (expression.kind === typescript_1.default.SyntaxKind.FalseKeyword) {
            return typescript_1.default.createFalse();
        }
        else if (expression.kind === typescript_1.default.SyntaxKind.NullKeyword) {
            return typescript_1.default.createNull();
        }
        else if (typescript_1.default.isIdentifier(expression)) {
            return recastIdExpression(expression);
        }
        else if (typescript_1.default.isPropertyAccessExpression(expression)) {
            return typescript_1.default.createPropertyAccess(recastExpression(expression.expression), expression.name.text);
        }
        else {
            return typescript_1.default.createStringLiteral(`Bad expression <${expression.getText()}>`);
        }
    }
    function recastIdExpression(id) {
        const resolveResult = resolveIdentifier(id);
        if (resolveResult) {
            return createAccessLinkFromNameResolveResult(resolveResult);
        }
        else {
            return typescript_1.default.createIdentifier(id.text);
        }
    }
    function resolveIdentifier(id) {
        const rEntity = tryGetEntityAtLocation(id);
        if (rEntity) {
            return nameResolver.resolve(rEntity);
        }
    }
    function resolveImportTypeOrTypeQueryNode(type) {
        let symbol;
        const typeType = typeChecker.getTypeAtLocation(type);
        if (typeType) {
            symbol = typeType.symbol;
        }
        if (!symbol) {
            console.warn(`Failed to resolve type ${type.getText()}, There is no symbol info.`);
            return;
        }
        const rEntity = getEntityOfSymbol(symbol);
        if (rEntity) {
            const resolved = nameResolver.resolve(rEntity);
            if (resolved) {
                // TODO: consider 'module' ins resolve result.
                return createEntityNameFromNameResolveResult(resolved);
            }
        }
    }
    function createTypeNodeFromNameResolveResult(resolveResult, rightmost, typeArguments, isTypeOf) {
        if (isTypeOf) {
            const typeName = resolveResult.namespaces ?
                tsUtils.createEntityName(resolveResult.namespaces.concat([resolveResult.name]).concat(rightmost !== null && rightmost !== void 0 ? rightmost : []), undefined) :
                tsUtils.createEntityName(rightmost || [], typescript_1.default.createIdentifier(resolveResult.name));
            if (resolveResult.module) {
                return typescript_1.default.createImportTypeNode(typescript_1.default.createLiteralTypeNode(typescript_1.default.createStringLiteral(resolveResult.module.name)), // arguments(module specifier)
                typeName, typeArguments, isTypeOf);
            }
            else {
                return typescript_1.default.createTypeReferenceNode(typeName, typeArguments);
            }
        }
        else {
            const ids = prepareAndResolveIdsFromResolveResult(resolveResult);
            return typescript_1.default.createTypeReferenceNode(tsUtils.createEntityName(ids.concat(rightmost !== null && rightmost !== void 0 ? rightmost : [])), typeArguments);
        }
    }
    function createEntityNameFromNameResolveResult(resolveResult) {
        const ids = prepareAndResolveIdsFromResolveResult(resolveResult);
        return tsUtils.createEntityName(ids);
    }
    function createAccessLinkFromNameResolveResult(resolveResult) {
        const ids = prepareAndResolveIdsFromResolveResult(resolveResult);
        return tsUtils.createAccessLink(ids);
    }
    function prepareAndResolveIdsFromResolveResult(resolveResult) {
        const ids = [];
        if (resolveResult.namespaces) {
            ids.push(...resolveResult.namespaces);
        }
        ids.push(resolveResult.name);
        if (!resolveResult.module) {
            return ids;
        }
        else {
            const importName = rModule.addNamedImport(resolveResult.module.name, ids[0]);
            return [
                importName,
                ...ids.slice(1),
            ];
        }
    }
    function tryGetEntityAtLocation(node) {
        let symbol = typeChecker.getSymbolAtLocation(node);
        if (!symbol) {
            console.warn(`Failed to resolve symbol ${node.getText()}, There is no symbol info.`);
            return;
        }
        if (symbol.getFlags() & typescript_1.default.SymbolFlags.Alias) {
            symbol = typeChecker.getAliasedSymbol(symbol);
        }
        if (symbol.getFlags() & typescript_1.default.SymbolFlags.TypeParameter ||
            symbol.getFlags() & typescript_1.default.SymbolFlags.EnumMember ||
            symbol.getFlags() & typescript_1.default.SymbolFlags.FunctionScopedVariable) {
            return;
        }
        return getEntityOfSymbol(symbol);
    }
    function getEntityOfSymbol(symbol) {
        const resolved = resolveEntity(symbol);
        if (resolved) {
            return resolved;
        }
        else {
            return referenceNonExportedSymbol(symbol);
        }
    }
    function referenceNonExportedSymbol(symbol) {
        const declarations = symbol.getDeclarations();
        if (!declarations || declarations.length === 0) {
            return;
        }
        if (declarations.some((declaration) => {
            const sourceFile = declaration.getSourceFile();
            return program.isSourceFileDefaultLibrary(sourceFile) ||
                program.isSourceFileFromExternalLibrary(sourceFile);
        })) {
            return;
        }
        const { addStatements, entity } = registerNonExportedSymbol(symbol, nameResolver.current());
        // TODO: ensure that event `rEntity` is not a sub-namespace of current,
        // this also works well
        nameResolver.enter(entity.parent);
        const statements = [];
        for (const declaration of declarations) {
            if (typescript_1.default.isModuleDeclaration(declaration)) {
                const namespaceTraits = entity.addNamespaceTraits();
                nameResolver.enter(namespaceTraits);
                statements.push(recastModuleDeclarationAsNamespaceDeclaration(declaration, entity.name));
                nameResolver.leave();
            }
            else {
                pushIfNonNull(statements, recastDeclaration(declaration, entity.name, true));
            }
        }
        nameResolver.leave();
        addStatements(statements);
        return entity;
    }
    function addImport(module, symbolName) {
        const current = nameResolver.current();
        let currentExportingModule = current;
        while (!currentExportingModule.entity.symbol || !currentExportingModule.entity.isModule()) {
            currentExportingModule = currentExportingModule.entity.parent.entity.namespaceTraits;
        }
        const currentTLM = currentExportingModule.entity.moduleTraits;
        if (!(module in currentTLM.imports)) {
            currentTLM.imports[module] = {
                namedImports: {},
            };
        }
        const symbolNameX = symbolName || 'default';
        const importDetail = currentTLM.imports[module];
        const importSymbols = importDetail.namedImports;
        if (!(symbolNameX in importSymbols)) {
            const importName = generateUniqueNameInModule(currentTLM, symbolNameX, importDetail);
            importSymbols[symbolNameX] = importName;
        }
        return [
            importSymbols[symbolNameX],
        ];
    }
    function generateUniqueNameInModule(moduleTraits, preferredName, importDetail) {
        const nsTraits = moduleTraits.entity.namespaceTraits;
        let tryingName = preferredName;
        while (tryingName === '__private' ||
            nsTraits.children.some((child) => child.name === tryingName) ||
            (tryingName in importDetail.namedImports)) {
            tryingName = `_${tryingName}`;
        }
        return tryingName;
    }
}
exports.recastTopLevelModule = recastTopLevelModule;
//# sourceMappingURL=recast.js.map