{"code":"'use strict';\nimport { join } from 'path';\nimport { renderer, director, gfx, Scene, Vec3, assetManager, DirectionalLight, Light, MeshRenderer, SphereLight, SpotLight, Texture2D, Terrain, Vertex, MobilityMode, } from 'cc';\nimport exec from 'child_process';\nimport fs, { existsSync } from 'fs';\nimport { LFX_Baker } from './LFX_Baker';\nimport { LFX_Light, LFX_LightProbe, LFX_Material, LFX_Mesh, LFX_Terrain, LFX_Triangle, LFX_Vertex, LFX_World } from './LFX_Types';\nimport { NodeOperationType } from '../../event-enum';\nconst nodeMgr = cce.Node;\nimport { formatBytes } from '../../panel/operation/image';\nimport * as portFinder from './Port';\nimport fe from 'fs-extra';\nimport { Profile } from '../../profile';\n/**\n * @en Clamps a value between a minimum float and maximum float value.<br/>\n * @zh 返回最小浮点数和最大浮点数之间的一个数值。可以使用 clamp 函数将不断变化的数值限制在范围内。\n * @param val\n * @param min\n * @param max\n */\nexport function clamp(val, min, max) {\n    if (min > max) {\n        const temp = min;\n        min = max;\n        max = temp;\n    }\n    return val < min ? min : val > max ? max : val;\n}\nlet fileInfoMap;\nasync function readImageList(path, isSub = false, callback) {\n    isSub || (fileInfoMap = {});\n    const files = fs.readdirSync(path);\n    await Editor.Message.request('asset-db', 'refresh-asset', path);\n    await Promise.all(files.map(async (itm) => {\n        const res = join(path, itm);\n        const stat = fs.statSync(res);\n        if (stat.isDirectory()) {\n            // 递归读取文件\n            await readImageList(res, true);\n        }\n        else {\n            if (itm.endsWith('.png')) {\n                const url = await Editor.Message.request('asset-db', 'query-url', res);\n                let uuid = null;\n                if (url) {\n                    uuid = await Editor.Message.request('asset-db', 'query-uuid', url);\n                }\n                const metaPath = res + '.meta';\n                if (existsSync(metaPath)) {\n                    try {\n                        const json = fe.readJSONSync(metaPath);\n                        json.userData || (json.userData = {});\n                        const userData = json.userData;\n                        userData.fixAlphaTransparencyArtifacts = false;\n                        userData.type = 'texture';\n                        fe.writeJsonSync(metaPath, json, { encoding: 'utf8', spaces: 2 });\n                        await Editor.Message.request('asset-db', 'refresh-asset', res);\n                    }\n                    catch (error) {\n                        console.error('change meta failed', res);\n                        console.error(error);\n                    }\n                }\n                // 定义一个对象存放图片的路径和名字\n                const obj = {\n                    path,\n                    filename: itm,\n                    size: formatBytes(stat.size),\n                    uuid,\n                };\n                fileInfoMap[obj.filename] = obj;\n                // @6c48a 为texture类型\n                await new Promise((resolve, reject) => {\n                    assetManager.loadAny(obj.uuid + '@6c48a', (err, texture) => {\n                        if (err) {\n                            reject(err);\n                        }\n                        else {\n                            obj.texture = texture;\n                            resolve();\n                        }\n                    });\n                });\n            }\n        }\n    }));\n    callback && callback(fileInfoMap);\n    return fileInfoMap;\n}\n// tslint:disable-next-line: class-name\nexport class LFX_App {\n    constructor() {\n        this.Baker = new LFX_Baker();\n        this.Scene = null;\n        this.Models = [];\n        this.Lights = [];\n        this.Terrains = [];\n        this.MainLight = null;\n        this.MainCamera = null;\n        this._numLights = 0;\n        this._numObjects = 0;\n        this._numTriangles = 0;\n        this._currentTicks = 0;\n        this._lastTicks = 0;\n        this._uploadPath = '';\n        this._process = null;\n        this._timer = null;\n    }\n    // 重置节点lightmap\n    static Reset(node) {\n        const HideInHierarchy = 1 << 10;\n        const scene = node.scene;\n        if (scene !== null) {\n            scene.globals.bakedWithStationaryMainLight = false;\n            scene.globals.bakedWithHighpLightmap = false;\n        }\n        const terrain = node.getComponent(Terrain);\n        if (terrain != null && terrain.enabled) {\n            for (let i = 0; i < terrain.getBlocks().length; ++i) {\n                terrain._updateLightmap(i, null, 0, 0, 0, 0);\n            }\n        }\n        const models = node.getComponents(MeshRenderer);\n        for (const model of models) {\n            model._updateLightmap(null, 0, 0, 0, 0);\n            if (model.node) {\n                const compIndex = model.node.components.indexOf(model);\n                nodeMgr.emit('change', model.node, {\n                    type: NodeOperationType.SET_PROPERTY,\n                    propPath: `__comps__.${compIndex}.bakeSettings`,\n                });\n            }\n        }\n        const lights = node.getComponents(Light);\n        for (const light of lights) {\n            light.baked = false;\n        }\n        for (const child of node.children) {\n            if (!child.active) {\n                continue;\n            }\n            if (child._objFlags & HideInHierarchy) {\n                continue;\n            }\n            this.Reset(child);\n        }\n    }\n    // 禁用/启用lightmap\n    static Disable(node, disable) {\n        if (node.scene === null) {\n            return;\n        }\n        node.scene.globals.disableLightmap = disable;\n        // Notify all shader macros changed\n        //director.root?.onGlobalPipelineStateChanged();\n        const HideInHierarchy = 1 << 10;\n        const terrain = node.getComponent(Terrain);\n        if (terrain != null && terrain.enabled) {\n            for (let y = 0; y < terrain.info.blockCount[1]; ++y) {\n                for (let x = 0; x < terrain.info.blockCount[0]; ++x) {\n                    const blockId = y * terrain.info.blockCount[0] + x;\n                    const lmapInfo = terrain._getLightmapInfo(x, y);\n                    if (lmapInfo !== null && lmapInfo.texture !== null) {\n                        terrain._updateLightmap(blockId, lmapInfo.texture, lmapInfo.UOff, lmapInfo.VOff, lmapInfo.UScale, lmapInfo.VScale);\n                    }\n                }\n            }\n        }\n        const models = node.getComponents(MeshRenderer);\n        for (const model of models) {\n            const lmapInfo = model.bakeSettings;\n            if (lmapInfo.texture !== null) {\n                model._updateLightmap(lmapInfo.texture, lmapInfo.uvParam.x, lmapInfo.uvParam.y, lmapInfo.uvParam.z, lmapInfo.uvParam.w);\n            }\n        }\n        for (const child of node.children) {\n            if (!child.active) {\n                continue;\n            }\n            if (child._objFlags & HideInHierarchy) {\n                continue;\n            }\n            this.Disable(child, disable);\n        }\n    }\n    static DirtyBaked(node) {\n        const HideInHierarchy = 1 << 10;\n        if (node.mobility == MobilityMode.Static) {\n            const lights = node.getComponents(Light);\n            for (const light of lights) {\n                light.baked = true;\n            }\n        }\n        for (const child of node.children) {\n            if (!child.active) {\n                continue;\n            }\n            if (child._objFlags & HideInHierarchy) {\n                continue;\n            }\n            this.DirtyBaked(child);\n        }\n    }\n    Init(data = {}) {\n        this.Baker.World = new LFX_World();\n        this.Scene = null;\n        this.Models = [];\n        this.Lights = [];\n        this.Terrains = [];\n        this.MainLight = null;\n        this.MainCamera = null;\n        this._currentTicks = 0;\n        this._lastTicks = 0;\n        // 场景名字\n        this.Baker.World.Name = data.name || 'Test';\n        // 服务器地址\n        // this.Baker.World.Settings.Server = data.server || 'localhost:9002';\n        // 环境光照\n        // this.Baker.World.Settings.Ambient = data.ambient || [0.0, 0.0, 0.0];\n        // 天空辐照度(用于全局光照)\n        this.Baker.World.Settings.SkyRadiance = data.skyRadiance || [0.5, 0.5, 0.5];\n        // 高精度模式\n        this.Baker.World.Settings.Highp = data.highp ? true : false;\n        // 多重采样: 值(1, 2, 4, 8)\n        this.Baker.World.Settings.MSAA = data.msaa || 4;\n        // 烘培贴图大小: 值(128, 256, 512, 1024, 2048)\n        this.Baker.World.Settings.Size = data.size || 1024;\n        // Gamma值\n        this.Baker.World.Settings.Gamma = 2.2;\n        // 全局光照缩放\n        this.Baker.World.Settings.GIScale = data.giScale || 0;\n        // 全局光照采样数\n        // 全局光照光线最大跟踪次数\n        this.Baker.World.Settings.GIPathLength = data.giPathLength || 4;\n        // AO等级\n        this.Baker.World.Settings.AOLevel = data.aoLevel || 0;\n        // AO颜色\n        this.Baker.World.Settings.AOColor = data.aoColor || [127.5, 127.5, 127.5];\n        // AO半径\n        this.Baker.World.Settings.AORadius = data.aoRadius || 1.0;\n        // AO强度\n        this.Baker.World.Settings.AOStrength = data.aoStrength || 1.0;\n        // 线程数量\n        this.Baker.World.Settings.Threads = data.threads || 1;\n        // 过滤开关\n        this.Baker.World.Settings.Filter = data.filter !== undefined ? data.filter : false;\n        this._uploadPath = data.path || '';\n    }\n    Index2Str(index) {\n        let str = '';\n        if (index < 1000) {\n            str = str + '0';\n        }\n        if (index < 100) {\n            str = str + '0';\n        }\n        if (index < 10) {\n            str = str + '0';\n        }\n        str = str + index;\n        return str;\n    }\n    Cancel() {\n        if (this._timer) {\n            clearInterval(this._timer);\n            this.Baker.Stop();\n            this.Baker.Close();\n            this._timer = null;\n            this.Baker.emit('cancel', true);\n            if (this._process !== null) {\n                this._process.kill('SIGKILL');\n                this._process = null;\n            }\n        }\n    }\n    async Bake(node) {\n        this.Baker.World.Settings.BakeLightMap = true;\n        this.Baker.World.Settings.BakeLightProbe = true;\n        await this._bakeImp(node);\n    }\n    async BakeLightMap(node) {\n        this.Baker.World.Settings.BakeLightMap = true;\n        this.Baker.World.Settings.BakeLightProbe = false;\n        await this._bakeImp(node);\n    }\n    async BakeLightProbe(node) {\n        this.Baker.World.Settings.BakeLightMap = false;\n        this.Baker.World.Settings.BakeLightProbe = true;\n        await this._bakeImp(node);\n    }\n    async _bakeImp(node) {\n        if (this._process) {\n            console.warn('Baker has already starting');\n            return;\n        }\n        this.Scene = node;\n        this._numLights = 0;\n        this._numObjects = 0;\n        this._numTriangles = 0;\n        this._export(node);\n        this._exportLightProbes(node.scene);\n        const scene = this.Scene?.scene;\n        if (this.Baker.World.Settings.BakeLightProbe && scene && scene.globals && scene.globals.lightProbeInfo) {\n            this.Baker.World.Settings.GIProbeScale = scene.globals.lightProbeInfo.giScale;\n            this.Baker.World.Settings.GIProbeSamples = scene.globals.lightProbeInfo.giSamples;\n            this.Baker.World.Settings.GIProbePathLength = scene.globals.lightProbeInfo.bounces;\n        }\n        for (const mesh of this.Baker.World.Meshes) {\n            for (const mtl of mesh.MaterialBuffer) {\n                if (mtl.Texture.length === 0) {\n                    continue;\n                }\n                const uuid = mtl.Texture;\n                if (uuid.search('@') === -1) {\n                    const filename = await Editor.Message.request('asset-db', 'query-path', uuid);\n                    if (filename !== null) {\n                        mtl.Texture = filename;\n                    }\n                    else {\n                        mtl.Texture = '';\n                    }\n                }\n                else {\n                    mtl.Texture = join(Editor.Project.path, 'library', uuid.substr(0, 2), uuid);\n                }\n                if (mtl.Texture.length === 0) {\n                    console.warn('query-path texture ' + uuid + ' failed');\n                }\n            }\n        }\n        if (director.root.pipeline.pipelineSceneData.isHDR) {\n            const e = renderer.scene.Camera.standardExposureValue;\n            for (const light of this.Baker.World.Lights) {\n                light.Color[0] *= light.Illuminance * e;\n                light.Color[1] *= light.Illuminance * e;\n                light.Color[2] *= light.Illuminance * e;\n            }\n        }\n        else {\n            for (const light of this.Baker.World.Lights) {\n                light.Color[0] *= light.Illuminance;\n                light.Color[1] *= light.Illuminance;\n                light.Color[2] *= light.Illuminance;\n            }\n        }\n        this.Baker.Upload(this._uploadPath);\n        this._run();\n    }\n    async _export(node) {\n        this._exportImp(node);\n    }\n    _exportImp(node) {\n        if (node.mobility === MobilityMode.Movable) {\n            return;\n        }\n        if (!(node instanceof Scene)) {\n            this._exportNode(node);\n        }\n        const HideInHierarchy = 1 << 10;\n        for (const child of node.children) {\n            if (!child.active) {\n                continue;\n            }\n            if (child._objFlags & HideInHierarchy) {\n                continue;\n            }\n            this._exportImp(child);\n        }\n    }\n    _exportNode(node) {\n        const terrain = node.getComponent(Terrain);\n        if (terrain != null && terrain.enabled) {\n            this._exportTerrain(terrain);\n        }\n        const models = node.getComponents(MeshRenderer);\n        for (const model of models) {\n            if (model.enabled) {\n                this._exportModel(model);\n            }\n        }\n        const lights = node.getComponents(Light);\n        for (const light of lights) {\n            if (light.enabled) {\n                this._exportLight(light);\n            }\n        }\n        /*\n        const cameras = node.getComponents(Camera);\n        for (const camera of cameras) {\n            if (camera.enabled) {\n                this._exportCamera(camera);\n            }\n        }\n        */\n    }\n    _exportTerrain(terrain) {\n        const fxterrain = new LFX_Terrain();\n        fxterrain.Position[0] = terrain.node.getWorldPosition().x;\n        fxterrain.Position[1] = terrain.node.getWorldPosition().y;\n        fxterrain.Position[2] = terrain.node.getWorldPosition().z;\n        fxterrain.TileSize = terrain.info.tileSize;\n        fxterrain.BlockCount[0] = terrain.info.blockCount[0];\n        fxterrain.BlockCount[1] = terrain.info.blockCount[1];\n        fxterrain.LightMapSize = terrain.info.lightMapSize;\n        // @ts-ignore\n        fxterrain.HeightField = terrain.getHeightField();\n        this.Baker.World.Terrains.push(fxterrain);\n        this.Terrains.push(terrain);\n        this._numObjects++;\n        this._numTriangles += fxterrain.BlockCount[0] * fxterrain.BlockCount[1] * 2048;\n    }\n    async _exportModel(model) {\n        const mesh = model.mesh;\n        if (mesh == null) {\n            return false;\n        }\n        if (this.Baker.World.Settings.BakeLightMap) {\n            if (!model.bakeSettings.bakeable && !model.bakeSettings.castShadow) {\n                return false;\n            }\n        }\n        else if (this.Baker.World.Settings.BakeLightProbe) {\n            if (!model.bakeSettings.bakeToLightProbe) {\n                return false;\n            }\n        }\n        const fxmesh = new LFX_Mesh();\n        if (this.Baker.World.Settings.BakeLightMap) {\n            fxmesh.CastShadow = model.bakeSettings.castShadow;\n            fxmesh.ReceiveShadow = model.bakeSettings.receiveShadow;\n            if (model.bakeSettings.bakeable) {\n                fxmesh.LightMapSize = model.bakeSettings.lightmapSize;\n            }\n        }\n        else if (this.Baker.World.Settings.BakeLightProbe) {\n            fxmesh.CastShadow = model.bakeSettings.bakeToLightProbe;\n        }\n        let missLightmapUV = false;\n        let errorLightmapUV = false;\n        let startVertex = 0;\n        const worldTM = model.node.getWorldMatrix();\n        for (let iPrimitive = 0; iPrimitive < mesh.struct.primitives.length; ++iPrimitive) {\n            const positions = mesh.readAttribute(iPrimitive, gfx.AttributeName.ATTR_POSITION);\n            const normals = mesh.readAttribute(iPrimitive, gfx.AttributeName.ATTR_NORMAL);\n            const uvs = mesh.readAttribute(iPrimitive, gfx.AttributeName.ATTR_TEX_COORD);\n            const luvs = mesh.readAttribute(iPrimitive, gfx.AttributeName.ATTR_TEX_COORD1);\n            const indices = mesh.readIndices(iPrimitive);\n            // 检查是否有效\n            if (!positions || !normals || !indices) {\n                return false;\n            }\n            if (positions.length !== normals.length) {\n                return false;\n            }\n            if (uvs != null && positions.length / 3 !== uvs.length / 2) {\n                return false;\n            }\n            if (luvs != null && positions.length / 3 !== luvs.length / 2) {\n                return false;\n            }\n            // 没有lightmap uv\n            if (luvs == null) {\n                if (fxmesh.LightMapSize > 0) {\n                    missLightmapUV = true;\n                }\n                fxmesh.ReceiveShadow = false;\n            }\n            // 顶点数据\n            for (let v = 0; v < positions.length / 3; ++v) {\n                const P = new Vec3();\n                P.x = positions[v * 3 + 0];\n                P.y = positions[v * 3 + 1];\n                P.z = positions[v * 3 + 2];\n                Vec3.transformMat4(P, P, worldTM);\n                const N = new Vec3();\n                N.x = normals[v * 3 + 0];\n                N.y = normals[v * 3 + 1];\n                N.z = normals[v * 3 + 2];\n                Vec3.transformMat4Normal(N, N, worldTM);\n                N.normalize();\n                const vertex = new LFX_Vertex();\n                vertex.Position[0] = P.x;\n                vertex.Position[1] = P.y;\n                vertex.Position[2] = P.z;\n                vertex.Normal[0] = N.x;\n                vertex.Normal[1] = N.y;\n                vertex.Normal[2] = N.z;\n                if (uvs != null) {\n                    vertex.UV[0] = uvs[v * 2 + 0];\n                    vertex.UV[1] = uvs[v * 2 + 1];\n                }\n                if (luvs != null && fxmesh.LightMapSize > 0) {\n                    vertex.LUV[0] = luvs[v * 2 + 0];\n                    vertex.LUV[1] = luvs[v * 2 + 1];\n                    if (vertex.LUV[0] < 0 || vertex.LUV[0] > 1 || vertex.LUV[1] < 0 || vertex.LUV[1] > 1) {\n                        errorLightmapUV = true;\n                    }\n                }\n                fxmesh.VertexBuffer.push(vertex);\n            }\n            // 索引数据\n            for (let i = 0; i < indices.length / 3; ++i) {\n                const tri = new LFX_Triangle();\n                if (positions.length < 256) {\n                    tri.Index[0] = indices[i * 3 + 0] + startVertex;\n                    tri.Index[1] = indices[i * 3 + 1] + startVertex;\n                    tri.Index[2] = indices[i * 3 + 2] + startVertex;\n                }\n                else if (positions.length < 65536) {\n                    tri.Index[0] = indices[i * 3 + 0] + startVertex;\n                    tri.Index[1] = indices[i * 3 + 1] + startVertex;\n                    tri.Index[2] = indices[i * 3 + 2] + startVertex;\n                }\n                else {\n                    tri.Index[0] = indices[i * 3 + 0] + startVertex;\n                    tri.Index[1] = indices[i * 3 + 1] + startVertex;\n                    tri.Index[2] = indices[i * 3 + 2] + startVertex;\n                }\n                if (model.materials.length > 0) {\n                    tri.MaterialId = clamp(iPrimitive, 0, model.materials.length - 1);\n                }\n                else {\n                    tri.MaterialId = 0;\n                }\n                fxmesh.TriangleBuffer.push(tri);\n            }\n            startVertex = fxmesh.VertexBuffer.length;\n        }\n        // Materials\n        if (model.materials.length > 0) {\n            const PixelFormat = Texture2D.PixelFormat;\n            for (let m = 0; m < model.materials.length; ++m) {\n                const fxmtl = new LFX_Material();\n                fxmtl.Diffuse[0] = 1;\n                fxmtl.Diffuse[1] = 1;\n                fxmtl.Diffuse[2] = 1;\n                fxmtl.Emissive[0] = 0;\n                fxmtl.Emissive[1] = 0;\n                fxmtl.Emissive[2] = 0;\n                const mmtl = model.materials[m];\n                if (mmtl !== null) {\n                    const mainColor = mmtl.getProperty('mainColor', 0);\n                    if (mainColor) {\n                        fxmtl.Diffuse[0] = mainColor.x;\n                        fxmtl.Diffuse[1] = mainColor.y;\n                        fxmtl.Diffuse[2] = mainColor.z;\n                    }\n                    if (mmtl.passes[0].blendState.targets[0].blend) {\n                        // Blend is enabled\n                        fxmtl.AlphaCulloff = 0.5;\n                    }\n                    else {\n                        // Alpha test\n                        const alphaThreshold = mmtl.getProperty('alphaThreshold', 0);\n                        if (alphaThreshold) {\n                            fxmtl.AlphaCulloff = alphaThreshold;\n                        }\n                        else {\n                            fxmtl.AlphaCulloff = 0.5;\n                        }\n                    }\n                    const roughness = mmtl.getProperty('roughness', 0);\n                    if (roughness) {\n                        fxmtl.Roughness = roughness;\n                    }\n                    else {\n                        fxmtl.Roughness = 0.8;\n                    }\n                    const metallic = mmtl.getProperty('metallic', 0);\n                    if (metallic) {\n                        fxmtl.Metallic = metallic;\n                    }\n                    else {\n                        fxmtl.Metallic = 0.6;\n                    }\n                    const albedoScale = mmtl.getProperty('albedoScale', 0);\n                    if (albedoScale) {\n                        if (albedoScale instanceof Vec3) {\n                            fxmtl.Diffuse[0] *= albedoScale.x;\n                            fxmtl.Diffuse[1] *= albedoScale.y;\n                            fxmtl.Diffuse[2] *= albedoScale.z;\n                        }\n                        else {\n                            fxmtl.Diffuse[0] *= albedoScale;\n                            fxmtl.Diffuse[1] *= albedoScale;\n                            fxmtl.Diffuse[2] *= albedoScale;\n                        }\n                    }\n                    let tex = mmtl.getProperty('mainTexture', 0);\n                    if (tex == null) {\n                        tex = mmtl.getProperty('albedoMap', 0);\n                    }\n                    const isValidTextureFormat = (tex) => {\n                        const format = tex.getPixelFormat();\n                        return format == PixelFormat.RGBA8888 || format === PixelFormat.RGB888;\n                    };\n                    if (tex !== null && isValidTextureFormat(tex)) {\n                        const asset = tex.mipmaps[0];\n                        if (asset !== null) {\n                            if (asset._uuid.search('@') !== -1) {\n                                fxmtl.Texture = asset._uuid + asset._native;\n                            }\n                            else {\n                                fxmtl.Texture = asset._uuid;\n                            }\n                        }\n                    }\n                    tex = mmtl.getProperty('pbrMap', 0);\n                    if (tex !== null && isValidTextureFormat(tex)) {\n                        const asset = tex.mipmaps[0];\n                        if (asset !== null) {\n                            if (asset._uuid.search('@') !== -1) {\n                                fxmtl.PBRMap = asset._uuid + asset._native;\n                            }\n                            else {\n                                fxmtl.PBRMap = asset._uuid;\n                            }\n                        }\n                    }\n                    // export emissive material parameters\n                    const emissiveColor = mmtl.getProperty('emissive', 0);\n                    if (emissiveColor) {\n                        fxmtl.Emissive[0] = emissiveColor.x;\n                        fxmtl.Emissive[1] = emissiveColor.y;\n                        fxmtl.Emissive[2] = emissiveColor.z;\n                        const emissiveScale = mmtl.getProperty('emissiveScale', 0);\n                        if (emissiveScale) {\n                            if (emissiveScale instanceof Vec3) {\n                                fxmtl.Emissive[0] *= emissiveScale.x;\n                                fxmtl.Emissive[1] *= emissiveScale.y;\n                                fxmtl.Emissive[2] *= emissiveScale.z;\n                            }\n                            else {\n                                fxmtl.Emissive[0] *= emissiveScale;\n                                fxmtl.Emissive[1] *= emissiveScale;\n                                fxmtl.Emissive[2] *= emissiveScale;\n                            }\n                        }\n                    }\n                    tex = mmtl.getProperty('emissiveMap', 0);\n                    if (tex !== null && isValidTextureFormat(tex)) {\n                        const asset = tex.mipmaps[0];\n                        if (asset !== null) {\n                            if (asset._uuid.search('@') !== -1) {\n                                fxmtl.EmissiveMap = asset._uuid + asset._native;\n                            }\n                            else {\n                                fxmtl.EmissiveMap = asset._uuid;\n                            }\n                        }\n                    }\n                }\n                fxmesh.MaterialBuffer.push(fxmtl);\n            }\n        }\n        else {\n            const fxmtl = new LFX_Material();\n            fxmtl.Diffuse[0] = 1;\n            fxmtl.Diffuse[1] = 1;\n            fxmtl.Diffuse[2] = 1;\n            fxmesh.MaterialBuffer.push(fxmtl);\n        }\n        if (missLightmapUV) {\n            if (this.Baker.World.Settings.BakeLightMap) {\n                const filename = await Editor.Message.request('asset-db', 'query-path', mesh._uuid);\n                if (filename) {\n                    console.error('Error: missing lightmap uv, ' + filename);\n                }\n                else {\n                    console.error('Error: missing lightmap uv, ' + mesh._uuid);\n                }\n            }\n        }\n        else if (errorLightmapUV) {\n            if (this.Baker.World.Settings.BakeLightMap) {\n                const filename = await Editor.Message.request('asset-db', 'query-path', mesh._uuid);\n                if (filename) {\n                    console.error('Error: error lightmap uv, ' + filename);\n                }\n                else {\n                    console.error('Error: error lightmap uv, ' + mesh._uuid);\n                }\n            }\n            fxmesh.LightMapSize = 0;\n        }\n        this.Baker.World.Meshes.push(fxmesh);\n        this.Models.push(model);\n        this._numObjects++;\n        if (fxmesh.LightMapSize > 0) {\n            this._numTriangles += fxmesh.TriangleBuffer.length;\n        }\n    }\n    _exportLight(light) {\n        const fxlight = new LFX_Light();\n        fxlight.Type = LFX_Light.DIRECTION;\n        fxlight.GIEnable = true;\n        fxlight.CastShadow = light.staticSettings.castShadow;\n        fxlight.Position[0] = light.node.getWorldPosition().x;\n        fxlight.Position[1] = light.node.getWorldPosition().y;\n        fxlight.Position[2] = light.node.getWorldPosition().z;\n        const dir = new Vec3(0, 0, -1);\n        Vec3.transformQuat(dir, dir, light.node.getWorldRotation());\n        fxlight.Direction[0] = dir.x;\n        fxlight.Direction[1] = dir.y;\n        fxlight.Direction[2] = dir.z;\n        fxlight.Color[0] = light.color.x;\n        fxlight.Color[1] = light.color.y;\n        fxlight.Color[2] = light.color.z;\n        const _lightMeterScale = 10000.0;\n        if (light instanceof DirectionalLight) {\n            const l = light;\n            fxlight.Type = LFX_Light.DIRECTION;\n            fxlight.Illuminance = l.illuminance;\n            fxlight.ShadowMask = 1.0 - l.shadowSaturation;\n            if (this.MainLight === null) {\n                this.MainLight = light;\n            }\n        }\n        else if (light instanceof SphereLight) {\n            const l = light;\n            fxlight.Type = LFX_Light.POINT;\n            fxlight.Size = l.size;\n            fxlight.Range = l.range;\n            fxlight.AttenFallOff = 1;\n            fxlight.Illuminance = l.luminance;\n            if (director.root.pipeline.pipelineSceneData.isHDR) {\n                fxlight.Illuminance *= _lightMeterScale;\n            }\n        }\n        else if (light instanceof SpotLight) {\n            const l = light;\n            fxlight.Type = LFX_Light.SPOT;\n            fxlight.Size = l.size;\n            fxlight.Range = l.range;\n            fxlight.AttenFallOff = 1;\n            fxlight.SpotInner = Math.cos((l.spotAngle / 4) * (Math.PI / 180.0));\n            fxlight.SpotOuter = Math.cos((l.spotAngle / 2) * (Math.PI / 180.0));\n            fxlight.SpotFallOff = 1;\n            fxlight.Illuminance = l.luminance;\n            if (director.root.pipeline.pipelineSceneData.isHDR) {\n                fxlight.Illuminance *= _lightMeterScale;\n            }\n        }\n        else {\n            return;\n        }\n        if (light.node.mobility === MobilityMode.Static) {\n            fxlight.DirectScale = 1;\n            fxlight.IndirectScale = 1;\n        }\n        else {\n            fxlight.DirectScale = 0;\n            fxlight.IndirectScale = 1;\n        }\n        this.Baker.World.Lights.push(fxlight);\n        this.Lights.push(light);\n        this._numLights++;\n    }\n    _exportCamera(camera) {\n        if (this.MainCamera === null) {\n            this.MainCamera = camera;\n        }\n        else if (camera.node.name === 'MainCamera') {\n            this.MainCamera = camera;\n        }\n    }\n    _exportLightProbes(scene) {\n        if (scene.globals.lightProbeInfo.data === null) {\n            return;\n        }\n        for (const probe of scene.globals.lightProbeInfo.data.probes) {\n            const lfxLightProbe = new LFX_LightProbe();\n            lfxLightProbe.Position[0] = probe.position.x;\n            lfxLightProbe.Position[1] = probe.position.y;\n            lfxLightProbe.Position[2] = probe.position.z;\n            lfxLightProbe.Normal[0] = probe.normal.x;\n            lfxLightProbe.Normal[1] = probe.normal.y;\n            lfxLightProbe.Normal[2] = probe.normal.z;\n            this.Baker.World.LightProbes.push(lfxLightProbe);\n        }\n    }\n    _run() {\n        const lfx_debug = false;\n        let lfx_launching = false;\n        let lfx_port = 3000;\n        // 获取端口\n        if (!lfx_debug) {\n            lfx_port = 0;\n            portFinder.getPort((err, port) => {\n                if (!err) {\n                    lfx_port = port;\n                }\n                else {\n                    lfx_port = -1;\n                    console.log('Configure port failed');\n                }\n            });\n        }\n        console.log('Start baker server ' + lfx_port);\n        // 定时器模拟更新\n        this._timer = setInterval(() => {\n            if (!lfx_launching) {\n                if (lfx_port > 0) {\n                    this.Baker.Launch(lfx_port);\n                    // 启动烘焙程序 (调试模式从c++启动)\n                    if (!lfx_debug) {\n                        const LFX_URL = 'http://127.0.0.1:' + lfx_port;\n                        const LFX_SERVER = this.Baker.lfxpath + '/LightFX';\n                        console.log('Launching ' + LFX_SERVER);\n                        this._process = exec.execFile(LFX_SERVER, [LFX_URL], { cwd: this._uploadPath }, (err, stdout, stderr) => {\n                            // TODO 确认为什么要用 kill 退出进程，kill 退出会报 err\n                            if (err && err.signal !== 'SIGKILL') {\n                                this.Baker.Error = true;\n                                console.error(err);\n                                console.error('Baker app aborted with an exception');\n                                this.Baker.Stop();\n                                clearInterval(this._timer);\n                                this.Baker.Close();\n                                this._timer = null;\n                                this.Baker.emit('end', true);\n                                this._process.kill('SIGKILL');\n                            }\n                        });\n                        if (!this._process) {\n                            console.log('Launching baker failed.');\n                            clearInterval(this._timer);\n                        }\n                    }\n                    lfx_launching = true;\n                }\n                else if (lfx_port < 0) {\n                    // error\n                    clearInterval(this._timer);\n                }\n                return;\n            }\n            if (this.Baker.closed) {\n                clearInterval(this._timer);\n                return;\n            }\n            if (!this.Baker.Started) {\n                // 开始烘培\n                if (this.Baker.connected) {\n                    this.Baker.Start();\n                    this.Baker.client.on('Tick', (data) => {\n                        this._lastTicks = this._currentTicks;\n                    });\n                }\n            }\n            else {\n                // 结束了\n                if (this.Baker.Finished) {\n                    console.log('End');\n                    let file = null;\n                    try {\n                        file = this.Baker.Download();\n                    }\n                    catch (error) {\n                        console.error('LightFX get result file failed.');\n                        file = null;\n                    }\n                    const bakeStats = 'Bake scene stats:\\n' +\n                        '\\tobjects ' +\n                        this._numObjects +\n                        '\\n' +\n                        '\\tlights ' +\n                        this._numLights +\n                        '\\n' +\n                        '\\ttriangles ' +\n                        this._numTriangles +\n                        '\\n';\n                    this.Baker.emit('log', bakeStats);\n                    if (file !== null) {\n                        // 模型的Lightmap信息\n                        for (let i = 0; i < file.MeshInfos.length; ++i) {\n                            // 对应output/LFX_Mesh_xxxx.png\n                            const info = file.MeshInfos[i];\n                            const logInfo = 'Mesh ' +\n                                info.Id +\n                                ':' +\n                                ' Index(' +\n                                info.Index +\n                                ') ' +\n                                ' Offset(' +\n                                info.Offset[0] +\n                                ', ' +\n                                info.Offset[1] +\n                                ') ' +\n                                ' Scale(' +\n                                info.Scale[0] +\n                                ', ' +\n                                info.Scale[1] +\n                                ')';\n                            this.Baker.emit('log', logInfo);\n                        }\n                        // LightProbe信息\n                        for (let i = 0; i < file.LightProbeInfos.length; ++i) {\n                            const info = file.LightProbeInfos[i];\n                            const logInfo = 'LightProbe ' +\n                                i +\n                                ':' +\n                                ' pos(' +\n                                info.Position[0] +\n                                ', ' +\n                                info.Position[1] +\n                                ', ' +\n                                info.Position[2] +\n                                ')' +\n                                ' coef(' +\n                                info.Coefficients[0] +\n                                ', ' +\n                                info.Coefficients[1] +\n                                ', ' +\n                                info.Coefficients[2] +\n                                ', ...)';\n                            this.Baker.emit('log', logInfo);\n                        }\n                    }\n                    this.Baker.Stop();\n                    clearInterval(this._timer);\n                    this.Baker.Close();\n                    this._timer = null;\n                    this.Baker.emit('end', true);\n                    if (this._process !== null) {\n                        this._process.kill('SIGKILL');\n                        this._process = null;\n                    }\n                    if (this.Baker.World.Settings.BakeLightMap) {\n                        const scene = this.Scene?.scene;\n                        if (this.Scene != null) {\n                            LFX_App.DirtyBaked(this.Scene);\n                        }\n                        for (const t of this.Terrains) {\n                            if (t.lightMapSize > 0) {\n                                t._resetLightmap(true);\n                            }\n                        }\n                        if (scene && this.MainLight && this.MainLight.node && this.MainLight.node.mobility == MobilityMode.Stationary) {\n                            scene.globals.bakedWithStationaryMainLight = true;\n                        }\n                        if (scene) {\n                            scene.globals.bakedWithHighpLightmap = this.Baker.World.Settings.Highp;\n                        }\n                    }\n                    if (file !== null && this.Baker.World.Settings.BakeLightProbe) {\n                        const scene = this.Scene?.scene;\n                        // 导出LightProbe信息\n                        const overloadLightProbeInfo = true;\n                        if (!scene ||\n                            !scene.globals ||\n                            !scene.globals.lightProbeInfo ||\n                            !scene.globals.lightProbeInfo.data ||\n                            !scene.globals.lightProbeInfo.data.probes) {\n                            console.warn('No light probes were found in the scene and cannot be baked.');\n                        }\n                        else if (overloadLightProbeInfo &&\n                            scene.globals.lightProbeInfo.data.probes.length !== file.LightProbeInfos.length) {\n                            scene.globals.lightProbeInfo.data.probes.length = file.LightProbeInfos.length;\n                            for (let i = 0; i < scene.globals.lightProbeInfo.data.probes.length; ++i) {\n                                const info = file.LightProbeInfos[i];\n                                const pos = new Vec3(info.Position[0], info.Position[1], info.Position[2]);\n                                const normal = new Vec3(info.Normal[0], info.Normal[1], info.Normal[2]);\n                                scene.globals.lightProbeInfo.data.probes[i] = new Vertex(pos);\n                                const probe = scene.globals.lightProbeInfo.data.probes[i];\n                                if (info && probe) {\n                                    probe.normal = normal;\n                                    probe.coefficients.length = info.Coefficients.length / 3;\n                                    for (let j = 0; j < probe.coefficients.length; ++j) {\n                                        probe.coefficients[j] = new Vec3();\n                                        probe.coefficients[j].x = info.Coefficients[j * 3 + 0];\n                                        probe.coefficients[j].y = info.Coefficients[j * 3 + 1];\n                                        probe.coefficients[j].z = info.Coefficients[j * 3 + 2];\n                                    }\n                                    cce.Engine.repaintInEditMode();\n                                    cce.SceneFacadeManager.recordNode(scene);\n                                    cce.SceneFacadeManager.snapshot();\n                                }\n                            }\n                        }\n                        else {\n                            if (file.LightProbeInfos.length === scene.globals.lightProbeInfo.data?.probes.length) {\n                                if (this.Baker.World.Settings.BakeLightProbe && scene.globals.lightProbeInfo.data) {\n                                    for (let i = 0; i < scene.globals.lightProbeInfo.data.probes.length; ++i) {\n                                        const info = file.LightProbeInfos[i];\n                                        const probe = scene.globals.lightProbeInfo.data.probes[i];\n                                        if (info && probe) {\n                                            probe.coefficients.length = info.Coefficients.length / 3;\n                                            for (let j = 0; j < probe.coefficients.length; ++j) {\n                                                probe.coefficients[j] = new Vec3();\n                                                probe.coefficients[j].x = info.Coefficients[j * 3 + 0];\n                                                probe.coefficients[j].y = info.Coefficients[j * 3 + 1];\n                                                probe.coefficients[j].z = info.Coefficients[j * 3 + 2];\n                                            }\n                                        }\n                                    }\n                                    cce.Engine.repaintInEditMode();\n                                    cce.SceneFacadeManager.recordNode(scene);\n                                    cce.SceneFacadeManager.snapshot();\n                                }\n                            }\n                            else {\n                                console.error('Light probe bake result mismatch with scene.');\n                            }\n                        }\n                    }\n                    if (file !== null && this.Baker.World.Settings.BakeLightMap) {\n                        readImageList(join(this._uploadPath, 'output'), false, (objs) => {\n                            // 地形的Lightmap信息\n                            for (const info of file.TerrainInfos) {\n                                // 对应output/LFX_Terrain_xxxx.png\n                                const terrain = this.Terrains[info.Id];\n                                const filename = 'LFX_Terrain_' + this.Index2Str(info.Index) + '.png';\n                                const obj = objs[filename];\n                                if (!obj) {\n                                    continue;\n                                }\n                                const tex = obj.texture;\n                                if (tex) {\n                                    terrain._updateLightmap(info.BlockId, tex, info.Offset[0], info.Offset[1], info.Scale[0], info.Scale[1]);\n                                }\n                                else {\n                                    terrain._updateLightmap(info.BlockId, null, info.Offset[0], info.Offset[1], info.Scale[0], info.Scale[1]);\n                                }\n                                // 记录到 undo\n                                Editor.Message.broadcast('scene:change-node', terrain.node.uuid);\n                            }\n                            // 模型的lightmap\n                            for (const info of file.MeshInfos) {\n                                // 对应output/LFX_Mesh_xxxx.png\n                                const model = this.Models[info.Id];\n                                const filename = 'LFX_Mesh_' + this.Index2Str(info.Index) + '.png';\n                                const obj = objs[filename];\n                                if (!obj) {\n                                    continue;\n                                }\n                                const tex = obj.texture;\n                                if (tex) {\n                                    model._updateLightmap(tex, info.Offset[0], info.Offset[1], info.Scale[0], info.Scale[1]);\n                                    // @ts-ignore\n                                    model.node._dirtyFlags = 1;\n                                }\n                                else {\n                                    model._updateLightmap(null, info.Offset[0], info.Offset[1], info.Scale[0], info.Scale[1]);\n                                }\n                                if (model.node) {\n                                    const compIndex = model.node.components.indexOf(model);\n                                    nodeMgr.emit('change', model.node, {\n                                        type: NodeOperationType.SET_PROPERTY,\n                                        propPath: `__comps__.${compIndex}.bakeSettings`,\n                                    });\n                                }\n                            }\n                            Profile.setLatestLightmapResults(this.Scene.uuid, Object.values(objs)\n                                .map((item) => item.uuid)\n                                .filter(Boolean));\n                            Profile.setLatestLightmapResultsDir(this.Scene.uuid, this._uploadPath);\n                            cce.Engine.repaintInEditMode();\n                        });\n                    }\n                }\n            }\n            this._currentTicks += 100;\n        }, 100);\n    }\n}\nexport default LFX_App;\n","references":["/Users/mac/Documents/editor_3d/v3.8.7/app/node_modules/path/path.js","/Users/mac/Documents/editor_3d/v3.8.7/app/node_modules/cc/cc.d.ts","/Users/mac/Documents/editor_3d/v3.8.7/app/modules/editor-extensions/extensions/lightmap/source/lightmap/backer/LFX_Baker.ts","/Users/mac/Documents/editor_3d/v3.8.7/app/modules/editor-extensions/extensions/lightmap/source/lightmap/backer/LFX_Types.ts","/Users/mac/Documents/editor_3d/v3.8.7/app/modules/editor-extensions/extensions/lightmap/source/event-enum.ts","/Users/mac/Documents/editor_3d/v3.8.7/app/modules/editor-extensions/extensions/lightmap/source/panel/operation/image.ts","/Users/mac/Documents/editor_3d/v3.8.7/app/modules/editor-extensions/extensions/lightmap/source/lightmap/backer/Port.ts","/Users/mac/Documents/editor_3d/v3.8.7/app/node_modules/@types/fs-extra/index.d.ts","/Users/mac/Documents/editor_3d/v3.8.7/app/modules/editor-extensions/@types/userDatas.d.ts","/Users/mac/Documents/editor_3d/v3.8.7/app/modules/editor-extensions/extensions/lightmap/source/profile/index.ts"]}
