{"code":"// Settings 编辑器要提供编辑界面\n//\nexport class LFX_Settings {\n    constructor() {\n        // 多重采样: 值(1, 2, 4, 8)\n        this.MSAA = 4;\n        // 高精度模式\n        this.Highp = false;\n        // 烘培贴图大小: 值(128, 256, 512, 1024, 2048)\n        this.Size = 1024;\n        // Gamma值\n        this.Gamma = 2.2;\n        // 天空辐照度(用于全局光照)\n        this.SkyRadiance = [0, 0, 0];\n        // 全局光照缩放\n        this.GIScale = 1.0;\n        // 全局光照采样数\n        this.GISamples = 25;\n        // 全局光照光线最大跟踪次数\n        this.GIPathLength = 2;\n        // Probe光照缩放\n        this.GIProbeScale = 1.0;\n        // Probe光照采样数\n        this.GIProbeSamples = 1024;\n        // Probe光线最大跟踪次数\n        this.GIProbePathLength = 2;\n        // AO等级(0：关闭，1：低，2：高)\n        this.AOLevel = 0;\n        // AO强度\n        this.AOStrength = 1.0;\n        // AO影响的范围\n        this.AORadius = 1.0;\n        // AO颜色\n        this.AOColor = [0.0, 0.0, 0.0];\n        // 线程数量\n        this.Threads = 1;\n        // 过滤开关\n        this.Filter = false;\n        // 烘培LightMap\n        this.BakeLightMap = true;\n        // 烘培LightProbe\n        this.BakeLightProbe = false;\n    }\n}\nexport class LFX_Vertex {\n    constructor() {\n        this.Position = [0, 0, 0];\n        this.Normal = [0, 0, 0];\n        this.UV = [0, 0];\n        this.LUV = [0, 0];\n    }\n}\nexport class LFX_Triangle {\n    constructor() {\n        this.Index = [0, 0, 0];\n        this.MaterialId = 0;\n    }\n}\nexport class LFX_Material {\n    constructor() {\n        this.AlphaCulloff = 0.5;\n        this.Metallic = 0;\n        this.Roughness = 0;\n        // Diffuse color\n        this.Diffuse = [1, 1, 1];\n        // Emissive color\n        this.Emissive = [0, 0, 0];\n        // 纹理，(所有'/'或者'\\\\'都必须转换成'$')\n        this.Texture = '';\n        // 纹理，(所有'/'或者'\\\\'都必须转换成'$')\n        //public MetallicMap = '';\n        // 纹理，(所有'/'或者'\\\\'都必须转换成'$')\n        //public RoughnessMap = '';\n        // 纹理，(所有'/'或者'\\\\'都必须转换成'$')\n        this.PBRMap = '';\n        // 纹理，(所有'/'或者'\\\\'都必须转换成'$')\n        this.EmissiveMap = '';\n    }\n}\n// 模型\nexport class LFX_Mesh {\n    constructor() {\n        this.CastShadow = false;\n        this.ReceiveShadow = false;\n        this.LightMapSize = 0;\n        this.VertexBuffer = new Array();\n        this.TriangleBuffer = new Array();\n        this.MaterialBuffer = new Array();\n    }\n}\n// 地形\nexport class LFX_Terrain {\n    constructor() {\n        this.Position = [0, 0, 0];\n        this.TileSize = 0;\n        this.BlockCount = [0, 0];\n        this.HeightField = new Uint16Array();\n        this.LightMapSize = 0;\n    }\n}\n// 灯光\nexport class LFX_Light {\n    constructor() {\n        // 类型\n        this.Type = LFX_Light.POINT;\n        // 位置\n        this.Position = [0, 0, 0];\n        // 方向\n        this.Direction = [0, 0, 0];\n        // 颜色\n        this.Color = [0, 0, 0];\n        // 强度\n        this.Illuminance = 1;\n        // 衰减开始距离\n        // public AttenStart = 0;\n        // 衰减结束距离\n        // public AttenEnd = 1;\n        this.Size = 0;\n        this.Range = 0;\n        // 衰减强度\n        this.AttenFallOff = 1;\n        // 聚光灯内角\n        this.SpotInner = 1;\n        // 聚光灯外角\n        this.SpotOuter = 0.7071;\n        // 聚光灯衰减强度\n        this.SpotFallOff = 1;\n        // 直接光照缩放\n        this.DirectScale = 1;\n        // 间接光照缩放\n        this.IndirectScale = 1;\n        // 是否开启全局光照\n        this.GIEnable = false;\n        // 是否投射阴影\n        this.CastShadow = false;\n        // 阴影饱和度\n        this.ShadowMask = 0.0;\n    }\n}\nLFX_Light.POINT = 0;\nLFX_Light.SPOT = 1;\nLFX_Light.DIRECTION = 2;\n// LightProbe\nexport class LFX_LightProbe {\n    constructor() {\n        // 位置\n        this.Position = [0, 0, 0];\n        // 法线\n        this.Normal = [0, 0, 0];\n    }\n}\n// tslint:disable-next-line: class-name\nexport class LFX_Buffer {\n    constructor() {\n        this.Length = 0;\n        this.Buffer = new Uint8Array(2048);\n        this._dview = new DataView(this.Buffer.buffer);\n        this._seekPos = 0;\n    }\n    Reserve(size) {\n        if (this.Buffer.byteLength > size) {\n            return;\n        }\n        let capacity = this.Buffer.byteLength;\n        while (capacity < size) {\n            capacity += capacity;\n        }\n        const temp = new Uint8Array(capacity);\n        for (let i = 0; i < this.Length; ++i) {\n            temp[i] = this.Buffer[i];\n        }\n        this.Buffer = temp;\n        this._dview = new DataView(this.Buffer.buffer);\n    }\n    Assign(buff) {\n        this.Buffer = buff;\n        this.Length = buff.length;\n        this._seekPos = buff.byteOffset;\n        this._dview = new DataView(buff.buffer);\n    }\n    WriteInt8(value) {\n        this.Reserve(this.Length + 1);\n        this._dview.setInt8(this.Length, value);\n        this.Length += 1;\n    }\n    WriteInt16(value) {\n        this.Reserve(this.Length + 2);\n        this._dview.setInt16(this.Length, value, true);\n        this.Length += 2;\n    }\n    WriteInt32(value) {\n        this.Reserve(this.Length + 4);\n        this._dview.setInt32(this.Length, value, true);\n        this.Length += 4;\n    }\n    WriteHeightField(value) {\n        this.Reserve(this.Length + 2 * value.length);\n        for (let i = 0; i < value.length; ++i) {\n            this._dview.setUint16(this.Length + i * 2, value[i], true);\n        }\n        this.Length += 2 * value.length;\n    }\n    WriteIntArray(value) {\n        this.Reserve(this.Length + 4 * value.length);\n        for (let i = 0; i < value.length; ++i) {\n            this._dview.setInt32(this.Length + i * 4, value[i], true);\n        }\n        this.Length += 4 * value.length;\n    }\n    WriteFloat(value) {\n        this.Reserve(this.Length + 4);\n        this._dview.setFloat32(this.Length, value, true);\n        this.Length += 4;\n    }\n    WriteFloatArray(value) {\n        this.Reserve(this.Length + 4 * value.length);\n        for (let i = 0; i < value.length; ++i) {\n            this._dview.setFloat32(this.Length + i * 4, value[i], true);\n        }\n        this.Length += 4 * value.length;\n    }\n    WriteString(value) {\n        this.Reserve(this.Length + value.length + 4);\n        this._dview.setInt32(this.Length, value.length, true);\n        for (let i = 0; i < value.length; ++i) {\n            this._dview.setInt8(this.Length + 4 + i, value.charCodeAt(i));\n        }\n        this.Length += value.length + 4;\n    }\n    ReadInt8() {\n        const value = this._dview.getInt8(this._seekPos);\n        this._seekPos += 1;\n        return value;\n    }\n    ReadInt16() {\n        const value = this._dview.getInt16(this._seekPos, true);\n        this._seekPos += 2;\n        return value;\n    }\n    ReadInt() {\n        const value = this._dview.getInt32(this._seekPos, true);\n        this._seekPos += 4;\n        return value;\n    }\n    ReadIntArray(value) {\n        for (let i = 0; i < value.length; ++i) {\n            value[i] = this._dview.getInt32(this._seekPos + i * 4, true);\n        }\n        this._seekPos += 4 * value.length;\n        return value;\n    }\n    ReadFloat() {\n        const value = this._dview.getFloat32(this._seekPos, true);\n        this._seekPos += 4;\n        return value;\n    }\n    ReadFloatArray(value) {\n        for (let i = 0; i < value.length; ++i) {\n            value[i] = this._dview.getFloat32(this._seekPos + i * 4, true);\n        }\n        this._seekPos += 4 * value.length;\n        return value;\n    }\n    ReadString() {\n        const length = this.ReadInt();\n        let value = '';\n        for (let i = 0; i < length; ++i) {\n            value += String.fromCharCode(this.ReadInt8());\n        }\n        return value;\n    }\n}\n// tslint:disable-next-line: class-name\nexport class LFX_World {\n    constructor() {\n        this.Name = '';\n        this.Settings = new LFX_Settings();\n        this.Textures = new Array();\n        this.Terrains = new Array();\n        this.Meshes = new Array();\n        this.Lights = new Array();\n        this.LightProbes = new Array();\n    }\n    AddUniqueTexture(tex) {\n        if (tex.length > 0) {\n            for (const i of this.Textures) {\n                if (i === tex) {\n                    return tex;\n                }\n            }\n            this.Textures.push(tex);\n        }\n        return tex;\n    }\n}\n// tslint:disable-next-line: class-name\nexport class LFX_TerrainLightMapInfo {\n    constructor() {\n        this.Id = 0;\n        this.BlockId = 0;\n        this.Index = 0;\n        this.Offset = [0, 0];\n        this.Scale = [0, 0];\n    }\n}\n// tslint:disable-next-line: class-name\nexport class LFX_MeshLightMapInfo {\n    constructor() {\n        this.Id = 0;\n        this.Index = 0;\n        this.Offset = [0, 0];\n        this.Scale = [0, 0];\n    }\n}\n// tslint:disable-next-line: class-name\nexport class LFX_LightProbeInfo {\n    constructor() {\n        this.Position = [0, 0, 0];\n        this.Normal = [0, 0, 0];\n        this.Coefficients = [0];\n    }\n}\n// tslint:disable-next-line: class-name\nexport class LFX_File {\n    constructor() {\n        this.Verison = 0;\n        this.MeshInfos = new Array();\n        this.TerrainInfos = new Array();\n        this.LightProbeInfos = new Array();\n    }\n}\n","references":[]}
