{"code":"'use strict';\nimport fs from 'fs';\nimport ps from 'path';\nconst io = require('socket.io');\nimport { LFX_Buffer, LFX_File, LFX_LightProbeInfo, LFX_MeshLightMapInfo, LFX_TerrainLightMapInfo, LFX_World } from './LFX_Types';\nimport EventEmitter from 'events';\n//const LFX_FILE_VERSION = 0x2000;\n//const LFX_FILE_VERSION = 0x2002; // 3.7.2 2\n//const LFX_FILE_VERSION = 0x2003; // 3.7.2 3\nconst LFX_FILE_VERSION = 0x3730; // 3.7.3 0\nconst LFX_FILE_TERRAIN = 0x01;\nconst LFX_FILE_MESH = 0x02;\nconst LFX_FILE_LIGHT = 0x03;\nconst LFX_FILE_LIGHT_PROBE = 0x04;\nconst LFX_FILE_EOF = 0x00;\n// tslint:disable-next-line: class-name\nexport class LFX_Baker extends EventEmitter {\n    constructor() {\n        super();\n        this.World = new LFX_World();\n        this.Started = false;\n        this.Finished = false;\n        this.Error = false;\n        //\n        this._server = null;\n        this._client = null;\n        this._path = null;\n        this._lfxpath = null;\n    }\n    get lfxpath() {\n        return this._lfxpath || ps.resolve('tools/lightmap-tools');\n    }\n    set lfxpath(path) {\n        this._lfxpath = path;\n    }\n    get closed() {\n        return this._server == null;\n    }\n    get connected() {\n        return this._client != null;\n    }\n    get client() {\n        return this._client;\n    }\n    // 启动socket.io, 0为随机分配端口\n    Launch(port = 0) {\n        this.Started = false;\n        this.Finished = false;\n        this.Error = false;\n        this._server = io.listen(port);\n        this._server.on('connection', (socket) => {\n            socket.on('Login', (data) => {\n                this._client = socket;\n                this.emit('login', this._client);\n            });\n            socket.on('Log', (data) => {\n                this.emit('log', data);\n            });\n            socket.on('Progress', (data) => {\n                this.emit('progress', data);\n            });\n            socket.on('Finished', (data) => {\n                this.Finished = true;\n                this.emit('fineshed', data);\n            });\n        });\n        return port;\n    }\n    // 关闭\n    Close() {\n        if (this._server != null) {\n            this._server.close();\n        }\n        this._server = null;\n        this._client = null;\n    }\n    // 上传\n    Upload(asset_path) {\n        this._path = asset_path;\n        const buff = new LFX_Buffer();\n        let triangleCount = 0;\n        // console.log(asset_path, '================');\n        // if(fs.existsSync(asset_path)) {\n        //     Utils.removeDir(asset_path);\n        // }\n        // fs.mkdirSync(asset_path);\n        const immediatePath = asset_path + '/tmp';\n        if (!fs.existsSync(immediatePath)) {\n            fs.mkdirSync(immediatePath);\n        }\n        // const outputPath = asset_path + '/output';\n        // if (!fs.existsSync(outputPath)) {\n        //     // 删除输出文件\n        //     const files = fs.readdirSync(outputPath);\n        //     files.forEach((file, index) => {\n        //         const curPath = outputPath + '/' + file;\n        //         if (!fs.statSync(curPath).isDirectory()) {\n        //             fs.unlinkSync(curPath);\n        //         }\n        //     });\n        // }\n        // Head\n        buff.WriteInt32(LFX_FILE_VERSION);\n        buff.WriteString(this.World.Name);\n        // Setting\n        const ambient = [0.0, 0.0, 0.0];\n        buff.WriteFloatArray(ambient);\n        buff.WriteFloatArray(this.World.Settings.SkyRadiance);\n        buff.WriteInt32(this.World.Settings.MSAA);\n        buff.WriteInt32(this.World.Settings.Size);\n        buff.WriteFloat(this.World.Settings.Gamma);\n        buff.WriteInt8(this.World.Settings.Highp ? 1 : 0);\n        buff.WriteFloat(this.World.Settings.GIScale);\n        buff.WriteInt32(this.World.Settings.GISamples);\n        buff.WriteInt32(this.World.Settings.GIPathLength);\n        buff.WriteFloat(this.World.Settings.GIProbeScale);\n        buff.WriteInt32(this.World.Settings.GIProbeSamples);\n        buff.WriteInt32(this.World.Settings.GIProbePathLength);\n        buff.WriteInt32(this.World.Settings.AOLevel);\n        buff.WriteFloat(this.World.Settings.AOStrength);\n        buff.WriteFloat(this.World.Settings.AORadius);\n        buff.WriteFloat(this.World.Settings.AOColor[0] / 255.0);\n        buff.WriteFloat(this.World.Settings.AOColor[1] / 255.0);\n        buff.WriteFloat(this.World.Settings.AOColor[2] / 255.0);\n        buff.WriteInt32(this.World.Settings.Threads);\n        buff.WriteInt8(this.World.Settings.Filter ? 1 : 0);\n        buff.WriteInt8(this.World.Settings.BakeLightMap ? 1 : 0);\n        buff.WriteInt8(this.World.Settings.BakeLightProbe ? 1 : 0);\n        // Terrains\n        for (const terrain of this.World.Terrains) {\n            buff.WriteInt32(LFX_FILE_TERRAIN);\n            buff.WriteFloatArray(terrain.Position);\n            buff.WriteFloat(terrain.TileSize);\n            buff.WriteIntArray(terrain.BlockCount);\n            buff.WriteInt32(terrain.LightMapSize);\n            buff.WriteHeightField(terrain.HeightField);\n        }\n        // Meshes\n        for (const mesh of this.World.Meshes) {\n            buff.WriteInt32(LFX_FILE_MESH);\n            buff.WriteInt8(mesh.CastShadow ? 1 : 0);\n            buff.WriteInt8(mesh.ReceiveShadow ? 1 : 0);\n            buff.WriteInt32(mesh.LightMapSize);\n            buff.WriteInt32(mesh.VertexBuffer.length);\n            buff.WriteInt32(mesh.TriangleBuffer.length);\n            buff.WriteInt32(mesh.MaterialBuffer.length);\n            triangleCount += mesh.TriangleBuffer.length;\n            for (const vtx of mesh.VertexBuffer) {\n                buff.WriteFloatArray(vtx.Position);\n                buff.WriteFloatArray(vtx.Normal);\n                buff.WriteFloatArray(vtx.UV);\n                buff.WriteFloatArray(vtx.LUV);\n            }\n            for (const tri of mesh.TriangleBuffer) {\n                buff.WriteIntArray(tri.Index);\n                buff.WriteInt32(tri.MaterialId);\n            }\n            for (const mtl of mesh.MaterialBuffer) {\n                buff.WriteFloat(mtl.AlphaCulloff);\n                buff.WriteFloat(mtl.Metallic);\n                buff.WriteFloat(mtl.Roughness);\n                buff.WriteFloatArray(mtl.Diffuse);\n                buff.WriteFloatArray(mtl.Emissive);\n                buff.WriteString(mtl.Texture);\n                buff.WriteString(mtl.PBRMap);\n                buff.WriteString(mtl.EmissiveMap);\n            }\n        }\n        // Lights\n        for (const light of this.World.Lights) {\n            buff.WriteInt32(LFX_FILE_LIGHT);\n            buff.WriteInt32(light.Type);\n            buff.WriteFloatArray(light.Position);\n            buff.WriteFloatArray(light.Direction);\n            buff.WriteFloatArray(light.Color);\n            buff.WriteFloat(light.Size);\n            buff.WriteFloat(light.Range);\n            buff.WriteFloat(light.AttenFallOff);\n            buff.WriteFloat(light.SpotInner);\n            buff.WriteFloat(light.SpotOuter);\n            buff.WriteFloat(light.SpotFallOff);\n            buff.WriteFloat(light.DirectScale);\n            buff.WriteFloat(light.IndirectScale);\n            buff.WriteInt8(light.GIEnable ? 1 : 0);\n            buff.WriteInt8(light.CastShadow ? 1 : 0);\n            buff.WriteFloat(light.ShadowMask);\n        }\n        // LightProbes\n        for (const probe of this.World.LightProbes) {\n            buff.WriteInt32(LFX_FILE_LIGHT_PROBE);\n            buff.WriteFloatArray(probe.Position);\n            buff.WriteFloatArray(probe.Normal);\n        }\n        // EOF\n        buff.WriteInt32(LFX_FILE_EOF);\n        // Save\n        fs.writeFileSync(immediatePath + '/lfx.in', buff.Buffer);\n        // Copy Textures\n        for (const tex of this.World.Textures) {\n            const data = fs.readFileSync(asset_path + '/' + tex);\n            const target = tex.replace('/', '$');\n            fs.writeFileSync(immediatePath + '/' + target, data);\n        }\n        // 参与烘焙物体的三角形总面数 埋点\n        Editor.Metrics.trackEvent({\n            sendToNewCocosAnalyticsOnly: true,\n            category: 'bakingSystem',\n            value: {\n                A100001: triangleCount,\n            },\n        });\n    }\n    //\n    Download() {\n        const file = new LFX_File();\n        const filename = this._path + '/output/lfx.out';\n        const buff = fs.readFileSync(filename);\n        if (buff != null) {\n            const stream = new LFX_Buffer();\n            stream.Assign(buff);\n            file.Verison = stream.ReadInt();\n            //console.log('Read lfx out fle, version ' +  file.Verison);\n            do {\n                const cid = stream.ReadInt();\n                if (cid === LFX_FILE_EOF) {\n                    break;\n                }\n                if (cid === LFX_FILE_TERRAIN) {\n                    const id = stream.ReadInt();\n                    const count = stream.ReadInt();\n                    //console.log('Read ' + count + ' terrain lightmap infos');\n                    for (let i = 0; i < count; ++i) {\n                        const info = new LFX_TerrainLightMapInfo();\n                        info.Id = id;\n                        info.BlockId = stream.ReadInt();\n                        info.Index = stream.ReadInt();\n                        info.Offset[0] = stream.ReadFloat();\n                        info.Offset[1] = stream.ReadFloat();\n                        info.Scale[0] = stream.ReadFloat();\n                        info.Scale[1] = stream.ReadFloat();\n                        file.TerrainInfos.push(info);\n                    }\n                }\n                else if (cid === LFX_FILE_MESH) {\n                    const count = stream.ReadInt();\n                    //console.log('Read ' + count + ' mesh lightmap infos');\n                    for (let i = 0; i < count; ++i) {\n                        const info = new LFX_MeshLightMapInfo();\n                        info.Id = stream.ReadInt();\n                        info.Index = stream.ReadInt();\n                        info.Offset[0] = stream.ReadFloat();\n                        info.Offset[1] = stream.ReadFloat();\n                        info.Scale[0] = stream.ReadFloat();\n                        info.Scale[1] = stream.ReadFloat();\n                        file.MeshInfos.push(info);\n                    }\n                }\n                else if (cid === LFX_FILE_LIGHT_PROBE) {\n                    const count = stream.ReadInt();\n                    //console.log('Read ' + count + ' light probe infos');\n                    for (let i = 0; i < count; ++i) {\n                        const info = new LFX_LightProbeInfo();\n                        stream.ReadFloatArray(info.Position);\n                        stream.ReadFloatArray(info.Normal);\n                        info.Coefficients.length = stream.ReadInt();\n                        stream.ReadFloatArray(info.Coefficients);\n                        file.LightProbeInfos.push(info);\n                    }\n                }\n                else {\n                    // error\n                    console.log('LightFX unknown chunk ' + cid);\n                }\n            } while (1); // eslint-disable-line\n        }\n        return file;\n    }\n    // 开始烘培\n    Start() {\n        this._client && this._client.emit('Start');\n        this.Started = true;\n    }\n    // 停止烘培\n    Stop() {\n        this._client && this._client.emit('Stop');\n    }\n}\n","references":["/Users/mac/Documents/editor_3d/v3.8.8/app/node_modules/path/path.js","/Users/mac/Documents/editor_3d/v3.8.8/app/node_modules/socket.io/lib/index.js","/Users/mac/Documents/editor_3d/v3.8.8/app/modules/editor-extensions/extensions/lightmap/source/lightmap/backer/LFX_Types.ts","/Users/mac/Documents/editor_3d/v3.8.8/app/node_modules/@types/events/index.d.ts"]}
