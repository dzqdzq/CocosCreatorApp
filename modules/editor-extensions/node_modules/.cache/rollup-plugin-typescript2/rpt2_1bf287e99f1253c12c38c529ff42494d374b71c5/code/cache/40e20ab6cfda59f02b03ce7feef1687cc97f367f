{"code":"'use strict';\nconst fs = require('fs'), os = require('os'), net = require('net'), path = require('path'), _async = require('async'), debug = require('debug'), mkdirp = require('mkdirp').mkdirp;\nconst debugTestPort = debug('portfinder:testPort'), debugGetPort = debug('portfinder:getPort'), debugDefaultHosts = debug('portfinder:defaultHosts');\nconst internals = {};\ninternals.testPort = function (options, callback) {\n    if (!callback) {\n        callback = options;\n        options = {};\n    }\n    options.server =\n        options.server ||\n            net.createServer(function () {\n                //\n                // Create an empty listener for the port testing server.\n                //\n            });\n    debugTestPort('entered testPort(): trying', options.host, 'port', options.port);\n    function onListen() {\n        debugTestPort('done w/ testPort(): OK', options.host, 'port', options.port);\n        options.server.removeListener('error', onError);\n        options.server.close();\n        callback(null, options.port);\n    }\n    function onError(err) {\n        debugTestPort('done w/ testPort(): failed', options.host, 'w/ port', options.port, 'with error', err.code);\n        options.server.removeListener('listening', onListen);\n        if (!(err.code == 'EADDRINUSE' || err.code == 'EACCES')) {\n            return callback(err);\n        }\n        const port = nextPort(options.port);\n        if (port > highestPort) {\n            return callback(new Error('No open ports available'));\n        }\n        internals.testPort({\n            port,\n            host: options.host,\n            server: options.server,\n        }, callback);\n    }\n    options.server.once('error', onError);\n    options.server.once('listening', onListen);\n    if (options.host) {\n        options.server.listen(options.port, options.host);\n    }\n    else {\n        /*\n      Judgement of service without host\n      example:\n        express().listen(options.port)\n    */\n        options.server.listen(options.port);\n    }\n};\n//\n// ### @basePort {Number}\n// The lowest port to begin any port search from\n//\nexport const basePort = 8000;\n//\n// ### @highestPort {Number}\n// Largest port number is an unsigned short 2**16 -1=65335\n//\nexport const highestPort = 65535;\n//\n// ### @basePath {string}\n// Default path to begin any socket search from\n//\nexport const basePath = '/tmp/portfinder';\n//\n// ### function getPort (options, callback)\n// #### @options {Object} Settings to use when finding the necessary port\n// #### @callback {function} Continuation to respond to when complete.\n// Responds with a unbound port on the current machine.\n//\nexport function getPort(options, callback) {\n    if (!callback) {\n        callback = options;\n        options = {};\n    }\n    options.port = Number(options.port) || Number(basePort);\n    options.host = options.host || null;\n    options.stopPort = Number(options.stopPort) || Number(highestPort);\n    if (!options.startPort) {\n        options.startPort = Number(options.port);\n        if (options.startPort < 0) {\n            throw Error('Provided options.startPort(' + options.startPort + ') is less than 0, which are cannot be bound.');\n        }\n        if (options.stopPort < options.startPort) {\n            throw Error('Provided options.stopPort(' + options.stopPort + 'is less than options.startPort (' + options.startPort + ')');\n        }\n    }\n    if (options.host) {\n        let hasUserGivenHost;\n        for (let i = 0; i < _defaultHosts.length; i++) {\n            if (_defaultHosts[i] === options.host) {\n                hasUserGivenHost = true;\n                break;\n            }\n        }\n        if (!hasUserGivenHost) {\n            _defaultHosts.push(options.host);\n        }\n    }\n    const openPorts = [];\n    let currentHost;\n    return _async.eachSeries(_defaultHosts, function (host, next) {\n        debugGetPort('in eachSeries() iteration callback: host is', host);\n        return internals.testPort({ host: host, port: options.port }, function (err, port) {\n            if (err) {\n                debugGetPort('in eachSeries() iteration callback testPort() callback', 'with an err:', err.code);\n                currentHost = host;\n                return next(err);\n            }\n            else {\n                debugGetPort('in eachSeries() iteration callback testPort() callback', 'with a success for port', port);\n                openPorts.push(port);\n                return next();\n            }\n        });\n    }, function (err) {\n        if (err) {\n            debugGetPort('in eachSeries() result callback: err is', err);\n            // If we get EADDRNOTAVAIL it means the host is not bindable, so remove it\n            // from exports._defaultHosts and start over. For ubuntu, we use EINVAL for the same\n            if (err.code === 'EADDRNOTAVAIL' || err.code === 'EINVAL') {\n                if (options.host === currentHost) {\n                    // if bad address matches host given by user, tell them\n                    // NOTE: We may need to one day handle `my-non-existent-host.local` if users\n                    // report frustration with passing in hostnames that DONT map to bindable\n                    // hosts, without showing them a good error.\n                    const msg = 'Provided host ' + options.host + ' could NOT be bound. Please provide a different host address or hostname';\n                    return callback(Error(msg));\n                }\n                else {\n                    const idx = _defaultHosts.indexOf(currentHost);\n                    _defaultHosts.splice(idx, 1);\n                    return getPort(options, callback);\n                }\n            }\n            else {\n                // error is not accounted for, file ticket, handle special case\n                return callback(err);\n            }\n        }\n        // sort so we can compare first host to last host\n        openPorts.sort(function (a, b) {\n            return a - b;\n        });\n        debugGetPort('in eachSeries() result callback: openPorts is', openPorts);\n        if (openPorts[0] === openPorts[openPorts.length - 1]) {\n            // if first === last, we found an open port\n            if (openPorts[0] <= options.stopPort) {\n                return callback(null, openPorts[0]);\n            }\n            else {\n                const msg = 'No open ports found in between ' + options.startPort + ' and ' + options.stopPort;\n                return callback(Error(msg));\n            }\n        }\n        else {\n            // otherwise, try again, using sorted port, aka, highest open for >= 1 host\n            return getPort({ port: openPorts.pop(), host: options.host, startPort: options.startPort, stopPort: options.stopPort }, callback);\n        }\n    });\n}\n//\n// ### function getPortPromise (options)\n// #### @options {Object} Settings to use when finding the necessary port\n// Responds a promise to an unbound port on the current machine.\n//\nexport function getPortPromise(options) {\n    if (typeof Promise !== 'function') {\n        throw Error('Native promise support is not available in this version of node.' +\n            'Please install a polyfill and assign Promise to global.Promise before calling this method');\n    }\n    if (!options) {\n        options = {};\n    }\n    return new Promise(function (resolve, reject) {\n        getPort(options, function (err, port) {\n            if (err) {\n                return reject(err);\n            }\n            resolve(port);\n        });\n    });\n}\n//\n// ### function getPorts (count, options, callback)\n// #### @count {Number} The number of ports to find\n// #### @options {Object} Settings to use when finding the necessary port\n// #### @callback {function} Continuation to respond to when complete.\n// Responds with an array of unbound ports on the current machine.\n//\nexport function getPorts(count, options, callback) {\n    if (!callback) {\n        callback = options;\n        options = {};\n    }\n    let lastPort = null;\n    _async.timesSeries(count, function (index, asyncCallback) {\n        if (lastPort) {\n            options.port = nextPort(lastPort);\n        }\n        getPort(options, function (err, port) {\n            if (err) {\n                asyncCallback(err);\n            }\n            else {\n                lastPort = port;\n                asyncCallback(null, port);\n            }\n        });\n    }, callback);\n}\n//\n// ### function getSocket (options, callback)\n// #### @options {Object} Settings to use when finding the necessary port\n// #### @callback {function} Continuation to respond to when complete.\n// Responds with a unbound socket using the specified directory and base\n// name on the current machine.\n//\nexport function getSocket(options, callback) {\n    if (!callback) {\n        callback = options;\n        options = {};\n    }\n    options.mod = options.mod || parseInt('755', 8);\n    options.path = options.path || basePath + '.sock';\n    //\n    // Tests the specified socket\n    //\n    function testSocket() {\n        fs.stat(options.path, function (err) {\n            //\n            // If file we're checking doesn't exist (thus, stating it emits ENOENT),\n            // we should be OK with listening on this socket.\n            //\n            if (err) {\n                if (err.code == 'ENOENT') {\n                    callback(null, options.path);\n                }\n                else {\n                    callback(err);\n                }\n            }\n            else {\n                //\n                // This file exists, so it isn't possible to listen on it. Lets try\n                // next socket.\n                //\n                options.path = nextSocket(options.path);\n                getSocket(options, callback);\n            }\n        });\n    }\n    //\n    // Create the target `dir` then test connection\n    // against the socket.\n    //\n    function createAndTestSocket(dir) {\n        mkdirp(dir, options.mod, function (err) {\n            if (err) {\n                return callback(err);\n            }\n            options.exists = true;\n            testSocket();\n        });\n    }\n    //\n    // Check if the parent directory of the target\n    // socket path exists. If it does, test connection\n    // against the socket. Otherwise, create the directory\n    // then test connection.\n    //\n    function checkAndTestSocket() {\n        const dir = path.dirname(options.path);\n        fs.stat(dir, function (err, stats) {\n            if (err || !stats.isDirectory()) {\n                return createAndTestSocket(dir);\n            }\n            options.exists = true;\n            testSocket();\n        });\n    }\n    //\n    // If it has been explicitly stated that the\n    // target `options.path` already exists, then\n    // simply test the socket.\n    //\n    return options.exists ? testSocket() : checkAndTestSocket();\n}\n//\n// ### function nextPort (port)\n// #### @port {Number} Port to increment from.\n// Gets the next port in sequence from the\n// specified `port`.\n//\nexport function nextPort(port) {\n    return port + 1;\n}\n//\n// ### function nextSocket (socketPath)\n// #### @socketPath {string} Path to increment from\n// Gets the next socket path in sequence from the\n// specified `socketPath`.\n//\nexport function nextSocket(socketPath) {\n    const dir = path.dirname(socketPath);\n    const name = path.basename(socketPath, '.sock');\n    const match = name.match(/^([a-zA-z]+)(\\d*)$/i);\n    let index = parseInt(match[2]);\n    const base = match[1];\n    if (isNaN(index)) {\n        index = 0;\n    }\n    index += 1;\n    return path.join(dir, base + index + '.sock');\n}\n/**\n * @desc List of internal hostnames provided by your machine. A user\n *       provided hostname may also be provided when calling portfinder.getPort,\n *       which would then be added to the default hosts we lookup and return here.\n *\n * @return {array}\n *\n * Long Form Explantion:\n *\n *    - Input: (os.networkInterfaces() w/ MacOS 10.11.5+ and running a VM)\n *\n *        { lo0:\n *         [ { address: '::1',\n *             netmask: 'ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff',\n *             family: 'IPv6',\n *             mac: '00:00:00:00:00:00',\n *             scopeid: 0,\n *             internal: true },\n *           { address: '127.0.0.1',\n *             netmask: '255.0.0.0',\n *             family: 'IPv4',\n *             mac: '00:00:00:00:00:00',\n *             internal: true },\n *           { address: 'fe80::1',\n *             netmask: 'ffff:ffff:ffff:ffff::',\n *             family: 'IPv6',\n *             mac: '00:00:00:00:00:00',\n *             scopeid: 1,\n *             internal: true } ],\n *        en0:\n *         [ { address: 'fe80::a299:9bff:fe17:766d',\n *             netmask: 'ffff:ffff:ffff:ffff::',\n *             family: 'IPv6',\n *             mac: 'a0:99:9b:17:76:6d',\n *             scopeid: 4,\n *             internal: false },\n *           { address: '10.0.1.22',\n *             netmask: '255.255.255.0',\n *             family: 'IPv4',\n *             mac: 'a0:99:9b:17:76:6d',\n *             internal: false } ],\n *        awdl0:\n *         [ { address: 'fe80::48a8:37ff:fe34:aaef',\n *             netmask: 'ffff:ffff:ffff:ffff::',\n *             family: 'IPv6',\n *             mac: '4a:a8:37:34:aa:ef',\n *             scopeid: 8,\n *             internal: false } ],\n *        vnic0:\n *         [ { address: '10.211.55.2',\n *             netmask: '255.255.255.0',\n *             family: 'IPv4',\n *             mac: '00:1c:42:00:00:08',\n *             internal: false } ],\n *        vnic1:\n *         [ { address: '10.37.129.2',\n *             netmask: '255.255.255.0',\n *             family: 'IPv4',\n *             mac: '00:1c:42:00:00:09',\n *             internal: false } ] }\n *\n *    - Output:\n *\n *         [\n *          '0.0.0.0',\n *          '::1',\n *          '127.0.0.1',\n *          'fe80::1',\n *          '10.0.1.22',\n *          'fe80::48a8:37ff:fe34:aaef',\n *          '10.211.55.2',\n *          '10.37.129.2'\n *         ]\n *\n *     Note we export this so we can use it in our tests, otherwise this API is private\n */\nexport const _defaultHosts = (function () {\n    let interfaces = {};\n    try {\n        interfaces = os.networkInterfaces();\n    }\n    catch (e) {\n        // As of October 2016, Windows Subsystem for Linux (WSL) does not support\n        // the os.networkInterfaces() call and throws instead. For this platform,\n        // assume 0.0.0.0 as the only address\n        //\n        // - https://github.com/Microsoft/BashOnWindows/issues/468\n        //\n        // - Workaround is a mix of good work from the community:\n        //   - https://github.com/http-party/node-portfinder/commit/8d7e30a648ff5034186551fa8a6652669dec2f2f\n        //   - https://github.com/yarnpkg/yarn/pull/772/files\n        // @ts-ignore\n        if (e && e.syscall === 'uv_interface_addresses') {\n            // swallow error because we're just going to use defaults\n            // documented @ https://github.com/nodejs/node/blob/4b65a65e75f48ff447cabd5500ce115fb5ad4c57/doc/api/net.md#L231\n        }\n        else {\n            throw e;\n        }\n    }\n    const interfaceNames = Object.keys(interfaces), hiddenButImportantHost = '0.0.0.0', // !important - dont remove, hence the naming :)\n    results = [hiddenButImportantHost];\n    for (let i = 0; i < interfaceNames.length; i++) {\n        const _interface = interfaces[interfaceNames[i]];\n        for (let j = 0; j < _interface.length; j++) {\n            const curr = _interface[j];\n            results.push(curr.address);\n        }\n    }\n    // add null value, For createServer function, do not use host.\n    results.push(null);\n    debugDefaultHosts('exports._defaultHosts is: %o', results);\n    return results;\n})();\n","references":["/Users/mac/Documents/editor_3d/v3.8.8/app/node_modules/path/path.js","/Users/mac/Documents/editor_3d/v3.8.8/app/node_modules/async/dist/async.js","/Users/mac/Documents/editor_3d/v3.8.8/app/node_modules/debug/src/index.js","/Users/mac/Documents/editor_3d/v3.8.8/app/node_modules/mkdirp/index.js"]}
