"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.unload=exports.load=exports.methods=exports.contributions=void 0;const requestProgress=require("request-progress"),request=require("request"),electron_1=require("electron"),fs_extra_1=require("fs-extra"),path_1=require("path"),semver_1=require("semver"),utils_1=require("../public/utils"),import_1=require("../public/import"),contribution_1=require("./contribution"),downloader_1=require("./downloader"),vscode_workflow_1=require("./vscode-workflow"),force_update_1=require("./force-update"),config_1=require("../shared/config");async function enable(e,t,o){if(o=o||{},!0===t){const t=await Editor.Package.enable(e);if(o.showInExtensionManager&&exports.methods.showInManager(e),o.addNotification){await Editor.Task.addNotice({type:"log",message:e,title:Editor.I18n.t("extension.extension.enable")})}return t}if(!1===t){const t=await Editor.Package.disable(e,o);if(o.showInExtensionManager&&exports.methods.showInManager(e),o.addNotification){await Editor.Task.addNotice({type:"log",message:e,title:Editor.I18n.t("extension.extension.disable")})}return t}}async function load(){await downloader_1.init();const e=()=>{force_update_1.forceUpdate({selfUpdate:exports.methods.selfUpdate}).catch(e=>{console.error(e)})};Editor.Startup.ready.package?e():Editor.Startup.once("package-ready",e)}function unload(){}exports.contributions={enable(e,t){contribution_1.register(e.name,e.path,t)},disable(e,t){contribution_1.unregister(e.name)}},exports.methods={importPackage:import_1.importPackage,async showInManager(e){await Editor.Panel.has("extension.manager")?(await Editor.Message.request("extension","refresh-package",e),Editor.Message.send("extension","select-package",e)):Editor.Panel.open("extension.manager",e)},openManager(){Editor.Panel.open("extension.manager")},async openStore(){if(semver_1.satisfies(semver_1.valid(semver_1.coerce(process.env.COCOS_DASHBOARD_VERSION))||"",">= 1.1.0"))Editor.Message.send("program","open-url","cocos-dashboard://plugin/store/index");else{const e=-1;(await Editor.Dialog.error(Editor.I18n.t("extension.store.dashboard_not_found"),{buttons:[Editor.I18n.t("extension.store.download_dashboard")],cancel:e})).response!==e&&Editor.Message.send("program","open-url","https://www.cocos.com/creator")}},openCreate(){Editor.Panel.open("extension.create")},async addChromeDebugSetting(){vscode_workflow_1.addChromeDebugSetting()},async addCompileTask(){vscode_workflow_1.addCompileTask()},enable:enable,async remove(e){try{await Editor.Package.unregister(e),"develop"!==utils_1.getPackageType(e)&&await electron_1.shell.trashItem(e)}catch(t){Editor.Dialog.error(t+"",{title:Editor.I18n.t("extension.dialog.remove_failed")});try{await Editor.Package.register(e)}catch(e){console.error(e)}return console.error(t),!1}return!0},async reload(e){const t=Editor.Package.getPackages({path:e});if(!t||!t[0])return;const o=t[0].enable;await enable(e,!1,{replacement:!1}),await Editor.Package.unregister(e),await Editor.Package.register(e),o&&await enable(e,!0)},async scanning(e){const t=config_1.getPathConfig();let o="";if("project"===e?o=t.project:"global"===e&&(o=t.global),""===o)return;await fs_extra_1.ensureDir(o);const a=(await fs_extra_1.readdir(o)).map(e=>path_1.join(o,e)),r=(await Editor.Package.getPackages()).filter(e=>Editor.Utils.Path.contains(o,e.path));for(const e of r)fs_extra_1.existsSync(e.path)||(e.enable&&await enable(e.path,!1),await Editor.Package.unregister(e.path));for(const e of a){(await fs_extra_1.stat(e)).isDirectory()&&await Editor.Package.register(e)}return!0},async downloadItem(e){const t=contribution_1.getInfoFromTypeID(e.type_id);if(downloader_1.getDownloadInfo(e.version_id,e.production_id))return Editor.Dialog.warn(Editor.I18n.t("extension.store.download_exists_error")),null;if(!e.version_id||!e.production_id)return Editor.Dialog.warn("empty version id or prodduction id"),null;const o=downloader_1.generateDownloadItem(e);o.downloadProgress=0,downloader_1.pushDownloadList(o),downloader_1.onItemUpdate(o);try{for(let e=0;e<t.length;e++){const a=t[e];if(!a.module)continue;const r=require(a.module);if(a.check){if(!1===await r.methods[a.check](o))continue}if(r.methods[a.download])await r.methods[a.download](o,()=>{downloader_1.onItemUpdate(o)}).catch(e=>{throw e});else{const e=require(contribution_1.defaultDownloadTypeInfoMap.module);await e.methods[contribution_1.defaultDownloadTypeInfoMap.download](o,()=>{downloader_1.onItemUpdate(o)}).catch(e=>{throw e})}return o.downloadProgress=1,downloader_1.onItemUpdate(o),Editor.Task.addNotice({title:Editor.I18n.t("extension.store.download_successful"),type:"success",source:"extension",timeout:5e3}),o}}catch(e){return"cancel"===e.message?Editor.Task.addNotice({title:Editor.I18n.t("extension.store.download_cancel"),message:e.message||e,type:"log",source:"extension",timeout:5e3}):Editor.Task.addNotice({title:Editor.I18n.t("extension.store.download_failed"),message:e.message||e,type:"error",source:"extension",timeout:5e3}),null}return Editor.Task.addNotice({title:Editor.I18n.t("extension.store.download_failed"),type:"error",source:"extension",timeout:5e3}),null},async installItem(e,t){const o=downloader_1.getDownloadInfo(e,t);if(!o)return null;const a=contribution_1.getInfoFromTypeID(o.type);o.installProgress=0,downloader_1.onItemUpdate(o);try{for(let e=0;e<a.length;e++){const t=a[e];if(!t.module)continue;const r=require(t.module);if(!t.check||!1!==await r.methods[t.check](o)){if(r.methods[t.install])await r.methods[t.install](o,()=>{downloader_1.onItemUpdate(o)}).catch(e=>{throw e});else{const e=require(contribution_1.defaultDownloadTypeInfoMap.module);await e.methods[contribution_1.defaultDownloadTypeInfoMap.install](o,()=>{downloader_1.onItemUpdate(o)}).catch(e=>{throw e})}return o.installProgress=1,downloader_1.onItemUpdate(o),Editor.Task.addNotice({title:Editor.I18n.t("extension.store.install_successful"),type:"success",source:"extension",timeout:8e3}),Editor.Dialog.info(Editor.I18n.t("extension.store.install_successful"),{buttons:[Editor.I18n.t("extension.store.confirm")]}),o}}}catch(e){return"cancel"===e.message?utils_1.handleCancelImport():"manual install"===e.message?utils_1.handleManualInstall():utils_1.handleUnexpectedImportError(e),null}return utils_1.handleUnexpectedImportError(),null},removeItem:async(e,t)=>await downloader_1.removeDownloadItem(e,t),removeAllItem:async()=>await downloader_1.removeDownloadList(),queryDownloaderList:async()=>downloader_1.downloadList,async updateExtension(e,t,o="local"){e=encodeURI(e);const a=path_1.join(Editor.Project.tmpDir,"extension/download",t+".zip");await fs_extra_1.ensureDir(path_1.dirname(a)),await new Promise((t,o)=>{requestProgress(request(e),{delay:300}).on("progreass",function(e){}).on("error",function(e){o(e)}).on("end",function(e,o){t(null)}).pipe(fs_extra_1.createWriteStream(a))});let r="",n="";"local"===o?(n="project",r=path_1.join(Editor.Project.path,"extensions",t)):(n="global",r=path_1.join(Editor.App.home,"extensions",t));const i=path_1.basename(r,".zip");try{await import_1.importPackage(n,a,{forceImport:!0}),await enable(r,!0)}catch(e){switch(e.message){case import_1.ImportPackageErrorMessage.cancel:utils_1.handleCancelImport();break;case import_1.ImportPackageErrorMessage.decompressFail:utils_1.handleDecompressFail(r,i,!0);break;case import_1.ImportPackageErrorMessage.invalidPath:utils_1.handleInvalidPath(r);break;default:utils_1.handleUnexpectedImportError(e)}}await fs_extra_1.remove(a)},getExtensionInfoMap:()=>contribution_1.getExtensionInfoMap(),trashItem:e=>electron_1.shell.trashItem(e),async selfUpdate(e){const{builtInPath:t,currentPath:o,newInstallPath:a}=e,{sdk:r,extensionPaths:n}=await force_update_1.setupContext();if(await enable(o,!1),o!==t&&await Editor.Package.unregister(o),a!==t&&await Editor.Package.register(a),""!==t&&a===t)try{await r.uninstall(utils_1.INTERNAL_EXTENSION_NAME,n.global)}catch(e){console.error(e)}await(async()=>{await enable(a,!0),!1!==e.reopenPanel&&setTimeout(()=>{Editor.Panel.open("extension.manager")},500)})()}},exports.load=load,exports.unload=unload;