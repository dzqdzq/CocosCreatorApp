"use strict";var __importDefault=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(exports,"__esModule",{value:!0}),exports.GltfMeshImporter=void 0;const asset_db_1=require("@editor/asset-db"),reader_manager_1=require("./reader-manager"),utils_1=require("../../utils"),meshSimplify_1=require("./meshSimplify"),cc_1=require("cc"),fs_extra_1=__importDefault(require("fs-extra")),uv_unwrap_1=require("../utils/uv-unwrap"),fs_extra_2=require("fs-extra");class GltfMeshImporter extends asset_db_1.Importer{get version(){return"1.1.1"}get name(){return"gltf-mesh"}get assetType(){return"cc.Mesh"}get instantiation(){return".mesh"}async import(e){var t,r,i;if(!e.parent)return!1;const a=await reader_manager_1.glTfReaderManager.getOrCreate(e.parent),s=e.parent.userData.generateLightmapUVNode,n=e.parent.userData,l=e.userData;let u=a.createMesh(e.userData.gltfIndex,s,null!==(t=n.addVertexColor)&&void 0!==t&&t);if(l.lodOptions){const e=meshSimplify_1.getDefautOptions();e.targetRatio=l.lodOptions.faceCount,u=meshSimplify_1.simplifyMesh(u,e)}let o=0;if(l.triangleCount=0,null===(r=u.struct.primitives)||void 0===r||r.forEach(e=>{e&&e.indexView&&(o+=e.indexView.count/3)}),l.triangleCount=o,u.allowDataAccess=null===(i=e.parent.userData.allowMeshDataAccess)||void 0===i||i,s){let t=!1;const r=[],i=[];let a=0;for(let e=0;e<u.struct.primitives.length;e++){const s=u.readAttribute(e,cc_1.gfx.AttributeName.ATTR_POSITION);let n;2===u.struct.vertexBundles[e].view.stride?n=u.readIndices(e):4===u.struct.vertexBundles[e].view.stride?n=u.readIndices(e):(console.warn("Invalid indeces stride"),n=[]);for(let e=0;e<s.length;++e)r.push(s[e]);for(let e=0;e<n.length;++e)i.push(n[e]+a);u.readAttribute(e,cc_1.gfx.AttributeName.ATTR_TEX_COORD1)&&(t=!0),a+=u.struct.vertexBundles[e].view.count}const s=r.length/3,n=new Uint8Array(8+4*r.length+4*i.length),l=new Int32Array(n.buffer,0);l[0]=s,l[1]=i.length;const o=new Float32Array(n.buffer,8),f=new Int32Array(n.buffer,8+4*r.length);for(let e=0;e<r.length;e++)o[e]=r[e];for(let e=0;e<i.length;e++)f[e]=i[e];const c=e.uuid,d=e.temp;await fs_extra_2.ensureDir(d),await fs_extra_1.default.promises.writeFile(`${d}/${c}_in.bin`,n),await uv_unwrap_1.unwrapLightmapUV(`${d}/${c}_in.bin`,`${d}/${c}_out.bin`);const _=await fs_extra_1.default.promises.readFile(`${d}/${c}_out.bin`),m=new Uint8Array(_),p=new Float32Array(m.buffer,4);let h=0;for(let e=0;e<u.struct.primitives.length;e++){const t=u.readAttribute(e,cc_1.gfx.AttributeName.ATTR_TEX_COORD1),r=u.struct.vertexBundles[e].attributes;let i=0;if(t.length>0){for(let t=0;t<r.length&&r[t].name!==cc_1.gfx.AttributeName.ATTR_TEX_COORD1;t++){const a=u.readAttributeFormat(e,r[t].name);a&&(i+=a.size)}if(i>0)for(let t=0;t<u.struct.vertexBundles[e].view.count;t++){const r=u.struct.vertexBundles[e].view.offset+i+t*u.struct.vertexBundles[e].view.stride,a=new DataView(u.data.buffer);a.setFloat32(r,p[h],!0),a.setFloat32(r+4,p[h+1],!0),h+=2}}}}n.meshOptimizer&&n.meshOptimizer.enable&&"gltfpack"!==n.meshOptimizer.algorithm&&(u=meshSimplify_1.simplifyMesh(u,n.meshOptimizer.simplifyOptions)),0!==u.data.byteLength&&(u._setRawAsset(".bin"),await e.saveToLibrary(".bin",Buffer.from(u.data)));const f=EditorExtends.serialize(u);await e.saveToLibrary(".json",f);const c=utils_1.getDependUUIDList(f);return e.setData("depends",c),!0}}exports.GltfMeshImporter=GltfMeshImporter;