"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.simplifyMesh=exports.getDefautOptions=exports.MeshSimplify=void 0;const cc_1=require("cc"),cc_2=require("cc"),_tempVec2=new cc_1.Vec2,_tempVec3=new cc_1.Vec3,_tempVec3_2=new cc_1.Vec3,_tempVec3_3=new cc_1.Vec3,_tempVec4=new cc_1.Vec4,_tempColor=new cc_1.Color,DenomEpilson=1e-8;function colorScaleAndAdd(t,e,s,i){t.r=Math.max(e.r+s.r*i,255),t.g=Math.max(e.g+s.g*i,255),t.b=Math.max(e.b+s.b*i,255),t.a=Math.max(e.a+s.a*i,255)}class SymetricMatrix{constructor(){this.m=new Array(10).fill(0)}set(t,e,s,i,r,c,n,o,h,l){return this.m[0]=t,this.m[1]=e,this.m[2]=s,this.m[3]=i,this.m[4]=r,this.m[5]=c,this.m[6]=n,this.m[7]=o,this.m[8]=h,this.m[9]=l,this}makePlane(t,e,s,i){return this.set(t*t,t*e,t*s,t*i,e*e,e*s,e*i,s*s,s*i,i*i)}det(t,e,s,i,r,c,n,o,h){return this.m[t]*this.m[r]*this.m[h]+this.m[s]*this.m[i]*this.m[o]+this.m[e]*this.m[c]*this.m[n]-this.m[s]*this.m[r]*this.m[n]-this.m[t]*this.m[c]*this.m[o]-this.m[e]*this.m[i]*this.m[h]}add(t){return(new SymetricMatrix).set(this.m[0]+t.m[0],this.m[1]+t.m[1],this.m[2]+t.m[2],this.m[3]+t.m[3],this.m[4]+t.m[4],this.m[5]+t.m[5],this.m[6]+t.m[6],this.m[7]+t.m[7],this.m[8]+t.m[8],this.m[9]+t.m[9])}addSelf(t){this.m[0]+=t.m[0],this.m[1]+=t.m[1],this.m[2]+=t.m[2],this.m[3]+=t.m[3],this.m[4]+=t.m[4],this.m[5]+=t.m[5],this.m[6]+=t.m[6],this.m[7]+=t.m[7],this.m[8]+=t.m[8],this.m[9]+=t.m[9]}}class Triangle{constructor(){this.v=new Array(3),this.va=new Array(3),this.err=new Array(4),this.deleted=!1,this.dirty=!1,this.n=new cc_1.Vec3}}class Vertex{constructor(){this.p=new cc_1.Vec3,this.tstart=-1,this.tcount=-1,this.q=new SymetricMatrix,this.border=!1}}class Ref{}class BorderVertex{constructor(t,e){this.index=t,this.hash=e}}class SimplificationOptions{constructor(){this.preserveSurfaceCurvature=!1,this.preserveBorderEdges=!1,this.preserveUVSeamEdges=!1,this.preserveUVFoldoverEdges=!1,this.enableSmartLink=!0,this.vertexLinkDistance=Number.MIN_VALUE,this.maxIterationCount=100,this.agressiveness=7}}class MeshSimplify{constructor(){this.simplificationOptions=new SimplificationOptions,this._triangles=[],this._vertices=[],this._vertNormals=null,this._vertTangents=null,this._vertUV2D=null,this._vertUV3D=null,this._vertUV4D=null,this._vertColors=null,this._vertJoints=null,this._vertWeights=null,this._refs=[],this._geometricInfo="",this._triangleHashSet1=new Map,this._triangleHashSet2=new Map}init(t,e,s){if(this._vertices=t.map((t,e)=>{const s=new Vertex;return s.index=e,s.p=new cc_1.Vec3(t.x,t.y,t.z),s}),s.uvs&&s.uvs.length>0){this._vertUV2D=[];for(let t=0;t<s.uvs.length;t+=2)this._vertUV2D.push(new cc_1.Vec2(s.uvs[t],s.uvs[t+1]))}if(s.normals&&s.normals.length>0){this._vertNormals=[];for(let t=0;t<s.normals.length;t+=3)this._vertNormals.push(new cc_1.Vec3(s.normals[t],s.normals[t+1],s.normals[t+2]))}if(s.tangents&&s.tangents.length>0){this._vertTangents=[];for(let t=0;t<s.tangents.length;t+=4)this._vertTangents.push(new cc_1.Vec4(s.tangents[t],s.tangents[t+1],s.tangents[t+2],s.tangents[t+3]))}if(s.colors&&s.colors.length>0){this._vertColors=[];for(let t=0;t<s.colors.length;t+=4)this._vertColors.push(new cc_1.Color(s.colors[t],s.colors[t+1],s.colors[t+2],s.colors[t+3]))}if(s.joints&&s.joints.length>0){this._vertJoints=[];for(let t=0;t<s.joints.length;t+=4)this._vertJoints.push(new cc_1.Vec4(s.joints[t],s.joints[t+1],s.joints[t+2],s.joints[t+3]))}if(s.weights&&s.weights.length>0){this._vertWeights=[];for(let t=0;t<s.weights.length;t+=4)this._vertWeights.push(new cc_1.Vec4(s.weights[t],s.weights[t+1],s.weights[t+2],s.weights[t+3]))}this._triangles=e.map(t=>{const e=new Triangle;return e.v[0]=t.a,e.v[1]=t.b,e.v[2]=t.c,e.va[0]=t.a,e.va[1]=t.b,e.va[2]=t.c,e})}_resize(t,e){if(e<t.length)return t.splice(e);t.length}_move(t,e,s,i){for(let r=0;r<i;r++)t[e+r].tvertex=t[s+r].tvertex,t[e+r].tid=t[s+r].tid}compactMesh(){let t=0;for(let t=0;t<this._vertices.length;t++)this._vertices[t].tcount=0;for(let e=0;e<this._triangles.length;e++)if(!this._triangles[e].deleted){const s=this._triangles[e];for(let t=0;t<3;t++)if(s.va[t]!=s.v[t]){const e=s.va[t],i=s.v[t];cc_1.Vec3.copy(this._vertices[e].p,this._vertices[i].p),null!=this._vertWeights&&cc_1.Vec4.copy(this._vertWeights[e],this._vertWeights[i]),null!=this._vertJoints&&cc_1.Vec4.copy(this._vertJoints[e],this._vertJoints[i]),s.v[t]=s.va[t]}this._triangles[t++]=s;for(let t=0;t<3;t++)this._vertices[s.v[t]].tcount=1}this._resize(this._triangles,t),t=0;for(let e=0;e<this._vertices.length;e++)this._vertices[e].tcount&&(this._vertices[e].tstart=t,this._vertices[t].index=t,this._vertices[t].p=this._vertices[e].p,this._vertUV2D&&(this._vertUV2D[t]=this._vertUV2D[e]),this._vertNormals&&(this._vertNormals[t]=this._vertNormals[e]),this._vertTangents&&(this._vertTangents[t]=this._vertTangents[e]),this._vertColors&&(this._vertColors[t]=this._vertColors[e]),this._vertJoints&&(this._vertJoints[t]=this._vertJoints[e]),this._vertWeights&&(this._vertWeights[t]=this._vertWeights[e]),t++);for(let t=0;t<this._triangles.length;t++){const e=this._triangles[t];for(let t=0;t<3;t++)e.v[t]=this._vertices[e.v[t]].tstart}this._resize(this._vertices,t)}_simplifyMesh(t,e){let s,i;for(void 0===e&&(e=this.simplificationOptions.agressiveness),console.time("simplify_mesh"),s=0,i=this._triangles.length;s<i;s++)this._triangles[s].deleted=!1;let r=0;const c=[],n=[],o=this._triangles.length;for(let h=0;h<this.simplificationOptions.maxIterationCount&&!(o-r<=t);h++){h%5==0&&this._updateMesh(h);for(let t=0;t<this._triangles.length;t++)this._triangles[t].dirty=!1;const l=1e-13*Math.pow(h+3,e);for(s=0,i=this._triangles.length;s<i;s++){const e=this._triangles[s];if(!(e.err[3]>l||e.deleted||e.dirty)){for(let t=0;t<3;t++)if(e.err[t]<l){const s=e.v[t],i=this._vertices[s],o=e.v[(t+1)%3],h=this._vertices[o];if(i.border!=h.border)continue;if(i.uvSteam!=h.uvSteam)continue;if(i.uvFoldover!=h.uvFoldover)continue;if(this.simplificationOptions.preserveBorderEdges&&i.border)continue;if(this.simplificationOptions.preserveUVSeamEdges&&i.uvSteam)continue;if(this.simplificationOptions.preserveUVFoldoverEdges&&i.uvFoldover)continue;const l=new cc_1.Vec3;if(this._calculateError(s,o,l),this._resize(c,i.tcount),this._resize(n,h.tcount),this._flipped(l,s,o,i,h,c))continue;if(this._flipped(l,o,s,h,i,n))continue;const _=e.v[(t+2)%3],a=new cc_1.Vec3;this.calculateBarycentricCoords(l,i.p,h.p,this._vertices[_].p,a),i.p=l,i.q.addSelf(h.q);let v=e.va[t];const m=e.va[(t+1)%3],p=e.va[(t+2)%3];this._interpolateVertexAttributes(v,v,m,p,a),this._vertices[s].uvSteam&&(v=-1);const u=this._refs.length;r=this._updateTriangles(s,v,i,c,r),r=this._updateTriangles(s,v,h,n,r);const g=this._refs.length-u;g<=i.tcount?g&&this._move(this._refs,i.tstart,u,g):i.tstart=u,i.tcount=g;break}if(o-r<=t)break}}}this.compactMesh(),console.timeEnd("simplify_mesh")}_flipped(t,e,s,i,r,c){for(let e=0;e<i.tcount;e++){const r=this._triangles[this._refs[i.tstart+e].tid];if(r.deleted)continue;const n=this._refs[i.tstart+e].tvertex,o=r.v[(n+1)%3],h=r.v[(n+2)%3];if(o!=s&&h!=s){if(cc_1.Vec3.subtract(_tempVec3,this._vertices[o].p,t),_tempVec3.normalize(),cc_1.Vec3.subtract(_tempVec3_2,this._vertices[h].p,t),_tempVec3_2.normalize(),Math.abs(cc_1.Vec3.dot(_tempVec3,_tempVec3_2))>.999)return!0;if(cc_1.Vec3.cross(_tempVec3_3,_tempVec3,_tempVec3_2),_tempVec3_3.normalize(),c[e]=!1,cc_1.Vec3.dot(_tempVec3_3,r.n)<.2)return!0}else c[e]=!0}return!1}_updateTriangles(t,e,s,i,r){const c=new cc_1.Vec3;for(let n=0;n<s.tcount;n++){const o=this._refs[s.tstart+n],h=this._triangles[o.tid];h.deleted||(i[n]?(h.deleted=!0,r++):(h.v[o.tvertex]=t,-1!=e&&(h.va[o.tvertex]=e),h.dirty=!0,h.err[0]=this._calculateError(h.v[0],h.v[1],c),h.err[1]=this._calculateError(h.v[1],h.v[2],c),h.err[2]=this._calculateError(h.v[2],h.v[0],c),h.err[3]=Math.min(h.err[0],h.err[1],h.err[2]),this._refs.push(o)))}return r}_updateMesh(t){if(t>0){let t=0;for(let e=0;e<this._triangles.length;e++){const s=this._triangles[e];s.deleted||(this._triangles[t++]=s)}this._triangles.splice(t)}if(this._updateReferences(),0==t){let t,e,s=0,i=1.7976931348623157e308,r=-1.7976931348623157e308;for(let t=0;t<this._vertices.length;t++)this._vertices[t].border=!1,this._vertices[t].uvSteam=!1,this._vertices[t].uvFoldover=!1;for(let c=0;c<this._vertices.length;c++){const n=this._vertices[c];t=[],e=[];for(let s=0;s<n.tcount;s++){const i=this._refs[n.tstart+s].tid,r=this._triangles[i];for(let s=0;s<3;s++){let i=0,c=r.v[s];for(;i<t.length&&e[i]!=c;)i++;i==t.length?(t.push(1),e.push(c)):t[i]++}}for(let c=0;c<t.length;c++)if(1==t[c]&&(this._vertices[e[c]].border=!0,s++,this.simplificationOptions.enableSmartLink)){const t=e[c];this._vertices[t].p.x<i&&(i=this._vertices[t].p.x),this._vertices[t].p.x>r&&(r=this._vertices[t].p.x)}}if(this.simplificationOptions.enableSmartLink){const t=new Array(s);let e=0;const c=r-i;for(let s=0;s<this._vertices.length;s++)if(this._vertices[s].border){const r=2147483647*((this._vertices[s].p.x-i)/c*2-1);t[e]=new BorderVertex(s,r),++e}t.sort((t,e)=>t.hash-e.hash);const n=this.simplificationOptions.vertexLinkDistance*this.simplificationOptions.vertexLinkDistance,o=Math.sqrt(n),h=Math.max(o/c*2147483647,1);for(let s=0;s<e;s++){const i=t[s].index;if(-1==i)continue;const r=this._vertices[i].p;for(let c=s+1;c<e;c++){const e=t[c].index;if(-1==e)continue;if(t[c].hash-t[s].hash>h)break;const o=this._vertices[e].p;if((r.x-o.x)*(r.x-o.x)+(r.y-o.y)*(r.y-o.y)+(r.z-o.z)*(r.z-o.z)<=n){t[c].index=-1,this._vertices[i].border=!1,this._vertices[e].border=!1,this._vertUV2D[i].equals(this._vertUV2D[e])?(this._vertices[i].uvFoldover=!0,this._vertices[e].uvFoldover=!0):(this._vertices[i].uvSteam=!0,this._vertices[e].uvSteam=!0);const s=this._vertices[e].tcount,r=this._vertices[e].tstart;for(let t=0;t<s;t++){const e=this._refs[r+t];this._triangles[e.tid].v[e.tvertex]=i}}}}this._updateReferences()}for(let t=0;t<this._vertices.length;t++)this._vertices[t].q=new SymetricMatrix;const c=new cc_1.Vec3,n=new cc_1.Vec3,o=new Array(3),h=new SymetricMatrix;for(let t=0;t<this._triangles.length;t++){const e=this._triangles[t],s=new cc_1.Vec3;for(let t=0;t<3;t++)o[t]=this._vertices[e.v[t]].p;cc_1.Vec3.subtract(c,o[1],o[0]),cc_1.Vec3.subtract(n,o[2],o[0]),cc_1.Vec3.cross(s,c,n),cc_1.Vec3.normalize(s,s),e.n=s,h.makePlane(s.x,s.y,s.z,-s.dot(o[0]));for(let t=0;t<3;t++)this._vertices[e.v[t]].q.addSelf(h)}for(let t=0;t<this._triangles.length;t++){const e=this._triangles[t],s=new cc_1.Vec3;for(let t=0;t<3;t++)e.err[t]=this._calculateError(e.v[t],e.v[(t+1)%3],s);e.err[3]=Math.min(e.err[0],e.err[1],e.err[2])}}}_vertexError(t,e,s,i){return t.m[0]*e*e+2*t.m[1]*e*s+2*t.m[2]*e*i+2*t.m[3]*e+t.m[4]*s*s+2*t.m[5]*s*i+2*t.m[6]*s+t.m[7]*i*i+2*t.m[8]*i+t.m[9]}_calculateError(t,e,s){const i=this._vertices[t],r=this._vertices[e],c=i.q.add(r.q),n=i.border&&r.border;let o=0;const h=c.det(0,1,2,1,4,5,2,5,7);if(0===h||n){const t=i.p,e=r.p,n=new cc_1.Vec3;cc_1.Vec3.add(n,t,e),n.multiplyScalar(.5);const h=this._vertexError(c,t.x,t.y,t.z),l=this._vertexError(c,e.x,e.y,e.z),_=this._vertexError(c,n.x,n.y,n.z);h===(o=Math.min(h,l,_))&&cc_1.Vec3.copy(s,t),l===o&&cc_1.Vec3.copy(s,e),_===o&&cc_1.Vec3.copy(s,n)}else{s.x=-1/h*c.det(1,2,3,4,5,6,5,7,8),s.y=1/h*c.det(0,2,3,1,5,6,2,7,8),s.z=-1/h*c.det(0,1,3,1,4,6,2,5,8);let t=0;this.simplificationOptions.preserveSurfaceCurvature&&(t=this._curvatureError(i,r)),o=this._vertexError(c,s.x,s.y,s.z)+t}return o}_updateReferences(){for(let t=0;t<this._vertices.length;t++)this._vertices[t].tstart=0,this._vertices[t].tcount=0;for(let t=0;t<this._triangles.length;t++){const e=this._triangles[t];for(let t=0;t<3;t++)this._vertices[e.v[t]].tcount++}let t=0;for(let e=0;e<this._vertices.length;e++){const s=this._vertices[e];s.tstart=t,t+=s.tcount,s.tcount=0}for(let t=this._refs.length;t<3*this._triangles.length;t++)this._refs[t]=new Ref;for(let t=0;t<this._triangles.length;t++){const e=this._triangles[t];for(let s=0;s<3;s++){const i=this._vertices[e.v[s]];this._refs[i.tstart+i.tcount].tid=t,this._refs[i.tstart+i.tcount].tvertex=s,i.tcount++}}}_curvatureError(t,e){cc_1.Vec3.subtract(_tempVec3,t.p,e.p);const s=_tempVec3.length(),i=this._triangleHashSet1;i.clear(),this._getTrianglesContainingVertex(t,i),this._getTrianglesContainingVertex(e,i);const r=this._triangleHashSet2;r.clear(),this._getTrianglesContainingBothVertices(t,e,r);let c=0;return i.forEach((t,e)=>{let s=0;const i=e.n.clone();r.forEach((t,e)=>{const r=e.n.clone(),c=cc_1.Vec3.dot(i,r);c>s&&(s=c)}),s>c&&(c=s)}),s*c}_getTrianglesContainingVertex(t,e){const s=t.tcount,i=t.tstart;for(let t=i;t<i+s;t++)e.set(this._triangles[this._refs[t].tid],!0)}_getTrianglesContainingBothVertices(t,e,s){const i=t.tcount,r=t.tstart;for(let t=r;t<r+i;t++){const i=this._refs[t].tid,r=this._triangles[i];this._vertices[r.v[0]].index!=e.index&&this._vertices[r.v[1]].index!=e.index&&this._vertices[r.v[2]].index!=e.index||s.set(r,!0)}}simplifyMesh(t,e=7){try{t=Math.round(t);const s=JSON.parse(this._geometricInfo);this.init(s.vertices,s.faces,s),console.time("simplify"),this._simplifyMesh(t,e),console.timeEnd("simplify"),console.log("new vertices "+this._vertices.length,"old faces "+this._triangles.length);const i={positions:[],indices:[],attrs:{}},r=this._vertices.length;for(let t=0;t<this._vertices.length;t++){const e=this._vertices[t];i.positions.push(e.p.x),i.positions.push(e.p.y),i.positions.push(e.p.z)}if(this._vertUV2D){this._resize(this._vertUV2D,r),i.uvs=[];for(let t=0;t<this._vertUV2D.length;t++){const e=this._vertUV2D[t];i.uvs.push(e.x),i.uvs.push(e.y)}}if(this._vertNormals){this._resize(this._vertNormals,r),i.normals=[];for(let t=0;t<this._vertNormals.length;t++){const e=this._vertNormals[t];i.normals.push(e.x),i.normals.push(e.y),i.normals.push(e.z)}}if(this._vertTangents){this._resize(this._vertTangents,r),i.tangents=[];for(let t=0;t<this._vertTangents.length;t++){const e=this._vertTangents[t];i.tangents.push(e.x),i.tangents.push(e.y),i.tangents.push(e.z),i.tangents.push(e.w)}}if(this._vertColors){this._resize(this._vertColors,r),i.colors=[];for(let t=0;t<this._vertColors.length;t++){const e=this._vertColors[t];i.colors.push(e.r),i.colors.push(e.g),i.colors.push(e.b),i.colors.push(e.a)}}if(this._vertJoints){this._resize(this._vertJoints,r);const t=i.attrs.joints=[];for(let e=0;e<this._vertJoints.length;e++){const s=this._vertJoints[e];t.push(s.x),t.push(s.y),t.push(s.z),t.push(s.w)}}if(this._vertWeights){this._resize(this._vertWeights,r);const t=i.attrs.weights=[];for(let e=0;e<this._vertWeights.length;e++){const s=this._vertWeights[e];t.push(s.x),t.push(s.y),t.push(s.z),t.push(s.w)}}for(let t=0;t<this._triangles.length;t++){const e=this._triangles[t];i.indices.push(e.v[0]),i.indices.push(e.v[1]),i.indices.push(e.v[2])}return i}catch(t){console.error(t)}}buildGeometric(t){const e=[];if(t.indices)for(let s=0;s<t.indices.length;s+=3)e.push({a:t.indices[s],b:t.indices[s+1],c:t.indices[s+2]});else{const s=t.positions.length/3;for(let t=0;t<s;t+=3)e.push({a:3*t+0,b:3*t+1,c:3*t+2})}t.faces=e;const s=[];for(let e=0;e<t.positions.length;e+=3)s.push(new cc_1.Vec3(t.positions[e],t.positions[e+1],t.positions[e+2]));t.vertices=s;for(const e in t)t[e]?t[e]instanceof Array||(t[e]=Array.from(t[e])):delete t[e];this._geometricInfo=JSON.stringify(t)}calculateBarycentricCoords(t,e,s,i,r){const c=new cc_1.Vec3,n=new cc_1.Vec3,o=new cc_1.Vec3;cc_1.Vec3.subtract(c,s,e),cc_1.Vec3.subtract(n,i,e),cc_1.Vec3.subtract(o,t,e);const h=cc_1.Vec3.dot(c,c),l=cc_1.Vec3.dot(c,n),_=cc_1.Vec3.dot(n,n),a=cc_1.Vec3.dot(o,c),v=cc_1.Vec3.dot(o,n);let m=h*_-l*l;Math.abs(m)<DenomEpilson&&(m=DenomEpilson);const p=(_*a-l*v)/m,u=(h*v-l*a)/m,g=1-p-u;r.set(g,p,u)}_interpolateVertexAttributes(t,e,s,i,r){this._vertNormals&&(_tempVec3.set(0,0,0),cc_1.Vec3.scaleAndAdd(_tempVec3,_tempVec3,this._vertNormals[e],r.x),cc_1.Vec3.scaleAndAdd(_tempVec3,_tempVec3,this._vertNormals[s],r.y),cc_1.Vec3.scaleAndAdd(_tempVec3,_tempVec3,this._vertNormals[i],r.z),cc_1.Vec3.normalize(_tempVec3,_tempVec3),cc_1.Vec3.copy(this._vertNormals[t],_tempVec3)),this._vertUV2D&&(_tempVec2.set(0,0),cc_1.Vec2.scaleAndAdd(_tempVec2,_tempVec2,this._vertUV2D[e],r.x),cc_1.Vec2.scaleAndAdd(_tempVec2,_tempVec2,this._vertUV2D[s],r.y),cc_1.Vec2.scaleAndAdd(_tempVec2,_tempVec2,this._vertUV2D[i],r.z),cc_1.Vec2.copy(this._vertUV2D[t],_tempVec2)),this._vertTangents&&(_tempVec4.set(0,0,0,0),cc_1.Vec4.scaleAndAdd(_tempVec4,_tempVec4,this._vertTangents[e],r.x),cc_1.Vec4.scaleAndAdd(_tempVec4,_tempVec4,this._vertTangents[s],r.y),cc_1.Vec4.scaleAndAdd(_tempVec4,_tempVec4,this._vertTangents[i],r.z),this._normalizeTangent(this._vertTangents[t],_tempVec4)),this._vertColors&&(_tempColor.set(0,0,0,0),colorScaleAndAdd(_tempColor,_tempColor,this._vertColors[e],r.x),colorScaleAndAdd(_tempColor,_tempColor,this._vertColors[s],r.y),colorScaleAndAdd(_tempColor,_tempColor,this._vertColors[i],r.z),this._vertColors[t].set(_tempColor.r,_tempColor.g,_tempColor.b,_tempColor.a))}_normalizeTangent(t,e){const s=new cc_1.Vec3(e.x,e.y,e.z);s.normalize(),t.set(s.x,s.y,s.z,e.w)}}function appendUint8Array(t,e){const s=new Uint8Array(t.length+e.length);return s.set(t,0),s.set(e,t.length),s}function getDefautOptions(){return{targetRatio:1,enableSmartLink:!0,agressiveness:7,maxIterationCount:100}}function simplifyMesh(t,e){for(let e=0;e<t.struct.primitives.length;e++){const s=t.struct.primitives[e];if(s.primitiveMode!==cc_2.gfx.PrimitiveMode.TRIANGLE_LIST||void 0===s.indexView)return console.warn("SimplifyMesh current only support indexed triangle mesh, opreation is skipped"),t}const s=getDefautOptions();e=Object.assign(s,e||{});let i=0,r=0;const c=new Array,n=new Array;let o=new Uint8Array;for(let s=0;s<t.struct.vertexBundles.length;s++){const h=t.readIndices(s),l=t.struct.vertexBundles[s].view.count,_=h?h.length/3:l/3;if(_>0){const l=t.readAttribute(s,cc_2.gfx.AttributeName.ATTR_TEX_COORD),a=t.readAttribute(s,cc_2.gfx.AttributeName.ATTR_TANGENT),v=t.readAttribute(s,cc_2.gfx.AttributeName.ATTR_NORMAL),m=t.readAttribute(s,cc_2.gfx.AttributeName.ATTR_WEIGHTS),p=t.readAttribute(s,cc_2.gfx.AttributeName.ATTR_JOINTS),u=t.readAttribute(s,cc_2.gfx.AttributeName.ATTR_COLOR),g=t.readAttribute(s,cc_2.gfx.AttributeName.ATTR_POSITION),f=new MeshSimplify;f.buildGeometric({positions:g,normals:v,uvs:l,indices:null!==h&&void 0!==h?h:void 0,tangents:a,weights:m,joints:p,colors:u}),f.simplificationOptions.agressiveness=e.agressiveness,f.simplificationOptions.enableSmartLink=e.enableSmartLink;const d=f.simplifyMesh(e.targetRatio*_),V=Object.assign(Object.assign({},d),{customAttributes:[],primitiveMode:cc_2.gfx.PrimitiveMode.TRIANGLE_LIST});if(V.attrs){const t=V.attrs;delete V.attrs;for(const e in t)if("joints"==e){const s={attr:new cc_2.gfx.Attribute(cc_2.gfx.AttributeName.ATTR_JOINTS,cc_2.gfx.Format.RGBA16UI),values:t[e]};V.customAttributes.push(s)}else if("weights"==e){const s={attr:new cc_2.gfx.Attribute(cc_2.gfx.AttributeName.ATTR_WEIGHTS,cc_2.gfx.Format.RGBA32F),values:t[e]};V.customAttributes.push(s)}}const x=new cc_2.Mesh;cc_2.utils.createMesh(V,x,{calculateBounds:!0}),cc_1.assert(1==x.struct.vertexBundles.length);const w=x.struct.vertexBundles[0];let y;o=appendUint8Array(o,x.data.slice(w.view.offset,w.view.offset+w.view.length)),w.view.offset=i,c.push(w),i+=w.view.length,void 0!==x.struct.primitives&&(cc_1.assert(1==x.struct.primitives.length),y=x.struct.primitives[0],cc_1.assert(y.indexView),o=appendUint8Array(o,x.data.slice(y.indexView.offset,y.indexView.offset+y.indexView.length)),y.indexView.offset=i,y.jointMapIndex=x.struct.primitives[0].jointMapIndex,n.push(y),i+=y.indexView.length,n[r].vertexBundelIndices=[r],r+=1)}}const h={struct:{vertexBundles:c,primitives:n,minPosition:t.struct.minPosition,maxPosition:t.struct.maxPosition},data:o},l=new cc_2.Mesh;return l.reset(h),l.hash,l}exports.MeshSimplify=MeshSimplify,exports.getDefautOptions=getDefautOptions,exports.simplifyMesh=simplifyMesh;