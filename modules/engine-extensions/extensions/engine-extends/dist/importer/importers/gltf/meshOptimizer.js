"use strict";var __importDefault=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(exports,"__esModule",{value:!0}),exports.deflateMesh=exports.quantizeMesh=exports.encodeMesh=exports.compressMesh=exports.simplifyMesh=exports.getDefaultSimplifyOptions=exports.clusterizeMesh=exports.optimizeMesh=void 0;const cc_1=require("cc"),meshopt_encoder_1=__importDefault(require("meshopt_encoder")),zlib_1=__importDefault(require("zlib")),gltf_converter_1=require("../utils/gltf-converter");let inited=!1;async function tryInitMeshOpt(){return inited?Promise.resolve():meshopt_encoder_1.default.init().then(()=>{console.log("MeshOpt init success"),inited=!0})}function getOffset(e,t){let n=0;for(let r=0;r<t;++r){const t=e[r];n+=cc_1.gfx.FormatInfos[t.format].size}return n}const overdrawThreshold=3;async function optimizeMesh(e,t){if(await tryInitMeshOpt(),!t)return e;if(!(t.overdraw||t.vertexCache||t.vertexFetch))return console.warn("No optimization option is enabled, return the original mesh"),e;const n=new gltf_converter_1.BufferBlob;n.setNextAlignment(0);const r=JSON.parse(JSON.stringify(e.struct));for(let i=0;i<r.primitives.length;++i){const o=r.primitives[i];if(o.primitiveMode===cc_1.gfx.PrimitiveMode.POINT_LIST||void 0===o.indexView){console.warn("Only triangle list is supported.");for(let t=0;t<o.vertexBundelIndices.length;++t){const i=r.vertexBundles[o.vertexBundelIndices[t]],s=i.view,c=new Uint8Array(e.data.buffer,s.offset,s.length);n.setNextAlignment(s.stride);const a={offset:n.getLength(),length:c.byteLength,count:s.count,stride:s.stride};i.view=a,n.addBuffer(c)}continue}const s=o.indexView,c=r.vertexBundles[o.vertexBundelIndices[0]].view.count,a=new Uint8Array(s.count*Uint32Array.BYTES_PER_ELEMENT);if(2===s.stride){const t=new Uint16Array(e.data.buffer,s.offset,s.count),n=new Uint32Array(a.buffer,0,s.count);for(let e=0;e<s.count;++e)n[e]=t[e]}else 4===s.stride&&a.set(new Uint8Array(e.data.buffer,s.offset,s.count*Uint32Array.BYTES_PER_ELEMENT));if(t.vertexCache&&meshopt_encoder_1.default.optimizer.optimizeVertexCache(a,a,s.count,c),t.overdraw){const t=o.vertexBundelIndices.findIndex(e=>{return r.vertexBundles[e].attributes.findIndex(e=>e.name===cc_1.gfx.AttributeName.ATTR_POSITION)>=0});if(t<0)console.warn("No position attribute found, overdraw optimization is not supported.");else{const n=r.vertexBundles[o.vertexBundelIndices[t]],i=n.view,f=n.attributes,u=getOffset(f,f.findIndex(e=>e.name===cc_1.gfx.AttributeName.ATTR_POSITION)),d=new Uint8Array(e.data.buffer,i.offset,i.length);meshopt_encoder_1.default.optimizer.optimizeOverdraw(a,a,s.count,d.subarray(u),c,i.stride,overdrawThreshold)}}if(t.vertexCache||t.overdraw||t.vertexFetch)for(let t=0;t<o.vertexBundelIndices.length;++t){const i=r.vertexBundles[o.vertexBundelIndices[t]],s=i.view,c=new Uint8Array(e.data.buffer,s.offset,s.length);n.setNextAlignment(s.stride);const a={offset:n.getLength(),length:c.byteLength,count:s.count,stride:s.stride};i.view=a,n.addBuffer(c)}else if(1===o.vertexBundelIndices.length){const t=r.vertexBundles[o.vertexBundelIndices[0]],i=t.view,c=new Uint8Array(e.data.buffer,i.offset,i.length),f=new Uint8Array(i.count*i.stride);meshopt_encoder_1.default.optimizer.optimizeVertexFetch(f,a,s.count,c,i.count,i.stride),n.setNextAlignment(i.stride);const u={offset:n.getLength(),length:f.byteLength,count:i.count,stride:i.stride};t.view=u,n.addBuffer(f)}else if(o.vertexBundelIndices.length>1){const t=new Uint8Array(s.count*Uint32Array.BYTES_PER_ELEMENT),i=meshopt_encoder_1.default.optimizer.optimizeVertexFetchRemap(t,a,s.count,c);meshopt_encoder_1.default.optimizer.optimizeRemapIndex(a,a,s.count,t);for(let s=0;s<o.vertexBundelIndices.length;++s){const c=r.vertexBundles[o.vertexBundelIndices[s]],a=c.view,f=new Uint8Array(e.data.buffer,a.offset,a.length),u=new Uint8Array(i*a.stride);meshopt_encoder_1.default.optimizer.optimizeRemapVertex(u,f,i,a.stride,t),n.setNextAlignment(a.stride);const d={offset:n.getLength(),length:u.byteLength,count:i,stride:a.stride};c.view=d,n.addBuffer(u)}}n.setNextAlignment(Uint32Array.BYTES_PER_ELEMENT);const f={offset:n.getLength(),length:a.byteLength,count:s.count,stride:Uint32Array.BYTES_PER_ELEMENT};o.indexView=f,n.addBuffer(a)}const i=new cc_1.Mesh;i.reset({struct:r,data:n.getCombined()});i.hash;return i}exports.optimizeMesh=optimizeMesh;const maxTriangleCount=124,maxVertexCount=64,coneWeight=.5;async function clusterizeMesh(e,t){if(await tryInitMeshOpt(),!t)return e;const n=e.struct,r=e.struct.primitives,i=e.struct.vertexBundles,o=[],s=[],c=[];let a=0,f=0,u=0;if(r.forEach((n,r)=>{if(n.indexView)if(1===n.vertexBundelIndices.length){const d=n.indexView,l=d.count,m=i[n.vertexBundelIndices[0]].view,g=m.count,h=meshopt_encoder_1.default.optimizer.buildMeshLetsBound(l,maxVertexCount,maxTriangleCount),_=new Uint8Array(h*Uint32Array.BYTES_PER_ELEMENT*4),x=new Uint8Array(h*maxVertexCount*Uint32Array.BYTES_PER_ELEMENT),p=new Uint8Array(h*maxTriangleCount*Uint32Array.BYTES_PER_ELEMENT*3),A=i[n.vertexBundelIndices[0]].attributes,y=getOffset(A,A.findIndex(e=>e.name===cc_1.gfx.AttributeName.ATTR_POSITION)),E=new Uint8Array(e.data.buffer,m.offset+y,m.length-y);let w=0;if(4===d.stride){const t=new Uint32Array(e.data.buffer,d.offset,l);w=meshopt_encoder_1.default.optimizer.buildMeshLets(_,x,p,t,l,E,g,m.stride,maxVertexCount,maxTriangleCount,coneWeight)}else{if(2!==d.stride)return void console.warn(`Submesh ${r} has unsupported index stride, meshlet optimization is not supported.`);{const t=new Uint16Array(e.data.buffer,d.offset,l),n=new Uint32Array(l);for(let e=0;e<l;++e)n[e]=t[e];w=meshopt_encoder_1.default.optimizer.buildMeshLets(_,x,p,n,l,E,g,m.stride,maxVertexCount,maxTriangleCount,coneWeight)}}if(null===t||void 0===t?void 0:t.coneCluster){new Uint8Array(48*w);for(let e=0;e<w;++e);}o.push(_),s.push(x),c.push(p),a+=_.byteLength,f+=x.byteLength,u+=p.byteLength,n.cluster={clusterView:{offset:a,length:_.byteLength,count:w,stride:4*Uint32Array.BYTES_PER_ELEMENT},vertexView:{offset:f,length:x.byteLength,count:g,stride:Uint32Array.BYTES_PER_ELEMENT},triangleView:{offset:u,length:p.byteLength,count:l,stride:3*Uint32Array.BYTES_PER_ELEMENT}}}else n.vertexBundelIndices.length>1?console.warn(`Submesh ${r} has more than one vertex bundle, cache optimization is not supported.`):console.warn(`Submesh ${r} has no vertex bundle, cache optimization is not supported.`);else console.warn(`Submesh ${r} has no index buffer, meshlet optimization is not supported.`)}),o.length>0){const t=o.reduce((e,t)=>e+t.byteLength,0),i=s.reduce((e,t)=>e+t.byteLength,0),a=c.reduce((e,t)=>e+t.byteLength,0),f=new Uint8Array(e.data.byteLength+t+i+a);f.set(e.data);let u=e.data.byteLength;o.forEach(e=>{f.set(e,u),u+=e.byteLength}),s.forEach(e=>{f.set(e,u),u+=e.byteLength}),c.forEach(e=>{f.set(e,u),u+=e.byteLength}),r.forEach((n,r)=>{n.cluster&&(n.cluster.clusterView.offset+=e.data.byteLength,n.cluster.vertexView.offset+=e.data.byteLength+t,n.cluster.triangleView.offset+=e.data.byteLength+t+i)});const d=new cc_1.Mesh;d.reset({struct:n,data:f}),d.struct.cluster=!0;d.hash;return d}return e}function getDefaultSimplifyOptions(){return{enable:!0,targetRatio:.5,autoErrorRatio:!0,lockBoundary:!0}}async function simplifyMesh(e,t){if(await tryInitMeshOpt(),!t||!t.targetRatio)return e;if(!e.struct.primitives.every(e=>e.primitiveMode===cc_1.gfx.PrimitiveMode.TRIANGLE_LIST||e.primitiveMode===cc_1.gfx.PrimitiveMode.POINT_LIST))return console.warn("Only triangle list and point list are supported."),e;if(e.struct.compressed)return console.warn("Compressed mesh is not supported."),e;if(e.struct.cluster)return console.warn("Mesh cluster is not supported."),e;if(e.struct.quantized)return console.warn("Quantized mesh is not supported."),e;const n=t.lockBoundary?1:0,r=t.targetRatio,i=1-Math.pow(.9,-Math.log10(r)),o=t.autoErrorRate?i:t.errorRate||i,s=new gltf_converter_1.BufferBlob;s.setNextAlignment(0);const c=JSON.parse(JSON.stringify(e.struct)),a=c.primitives;for(let t=0;t<a.length;++t){const i=a[t];if(i.primitiveMode===cc_1.gfx.PrimitiveMode.TRIANGLE_LIST&&i.indexView){const a=i.indexView;let f,u=new Uint8Array(a.count*Uint32Array.BYTES_PER_ELEMENT),d=a.count;if(2===a.stride){f=new Uint8Array(u.buffer,0,a.count*Uint32Array.BYTES_PER_ELEMENT);const t=new Uint16Array(e.data.buffer,a.offset,a.count),n=new Uint32Array(f.buffer,0,a.count);for(let e=0;e<a.count;++e)n[e]=t[e]}else{if(4!==a.stride)return console.warn(`Submesh ${t} has unsupported index stride, simplify optimization is not supported.`),e;f=new Uint8Array(e.data.buffer,a.offset,a.count*Uint32Array.BYTES_PER_ELEMENT)}const l=i.vertexBundelIndices.findIndex(e=>{return c.vertexBundles[e].attributes.findIndex(e=>e.name===cc_1.gfx.AttributeName.ATTR_POSITION)>=0});if(l<0)return console.warn("No position attribute found, simplify optimization is not supported."),e;{const t=c.vertexBundles[i.vertexBundelIndices[l]],m=t.view,g=t.attributes,h=getOffset(g,g.findIndex(e=>e.name===cc_1.gfx.AttributeName.ATTR_POSITION)),_=new Uint8Array(e.data.buffer,m.offset,m.length),x=3*Math.floor(a.count*r/3),p=0;if(d=meshopt_encoder_1.default.optimizer.simplify(u,f,a.count,_.subarray(h),m.count,m.stride,x,o,n,p),u=new Uint8Array(u.buffer,0,d*Uint32Array.BYTES_PER_ELEMENT),1===i.vertexBundelIndices.length){let e=d<m.count?d:m.count,n=new Uint8Array(m.count*m.stride);e=meshopt_encoder_1.default.optimizer.optimizeVertexFetch(n,u,d,_,m.count,m.stride),n=new Uint8Array(n.buffer,0,e*m.stride),s.setNextAlignment(m.stride);const r={offset:s.getLength(),length:n.byteLength,count:e,stride:m.stride};t.view=r,s.addBuffer(n)}else{const t=new Uint8Array(d*Uint32Array.BYTES_PER_ELEMENT),n=meshopt_encoder_1.default.optimizer.optimizeVertexFetchRemap(t,u,d,m.count);meshopt_encoder_1.default.optimizer.optimizeRemapIndex(u,u,d,t);for(let r=0;r<i.vertexBundelIndices.length;++r){const o=c.vertexBundles[i.vertexBundelIndices[r]],a=o.view,f=new Uint8Array(e.data.buffer,a.offset,a.length),u=new Uint8Array(n*a.stride);meshopt_encoder_1.default.optimizer.optimizeRemapVertex(u,f,n,a.stride,t),s.setNextAlignment(a.stride);const d={offset:s.getLength(),length:u.byteLength,count:n,stride:a.stride};o.view=d,s.addBuffer(u)}}}s.setNextAlignment(Uint32Array.BYTES_PER_ELEMENT);const m={offset:s.getLength(),length:u.byteLength,count:d,stride:Uint32Array.BYTES_PER_ELEMENT};i.indexView=m,s.addBuffer(u)}else if(i.primitiveMode===cc_1.gfx.PrimitiveMode.POINT_LIST){if(1===i.vertexBundelIndices.length){const t=c.vertexBundles[i.vertexBundelIndices[0]],n=t.view,o=t.attributes,a=getOffset(o,o.findIndex(e=>e.name===cc_1.gfx.AttributeName.ATTR_POSITION)),f=new Uint8Array(e.data.buffer,n.offset,n.length),u=3*Math.floor(n.count*r/3);let d=new Uint8Array(u*n.stride);const l=meshopt_encoder_1.default.optimizer.simplifyPoints(d,f.subarray(a),n.count,n.stride,u);d=new Uint8Array(d.buffer,0,l*n.stride),s.setNextAlignment(n.stride);const m={offset:s.getLength(),length:d.byteLength,count:l,stride:n.stride};t.view=m,s.addBuffer(d)}else if(i.vertexBundelIndices.length>1)return console.warn(`Submesh ${t} has more than one vertex bundle, which is not supported.`),e}else{for(let t=0;t<i.vertexBundelIndices.length;++t){const n=c.vertexBundles[i.vertexBundelIndices[t]],r=n.view,o=new Uint8Array(e.data.buffer,r.offset,r.length);s.setNextAlignment(r.stride);const a={offset:s.getLength(),length:o.byteLength,count:r.count,stride:r.stride};n.view=a,s.addBuffer(o)}if(i.indexView){const t=i.indexView,n=new Uint8Array(e.data.buffer,t.offset,t.length);s.setNextAlignment(Uint32Array.BYTES_PER_ELEMENT);const r={offset:s.getLength(),length:n.byteLength,count:t.count,stride:Uint32Array.BYTES_PER_ELEMENT};i.indexView=r,s.addBuffer(n)}}}const f=new cc_1.Mesh;f.reset({struct:c,data:s.getCombined()});f.hash;return f}async function compressMesh(e,t){return await tryInitMeshOpt(),t?((null===t||void 0===t?void 0:t.quantize)&&(e=await quantizeMesh(e)),(null===t||void 0===t?void 0:t.encode)&&(e=await encodeMesh(e)),(null===t||void 0===t?void 0:t.compress)&&(e=await deflateMesh(e)),e):(console.warn("Mesh compression is not enabled, original mesh will be returned."),e)}async function encodeMesh(e){if(await tryInitMeshOpt(),e.struct.encoded)return e;const t=JSON.parse(JSON.stringify(e.struct)),n=new gltf_converter_1.BufferBlob;n.setNextAlignment(0);for(const r of t.vertexBundles){const t=r.view,i=new Uint8Array(e.data.buffer,t.offset,t.length),o=meshopt_encoder_1.default.optimizer.encodeVertexBufferBound(t.count,t.stride);let s=new Uint8Array(o);const c=meshopt_encoder_1.default.optimizer.encodeVertexBuffer(s,o,i,t.count,t.stride);s=new Uint8Array(s.buffer,0,c),n.setNextAlignment(t.stride);const a={offset:n.getLength(),length:s.byteLength,count:t.count,stride:t.stride};r.view=a,n.addBuffer(s)}for(const r of t.primitives){if(void 0===r.indexView)continue;const t=r.indexView;let i=new Uint8Array;if(2===t.stride){const n=new Uint16Array(e.data.buffer,t.offset,t.count),r=new Uint32Array(t.count*Uint32Array.BYTES_PER_ELEMENT);for(let e=0;e<t.count;++e)r[e]=n[e];i=new Uint8Array(r.buffer,0,t.count*Uint32Array.BYTES_PER_ELEMENT)}else 4===t.stride&&(i=new Uint8Array(e.data.buffer,t.offset,t.count*Uint32Array.BYTES_PER_ELEMENT));const o=meshopt_encoder_1.default.optimizer.encodeIndexBufferBound(t.count,t.count);let s=new Uint8Array(o);const c=meshopt_encoder_1.default.optimizer.encodeIndexBuffer(s,o,i,t.count);s=new Uint8Array(s.buffer,0,c),n.setNextAlignment(Uint32Array.BYTES_PER_ELEMENT);const a={offset:n.getLength(),length:s.byteLength,count:t.count,stride:Uint32Array.BYTES_PER_ELEMENT};r.indexView=a,n.addBuffer(s)}const r=new cc_1.Mesh;r.reset({struct:t,data:n.getCombined()}),r.struct.encoded=!0;r.hash;return r}exports.clusterizeMesh=clusterizeMesh,exports.getDefaultSimplifyOptions=getDefaultSimplifyOptions,exports.simplifyMesh=simplifyMesh,exports.compressMesh=compressMesh,exports.encodeMesh=encodeMesh;const quantizeConfiguration=new Map([[cc_1.gfx.AttributeName.ATTR_POSITION,{enum:0,size:6,format:cc_1.gfx.Format.RGB16F,origin:cc_1.gfx.Format.RGB32F}],[cc_1.gfx.AttributeName.ATTR_NORMAL,{enum:1,size:6,format:cc_1.gfx.Format.RGB16F,origin:cc_1.gfx.Format.RGB32F}],[cc_1.gfx.AttributeName.ATTR_TANGENT,{enum:2,size:8,format:cc_1.gfx.Format.RGBA16F,origin:cc_1.gfx.Format.RGBA32F}],[cc_1.gfx.AttributeName.ATTR_BITANGENT,{enum:2,size:8,format:cc_1.gfx.Format.RGBA16F,origin:cc_1.gfx.Format.RGBA32F}],[cc_1.gfx.AttributeName.ATTR_COLOR,{enum:3,size:4,format:cc_1.gfx.Format.RGBA8,origin:cc_1.gfx.Format.RGBA32F}],[cc_1.gfx.AttributeName.ATTR_COLOR1,{enum:3,size:4,format:cc_1.gfx.Format.RGBA8,origin:cc_1.gfx.Format.RGBA32F}],[cc_1.gfx.AttributeName.ATTR_COLOR2,{enum:3,size:4,format:cc_1.gfx.Format.RGBA8,origin:cc_1.gfx.Format.RGBA32F}],[cc_1.gfx.AttributeName.ATTR_JOINTS,{enum:4,size:16,format:cc_1.gfx.Format.RGBA32F,origin:cc_1.gfx.Format.RGBA32F}],[cc_1.gfx.AttributeName.ATTR_WEIGHTS,{enum:5,size:16,format:cc_1.gfx.Format.RGBA32F,origin:cc_1.gfx.Format.RGBA32F}],[cc_1.gfx.AttributeName.ATTR_TEX_COORD,{enum:6,size:4,format:cc_1.gfx.Format.RG16F,origin:cc_1.gfx.Format.RG32F}],[cc_1.gfx.AttributeName.ATTR_TEX_COORD1,{enum:6,size:4,format:cc_1.gfx.Format.RG16F,origin:cc_1.gfx.Format.RG32F}],[cc_1.gfx.AttributeName.ATTR_TEX_COORD2,{enum:6,size:4,format:cc_1.gfx.Format.RG16F,origin:cc_1.gfx.Format.RG32F}],[cc_1.gfx.AttributeName.ATTR_TEX_COORD3,{enum:6,size:4,format:cc_1.gfx.Format.RG16F,origin:cc_1.gfx.Format.RG32F}],[cc_1.gfx.AttributeName.ATTR_TEX_COORD4,{enum:6,size:4,format:cc_1.gfx.Format.RG16F,origin:cc_1.gfx.Format.RG32F}],[cc_1.gfx.AttributeName.ATTR_TEX_COORD5,{enum:6,size:4,format:cc_1.gfx.Format.RG16F,origin:cc_1.gfx.Format.RG32F}],[cc_1.gfx.AttributeName.ATTR_TEX_COORD6,{enum:6,size:4,format:cc_1.gfx.Format.RG16F,origin:cc_1.gfx.Format.RG32F}],[cc_1.gfx.AttributeName.ATTR_TEX_COORD7,{enum:6,size:4,format:cc_1.gfx.Format.RG16F,origin:cc_1.gfx.Format.RG32F}],[cc_1.gfx.AttributeName.ATTR_TEX_COORD8,{enum:6,size:4,format:cc_1.gfx.Format.RG16F,origin:cc_1.gfx.Format.RG32F}],[cc_1.gfx.AttributeName.ATTR_BATCH_ID,{enum:7,size:4,format:cc_1.gfx.Format.R32F,origin:cc_1.gfx.Format.R32F}],[cc_1.gfx.AttributeName.ATTR_BATCH_UV,{enum:8,size:8,format:cc_1.gfx.Format.RG32F,origin:cc_1.gfx.Format.RG32F}]]);function quantizeSize(e){let t=0;for(let n=0;n<e.length;++n){const r=e[n],i=r.name,o=quantizeConfiguration.get(i);if(void 0===o)return void console.log(`Attribute ${i} is not supported for quantization.`);if(t+=o.size,o.origin!==r.format)return void console.warn(`Attribute ${i} has different format from origin, quantization may not work.`);r.format=o.format}return t}function mapAttribute(e){return e.map(e=>{const t=e.name,n=quantizeConfiguration.get(t);return void 0===n&&console.error(`Attribute ${t} is not supported for quantization.`),n.enum})}async function quantizeMesh(e){if(e.struct.quantized)return e;const t=new gltf_converter_1.BufferBlob;t.setNextAlignment(0);const n=JSON.parse(JSON.stringify(e.struct));for(let r=0;r<n.vertexBundles.length;++r){const i=n.vertexBundles[r],o=i.view,s=JSON.parse(JSON.stringify(i.attributes)),c=quantizeSize(s);if(!c)return e;const a=new Uint8Array(e.data.buffer,o.offset,o.length),f=mapAttribute(s),u=new Uint8Array(c*o.count);meshopt_encoder_1.default.optimizer.quantizeMesh(u,u.byteLength,a,o.count,o.stride,Uint32Array.from(f),f.length),t.setNextAlignment(c);const d={offset:t.getLength(),length:u.byteLength,count:o.count,stride:c};i.view=d,i.attributes=s,t.addBuffer(u)}for(let r=0;r<n.primitives.length;++r){const i=n.primitives[r];if(void 0===i.indexView)continue;const o=i.indexView,s=new Uint8Array(e.data.buffer,o.offset,o.length);t.setNextAlignment(o.stride);const c={offset:t.getLength(),length:s.byteLength,count:o.count,stride:o.stride};i.indexView=c,t.addBuffer(s)}const r=new cc_1.Mesh;r.reset({struct:n,data:t.getCombined()}),r.struct.quantized=!0;r.hash;return r}async function deflateMesh(e){if(e.struct.compressed)return e;const t=(n=e.data,zlib_1.default.deflateSync(n));var n;const r=JSON.parse(JSON.stringify(e.struct));r.compressed=!0;const i=new cc_1.Mesh;i.reset({struct:r,data:t});i.hash;return i}exports.quantizeMesh=quantizeMesh,exports.deflateMesh=deflateMesh;