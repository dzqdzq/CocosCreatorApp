"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.mergeMeshes=void 0;const cc_1=require("cc");function mergeMeshes(e=[]){var t,n,r,s,o,i;if(0===e.length)return console.warn("mergeMeshes: meshes is empty"),new cc_1.Mesh;if(1===e.length)return e[0];if(e.every(e=>e.struct.compressed))return new cc_1.Mesh;if(!(e=>{const t=e.map(e=>e.struct.encoded),n=e.map(e=>e.struct.compressed),r=e.map(e=>e.struct.quantized);if(t.every(e=>void 0===e)&&n.every(e=>void 0===e)&&r.every(e=>void 0===e))return!0;const s=t[0];for(let e=1;e<t.length;e++)if(t[e]!==s)return!1;const o=n[0];for(let e=1;e<n.length;e++)if(n[e]!==o)return!1;const i=r[0];for(let e=1;e<r.length;e++)if(r[e]!==i)return!1;return!0})(e))return console.warn("mergeMeshes: encoded state is not the same"),new cc_1.Mesh;if(!(e=>{const t=e.map(e=>e.struct.jointMaps);if(t.every(e=>void 0===e))return!0;const n=t[0],r=n.length;for(let e=1;e<t.length;e++){const s=t[e];if(s.length!==r)return!1;for(let e=0;e<s.length;e++){const t=n[e].length;if(s[e].length!==t)return!1;for(let r=0;r<t;r++)if(s[e][r]!==n[e][r])return!1}}return!0})(e))return console.warn("mergeMeshes: jointMap is not the same"),new cc_1.Mesh;if(!(e=>{return!!e.map(e=>e.struct.morph).every(e=>void 0===e)})(e))return console.warn("mergeMeshes: morph is not supported"),new cc_1.Mesh;const c=e.reduce((e,t)=>e+t.data.byteLength,0),u=new Uint8Array(c),d=[],a=[];let m=0,h=0;const l=e[0].struct.minPosition||new cc_1.Vec3(1e9),v=e[0].struct.maxPosition||new cc_1.Vec3(-1e9);for(let c=0;c<e.length;c++){const p=e[c],f=p.data;u.set(f,m),d.push(...p.struct.vertexBundles.map(e=>{const t=e;return t.view.offset+=m,t})),a.push(...p.struct.primitives.map(e=>{const t=e;return t.vertexBundelIndices=e.vertexBundelIndices.map(e=>e+h),t.indexView&&(t.indexView.offset+=m),t})),m+=f.byteLength,h+=p.struct.vertexBundles.length,l.x=Math.min(l.x,(null===(t=p.struct.minPosition)||void 0===t?void 0:t.x)||1e9),l.y=Math.min(l.y,(null===(n=p.struct.minPosition)||void 0===n?void 0:n.y)||1e9),l.z=Math.min(l.z,(null===(r=p.struct.minPosition)||void 0===r?void 0:r.z)||1e9),v.x=Math.max(v.x,(null===(s=p.struct.maxPosition)||void 0===s?void 0:s.x)||-1e9),v.y=Math.max(v.y,(null===(o=p.struct.maxPosition)||void 0===o?void 0:o.y)||-1e9),v.z=Math.max(v.z,(null===(i=p.struct.maxPosition)||void 0===i?void 0:i.z)||-1e9)}const p={struct:{vertexBundles:d,primitives:a,minPosition:l,maxPosition:v,jointMaps:e[0].struct.jointMaps,dynamic:e[0].struct.dynamic,compressed:e[0].struct.compressed,quantized:e[0].struct.quantized,encoded:e[0].struct.encoded},data:u},f=new cc_1.Mesh;return f.reset(p),f.hash,f}exports.mergeMeshes=mergeMeshes;