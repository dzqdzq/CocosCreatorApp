"use strict";var __importDefault=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(exports,"__esModule",{value:!0}),exports.decodeDracoGeometry=void 0;const draco3dgltf_1=__importDefault(require("draco3dgltf")),decoderModule=draco3dgltf_1.default.createDecoderModule({});function decodeDracoGeometry(e){const r=new decoderModule.Decoder,t=decodeDracoData(e.buffer,r,e);return decoderModule.destroy(r),t}function decodeDracoData(e,r,t){const o=new decoderModule.DecoderBuffer;o.Init(new Int8Array(e),e.byteLength);const d=r.GetEncodedGeometryType(o);let n,c;switch(d){case decoderModule.TRIANGULAR_MESH:n=new decoderModule.Mesh,c=r.DecodeBufferToMesh(o,n);break;case decoderModule.POINT_CLOUD:n=new decoderModule.PointCloud,c=r.DecodeBufferToPointCloud(o,n);break;default:throw new Error(`Unknown geometry type ${d}.`)}if(!c.ok()||0===n.ptr)throw new Error(`Decoding failed: ${c.error_msg()}`);const a={vertices:decodeAttributes(n,r,t)};if(d===decoderModule.TRIANGULAR_MESH&&t.indices){const e=decodeIndices(n,r,t.indices);a.indices=e}return decoderModule.destroy(n),decoderModule.destroy(o),a}function decodeAttributes(e,r,t){const o=e.num_points(),d={};for(const n of Object.keys(t.attributes)){const{uniqueId:c,storageConstructor:a,components:u}=t.attributes[n],s=u*o,i=r.GetAttributeByUniqueId(e,c);if(i.num_components()!==u)throw new Error(`Decompression error: components-per-attribute of ${n} mismatch.`);let l;switch(a){case Float32Array:l=new decoderModule.DracoFloat32Array,r.GetAttributeFloatForAllPoints(e,i,l);break;case Int8Array:l=new decoderModule.DracoInt8Array,r.GetAttributeInt8ForAllPoints(e,i,l);break;case Int16Array:l=new decoderModule.DracoInt16Array,r.GetAttributeInt16ForAllPoints(e,i,l);break;case Int32Array:l=new decoderModule.DracoInt32Array,r.GetAttributeInt32ForAllPoints(e,i,l);break;case Uint8Array:l=new decoderModule.DracoUInt8Array,r.GetAttributeUInt8ForAllPoints(e,i,l);break;case Uint16Array:l=new decoderModule.DracoUInt16Array,r.GetAttributeUInt16ForAllPoints(e,i,l);break;case Uint32Array:l=new decoderModule.DracoUInt32Array,r.GetAttributeUInt32ForAllPoints(e,i,l);break;default:throw new Error("THREE.DRACOLoader: Unexpected attribute type.")}if(s!==l.size())throw new Error(`Decompression error: ${n} data size mismatch.`);const A=new a(s);for(let e=0;e<s;++e)A[e]=l.GetValue(e);d[n]=A,decoderModule.destroy(l)}return d}function decodeIndices(e,r,t){const o=e.num_faces(),d=new t(3*o),n=new decoderModule.DracoInt32Array;for(let t=0;t<o;++t){r.GetFaceFromMesh(e,t,n);const o=3*t;d[o]=n.GetValue(0),d[o+1]=n.GetValue(1),d[o+2]=n.GetValue(2)}return decoderModule.destroy(n),d}exports.decodeDracoGeometry=decodeDracoGeometry;