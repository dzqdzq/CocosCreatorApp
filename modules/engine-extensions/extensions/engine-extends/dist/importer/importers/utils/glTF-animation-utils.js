"use strict";var __createBinding=this&&this.__createBinding||(Object.create?function(t,n,e,a){void 0===a&&(a=e),Object.defineProperty(t,a,{enumerable:!0,get:function(){return n[e]}})}:function(t,n,e,a){void 0===a&&(a=e),t[a]=n[e]}),__setModuleDefault=this&&this.__setModuleDefault||(Object.create?function(t,n){Object.defineProperty(t,"default",{enumerable:!0,value:n})}:function(t,n){t.default=n}),__importStar=this&&this.__importStar||function(t){if(t&&t.__esModule)return t;var n={};if(null!=t)for(var e in t)"default"!==e&&Object.prototype.hasOwnProperty.call(t,e)&&__createBinding(n,t,e);return __setModuleDefault(n,t),n};Object.defineProperty(exports,"__esModule",{value:!0}),exports.GlTFTrsTrackData=exports.GlTFTrsAnimationData=void 0;const glTF_constants_1=require("./glTF.constants"),cc=__importStar(require("cc")),exotic_animation_1=require("cc/editor/exotic-animation");class GlTFTrsAnimationData{constructor(){this.nodes={},this.inputs=[]}addNodeAnimation(t){var n,e;return null!==(n=(e=this.nodes)[t])&&void 0!==n?n:e[t]=new GlTFNodeTrsAnimationData}createExotic(){const t=new exotic_animation_1.ExoticAnimation;for(const[n,e]of Object.entries(this.nodes))e.emitExotic(t,n);return t}}exports.GlTFTrsAnimationData=GlTFTrsAnimationData;const INPUT_0=new Float32Array([0]);class GlTFNodeTrsAnimationData{constructor(){this.position=null,this.rotation=null,this.scale=null}setConstantPosition(t){this.position=new GlTFTrsTrackData(glTF_constants_1.GlTfAnimationInterpolation.STEP,INPUT_0,cc.Vec3.toArray(new Float32Array(3),t))}setConstantRotation(t){this.rotation=new GlTFTrsTrackData(glTF_constants_1.GlTfAnimationInterpolation.STEP,INPUT_0,cc.Quat.toArray(new Float32Array(4),t))}setConstantScale(t){this.scale=new GlTFTrsTrackData(glTF_constants_1.GlTfAnimationInterpolation.STEP,INPUT_0,cc.Vec3.toArray(new Float32Array(3),t))}emitExotic(t,n){const{position:e,rotation:a,scale:o}=this;if(!e&&!a&&!o)return;const r=t.addNodeAnimation(n);if(e){const{input:t,output:n}=e.toLinearVec3Curve(30);r.createPosition(t,n)}if(a){const{input:t,output:n}=a.toLinearQuatCurveNormalized(30);r.createRotation(t,n)}if(o){const{input:t,output:n}=o.toLinearVec3Curve(30);r.createScale(t,n)}}}class GlTFTrsTrackData{constructor(t,n,e){this.interpolation=t,this.input=n,this.output=e}toLinearVec3Curve(t){switch(this.interpolation){case glTF_constants_1.GlTfAnimationInterpolation.CUBIC_SPLINE:return cubicSplineToLinearCurveData(this.input,this.output,3,t);case glTF_constants_1.GlTfAnimationInterpolation.STEP:return constantToLinearCurveData(this.input,this.output,3,t);default:return{input:this.input,output:this.output}}}toLinearQuatCurveNormalized(t){const n=this.toLinearQuatCurve(t),{output:e}=n,a=new cc.Quat;for(let t=0;t<e.length/4;++t)cc.Quat.fromArray(a,e,4*t),cc.Quat.normalize(a,a),cc.Quat.toArray(e,a,4*t);return n}toLinearQuatCurve(t){switch(this.interpolation){case glTF_constants_1.GlTfAnimationInterpolation.CUBIC_SPLINE:return cubicSplineToLinearCurveData(this.input,this.output,4,t);case glTF_constants_1.GlTfAnimationInterpolation.STEP:return constantToLinearCurveData(this.input,this.output,4,t);default:return{input:this.input,output:this.output}}}}function calculateBakeParams(t,n){const e=t[0],a=t[t.length-1],o=1/n;return{startTime:e,endTime:a,interval:o,count:(a-e)/o}}function createTimesFromBakeParams(t,n){const{startTime:e,endTime:a,interval:o,count:r}=t;return n.from({length:r},(t,n)=>n===r-1?a:e+o*n)}function constantToLinearCurveData(t,n,e,a){if(t.length<2)return{input:t,output:n};const o=n.length/e,r=calculateBakeParams(t,a),i=new Float32Array(e*r.count);for(let a=0;a<e;++a){const s=new cc.RealCurve;s.assignSorted(Array.from(t),Array.from({length:o},(t,o)=>({value:n[e*o+a],interpolationMode:cc.RealInterpolationMode.CONSTANT}))),bake(s,r,i,e,a)}return{input:createTimesFromBakeParams(r,Float32Array),output:i}}function cubicSplineToLinearCurveData(t,n,e,a){if(t.length<2)return{input:t,output:n};const o=n.length/(3*e),r=calculateBakeParams(t,a),i=new Float32Array(e*r.count);for(let a=0;a<e;++a){const s=new cc.RealCurve;s.assignSorted(Array.from(t),Array.from({length:o},(t,o)=>{const r=3*e*o+a,i=n[r+0*e];return{value:n[r+1*e],leftTangent:i,rightTangent:n[r+2*e],interpolationMode:cc.RealInterpolationMode.CUBIC}})),bake(s,r,i,e,a)}return{input:createTimesFromBakeParams(r,Float32Array),output:i}}function bake(t,n,e,a,o){const{startTime:r,endTime:i,interval:s,count:u}=n;let c=r;for(let n=0;n<u;++n,c+=s){const r=t.evaluate(n===u-1?i:c);e[a*n+o]=r}}exports.GlTFTrsTrackData=GlTFTrsTrackData;