"use strict";const tokenizer=require("glsl-tokenizer/string"),parser=require("glsl-parser/direct"),mappings=require("./offline-mappings"),yaml=require("js-yaml"),tabAsSpaces=2,plainDefineRE=/#define\s+(\w+)/g,effectDefineRE=/#pragma\s+define\s+(\w+)\s+(.*)\n/g,ident=/[_a-zA-Z]\w*/g,labelRE=/(\w+)\((.*?)\)/,locationRE=/location\s*=\s*(\d+)/,inDecl=/(?:layout\s*\((.*?)\)\s*)?in ((?:\w+\s+)?\w+\s+(\w+)\s*(?:\[[\d\s]+])?)\s*;/g,outDecl=/(?:layout\s*\((.*?)\)\s*)?(?<=\b)out ((?:\w+\s+)?\w+\s+(\w+)\s*(?:\[[\d\s]+])?)\s*;/g,layoutExtract=/layout\s*\((.*?)\)(\s*)$/,bindingExtract=/(?:location|binding)\s*=\s*(\d+)/,builtinRE=/^cc\w+$/i,pragmasToStrip=/^\s*(?:#pragma\s*)(?!STDGL|optimize|debug).*$\n/gm;let effectName="",shaderName="",shaderTokens=[];const formatMsg=(e,t)=>`${effectName}.effect - ${shaderName}`+(void 0!==t?` - ${t}: `:": ")+e,options={throwOnError:!0,throwOnWarning:!1,noSource:!1,skipParserTest:!1,chunkSearchFn:e=>({}),getAlternativeChunkPaths:e=>[]},dumpSource=e=>{let t=0;return e.reduce((e,n)=>n.line>t?e+`\n${t=n.line}\t${n.data.replace(/\n/g,"")}`:e+n.data,"")},throwFnFactory=(e,t)=>(n,r)=>{options.noSource&&(r=void 0);let s=void 0!==r?" ↓↓↓↓↓ EXPAND THIS MESSAGE FOR MORE INFO ↓↓↓↓↓"+dumpSource(shaderTokens)+"\n":"";const i=formatMsg(e+" "+n,r)+s;if(options.throwOnWarning)throw i;t(i)},warn=throwFnFactory("Warning",console.warn),error=throwFnFactory("Error",console.error),convertType=e=>{let t=mappings.typeMap[e];return void 0===t?e:t},VSBit=mappings.getShaderStage("vertex"),FSBit=mappings.getShaderStage("fragment"),stripComments=(()=>{const e=/\r\n/g,t=/\/\*.*?\*\//gs,n=/\s*\/\/.*$/gm;return r=>{let s=r.replace(t,"");return s=(s=s.replace(n,"")).replace(e,"\n")}})(),globalChunks={},globalDeprecations={chunks:{},identifiers:{}},addChunk=(()=>{const e=/#pragma\s+deprecate-(chunk|identifier)\s+([\w-]+)(?:\s+(.*))?/g;return(t,n,r=globalChunks,s=globalDeprecations)=>{const i=stripComments(n);let a=e.exec(i),o="",l=0;for(;a;){const t=`${a[1]}s`;s[t]||(s[t]={}),s[t][a[2]]=a[3],o+=i.slice(l,a.index),l=a.index+a[0].length,a=e.exec(i)}r[t]=o+i.slice(l)}})(),invokeSearch=e=>{const{name:t,content:n}=options.chunkSearchFn(e);return void 0!==n?(addChunk(t,n),t):""},unwindIncludes=(()=>{const e=/^(.*)#include\s+[<"]([^>"]+)[>"](.*)$/gm;let t;return(n,r,s,i=new Set)=>{if(t=((n,r,s)=>(i,a,o,l)=>{(o=o.trim()).endsWith(".chunk")&&(o=o.slice(0,-6));const c=o;if(s.has(o))return"";void 0!==r[o]&&error(`EFX2003: header '${o}' is deprecated: ${r[o]}`);let p=void 0;do{if(void 0!==(p=n[o]))break;const e=options.getAlternativeChunkPaths(o);if(e.some(e=>void 0!==n[e]&&(o=e,p=n[e],!0)))break;if(o=invokeSearch([].concat(o,e)),void 0!==(p=globalChunks[o]))break;return error(`EFX2001: can not resolve '${c}'`),""}while(0);return s.add(o),a&&(p=p.replace(/^/gm,a)),l&&(p=p.replace(/\n/g,l+"\n")+l),p=p.replace(e,t)})(r,s.chunks,i),n=n.replace(e,t),s.identifierRE){let e=s.identifierRE.exec(n);for(;e;){const t=s.identifiers[e[1]];t&&error(`EFX2004: identifier '${e[1]}' is deprecated: ${t}`),e=s.identifierRE.exec(n)}}return n}})(),expandFunctionalMacro=(()=>{const e=(e,t)=>{if("("!==e[t])return t;let n=1,r=t+1;for(;r<e.length&&("("===e[r]&&n++,")"===e[r]&&n--,0!==n);r++);return r},t=t=>{const n=[];let r=0;for(let s=0;s<t.length;s++)"("===t[s]&&(s=e(t,s)+1),","===t[s]&&(n.push(t.substring(r,s).trim()),r=s+1);return r===t.length&&","!==t[t.length-1]||n.push(t.substring(r).trim()),n},n=/#pragma\s+define\s+(\w+)\(([\w,\s]*)\)\s+(.*?)\n/g,r=/(?<=\w)##(?=\w)/g,s=/\\\s*?\n/g,i=/@@/g,a=/#pragma\s+define|#define/;return o=>{o=o.replace(s,"@@");let l=n.exec(o);for(;null!==l;){const s=l[1],c=t(l[2]),p=l[3],d=l.index,f=l.index+l[0].length,u=new RegExp("^(.*?)"+s+"\\s*\\(","gm");if(new RegExp("\\b"+s+"\\b").test(p))warn(`EFX2002: recursive macro processor '${s}'`);else for(let n=u.exec(o);null!==n;n=u.exec(o)){const l=n.index+n[0].length-1;if(l>d&&l<f)continue;const g=n[1],m=n.index+g.length,b=e(o,l)+1,h=t(o.slice(n.index+n[0].length,b-1));h.length!==c.length&&warn(`EFX2005: not enough arguments for function-like macro invocation '${s}'`);let y=[];for(let e=0;e<c.length;e++){const t=new RegExp("\\b"+c[e]+"\\b","g");let n;for(;null!==(n=t.exec(p));)y.push({beg:n.index,end:t.lastIndex,target:h[e]})}let x="",E=0;for(const e of y.sort((e,t)=>e.beg-t.beg))x+=p.slice(E,e.beg)+e.target,E=e.end;if(x+=p.slice(E,p.length),a.test(g)){let e=g.lastIndexOf("@@"),t=e<0?g:g.slice(e+2),n=t.search(/\S/);n<0&&(n=t.length),x=x.replace(i,"@@"+" ".repeat(n))}else{let e=g.search(/\S/);e<0&&(e=g.length),x=(x=x.replace(r,"")).replace(i,"\n"+" ".repeat(e))}o=o.substring(0,m)+x+o.substring(b),u.lastIndex-=n[0].length}o=o.substring(0,d)+o.substring(f),n.lastIndex=0,l=n.exec(o)}return o.replace(i,"\\\n"),o}})(),expandLiteralMacro=e=>{const t={};let n=effectDefineRE.exec(e);for(;null!==n;){let r=n[2];r.endsWith("\\")&&(r=r.slice(0,-1)),t[n[1]]=r.trim();const s=n.index,i=n.index+n[0].length;e=e.substring(0,s)+e.substring(i),effectDefineRE.lastIndex=s,n=effectDefineRE.exec(e)}const r=Object.keys(t).map(e=>new RegExp(`\\b${e}\\b`,"g")),s=Object.values(t);for(let t=0;t<s.length;t++){let n=s[t];for(let e=0;e<t;e++)n=n.replace(r[e],s[e]);e=e.replace(r[t],n)}return e},extractMacroDefinitions=e=>{const t=new Set;let n=plainDefineRE.exec(e);for(;null!==n;)t.add(n[1]),n=plainDefineRE.exec(e);return t},eliminateDeadCode=(()=>{const e=/[{}()]/g,t=/(?:\w+p\s+)?\w+\s+(\w+)\s*$/,n=/^\s*$/;let r="",s=0,i=0;const a=(e,n)=>{const a=e.substring(i,n).match(t)||["",""];r=a[1],s=n-a[0].length},o=(e,t)=>{const n=[];let r=t.exec(e);for(;r;)n.push(r),r=t.exec(e);return n},l=new Set,c=(e,t)=>{if(!l.has(t)){l.add(t);for(const n of e[t].deps)c(e,n)}};return(t,p,d)=>{let f=0,u=0,g=0;i=0,e.lastIndex=0,l.clear();const m=[];for(const l of o(t,e)){const e=l[0];if(0===f&&("("===e?(u=1,a(t,l.index)):")"===e?1===u?(u=2,g=l.index+1):u=0:"{"===e&&(u=2===u&&n.test(t.substring(g,l.index))?3:0)),"{"===e&&f++,"}"===e&&0==--f){if(3!==u)continue;i=l.index+1,u=0,r&&m.push({name:r,beg:s,end:i,paramListEnd:g,deps:[]})}}let b=m.findIndex(e=>e.name===p);b<0&&(error(`EFX2403: entry function '${p}' not found.`),b=0);for(let e=0;e<m.length;e++){const n=m[e],r=o(t,new RegExp("\\b"+n.name+"\\b","g"));for(const t of r){const n=m.findIndex(e=>t.index>e.beg&&t.index<e.end);n>=0&&n!==e&&m[n].deps.push(e)}}c(m,b);let h="",y=0,x=0;for(let e=0;e<m.length;e++){const n=m[e],{name:r,beg:s,end:i}=n;l.has(e)||"main"===r?(n.beg-=x,n.end-=x,n.paramListEnd-=x,d.push(n)):(h+=t.substring(y,s),y=i,x+=i-s)}return h+t.substring(y)}})(),parseCustomLabels=(e,t={})=>{let n=e.join(" "),r=labelRE.exec(n);for(;r;){try{t[r[1]]=yaml.load(r[2]||"true")}catch(e){warn(`EFX2102: parameter for label '${r[1]}' is not legal YAML: ${e.message}`)}n=n.substring(r.index+r[0].length),r=labelRE.exec(n)}return t},getDefs=(e,t)=>{let n=t.lines.findIndex(t=>t>e);return n<0&&(n=t.lines.length),t[t.lines[n-1]]||[]},pushDefines=(e,t,n)=>{t.has(n.name)||e.push(n)},extractDefines=(e,t,n)=>{let r=[],s=e=>{n[e]=r.reduce((e,t)=>e.concat(t),[]),n.lines.push(e)},i=0;for(let a=0;a<e.length;a++){let o,l,c=e[a],p=c.data;if("preprocessor"!==c.type||p.startsWith("#extension"))continue;if("#endif"===(p=p.split(/\s+/))[0]){for(;i>0;)r.pop(),i--;r.pop(),s(c.line);continue}if("#else"===p[0]||"#elif"===p[0]){const e=r[r.length-1];if(e&&e.forEach((t,n)=>e[n]="!"===t[0]?t.slice(1):"!"+t),s(c.line),"#else"===p[0])continue;i++}else{if("#pragma"===p[0]){if(p.length<=1)continue;if("define-meta"===p[1]){if(p.length<=2){warn("EFX2101: define pragma: missing info",c.line);continue}if(ident.lastIndex=0,!ident.test(p[2]))continue;let e=r.reduce((e,t)=>e.concat(t),[]),s=t.find(e=>e.name===p[2]);s||pushDefines(t,n.existingDefines,s={name:p[2],type:"boolean",defines:e,dummyDependency:!0});const i=parseCustomLabels(p.splice(3));for(const e in i)if("range"===e)s.type="number",s.range=[0,3],s.fixedType=!0,Array.isArray(i.range)?s.range=i.range:warn(`EFX2103: invalid range for macro '${s.name}'`,c.line);else if("options"===e)s.type="string",s.options=[],s.fixedType=!0,Array.isArray(i.options)?s.options=i.options:warn(`EFX2104: invalid options for macro '${s.name}'`,c.line);else if("default"===e)s.type="constant",s.default=i.default,s.fixedType=!0;else{if("editor"!==e){warn(`EFX2105: define pragma: illegal label '${e}'`,c.line);continue}s.editor=i.editor}}else if("warning"===p[1])warn(`EFX2107: ${p.slice(2).join(" ")}`);else if("error"===p[1])error(`EFX2108: ${p.slice(2).join(" ")}`);else{const e=parseCustomLabels(p.slice(1));e.extension?n.extensions[e.extension[0]]={defines:getDefs(c.line,n),cond:e.extension[1],level:e.extension[2],runtimeCond:e.extension[3]}:n[c.line]=e}continue}if(!/#(el)?if$/.test(p[0]))continue}let d=[];p.splice(1).some(e=>{if(ident.lastIndex=0,o=ident.exec(e)){if("defined"===o[0]||o[0].startsWith("__")||o[0].startsWith("GL_")||"VULKAN"===o[0])return!1;let s=r.reduce((e,t)=>e.concat(t),d.slice());if(l=t.find(e=>e.name===o[0])){let e=s.length<l.defines.length;l.dummyDependency&&(e=!0,delete l.dummyDependency),e&&(l.defines=s)}else pushDefines(t,n.existingDefines,l={name:o[0],type:"boolean",defines:s});d.push(("!"===e[0]?"!":"")+o[0])}else if(l&&/^[<=>]+$/.test(e)&&!l.fixedType)l.type="number",l.range=[0,3];else if("||"===e)return d=[],!0;return!1}),r.push(d),s(c.line)}t.forEach(e=>(delete e.fixedType,delete e.dummyDependency))},extractParams=(()=>{const precision=/(low|medium|high)p/,extractInfo=(tokens,i)=>{const param={},definedPrecision=precision.exec(tokens[i].data);let offset=definedPrecision?2:0;if(param.name=tokens[i+offset+2].data,param.typename=tokens[i+offset].data,param.type=convertType(tokens[i+offset].data),param.count=1,definedPrecision&&(param.precision=definedPrecision[0]+" "),"["===tokens[offset=nextWord(tokens,i+offset+2)].data){let expr="",end=offset;for(;"]"!==tokens[++end].data;)expr+=tokens[end].data;try{if(/^[\d+\-*/%\s]+$/.test(expr))param.count=eval(expr);else{if(!builtinRE.test(param.name))throw expr;param.count=expr}param.isArray=!0}catch(e){error(`EFX2202: ${param.name}: non-builtin array length must be compile-time constant: ${e}`,tokens[offset].line)}}return param},stripDuplicates=e=>{const t={};return e.filter(e=>!t[e]&&(t[e]=!0))},exMap={whitespace:!0},nextWord=(e,t)=>{do{++t}while(exMap[e[t].type]);return t},nextSemicolon=(e,t,n=(e=>{}))=>{for(;";"!==e[t].data;)n(e[t++]);return t},isFunctionParameter=(e,t)=>e.some(e=>t>e.beg&&t<e.paramListEnd),nonBlockUniforms=/texture|sampler|image|subpassInput/;return(e,t,n,r,s)=>{const i=[];for(let a=0;a<e.length;a++){let o,l,c=e[a],p=c.data;if("uniform"===p)o=n.blocks,l="blocks";else if("in"!==p||isFunctionParameter(s,c.position))if("out"!==p||isFunctionParameter(s,c.position)){if("buffer"!==p)continue;o=n.buffers,l="buffers"}else o=r?n.varyings:n.fragColors,l=r?"varyings":"fragColors";else o=r?n.attributes:n.varyings,l=r?"attributes":"varyings";let d=getDefs(c.line,t),f={};f.tags=t[c.line-1];let u=nextWord(e,a+2);if("{"!==e[u].data){if(Object.assign(f,extractInfo(e,a+2)),o===n.blocks){const t=e[a+(f.precision?4:2)].data,r=nonBlockUniforms.exec(t);r?"sampler"===t?(o=n.samplers,l="samplers"):"sampler"===r[0]?(o=n.samplerTextures,l="samplerTextures"):"texture"===r[0]?(o=n.textures,l="textures"):"image"===r[0]?(o=n.images,l="images"):"subpassInput"===r[0]&&(o=n.subpassInputs,l="subpassInputs"):error("EFX2201: vector uniforms must be declared in blocks.",c.line)}u=nextSemicolon(e,u)}else{for(f.name=e[a+2].data,f.members=[];"}"!==e[u=nextWord(e,u)].data;){if(o!==n.buffers){const t=extractInfo(e,u);mappings.isSampler(t.type)&&error("EFX2208: texture uniforms must be declared outside blocks.",e[u].line),f.members.push(t)}u=nextSemicolon(e,u)}f.members.reduce((e,t)=>{let n=mappings.GetTypeSize(t.type);switch(t.typename){case"mat2":n/=2;break;case"mat3":n/=3;break;case"mat4":n/=4}if(t.count>1&&n<16){const e=`uniform ${convertType(t.type)} ${t.name}[${t.count}]`;error("EFX2203: "+e+": array UBO members need to be 16-bytes-aligned to avoid implicit padding"),n=16}else if(12===n){const e=`uniform ${convertType(t.type)} ${t.name}`;error("EFX2204: "+e+": please use 1, 2 or 4-component vectors to avoid implicit padding"),n=16}else if(mappings.isPaddedMatrix(t.type)){const e=`uniform ${convertType(t.type)} ${t.name}`;error("EFX2210: "+e+": use only 4x4 matrices to avoid implicit padding")}const r=Math.ceil(e/n)*n,s=r-e;return s&&error(`EFX2205: UBO '${f.name}' introduces implicit padding: `+`${s} bytes before '${t.name}', consider re-ordering the members`),r+n*t.count},0);let r=t.lines.find(t=>t>=e[a].line&&t<e[u].line);r&&error(`EFX2206: ${f.name}: no preprocessors allowed inside uniform blocks!`,r),f.members.forEach(t=>{"string"==typeof t.type&&error(`EFX2211: '${t.type} ${t.name}' in block '${f.name}': `+"struct-typed member within UBOs is not supported due to compatibility reasons.",e[u].line)}),u=nextWord(e,u),";"!==e[u].data&&error("EFX2209: Block declarations must be semicolon-terminated，non-array-typed and instance-name-free. "+`Please check your '${f.name}' block declaration.`,e[u].line)}let g=o.find(e=>e.name===f.name);g&&(f.members&&JSON.stringify(g.members)!==JSON.stringify(f.members)&&error(`EFX2207: different UBO using the same name '${f.name}'`,c.line),g.stageFlags|=r?VSBit:FSBit,f.duplicate=g);let m=a;o!==n.buffers&&o!==n.images||(f.memoryAccess=mappings.getMemoryAccessFlag(e[a-2].data),/writeonly|readonly/.test(e[a-2].data)&&(m=a-2)),i.push({beg:e[m].position,end:e[u].position,param:f.duplicate||f,type:l}),f.duplicate||(f.defines=stripDuplicates(d),f.stageFlags=r?VSBit:FSBit,o.push(f)),a=u}return i}})(),miscChecks=(()=>{const e=new RegExp("\\b(?:asm|class|union|enum|typedef|template|this|packed|goto|switch|default|inline|noinline|volatile|public|static|extern|external|interface|flat|long|short|double|half|fixed|unsigned|superp|input|output|hvec2|hvec3|hvec4|dvec2|dvec3|dvec4|fvec2|fvec3|fvec4|sampler1D|sampler3D|sampler1DShadow|sampler2DShadow|sampler2DRect|sampler3DRect|sampler2DRectShadow|sizeof|cast|namespace|using|texture)\\b"),t=/precision\s+(low|medium|high)p\s+(\w+)/;return n=>{const r=t.exec(n);r?/#extension/.test(n.slice(r.index))&&warn("EFX2400: precision declaration should come after extensions"):warn("EFX2401: precision declaration not found.");const s=e.exec(n);if(s&&error(`EFX2402: using reserved keyword in glsl1: ${s[0]}`),options.skipParserTest)return;const i=tokenizer(n).filter(e=>"preprocessor"!==e.type);shaderTokens=i;try{parser(i)}catch(e){error(`EFX2404: glsl1 parser failed: ${e}`,0)}}})(),finalTypeCheck=(()=>{let e=null,t=!0;const n=(t,n)=>{let r=e.createShader(n);if(e.shaderSource(r,t),e.compileShader(r),!e.getShaderParameter(r,e.COMPILE_STATUS)){let n=1;const s=t.replace(/^|\n/g,()=>`\n${n++} `),i=e.getShaderInfoLog(r);e.deleteShader(r),r=null,error(`EFX2406: compilation failed: ↓↓↓↓↓ EXPAND THIS MESSAGE FOR MORE INFO ↓↓↓↓↓\n${i}\n${s}`)}return r};return(r,s,i,a,o)=>{if(!(()=>(e||"undefined"==typeof document||((e=document.createElement("canvas").getContext("webgl",{depth:!0,stencil:!0})).getSupportedExtensions().forEach(t=>e.getExtension(t)),t=t&&e.getParameter(e.MAX_VERTEX_TEXTURE_IMAGE_UNITS)>=8),t&&e))())return;const l="#version 100\n"+(e=>e.reduce((e,t)=>{let n=1;switch(t.type){case"string":n=t.options[0];break;case"number":n=t.range[0];break;case"constant":n=t.default}return`${e}#define ${t.name} ${n}\n`},""))(i);shaderName=a;const c=n(l+r,e.VERTEX_SHADER);shaderName=o;const p=n(l+s,e.FRAGMENT_SHADER);shaderName="linking";const d=((...t)=>{let n=e.createProgram();if(t.forEach(t=>e.attachShader(n,t)),e.linkProgram(n),!e.getProgramParameter(n,e.LINK_STATUS)){const t=e.getProgramInfoLog(n);e.deleteProgram(n),n=null,error(`EFX2407: link failed: ${t}`)}return n})(c,p);e.deleteProgram(d),e.deleteShader(p),e.deleteShader(c)}})(),stripToSpecificVersion=(()=>{const globalSearch=/#(if|elif|else|endif)(.*)?/g,legalExpr=/^[\d<=>!|&^\s]*(__VERSION__)?[\d<=>!|&^\s]*$/,macroWrap=(e,t,n)=>t?`#if ${t}\n${e}#endif\n`:e,declareExtension=(e,t)=>"require"===t?`#extension ${e}: require\n`:`\n#ifdef ${e}\n#extension ${e}: enable\n#endif\n`;return(code,version,extensions,isVert)=>{version<310&&(code=code.replace(/layout\s*\((.*?)\)(\s*)(\w+)\s+(\w+)/g,(e,t,n,r,s)=>{if(!isVert&&"out"===r)return e;if("out"!==r&&"in"!==r&&"uniform"!==r)return e;if("uniform"===r&&s.startsWith("image"))return e;return`${t.indexOf("std140")>=0?"layout(std140)"+n+r:r} ${s}`}));const instances=[];let cap=null,temp=null;for(;cap=globalSearch.exec(code),cap;)if("if"===cap[1]){if(temp){temp.level++;continue}if(!legalExpr.test(cap[2]))continue;temp={start:cap.index,end:cap.index,conds:[cap[2]],content:[cap.index+cap[0].length],level:1}}else if("elif"===cap[1]){if(!temp||temp.level>1)continue;legalExpr.test(cap[2])||(error(`EFX2301: #elif conditions after a constant #if should be constant too; get '${cap[2]}'`),cap[2]=""),temp.conds.push(cap[2]),temp.content.push(cap.index,cap.index+cap[0].length)}else if("else"===cap[1]){if(!temp||temp.level>1)continue;temp.conds.push("true"),temp.content.push(cap.index,cap.index+cap[0].length)}else if("endif"===cap[1]){if(!temp||--temp.level)continue;temp.content.push(cap.index),temp.end=cap.index+cap[0].length,instances.push(temp),temp=null}let res=code;if(instances.length){res=res.substring(0,instances[0].start);for(let j=0;j<instances.length;j++){const ins=instances[j];for(let i=0;i<ins.conds.length;i++)if(eval(ins.conds[i].replace("__VERSION__",version))){const e=code.substring(ins.content[2*i],ins.content[2*i+1]);res+=stripToSpecificVersion(e,version,isVert);break}const next=instances[j+1]&&instances[j+1].start||code.length;res+=code.substring(ins.end,next)}}for(const ext in extensions){const{defines:defines,cond:cond,level:level,runtimeCond:runtimeCond}=extensions[ext];eval(cond.replace("__VERSION__",version))&&(res=macroWrap(declareExtension(ext,level),runtimeCond,defines)+res)}return res}})(),glsl300to100=(e,t,n,r,s,i,a)=>{let o="",l=0;if(r.forEach(n=>{if("blocks"!==n.type)return;const r=(o+=e.slice(l,n.beg)).length-o.search(/\s*$/)+1;t.find(e=>e.name===n.param.name).members.forEach(t=>{const n=e.match(new RegExp(`\\b${t.name}\\b`,"g"));if(!n||n.length<=1)return;const s=convertType(t.type),i=t.precision||"",a="string"==typeof t.count||t.isArray?`[${t.count}]`:"";o+=" ".repeat(r)+`uniform ${i}${s} ${t.name}${a};\n`}),l=n.end+(";"===e[n.end])}),o=(o+=e.slice(l)).replace(/\btexture((?!2D|Cube)\w*)\s*\(\s*(\w+)\s*([,[])/g,(e,t,r,i,a)=>{const l="texture"+t;if(s.find(e=>e.name===l))return e;let c=new RegExp("sampler(\\w+)\\s+"+r);const p=s.find(e=>a>e.beg&&a<e.end);let d=p&&c.exec(o.substring(p.beg,p.eng))||c.exec(o);if(!d){const t=n.find(e=>e.name===r);if(t&&t.options)for(const e of t.options)if(d=(c=new RegExp("sampler(\\w+)\\s+"+e)).exec(o))break;if(!d)return error(`EFX2300: sampler '${r}' does not exist`),e}return`texture${d[1]}${t}(${r}${i}`}),a)o=(o=o.replace(inDecl,(e,t,n)=>`attribute ${n};`)).replace(outDecl,(e,t,n)=>`varying ${n};`);else{const e=[];if(o=(o=o.replace(inDecl,(e,t,n)=>`varying ${n};`)).replace(outDecl,(t,n,r,s)=>{const i=n&&locationRE.exec(n);return i||error("EFX2302: fragment output location must be specified"),e.push({name:s,location:i[1]}),""}),1===e.length){const t=new RegExp(e[0].name,"g");o=o.replace(t,"gl_FragColor")}else if(e.length>1){for(const t of e){const e=new RegExp(t.name,"g");o=o.replace(e,`gl_FragData[${t.location}]`)}i.extensions.GL_EXT_draw_buffers||(i.extensions.GL_EXT_draw_buffers={defines:[],cond:"__VERSION__ <= 100",level:"enable"})}}return(o=o.replace(/layout\s*\(.*?\)\s*/g,()=>"")).replace(pragmasToStrip,"")},decorateBlockMemoryLayouts=(e,t)=>{let n=0;const r=[];t.forEach((t,s)=>{if("blocks"!==t.type&&"buffers"!==t.type)return;const i="buffers"===t.type,a=e.slice(n,t.beg),o=layoutExtract.exec(a);r[s]=o?n+o.index+(i?0:o[0].length-o[2].length-1):-1,n=t.end});let s="";return n=0,t.forEach((t,i)=>{const a=r[i];if(void 0!==a){if("blocks"===t.type)a<0?(s+=e.slice(n,t.beg),s+="layout(std140) "):(s+=e.slice(n,a),s+=", std140",s+=e.slice(a,t.beg));else if("buffers"===t.type){let r="std430";t.param.tags&&void 0!==t.param.tags.glBinding&&(r+=`, binding = ${t.param.tags.glBinding}`),s+=e.slice(n,a<0?t.beg:a),s+=`layout(${r}) `}s+=e.slice(t.beg,t.end),n=t.end}}),s+=e.slice(n)},decorateBindings=(e,t,n)=>{let r=0;const s=[],i={};(n=n.filter(e=>!builtinRE.test(e.param.name))).forEach((n,a)=>{if("fragColors"===n.type)return;const o=n.param.name;if(!t[n.type])return;const l=e.slice(r,n.beg),c={prop:n.param},p=layoutExtract.exec(l),d=i[n.type]||(i[n.type]={});if(p){c.position=r+p.index+p[0].length-p[2].length-1;const e=bindingExtract.exec(p[1]);if(e){p[1].search(/\bset\s*=/)<0?c.position=p[1].length-c.position:c.position=-1;const r=parseInt(e[1]),s="varyings"===n.type||"attributes"===n.type?"location":"binding";let i=t[n.type].find(e=>e[s]===r);i||"subpassInputs"!==n.type||(i=!0),i?(d[r]&&d[r]!==o&&error(`EFX2600: duplicated binding/location declaration for '${d[r]}' and '${o}'`),d[d[r]=o]=r):"blocks"===n.type?error(`EFX2601: illegal custom binding for '${o}', block bindings should be consecutive and start from 0`):"samplerTextures"===n.type?error(`EFX2602: illegal custom binding for '${o}', texture bindings should be consecutive and after all the blocks`):"buffers"===n.type?error(`EFX2603: illegal custom binding for '${o}', buffer bindings should be consecutive and after all the `+"blocks/samplerTextures"):"images"===n.type?error(`EFX2604: illegal custom binding for '${o}', image bindings should be consecutive and after all the `+"blocks/samplerTextures/buffers"):"textures"===n.type?error(`EFX2605: illegal custom binding for '${o}', texture bindings should be consecutive and after all the `+"blocks/samplerTextures/buffers/images"):"samplers"===n.type?error(`EFX2606: illegal custom binding for '${o}', sampler bindings should be consecutive and after all the `+"blocks/samplerTextures/buffers/images/textures"):error(`EFX2607: illegal custom location for '${o}', locations should be consecutive and start from 0`)}}s[a]=c,r=n.end}),n.forEach((e,n)=>{if(!i[e.type])return;const r="attributes"===e.type||"varyings"===e.type||"fragColors"===e.type?"location":"binding",a=i[e.type],o=e.param.name;if("attributes"===e.type)if(o in a)s[n].prop[r]=a[o];else{let e=0;for(;a[e];)e++;s[n].prop[r]=e,a[e]=o}else if(o in a){const i=s[n].prop[r],l=t[e.type].find(e=>e[r]===a[o]);l&&(l[r]=i),s[n].prop[r]=a[o]}});let a="";r=0;const o=mappings.SetIndex.MATERIAL;return n.forEach((t,n)=>{if(!s[n])return;const i="attributes"===t.type||"varyings"===t.type||"fragColors"===t.type,l=i?"location":"binding",{position:c,prop:p}=s[n],d=i?"":`set = ${o}, `;void 0===c?(a+=e.slice(r,t.beg),a+=`layout(${d+l} = ${p[l]}) `):c>=0?(a+=e.slice(r,c),a+=`, ${d+l} = ${p[l]}`,a+=e.slice(c,t.beg)):c<-1?(a+=e.slice(r,-c),a+=d,a+=e.slice(-c,t.beg)):a+=e.slice(r,t.beg),a+=e.slice(t.beg,t.end),r=t.end}),a+=e.slice(r),t.samplerTextures=t.samplerTextures.filter(e=>t.subpassInputs.findIndex(t=>t.binding===e.binding)<0),a},shaderFactory=(()=>{const e=/\s+$/gm,t=/(^\s*\n){2,}/gm,n=n=>{let r=n.replace(pragmasToStrip,"");return r=(r=r.replace(t,"\n")).replace(e,"")},r=(e,t)=>n=>{if(!builtinRE.test(n.name))return!0;const r=n.tags;let s;return s=r&&r.builtin?r.builtin:"global",t[`${s}s`][e].push({name:n.name,defines:n.defines}),!1},s=(e,t,n)=>"main"===t?e:e+((e,t)=>e?`\nvoid main() { gl_Position = ${t}(); }\n`:`\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = ${t}(); }\n`)(n,t),i=/([^:]+)(?::(\w+))?/,a={version:"300 es"},o=(e,t,n=[],r={blocks:[],samplerTextures:[],samplers:[],textures:[],buffers:[],images:[],subpassInputs:[],attributes:[],varyings:[],fragColors:[]},o=globalChunks,l=globalDeprecations)=>{const c={};shaderName=e;const p={lines:[],extensions:{}};let{code:d,record:f,functions:u}=((e,t,n,r,a="main")=>{const o=i.exec(e),l=o[2]||a,c=new Set,p=[];let d=unwindIncludes(`#include <${o[1]}>`,t,n,c);return d=s(d,l,r),d=expandLiteralMacro(d),d=expandFunctionalMacro(d),{code:d=eliminateDeadCode(d,l,p),record:c,functions:p}})(e,o,l,t);const g=shaderTokens=tokenizer(d,a);p.existingDefines=extractMacroDefinitions(d),extractDefines(g,n,p);const m=extractParams(g,p,r,t,u);return c.blockInfo=m,c.record=f,c.extensions=p.extensions,c.glsl4=d,c.glsl3=stripToSpecificVersion(decorateBlockMemoryLayouts(d,m),300,p.extensions,t),c.glsl1=stripToSpecificVersion(glsl300to100(d,r.blocks,n,m,u,p,t),100,p.extensions,t),miscChecks(c.glsl1),c};return{compile:o,build:(e,t,s=globalChunks,i=globalDeprecations)=>{let a=[],l={blocks:[],samplerTextures:[],samplers:[],textures:[],buffers:[],images:[],subpassInputs:[],attributes:[],varyings:[],fragColors:[]};const c={};c.vert=o(e,!0,a,l,s,i),c.frag=o(t,!1,a,l,s,i),finalTypeCheck(c.vert.glsl1,c.frag.glsl1,a,e,t);const p={globals:{blocks:[],samplerTextures:[],buffers:[],images:[]},locals:{blocks:[],samplerTextures:[],buffers:[],images:[]},statistics:{}};a=a.filter(e=>"constant"!==e.type);let d=0,f=0;l.blocks.forEach(e=>{let t=e.members.reduce((e,t)=>"number"!=typeof t.count?e:e+Math.ceil(mappings.GetTypeSize(t.type)/16)*t.count,0);e.stageFlags&VSBit&&(d+=t),e.stageFlags&FSBit&&(f+=t)},0),p.statistics.CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS=d,p.statistics.CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS=f,l.blocks=l.blocks.filter(r("blocks",p)),l.samplerTextures=l.samplerTextures.filter(r("samplerTextures",p)),l.buffers=l.buffers.filter(r("buffers",p)),l.images=l.images.filter(r("images",p)),l.attributes.forEach(e=>{if(e.format=mappings.formatMap[e.typename],e.defines.indexOf("USE_INSTANCING")>=0&&(e.isInstanced=!0),e.tags&&e.tags.format){const t=mappings.getFormat(e.tags.format);void 0!==t&&(e.format=t),mappings.isNormalized(t)&&(e.isNormalized=!0)}}),l.attributes.forEach(e=>(delete e.tags,delete e.typename,delete e.precision,delete e.isArray,delete e.type,delete e.count,delete e.stageFlags)),l.varyings.forEach(e=>(delete e.tags,delete e.typename,delete e.precision,delete e.isArray)),l.blocks.forEach(e=>(delete e.tags,e.members.forEach(e=>(delete e.typename,delete e.precision,delete e.isArray)))),l.samplerTextures.forEach(e=>(delete e.tags,delete e.typename,delete e.precision,delete e.isArray)),l.buffers.forEach(e=>(delete e.tags,delete e.typename,delete e.precision,delete e.isArray,delete e.members)),l.images.forEach(e=>(delete e.tags,delete e.typename,delete e.precision,delete e.isArray)),l.textures.forEach(e=>(delete e.tags,delete e.typename,delete e.precision,delete e.isArray)),l.samplers.forEach(e=>(delete e.tags,delete e.typename,delete e.precision,delete e.isArray)),l.subpassInputs.forEach(e=>(delete e.tags,delete e.typename,delete e.precision,delete e.isArray,delete e.type));let u=0;l.blocks.forEach(e=>e.binding=u++),l.samplerTextures.forEach(e=>e.binding=u++),l.samplers.forEach(e=>e.binding=u++),l.textures.forEach(e=>e.binding=u++),l.buffers.forEach(e=>e.binding=u++),l.images.forEach(e=>e.binding=u++),l.subpassInputs.forEach(e=>e.binding=u++);let g=0;l.attributes.forEach(e=>e.location=g++),g=0,l.varyings.forEach(e=>e.location=g++),g=0,l.fragColors.forEach(e=>e.location=g++),c.vert.glsl4=stripToSpecificVersion(decorateBindings(c.vert.glsl4,l,c.vert.blockInfo),460,c.vert.extensions,!0),c.frag.glsl4=stripToSpecificVersion(decorateBindings(c.frag.glsl4,l,c.frag.blockInfo),460,c.frag.extensions,!1);const m={vert:n(c.vert.glsl4),frag:n(c.frag.glsl4)},b={vert:n(c.vert.glsl3),frag:n(c.frag.glsl3)},h={vert:n(c.vert.glsl1),frag:n(c.frag.glsl1)},y=mappings.murmurhash2_32_gc(m.vert+m.frag+b.vert+b.frag+h.vert+h.frag,666);c.frag.record.forEach(c.vert.record.add,c.vert.record);const x=c.vert.record;return Object.assign(l,{hash:y,glsl4:m,glsl3:b,glsl1:h,builtins:p,defines:a,record:x})}}})(),compileShader=shaderFactory.compile,parseEffect=(()=>{const e=/CCEffect\s*%{([^]+?)(?:}%|%})/,t=/CCProgram\s*([\w-]+)\s*%{([^]*?)(?:}%|%})/,n=/#.*$/gm,r=/^\s*$/,s=/\n[^\s]/,i=/^[^\S\n]/gm,a=/\t/g,o=(e,t,n="effect")=>{if(Array.isArray(e)){if(!Array.isArray(t))return void error(`EFX1002: ${n} must be an array`);if(e[0])for(let r=0;r<t.length;r++)o(e[0],t[r],n+`[${r}]`)}else{if(!t||"object"!=typeof t||Array.isArray(t))return void error(`EFX1003: ${n} must be an object`);for(const e of Object.keys(t))-1!==e.indexOf(":")&&error(`EFX1004: syntax error at '${e}', you might need to insert a space after colon`);if(e.any)for(const r of Object.keys(t))o(e.any,t[r],n+`.${r}`);else for(const r of Object.keys(e)){let s=r;if("$"===s[0])s=s.substring(1);else if(!t[s])continue;o(e[r],t[s],n+`.${s}`)}}};return(l,c)=>{shaderName="syntax",c=c.replace(a," ".repeat(tabAsSpaces));let p={},d={},f={},u=e.exec((e=>e.replace(n,""))(c));if(u){try{const e=yaml.load(u[1]);p=JSON.parse(JSON.stringify(e))}catch(e){error(`EFX1001: CCEffect parser failed: ${e}`)}p.name||(p.name=l),o(mappings.effectStructure,p)}else error("EFX1000: CCEffect is not defined");c=stripComments(c);let g=t.exec(c);for(;g;){let e=g[2];if(!r.test(e))for(;!s.test(e);)e=e.replace(i,"");addChunk(g[1],e,d,f),c=c.substring(g.index+g[0].length),g=t.exec(c)}return{effect:p,templates:d,localDeprecations:f}}})(),mapPassParam=(()=>{const e=(e,t)=>{let n=0,r=t=>t.name===e&&(n=t.type,!0);return t.blocks.some(e=>e.members.some(r))||t.samplerTextures.some(r),n},t=(e,t,n)=>{if(t<=0)return"no matching uniform";if(void 0===e)return"";if("string"===n){if(!mappings.isSampler(t))return"string for vectors"}else{if(!Array.isArray(e))return"non-array for buffer members";if(e.length!==mappings.GetTypeSize(t)/4)return"wrong array length"}return""},n=/^(\w+)(?:\.([xyzw]+|[rgba]+))?$/,r={x:0,y:1,z:2,w:3,r:0,g:1,b:2,a:3},s=(t,s)=>{const i=[t,0,0],a=n.exec(t);if(!a)return error(`EFX3303: illegal property target '${t}'`),i;const o=a[2]&&a[2].toLowerCase()||"",l=r[o[0]]||0;return o.split("").map((e,t)=>r[e]-l-t).some(e=>e)&&error(`EFX3304: '${t}': random component swizzle is not supported`),i[0]=a[1],i[1]=l,i[2]=e(a[1],s),o.length&&(i[2]-=Math.max(0,mappings.GetTypeSize(i[2])/4-o.length)),i[2]<=0&&error(`EFX3305: no matching uniform target '${t}'`),i},i=(e,t)=>{for(const n of Object.keys(t)){const r=t[n];"object"==typeof r&&"object"==typeof e[n]?i(e[n],r):void 0===e[n]&&(e[n]=r)}},a=e=>{for(let t in e){let n=e[t];if("string"==typeof n){let r=parseInt(n);isNaN(r)&&(r=mappings.passParams[n.toUpperCase()]),void 0!==r&&(e[t]=r)}else if(Array.isArray(n)){if(!n.length)continue;switch(typeof n[0]){case"object":n.forEach(a);break;case"string":a(n);break;case"number":e[t]=(255*n[0]<<24|255*n[1]<<16|255*n[2]<<8|255*(n[3]||255))>>>0}}else"object"==typeof n&&a(n)}return e},o=new mappings.SamplerInfo,l=e=>{for(const t of Object.keys(e))void 0===o[t]&&warn(`EFX3301: illegal sampler info '${t}'`);return mappings.Sampler.computeHash(e)},c=/^([a-zA-Z]+)?\s*([+-])?\s*([\dxabcdef]+)?$/i,p=mappings.RenderPriority.DEFAULT,d=mappings.RenderPriority.MIN,f=mappings.RenderPriority.MAX;return(n,r)=>{shaderName="type error";const o={};n.priority&&(o.priority=(e=>{let t=0;const n=c.exec(e);return n[1]&&(t=mappings.RenderPriority[n[1].toUpperCase()]),n[3]&&(t+=parseInt(n[3])*("-"===n[2]?-1:1)),isNaN(t)||t<d||t>f?(warn(`EFX3000: illegal pass priority: ${e}`),p):t})(n.priority),delete n.priority),n.depthStencilState&&(o.depthStencilState=(e=>{for(const t of Object.keys(e))t.startsWith("stencil")&&(t.endsWith("Front")||t.endsWith("Back")||(e[t+"Front"]=e[t+"Back"]=e[t],delete e[t]));return e.stencilWriteMaskFront!==e.stencilWriteMaskBack&&warn("EFX3100: WebGL(2) doesn't support inconsistent front/back stencil write mask"),e.stencilReadMaskFront!==e.stencilReadMaskBack&&warn("EFX3101: WebGL(2) doesn't support inconsistent front/back stencil read mask"),e.stencilRefFront!==e.stencilRefBack&&warn("EFX3102: WebGL(2) doesn't support inconsistent front/back stencil ref"),a(e)})(n.depthStencilState),delete n.depthStencilState),n.switch&&(o.switch=((e,t)=>(t.defines.find(t=>t.name===e)&&error("EFX3200: existing shader macros cannot be used as pass switch"),e))(n.switch,r),delete n.switch),n.properties&&(o.properties=((n,r)=>{let o={};for(const i of Object.keys(n)){if("__metadata__"===i){o=n[i],delete n[i];continue}const c=n[i],p=e(i,r);if(void 0!==c.type&&warn(`EFX3300: property '${i}': you don't have to specify type in here`),c.type=p,c.target){c.handleInfo=s(c.target,r),delete c.target,c.type=c.handleInfo[2];const t=c.editor&&c.editor.visible,i=c.handleInfo[0],a=e(c.handleInfo[0],r);n[i]||(n[i]={type:a,editor:{visible:!1}}),(void 0===t||t)&&(n[i].editor?void 0===n[i].editor.deprecated&&(n[i].editor.deprecated=!0):n[i].editor={deprecated:!0}),mappings.isSampler(a)?c.value&&(n[i].value=c.value):(n[i].value||(n[i].value=Array(mappings.GetTypeSize(a)/4).fill(0)),Array.isArray(c.value)?n[i].value.splice(c.handleInfo[1],c.value.length,...c.value):void 0!==c.value&&n[i].value.splice(c.handleInfo[1],1,c.value))}c.sampler&&(c.samplerHash=l(a(c.sampler)),delete c.sampler);const d=typeof c.value;"number"!==d&&"boolean"!==d||(c.value=[c.value]);const f=t(c.value,c.type,d);f&&error(`EFX3302: illegal property declaration for '${i}': ${f}`)}for(const e of Object.keys(n))i(n[e],o);return n})(n.properties,r),delete n.properties),n.migrations&&(o.migrations=n.migrations,delete n.migrations),a(n),Object.assign(n,o)}})(),reduceHeaderRecord=e=>{const t=new Set;for(const n of e)n.record.forEach(t.add,t);return[...t.values()]},buildEffect=(e,t)=>{effectName=e;let{effect:n,templates:r,localDeprecations:s}=parseEffect(e,t);if(!n||!Array.isArray(n.techniques))return null;r=Object.assign({},globalChunks,r);let i={};for(const e in globalDeprecations)i[e]=Object.assign({},globalDeprecations[e],s[e]);const a=Object.keys(i.identifiers).reduce((e,t)=>`|${t}`+e,"").slice(1);a.length&&(i.identifierRE=new RegExp(`\\b(${a})\\b`,"g"));const o=n.shaders=[];for(const e of n.techniques)for(const t of e.passes){let e=t.vert,n=t.frag;delete t.vert,delete t.frag;let s=t.program=`${effectName}|${e}|${n}`,a=o.find(e=>e.name===s);a||((a=shaderFactory.build(e,n,r,i)).name=s,o.push(a)),mapPassParam(t,a)}return n.dependencies=reduceHeaderRecord(o),n};module.exports={options:options,addChunk:addChunk,compileShader:compileShader,buildEffect:buildEffect};