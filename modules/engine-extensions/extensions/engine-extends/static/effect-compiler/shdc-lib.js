"use strict";const tokenizer=require("glsl-tokenizer/string"),parser=require("glsl-parser/direct"),mappings=require("./offline-mappings"),yaml=require("js-yaml"),tabAsSpaces=2,plainDefineRE=/#define\s+(\w+)\s+(\w+)/g,effectDefineRE=/#pragma\s+define\s+(\w+)\s+(.*)\n/g,ident=/[_a-zA-Z]\w*/g,labelRE=/(\w+)\((.*?)\)/,locationRE=/location\s*=\s*(\d+)/,inDecl=/(?:layout\s*\((.*?)\)\s*)?in ((?:\w+\s+)?\w+\s+(\w+)\s*(?:\[[\d\s]+])?)\s*;/g,outDecl=/(?:layout\s*\((.*?)\)\s*)?(?<=\b)out ((?:\w+\s+)?\w+\s+(\w+)\s*(?:\[[\d\s]+])?)\s*;/g,layoutExtract=/layout\s*\((.*?)\)(\s*)$/,bindingExtract=/(?:location|binding)\s*=\s*(\d+)/,builtinRE=/^cc\w+$/i,pragmasToStrip=/^\s*(?:#pragma\s*)(?!STDGL|optimize|debug).*$\n/gm;let effectName="",shaderName="",shaderTokens=[];const formatMsg=(e,t)=>`${effectName}.effect - ${shaderName}`+(void 0!==t?` - ${t}: `:": ")+e,options={throwOnError:!0,throwOnWarning:!1,noSource:!1,skipParserTest:!1,chunkSearchFn:e=>({}),getAlternativeChunkPaths:e=>[]},dumpSource=e=>{let t=0;return e.reduce((e,r)=>r.line>t?e+`\n${t=r.line}\t${r.data.replace(/\n/g,"")}`:e+r.data,"")},throwFnFactory=(e,t)=>(r,n)=>{options.noSource&&(n=void 0);const s=void 0!==n?" ↓↓↓↓↓ EXPAND THIS MESSAGE FOR MORE INFO ↓↓↓↓↓"+dumpSource(shaderTokens)+"\n":"",a=formatMsg(e+" "+r,n)+s;if(options.throwOnWarning)throw a;t(a)},warn=throwFnFactory("Warning",console.warn),error=throwFnFactory("Error",console.error),convertType=e=>{const t=mappings.typeMap[e];return void 0===t?e:t},VSBit=mappings.getShaderStage("vertex"),FSBit=mappings.getShaderStage("fragment"),CSBit=mappings.getShaderStage("compute"),mapShaderStage=e=>{switch(e){case"vert":return VSBit;case"frag":return FSBit;case"compute":return CSBit;default:return 0}},stripComments=(()=>{const e=/\r\n/g,t=/\/\*.*?\*\//gs,r=/\s*\/\/.*$/gm;return n=>{let s=n.replace(t,"");return s=(s=s.replace(r,"")).replace(e,"\n")}})(),globalChunks={},globalDeprecations={chunks:{},identifiers:{}},addChunk=(()=>{const e=/#pragma\s+deprecate-(chunk|identifier)\s+([\w-]+)(?:\s+(.*))?/g;return(t,r,n=globalChunks,s=globalDeprecations)=>{const a=stripComments(r);let i=e.exec(a),o="",l=0;for(;i;){const t=`${i[1]}s`;s[t]||(s[t]={}),s[t][i[2]]=i[3],o+=a.slice(l,i.index),l=i.index+i[0].length,i=e.exec(a)}n[t]=o+a.slice(l)}})(),invokeSearch=e=>{const{name:t,content:r}=options.chunkSearchFn(e);return void 0!==r?(addChunk(t,r),t):""},unwindIncludes=(()=>{const e=/^(.*)#include\s+[<"]([^>"]+)[>"](.*)$/gm;let t;return(r,n,s,a=new Set)=>{if(t=((r,n,s)=>(a,i,o,l)=>{(o=o.trim()).endsWith(".chunk")&&(o=o.slice(0,-6));const c=o;if(s.has(o))return"";void 0!==n[o]&&error(`EFX2003: header '${o}' is deprecated: ${n[o]}`);let p=void 0;do{if(void 0!==(p=r[o]))break;const e=options.getAlternativeChunkPaths(o);if(e.some(e=>void 0!==r[e]&&(o=e,p=r[e],!0)))break;if(o=invokeSearch([].concat(o,e)),void 0!==(p=globalChunks[o]))break;return error(`EFX2001: can not resolve '${c}'`),""}while(0);return s.add(o),i&&(p=p.replace(/^/gm,i)),l&&(p=p.replace(/\n/g,l+"\n")+l),p=p.replace(e,t)})(n,s.chunks,a),r=r.replace(e,t),s.identifierRE){let e=s.identifierRE.exec(r);for(;e;){const t=s.identifiers[e[1]];t&&error(`EFX2004: identifier '${e[1]}' is deprecated: ${t}`),e=s.identifierRE.exec(r)}}return r}})(),expandFunctionalMacro=(()=>{const e=(e,t)=>{if("("!==e[t])return t;let r=1,n=t+1;for(;n<e.length&&("("===e[n]&&r++,")"===e[n]&&r--,0!==r);n++);return n},t=t=>{const r=[];let n=0;for(let s=0;s<t.length;s++)"("===t[s]&&(s=e(t,s)+1),","===t[s]&&(r.push(t.substring(n,s).trim()),n=s+1);return n===t.length&&","!==t[t.length-1]||r.push(t.substring(n).trim()),r},r=/#pragma\s+define\s+(\w+)\(([\w,\s]*)\)\s+(.*?)\n/g,n=/(?<=\w)##(?=\w)/g,s=/\\\s*?\n/g,a=/@@/g,i=/#pragma\s+define|#define/;return o=>{o=o.replace(s,"@@");let l=r.exec(o);for(;null!==l;){const s=l[1],c=t(l[2]),p=l[3],f=l.index,d=l.index+l[0].length,u=new RegExp("^(.*?)"+s+"\\s*\\(","gm");if(new RegExp("\\b"+s+"\\b").test(p))warn(`EFX2002: recursive macro processor '${s}'`);else for(let r=u.exec(o);null!==r;r=u.exec(o)){const l=r.index+r[0].length-1;if(l>f&&l<d)continue;const m=r[1],g=r.index+m.length,h=e(o,l)+1,b=t(o.slice(r.index+r[0].length,h-1));b.length!==c.length&&warn(`EFX2005: not enough arguments for function-like macro invocation '${s}'`);const y=[];for(let e=0;e<c.length;e++){const t=new RegExp("\\b"+c[e]+"\\b","g");let r;for(;null!==(r=t.exec(p));)y.push({beg:r.index,end:t.lastIndex,target:b[e]})}let x="",E=0;for(const e of y.sort((e,t)=>e.beg-t.beg))x+=p.slice(E,e.beg)+e.target,E=e.end;if(x+=p.slice(E,p.length),i.test(m)){const e=m.lastIndexOf("@@"),t=e<0?m:m.slice(e+2);let r=t.search(/\S/);r<0&&(r=t.length),x=x.replace(a,"@@"+" ".repeat(r))}else{let e=m.search(/\S/);e<0&&(e=m.length),x=(x=x.replace(n,"")).replace(a,"\n"+" ".repeat(e))}o=o.substring(0,g)+x+o.substring(h),u.lastIndex-=r[0].length}o=o.substring(0,f)+o.substring(d),r.lastIndex=0,l=r.exec(o)}return o.replace(a,"\\\n"),o}})(),expandLiteralMacro=e=>{const t={};let r=effectDefineRE.exec(e);for(;null!==r;){let n=r[2];n.endsWith("\\")&&(n=n.slice(0,-1)),t[r[1]]=n.trim();const s=r.index,a=r.index+r[0].length;e=e.substring(0,s)+e.substring(a),effectDefineRE.lastIndex=s,r=effectDefineRE.exec(e)}const n=Object.keys(t).map(e=>new RegExp(`\\b${e}\\b`,"g")),s=Object.values(t);for(let t=0;t<s.length;t++){let r=s[t];for(let e=0;e<t;e++)r=r.replace(n[e],s[e]);e=e.replace(n[t],r)}return e},extractMacroDefinitions=e=>{const t=new Set;let r=plainDefineRE.exec(e);const n=new Map;for(;null!==r;){if(t.add(r[1]),r[2]&&"true"!==r[2].toLowerCase&&"false"!==r[2].toLowerCase){const e=parseInt(r[2]);isNaN(e)&&n.set(r[1],r[2])}r=plainDefineRE.exec(e)}return[t,n]},eliminateDeadCode=(()=>{const e=/[{}()]/g,t=/(?:\w+p\s+)?\w+\s+(\w+)\s*$/,r=/^\s*$/;let n="",s=0,a=0;const i=(e,r)=>{const i=e.substring(a,r).match(t)||["",""];n=i[1],s=r-i[0].length},o=(e,t)=>{const r=[];let n=t.exec(e);for(;n;)r.push(n),n=t.exec(e);return r},l=new Set,c=(e,t)=>{if(!l.has(t)){l.add(t);for(const r of e[t].deps)c(e,r)}};return(t,p,f)=>{let d=0,u=0,m=0;a=0,e.lastIndex=0,l.clear();const g=[];for(const l of o(t,e)){const e=l[0];if(0===d&&("("===e?(u=1,i(t,l.index)):")"===e?1===u?(u=2,m=l.index+1):u=0:"{"===e&&(u=2===u&&r.test(t.substring(m,l.index))?3:0)),"{"===e&&d++,"}"===e&&0==--d){if(3!==u)continue;a=l.index+1,u=0,n&&g.push({name:n,beg:s,end:a,paramListEnd:m,deps:[]})}}let h=g.findIndex(e=>e.name===p);h<0&&(error(`EFX2403: entry function '${p}' not found.`),h=0);for(let e=0;e<g.length;e++){const r=g[e],n=o(t,new RegExp("\\b"+r.name+"\\b","g"));for(const t of n){const r=g.findIndex(e=>t.index>e.beg&&t.index<e.end);r>=0&&r!==e&&g[r].deps.push(e)}}c(g,h);let b="",y=0,x=0;for(let e=0;e<g.length;e++){const r=g[e],{name:n,beg:s,end:a}=r;l.has(e)||"main"===n?(r.beg-=x,r.end-=x,r.paramListEnd-=x,f.push(r)):(b+=t.substring(y,s),y=a,x+=a-s)}return b+t.substring(y)}})(),parseCustomLabels=(e,t={})=>{let r=e.join(" "),n=labelRE.exec(r);for(;n;){try{t[n[1]]=yaml.load(n[2]||"true")}catch(e){warn(`EFX2102: parameter for label '${n[1]}' is not legal YAML: ${e.message}`)}r=r.substring(n.index+n[0].length),n=labelRE.exec(r)}return t},getDefs=(e,t)=>{let r=t.lines.findIndex(t=>t>e);return r<0&&(r=t.lines.length),t[t.lines[r-1]]||[]},pushDefines=(e,t,r)=>{t.has(r.name)||e.push(r)},extractDefines=(e,t,r)=>{const n=[],s=e=>{r[e]=n.reduce((e,t)=>e.concat(t),[]),r.lines.push(e)};let a=0;for(let i=0;i<e.length;i++){let o,l,c=e[i],p=c.data;if("preprocessor"!==c.type||p.startsWith("#extension"))continue;if("#endif"===(p=p.split(/\s+/))[0]){for(;a>0;)n.pop(),a--;n.pop(),s(c.line);continue}if("#else"===p[0]||"#elif"===p[0]){const e=n[n.length-1];if(e&&e.forEach((t,r)=>e[r]="!"===t[0]?t.slice(1):"!"+t),s(c.line),"#else"===p[0])continue;a++}else{if("#pragma"===p[0]){if(p.length<=1)continue;if("define-meta"===p[1]){if(p.length<=2){warn("EFX2101: define pragma: missing info",c.line);continue}if(ident.lastIndex=0,!ident.test(p[2]))continue;const e=n.reduce((e,t)=>e.concat(t),[]);let s=t.find(e=>e.name===p[2]);s||pushDefines(t,r.existingDefines,s={name:p[2],type:"boolean",defines:e,dummyDependency:!0});const a=parseCustomLabels(p.splice(3));for(const e in a)if("range"===e)s.type="number",s.range=[0,3],s.fixedType=!0,Array.isArray(a.range)?s.range=a.range:warn(`EFX2103: invalid range for macro '${s.name}'`,c.line);else if("options"===e)s.type="string",s.options=[],s.fixedType=!0,Array.isArray(a.options)?s.options=a.options:warn(`EFX2104: invalid options for macro '${s.name}'`,c.line);else if("default"===e)switch(a.default){case!0:s.default=1;break;case!1:s.default=0;break;default:s.type="constant",s.default=a.default,s.fixedType=!0}else{if("editor"!==e){warn(`EFX2105: define pragma: illegal label '${e}'`,c.line);continue}s.editor=a.editor}}else if("warning"===p[1])warn(`EFX2107: ${p.slice(2).join(" ")}`);else if("error"===p[1])error(`EFX2108: ${p.slice(2).join(" ")}`);else{const e=parseCustomLabels(p.slice(1));e.extension?r.extensions[e.extension[0]]={defines:getDefs(c.line,r),cond:e.extension[1],level:e.extension[2],runtimeCond:e.extension[3]}:r[c.line]=e}continue}if(!/#(el)?if$/.test(p[0]))continue}let f=[];p.splice(1).some(e=>{if(ident.lastIndex=0,o=ident.exec(e)){if("defined"===o[0]||o[0].startsWith("__")||o[0].startsWith("GL_")||"VULKAN"===o[0])return!1;const s=n.reduce((e,t)=>e.concat(t),f.slice());if(l=t.find(e=>e.name===o[0])){let e=s.length<l.defines.length;l.dummyDependency&&(e=!0,delete l.dummyDependency),e&&(l.defines=s)}else pushDefines(t,r.existingDefines,l={name:o[0],type:"boolean",defines:s});f.push(("!"===e[0]?"!":"")+o[0])}else if(l&&/^[<=>]+$/.test(e)&&!l.fixedType)l.type="number",l.range=[0,3];else if("||"===e)return f=[],!0;return!1}),n.push(f),s(c.line)}t.forEach(e=>(delete e.fixedType,delete e.dummyDependency))},extractUpdateRates=(e,t=[])=>{for(let r=0;r<e.length;r++){let n=e[r],s=n.data;"preprocessor"!==n.type||s.startsWith("#extension")||"#pragma"===(s=s.split(/\s+/))[0]&&4===s.length&&"rate"===s[1]&&t.push({name:s[2],rate:s[3]})}return t},extractParams=(()=>{const precision=/(low|medium|high)p/,extractInfo=(tokens,i)=>{const param={},definedPrecision=precision.exec(tokens[i].data);let offset=definedPrecision?2:0;if(param.name=tokens[i+offset+2].data,param.typename=tokens[i+offset].data,param.type=convertType(tokens[i+offset].data),param.count=1,definedPrecision&&(param.precision=definedPrecision[0]+" "),"["===tokens[offset=nextWord(tokens,i+offset+2)].data){let expr="",end=offset;for(;"]"!==tokens[++end].data;)expr+=tokens[end].data;try{if(/^[\d+\-*/%\s]+$/.test(expr))param.count=eval(expr);else{if(!builtinRE.test(param.name))throw expr;param.count=expr}param.isArray=!0}catch(e){error(`EFX2202: ${param.name}: non-builtin array length must be compile-time constant: ${e}`,tokens[offset].line)}}return param},stripDuplicates=e=>{const t={};return e.filter(e=>!t[e]&&(t[e]=!0))},exMap={whitespace:!0},nextWord=(e,t)=>{do{++t}while(exMap[e[t].type]);return t},nextSemicolon=(e,t,r=(e=>{}))=>{for(;";"!==e[t].data;)r(e[t++]);return t},isFunctionParameter=(e,t)=>e.some(e=>t>e.beg&&t<e.paramListEnd),nonBlockUniforms=/texture|sampler|image|subpassInput/;return(e,t,r,n,s)=>{const a=[],i="vert"===n;for(let o=0;o<e.length;o++){let l,c,p=e[o],f=p.data;if("uniform"===f)l=r.blocks,c="blocks";else if("in"!==f||isFunctionParameter(s,p.position))if("out"!==f||isFunctionParameter(s,p.position)){if("buffer"!==f)continue;l=r.buffers,c="buffers"}else l=i?r.varyings:r.fragColors,c=i?"varyings":"fragColors";else l=i?r.attributes:r.varyings,c=i?"attributes":"varyings";const d=getDefs(p.line,t),u={};u.tags=t[p.line-1];let m=nextWord(e,o+2);if("{"!==e[m].data){if(Object.assign(u,extractInfo(e,o+2)),l===r.blocks){const t=e[o+(u.precision?4:2)].data,n=nonBlockUniforms.exec(t);n?"sampler"===t?(l=r.samplers,c="samplers"):"sampler"===n[0]?(l=r.samplerTextures,c="samplerTextures"):"texture"===n[0]?(l=r.textures,c="textures"):"image"===n[0]?(l=r.images,c="images"):"subpassInput"===n[0]&&(l=r.subpassInputs,c="subpassInputs"):error("EFX2201: vector uniforms must be declared in blocks.",p.line)}m=nextSemicolon(e,m)}else{for(u.name=e[o+2].data,u.members=[];"}"!==e[m=nextWord(e,m)].data;){if(l!==r.buffers){const t=extractInfo(e,m);mappings.isSampler(t.type)&&error("EFX2208: texture uniforms must be declared outside blocks.",e[m].line),u.members.push(t)}m=nextSemicolon(e,m)}u.members.reduce((e,t)=>{let r=mappings.GetTypeSize(t.type);switch(t.typename){case"mat2":r/=2;break;case"mat3":r/=3;break;case"mat4":r/=4}if(t.count>1&&r<16){const e=`uniform ${convertType(t.type)} ${t.name}[${t.count}]`;error("EFX2203: "+e+": array UBO members need to be 16-bytes-aligned to avoid implicit padding"),r=16}else if(12===r){const e=`uniform ${convertType(t.type)} ${t.name}`;error("EFX2204: "+e+": please use 1, 2 or 4-component vectors to avoid implicit padding"),r=16}else if(mappings.isPaddedMatrix(t.type)){const e=`uniform ${convertType(t.type)} ${t.name}`;error("EFX2210: "+e+": use only 4x4 matrices to avoid implicit padding")}const n=Math.ceil(e/r)*r,s=n-e;return s&&error(`EFX2205: UBO '${u.name}' introduces implicit padding: `+`${s} bytes before '${t.name}', consider re-ordering the members`),n+r*t.count},0);const n=t.lines.find(t=>t>=e[o].line&&t<e[m].line);n&&error(`EFX2206: ${u.name}: no preprocessors allowed inside uniform blocks!`,n),u.members.forEach(t=>{"string"==typeof t.type&&error(`EFX2211: '${t.type} ${t.name}' in block '${u.name}': `+"struct-typed member within UBOs is not supported due to compatibility reasons.",e[m].line)}),m=nextWord(e,m),";"!==e[m].data&&error("EFX2209: Block declarations must be semicolon-terminated，non-array-typed and instance-name-free. "+`Please check your '${u.name}' block declaration.`,e[m].line)}const g=l.find(e=>e.name===u.name);g&&(u.members&&JSON.stringify(g.members)!==JSON.stringify(u.members)&&error(`EFX2207: different UBO using the same name '${u.name}'`,p.line),g.stageFlags|=mapShaderStage(n),u.duplicate=g);let h=o;l!==r.buffers&&l!==r.images||(u.memoryAccess=mappings.getMemoryAccessFlag(e[o-2].data),/writeonly|readonly/.test(e[o-2].data)&&(h=o-2)),a.push({beg:e[h].position,end:e[m].position,param:u.duplicate||u,type:c}),u.duplicate||(u.defines=stripDuplicates(d),u.stageFlags=mapShaderStage(n),l.push(u)),o=m}return a}})(),miscChecks=(()=>{const e=new RegExp("\\b(?:asm|class|union|enum|typedef|template|this|packed|goto|switch|default|inline|noinline|volatile|public|static|extern|external|interface|flat|long|short|double|half|fixed|unsigned|superp|input|output|hvec2|hvec3|hvec4|dvec2|dvec3|dvec4|fvec2|fvec3|fvec4|sampler1D|sampler3D|sampler1DShadow|sampler2DShadow|sampler2DRect|sampler3DRect|sampler2DRectShadow|sizeof|cast|namespace|using|texture)\\b"),t=/precision\s+(low|medium|high)p\s+(\w+)/;return r=>{const n=t.exec(r);n?/#extension/.test(r.slice(n.index))&&warn("EFX2400: precision declaration should come after extensions"):warn("EFX2401: precision declaration not found.");const s=e.exec(r);if(s&&error(`EFX2402: using reserved keyword in glsl1: ${s[0]}`),options.skipParserTest)return;const a=tokenizer(r).filter(e=>"preprocessor"!==e.type);shaderTokens=a;try{parser(a)}catch(e){error(`EFX2404: glsl1 parser failed: ${e}`,0)}}})(),finalTypeCheck=(()=>{let e=null,t=!0;const r=(t,r)=>{let n=e.createShader(r);if(e.shaderSource(n,t),e.compileShader(n),!e.getShaderParameter(n,e.COMPILE_STATUS)){let r=1;const s=t.replace(/^|\n/g,()=>`\n${r++} `),a=e.getShaderInfoLog(n);e.deleteShader(n),n=null,error(`EFX2406: compilation failed: ↓↓↓↓↓ EXPAND THIS MESSAGE FOR MORE INFO ↓↓↓↓↓\n${a}\n${s}`)}return n};return(n,s,a,i,o)=>{if(!(()=>(e||"undefined"==typeof document||(e=document.createElement("canvas").getContext("webgl",{depth:!0,stencil:!0}))&&(e.getSupportedExtensions().forEach(t=>e.getExtension(t)),t=t&&e.getParameter(e.MAX_VERTEX_TEXTURE_IMAGE_UNITS)>=8),t&&e))())return;const l="#version 100\n"+(e=>e.reduce((e,t)=>{let r=1;switch(t.type){case"string":r=t.options[0];break;case"number":r=t.range[0];break;case"constant":r=t.default;break;case"boolean":r=void 0===t.default?1:t.default}return`${e}#define ${t.name} ${r}\n`},""))(a);shaderName=i;const c=r(l+n,e.VERTEX_SHADER);shaderName=o;const p=r(l+s,e.FRAGMENT_SHADER);shaderName="linking";const f=((...t)=>{let r=e.createProgram();if(t.forEach(t=>e.attachShader(r,t)),e.linkProgram(r),!e.getProgramParameter(r,e.LINK_STATUS)){const t=e.getProgramInfoLog(r);e.deleteProgram(r),r=null,error(`EFX2407: link failed: ${t}`)}return r})(c,p);e.deleteProgram(f),e.deleteShader(p),e.deleteShader(c)}})(),stripToSpecificVersion=(()=>{const globalSearch=/#(if|elif|else|endif)(.*)?/g,legalExpr=/^[\d<=>!|&^\s]*(__VERSION__)?[\d<=>!|&^\s]*$/,macroWrap=(e,t,r)=>t?`#if ${t}\n${e}#endif\n`:e,declareExtension=(e,t)=>"require"===t?`#extension ${e}: require\n`:`\n#ifdef ${e}\n#extension ${e}: enable\n#endif\n`;return(code,version,extensions,isVert)=>{version<310&&(code=code.replace(/layout\s*\((.*?)\)(\s*)(\w+)\s+(\w+)/g,(e,t,r,n,s)=>{if(!isVert&&"out"===n)return e;if("out"!==n&&"in"!==n&&"uniform"!==n)return e;if("uniform"===n&&s.startsWith("image"))return e;return`${t.indexOf("std140")>=0?"layout(std140)"+r+n:n} ${s}`}));const instances=[];let cap=null,temp=null;for(;cap=globalSearch.exec(code),cap;)if("if"===cap[1]){if(temp){temp.level++;continue}if(!legalExpr.test(cap[2]))continue;temp={start:cap.index,end:cap.index,conds:[cap[2]],content:[cap.index+cap[0].length],level:1}}else if("elif"===cap[1]){if(!temp||temp.level>1)continue;legalExpr.test(cap[2])||(error(`EFX2301: #elif conditions after a constant #if should be constant too; get '${cap[2]}'`),cap[2]=""),temp.conds.push(cap[2]),temp.content.push(cap.index,cap.index+cap[0].length)}else if("else"===cap[1]){if(!temp||temp.level>1)continue;temp.conds.push("true"),temp.content.push(cap.index,cap.index+cap[0].length)}else if("endif"===cap[1]){if(!temp||--temp.level)continue;temp.content.push(cap.index),temp.end=cap.index+cap[0].length,instances.push(temp),temp=null}let res=code;if(instances.length){res=res.substring(0,instances[0].start);for(let j=0;j<instances.length;j++){const ins=instances[j];for(let i=0;i<ins.conds.length;i++)if(eval(ins.conds[i].replace("__VERSION__",version))){const e=code.substring(ins.content[2*i],ins.content[2*i+1]);res+=stripToSpecificVersion(e,version,isVert);break}const next=instances[j+1]&&instances[j+1].start||code.length;res+=code.substring(ins.end,next)}}for(const ext in extensions){const{defines:defines,cond:cond,level:level,runtimeCond:runtimeCond}=extensions[ext];eval(cond.replace("__VERSION__",version))&&(res=macroWrap(declareExtension(ext,level),runtimeCond,defines)+res)}return res}})(),glsl300to100=(e,t,r,n,s,a,i)=>{let o="",l=0;if(n.forEach(r=>{if("blocks"!==r.type)return;const n=(o+=e.slice(l,r.beg)).length-o.search(/\s*$/)+1;t.find(e=>e.name===r.param.name).members.forEach(t=>{const r=e.match(new RegExp(`\\b${t.name}\\b`,"g"));if(!r||r.length<=1)return;const s=convertType(t.type),a=t.precision||"",i="string"==typeof t.count||t.isArray?`[${t.count}]`:"";o+=" ".repeat(n)+`uniform ${a}${s} ${t.name}${i};\n`}),l=r.end+(";"===e[r.end])}),o=(o+=e.slice(l)).replace(/\btexture((?!2D|Cube)\w*)\s*\(\s*(\w+)\s*([,[])/g,(e,t,n,a,i)=>{const l="texture"+t;if(s.find(e=>e.name===l))return e;let c=new RegExp("sampler(\\w+)\\s+"+n);const p=s.find(e=>i>e.beg&&i<e.end);let f=p&&c.exec(o.substring(p.beg,p.eng))||c.exec(o);if(!f){const t=r.find(e=>e.name===n);if(t&&t.options)for(const e of t.options)if(f=(c=new RegExp("sampler(\\w+)\\s+"+e)).exec(o))break;if(!f)return error(`EFX2300: sampler '${n}' does not exist`),e}return`texture${f[1]}${t}(${n}${a}`}),i)o=(o=o.replace(inDecl,(e,t,r)=>`attribute ${r};`)).replace(outDecl,(e,t,r)=>`varying ${r};`);else{const e=[];if(o=(o=o.replace(inDecl,(e,t,r)=>`varying ${r};`)).replace(outDecl,(t,r,n,s)=>{const a=r&&locationRE.exec(r);return a||error("EFX2302: fragment output location must be specified"),e.push({name:s,location:a[1]}),""}),1===e.length){const t=new RegExp(e[0].name,"g");o=o.replace(t,"gl_FragColor")}else if(e.length>1){for(const t of e){const e=new RegExp(t.name,"g");o=o.replace(e,`gl_FragData[${t.location}]`)}a.extensions.GL_EXT_draw_buffers||(a.extensions.GL_EXT_draw_buffers={defines:[],cond:"__VERSION__ <= 100",level:"enable"})}}return(o=o.replace(/layout\s*\(.*?\)\s*/g,()=>"")).replace(pragmasToStrip,"")},decorateBlockMemoryLayouts=(e,t)=>{let r=0;const n=[];t.forEach((t,s)=>{if("blocks"!==t.type&&"buffers"!==t.type)return;const a="buffers"===t.type,i=e.slice(r,t.beg),o=layoutExtract.exec(i);n[s]=o?r+o.index+(a?0:o[0].length-o[2].length-1):-1,r=t.end});let s="";return r=0,t.forEach((t,a)=>{const i=n[a];if(void 0!==i){if("blocks"===t.type)i<0?(s+=e.slice(r,t.beg),s+="layout(std140) "):(s+=e.slice(r,i),s+=", std140",s+=e.slice(i,t.beg));else if("buffers"===t.type){let n="std430";t.param.tags&&void 0!==t.param.tags.glBinding&&(n+=`, binding = ${t.param.tags.glBinding}`),s+=e.slice(r,i<0?t.beg:i),s+=`layout(${n}) `}s+=e.slice(t.beg,t.end),r=t.end}}),s+=e.slice(r)},decorateBindings=(e,t,r)=>{let n=0;const s=[],a={};(r=r.filter(e=>!builtinRE.test(e.param.name))).forEach((r,i)=>{if("fragColors"===r.type)return;const o=r.param.name;if(!t[r.type])return;const l=e.slice(n,r.beg),c={prop:r.param},p=layoutExtract.exec(l),f=a[r.type]||(a[r.type]={});if(p){c.position=n+p.index+p[0].length-p[2].length-1;const e=bindingExtract.exec(p[1]);if(e){p[1].search(/\bset\s*=/)<0?c.position=p[1].length-c.position:c.position=-1;const n=parseInt(e[1]),s="varyings"===r.type||"attributes"===r.type?"location":"binding";let a=t[r.type].find(e=>e[s]===n);a||"subpassInputs"!==r.type||(a=!0),a?(f[n]&&f[n]!==o&&error(`EFX2600: duplicated binding/location declaration for '${f[n]}' and '${o}'`),f[f[n]=o]=n):"blocks"===r.type?error(`EFX2601: illegal custom binding for '${o}', block bindings should be consecutive and start from 0`):"samplerTextures"===r.type?error(`EFX2602: illegal custom binding for '${o}', texture bindings should be consecutive and after all the blocks`):"buffers"===r.type?error(`EFX2603: illegal custom binding for '${o}', buffer bindings should be consecutive and after all the `+"blocks/samplerTextures"):"images"===r.type?error(`EFX2604: illegal custom binding for '${o}', image bindings should be consecutive and after all the `+"blocks/samplerTextures/buffers"):"textures"===r.type?error(`EFX2605: illegal custom binding for '${o}', texture bindings should be consecutive and after all the `+"blocks/samplerTextures/buffers/images"):"samplers"===r.type?error(`EFX2606: illegal custom binding for '${o}', sampler bindings should be consecutive and after all the `+"blocks/samplerTextures/buffers/images/textures"):error(`EFX2607: illegal custom location for '${o}', locations should be consecutive and start from 0`)}}s[i]=c,n=r.end}),r.forEach((e,r)=>{if(!a[e.type])return;const n="attributes"===e.type||"varyings"===e.type||"fragColors"===e.type?"location":"binding",i=a[e.type],o=e.param.name;if("attributes"===e.type)if(o in i)s[r].prop[n]=i[o];else{let e=0;for(;i[e];)e++;s[r].prop[n]=e,i[e]=o}else if(o in i){const a=s[r].prop[n],l=t[e.type].find(e=>e[n]===i[o]);l&&(l[n]=a),s[r].prop[n]=i[o]}});let i="";n=0;const o=mappings.SetIndex.MATERIAL;return r.forEach((t,r)=>{if(!s[r])return;const a="attributes"===t.type||"varyings"===t.type||"fragColors"===t.type,l=a?"location":"binding",{position:c,prop:p}=s[r],f=a?"":`set = ${o}, `;void 0===c?(i+=e.slice(n,t.beg),i+=`layout(${f+l} = ${p[l]}) `):c>=0?(i+=e.slice(n,c),i+=`, ${f+l} = ${p[l]}`,i+=e.slice(c,t.beg)):c<-1?(i+=e.slice(n,-c),i+=f,i+=e.slice(-c,t.beg)):i+=e.slice(n,t.beg),i+=e.slice(t.beg,t.end),n=t.end}),i+=e.slice(n),t.samplerTextures=t.samplerTextures.filter(e=>t.subpassInputs.findIndex(t=>t.binding===e.binding)<0),i},remapDefine=(e,t)=>{for(let r=0;r<e.defines.length;++r){let n=t.get(e.defines[r]);for(;n;)e.defines[r]=n,n=t.get(n)}},shaderFactory=(()=>{const e=/\s+$/gm,t=/(^\s*\n){2,}/gm,r=r=>{let n=r.replace(pragmasToStrip,"");return n=(n=n.replace(t,"\n")).replace(e,"")},n=(e,t)=>r=>{if(!builtinRE.test(r.name))return!0;const n=r.tags;let s;return s=n&&n.builtin?n.builtin:"global",t[`${s}s`][e].push({name:r.name,defines:r.defines}),!1},s=(e,t,r)=>{const n=t[r];for(let t=0;t!==n.length;++t){const s=n[t];if(void 0!==s.rate){e[s.rate][r].push(s);continue}if(!builtinRE.test(s.name)){e[1][r].push(s);continue}const a=s.tags;s.tags&&s.tags.builtin?"global"===a.builtin?e[3][r].push(s):"local"===a.builtin&&e[0][r].push(s):e[3][r].push(s)}},a=(e,t,r)=>"main"===t?e:e+((e,t)=>{switch(e){case"vert":return`\nvoid main() { gl_Position = ${t}(); }\n`;case"frag":return`\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = ${t}(); }\n`;default:return`\nvoid main() { ${t}(); }\n`}})(r,t),i=/([^:]+)(?::(\w+))?/,o={instance:0,batch:1,phase:2,pass:3},l=(e,t)=>{e.forEach(e=>{const r=t.find(t=>t.name===e.name);r&&(e.rate=o[r.rate])})},c={version:"300 es"},p=(e,t,r=[],n={blocks:[],samplerTextures:[],samplers:[],textures:[],buffers:[],images:[],subpassInputs:[],attributes:[],varyings:[],fragColors:[],descriptors:[]},s=globalChunks,o=globalDeprecations)=>{const p={};shaderName=e;const f={lines:[],extensions:{}},{code:d,record:u,functions:m}=((e,t,r,n,s="main")=>{const o=i.exec(e),l=o[2]||s,c=new Set,p=[];let f=unwindIncludes(`#include <${o[1]}>`,t,r,c);return f=a(f,l,n),f=expandLiteralMacro(f),f=expandFunctionalMacro(f),{code:f=eliminateDeadCode(f,l,p),record:c,functions:p}})(e,s,o,t),g=shaderTokens=tokenizer(d,c),h=extractMacroDefinitions(d);f.existingDefines=h[0];const b=h[1];extractDefines(g,r,f);const y=extractUpdateRates(g),x=extractParams(g,f,n,t,m);p.blockInfo=x,p.record=u,p.extensions=f.extensions,p.glsl4=d,n.attributes.forEach(e=>{remapDefine(e,b)}),n.blocks.forEach(e=>{remapDefine(e,b)}),n.buffers.forEach(e=>{remapDefine(e,b)}),n.images.forEach(e=>{remapDefine(e,b)}),n.samplerTextures.forEach(e=>{remapDefine(e,b)}),n.samplers.forEach(e=>{remapDefine(e,b)}),n.textures.forEach(e=>{remapDefine(e,b)}),l(n.blocks,y),l(n.buffers,y),l(n.images,y),l(n.samplerTextures,y),l(n.samplers,y),l(n.textures,y);const E="vert"==t;return p.glsl3=stripToSpecificVersion(decorateBlockMemoryLayouts(d,x),300,f.extensions,E),"vert"==t||"frag"==t?(p.glsl1=stripToSpecificVersion(glsl300to100(d,n.blocks,r,x,m,f,E),100,f.extensions,E),miscChecks(p.glsl1)):p.glsl1="",p};return{compile:p,build:(e,t,a=globalChunks,i=globalDeprecations)=>{let o=[];const l={blocks:[],samplerTextures:[],samplers:[],textures:[],buffers:[],images:[],subpassInputs:[],attributes:[],varyings:[],fragColors:[],descriptors:[]},c={vert:"",frag:""};for(const t in e)c[t]=p(e[t],t,o,l,a,i);"graphics"===t&&finalTypeCheck(c.vert.glsl1,c.frag.glsl1,o,e.vert,e.frag);const f={globals:{blocks:[],samplerTextures:[],buffers:[],images:[]},locals:{blocks:[],samplerTextures:[],buffers:[],images:[]},statistics:{}};o=o.filter(e=>"constant"!==e.type);let d=0,u=0,m=0;l.blocks.forEach(e=>{const t=e.members.reduce((e,t)=>"number"!=typeof t.count?e:e+Math.ceil(mappings.GetTypeSize(t.type)/16)*t.count,0);e.stageFlags&VSBit&&(d+=t),e.stageFlags&FSBit&&(u+=t),e.stageFlags&CSBit&&(m+=t)},0),"graphics"===t&&(f.statistics.CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS=d,f.statistics.CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS=u),"compute"===t&&(f.statistics.CC_EFFECT_USED_COMPUTE_UNIFORM_VECTORS=m),l.descriptors[0]={rate:0,blocks:[],samplerTextures:[],samplers:[],textures:[],buffers:[],images:[],subpassInputs:[]},l.descriptors[1]={rate:1,blocks:[],samplerTextures:[],samplers:[],textures:[],buffers:[],images:[],subpassInputs:[]},l.descriptors[2]={rate:2,blocks:[],samplerTextures:[],samplers:[],textures:[],buffers:[],images:[],subpassInputs:[]},l.descriptors[3]={rate:3,blocks:[],samplerTextures:[],samplers:[],textures:[],buffers:[],images:[],subpassInputs:[]},((e,t)=>{s(e,t,"blocks"),s(e,t,"samplerTextures"),s(e,t,"samplers"),s(e,t,"textures"),s(e,t,"buffers"),s(e,t,"images")})(l.descriptors,l);for(let e=0;4!==e;++e)l.descriptors[e].blocks.forEach(e=>{for(const t of e.members)"number"!=typeof t.count&&(t.count=0)});l.blocks=l.blocks.filter(n("blocks",f)),l.samplerTextures=l.samplerTextures.filter(n("samplerTextures",f)),l.buffers=l.buffers.filter(n("buffers",f)),l.images=l.images.filter(n("images",f)),l.attributes.forEach(e=>{if(e.format=mappings.formatMap[e.typename],e.defines.indexOf("USE_INSTANCING")>=0&&(e.isInstanced=!0),e.tags&&e.tags.format){const t=mappings.getFormat(e.tags.format);void 0!==t&&(e.format=t),mappings.isNormalized(t)&&(e.isNormalized=!0)}}),l.attributes.forEach(e=>(delete e.tags,delete e.typename,delete e.precision,delete e.isArray,delete e.type,delete e.count,delete e.stageFlags)),l.varyings.forEach(e=>(delete e.tags,delete e.typename,delete e.precision,delete e.isArray)),l.blocks.forEach(e=>(delete e.rate,delete e.tags,e.members.forEach(e=>(delete e.typename,delete e.precision,delete e.isArray)))),l.samplerTextures.forEach(e=>(delete e.rate,delete e.tags,delete e.typename,delete e.precision,delete e.isArray)),l.buffers.forEach(e=>(delete e.rate,delete e.tags,delete e.typename,delete e.precision,delete e.isArray,delete e.members)),l.images.forEach(e=>(delete e.rate,delete e.tags,delete e.typename,delete e.precision,delete e.isArray)),l.textures.forEach(e=>(delete e.rate,delete e.tags,delete e.typename,delete e.precision,delete e.isArray)),l.samplers.forEach(e=>(delete e.rate,delete e.tags,delete e.typename,delete e.precision,delete e.isArray)),l.subpassInputs.forEach(e=>(delete e.rate,delete e.tags,delete e.typename,delete e.precision,delete e.isArray,delete e.type));let g=0;l.blocks.forEach(e=>e.binding=g++),l.samplerTextures.forEach(e=>e.binding=g++),l.samplers.forEach(e=>e.binding=g++),l.textures.forEach(e=>e.binding=g++),l.buffers.forEach(e=>e.binding=g++),l.images.forEach(e=>e.binding=g++),l.subpassInputs.forEach(e=>e.binding=g++);let h=0;l.attributes.forEach(e=>e.location=h++),h=0,l.varyings.forEach(e=>e.location=h++),h=0,l.fragColors.forEach(e=>e.location=h++),l.blocks.forEach(e=>e.defines=e.defines.filter(e=>o.find(t=>e.endsWith(t.name)))),l.samplerTextures.forEach(e=>e.defines=e.defines.filter(e=>o.find(t=>e.endsWith(t.name)))),l.samplers.forEach(e=>e.defines=e.defines.filter(e=>o.find(t=>e.endsWith(t.name)))),l.textures.forEach(e=>e.defines=e.defines.filter(e=>o.find(t=>e.endsWith(t.name)))),l.buffers.forEach(e=>e.defines=e.defines.filter(e=>o.find(t=>e.endsWith(t.name)))),l.images.forEach(e=>e.defines=e.defines.filter(e=>o.find(t=>e.endsWith(t.name)))),l.subpassInputs.forEach(e=>e.defines=e.defines.filter(e=>o.find(t=>e.endsWith(t.name)))),l.attributes.forEach(e=>e.defines=e.defines.filter(e=>o.find(t=>e.endsWith(t.name)))),l.varyings.forEach(e=>e.defines=e.defines.filter(e=>o.find(t=>e.endsWith(t.name)))),l.fragColors.forEach(e=>e.defines=e.defines.filter(e=>o.find(t=>e.endsWith(t.name))));const b={},y={},x={},E=new Set;for(const t in e){const e="vert"===t;c[t].glsl4=stripToSpecificVersion(decorateBindings(c[t].glsl4,l,c[t].blockInfo),460,c[t].extensions,e),x[t]=r(c[t].glsl4),y[t]=r(c[t].glsl3),b[t]=r(c[t].glsl1),c[t].record.forEach(e=>E.add(e))}let v=0;return"graphics"===t?((x.compute||y.compute)&&error("compute shader is not supported in graphics effect"),v=mappings.murmurhash2_32_gc(x.vert+x.frag+y.vert+y.frag+b.vert+b.frag,666)):((x.vert||x.frag||y.vert||y.frag||b.vert||b.frag)&&error("vertex/fragment shader is not supported in compute effect"),v=mappings.murmurhash2_32_gc(x.vert+x.frag+x.compute+y.vert+y.frag+y.compute+b.vert+b.frag,666)),Object.assign(l,{hash:v,glsl4:x,glsl3:y,glsl1:b,builtins:f,defines:o,record:E})}}})(),compileShader=shaderFactory.compile,parseEffect=(()=>{const e=/CCEffect\s*%{([^]+?)(?:}%|%})/,t=/CCProgram\s*([\w-]+)\s*%{([^]*?)(?:}%|%})/,r=/#.*$/gm,n=/^\s*$/,s=/\n[^\s]/,a=/^[^\S\n]/gm,i=/\t/g,o=(e,t,r="effect")=>{if(Array.isArray(e)){if(!Array.isArray(t))return void error(`EFX1002: ${r} must be an array`);if(e[0])for(let n=0;n<t.length;n++)o(e[0],t[n],r+`[${n}]`)}else{if(!t||"object"!=typeof t||Array.isArray(t))return void error(`EFX1003: ${r} must be an object`);for(const e of Object.keys(t))-1!==e.indexOf(":")&&error(`EFX1004: syntax error at '${e}', you might need to insert a space after colon`);if(e.any)for(const n of Object.keys(t))o(e.any,t[n],r+`.${n}`);else for(const n of Object.keys(e)){let s=n;if("$"===s[0])s=s.substring(1);else if(!t[s])continue;o(e[n],t[s],r+`.${s}`)}}};return(l,c)=>{shaderName="syntax",c=c.replace(i," ".repeat(tabAsSpaces));let p={},f={},d={};const u=e.exec((e=>e.replace(r,""))(c));if(u){try{const e=yaml.load(u[1]);p=JSON.parse(JSON.stringify(e))}catch(e){error(`EFX1001: CCEffect parser failed: ${e}`)}p.name||(p.name=l),o(mappings.effectStructure,p)}else error("EFX1000: CCEffect is not defined");c=stripComments(c);let m=t.exec(c);for(;m;){let e=m[2];if(!n.test(e))for(;!s.test(e);)e=e.replace(a,"");addChunk(m[1],e,f,d),c=c.substring(m.index+m[0].length),m=t.exec(c)}return{effect:p,templates:f,localDeprecations:d}}})(),mapPassParam=(()=>{const e=(e,t)=>{let r=0,n=t=>t.name===e&&(r=t.type,!0);return t.blocks.some(e=>e.members.some(n))||t.samplerTextures.some(n),r},t=(e,t,r)=>{if(t<=0)return"no matching uniform";if(void 0===e)return"";if("string"===r){if(!mappings.isSampler(t))return"string for vectors"}else{if(!Array.isArray(e))return"non-array for buffer members";if(e.length!==mappings.GetTypeSize(t)/4)return"wrong array length"}return""},r=/^(\w+)(?:\.([xyzw]+|[rgba]+))?$/,n={x:0,y:1,z:2,w:3,r:0,g:1,b:2,a:3},s=(t,s)=>{const a=[t,0,0],i=r.exec(t);if(!i)return error(`EFX3303: illegal property target '${t}'`),a;const o=i[2]&&i[2].toLowerCase()||"",l=n[o[0]]||0;return o.split("").map((e,t)=>n[e]-l-t).some(e=>e)&&error(`EFX3304: '${t}': random component swizzle is not supported`),a[0]=i[1],a[1]=l,a[2]=e(i[1],s),o.length&&(a[2]-=Math.max(0,mappings.GetTypeSize(a[2])/4-o.length)),a[2]<=0&&error(`EFX3305: no matching uniform target '${t}'`),a},a=(e,t)=>{for(const r of Object.keys(t)){const n=t[r];"object"==typeof n&&"object"==typeof e[r]?a(e[r],n):void 0===e[r]&&(e[r]=n)}},i=e=>{for(const t in e){const r=e[t];if("string"==typeof r){let n=parseInt(r);isNaN(n)&&(n=mappings.passParams[r.toUpperCase()]),void 0!==n&&(e[t]=n)}else if(Array.isArray(r)){if(!r.length)continue;switch(typeof r[0]){case"object":r.forEach(i);break;case"string":i(r);break;case"number":e[t]=(255*r[0]<<24|255*r[1]<<16|255*r[2]<<8|255*(r[3]||255))>>>0}}else"object"==typeof r&&i(r)}return e},o=new mappings.SamplerInfo,l=e=>{for(const t of Object.keys(e))void 0===o[t]&&warn(`EFX3301: illegal sampler info '${t}'`);return mappings.Sampler.computeHash(e)},c=/^([a-zA-Z]+)?\s*([+-])?\s*([\dxabcdef]+)?$/i,p=mappings.RenderPriority.DEFAULT,f=mappings.RenderPriority.MIN,d=mappings.RenderPriority.MAX;return(r,n)=>{shaderName="type error";const o={};r.priority&&(o.priority=(e=>{let t=0;const r=c.exec(e);return r[1]&&(t=mappings.RenderPriority[r[1].toUpperCase()]),r[3]&&(t+=parseInt(r[3])*("-"===r[2]?-1:1)),isNaN(t)||t<f||t>d?(warn(`EFX3000: illegal pass priority: ${e}`),p):t})(r.priority),delete r.priority),r.depthStencilState&&(o.depthStencilState=(e=>{for(const t of Object.keys(e))t.startsWith("stencil")&&(t.endsWith("Front")||t.endsWith("Back")||(e[t+"Front"]=e[t+"Back"]=e[t],delete e[t]));return e.stencilWriteMaskFront!==e.stencilWriteMaskBack&&warn("EFX3100: WebGL(2) doesn't support inconsistent front/back stencil write mask"),e.stencilReadMaskFront!==e.stencilReadMaskBack&&warn("EFX3101: WebGL(2) doesn't support inconsistent front/back stencil read mask"),e.stencilRefFront!==e.stencilRefBack&&warn("EFX3102: WebGL(2) doesn't support inconsistent front/back stencil ref"),i(e)})(r.depthStencilState),delete r.depthStencilState),r.switch&&(o.switch=((e,t)=>(t.defines.find(t=>t.name===e)&&error("EFX3200: existing shader macros cannot be used as pass switch"),e))(r.switch,n),delete r.switch),r.properties&&(o.properties=((r,n)=>{let o={};for(const a of Object.keys(r)){if("__metadata__"===a){o=r[a],delete r[a];continue}const c=r[a],p=e(a,n);if(void 0!==c.type&&warn(`EFX3300: property '${a}': you don't have to specify type in here`),c.type=p,c.target){c.handleInfo=s(c.target,n),delete c.target,c.type=c.handleInfo[2];const t=c.editor&&c.editor.visible,a=c.handleInfo[0],i=e(c.handleInfo[0],n);r[a]||(r[a]={type:i,editor:{visible:!1}}),(void 0===t||t)&&(r[a].editor?void 0===r[a].editor.deprecated&&(r[a].editor.deprecated=!0):r[a].editor={deprecated:!0}),mappings.isSampler(i)?c.value&&(r[a].value=c.value):(r[a].value||(r[a].value=Array(mappings.GetTypeSize(i)/4).fill(0)),Array.isArray(c.value)?r[a].value.splice(c.handleInfo[1],c.value.length,...c.value):void 0!==c.value&&r[a].value.splice(c.handleInfo[1],1,c.value))}c.sampler&&(c.samplerHash=l(i(c.sampler)),delete c.sampler);const f=typeof c.value;"number"!==f&&"boolean"!==f||(c.value=[c.value]);const d=t(c.value,c.type,f);d&&error(`EFX3302: illegal property declaration for '${a}': ${d}`)}for(const e of Object.keys(r))a(r[e],o);return r})(r.properties,n),delete r.properties),r.migrations&&(o.migrations=r.migrations,delete r.migrations),i(r),Object.assign(r,o)}})(),reduceHeaderRecord=e=>{const t=new Set;for(const r of e)r.record.forEach(t.add,t);return[...t.values()]},stageValidation=e=>{const t={vert:"graphics",frag:"graphics",compute:"compute"};if(0===e.length)return error("0 stages provided for a pass"),"";const r=t[e[0]];if(e.forEach(e=>t[e]?t[e]!==r?(error("more than one pass type appears"),""):void 0:(error(`invalid stage type ${e}`),"")),"graphics"===r){const t=e.find(e=>"vert"===e),r=e.find(e=>"frag"===e);if(1===e.length||!t||!r)return error("graphics pass must include vert and frag shaders"),""}return r},buildEffect=(e,t)=>{effectName=e;let{effect:r,templates:n,localDeprecations:s}=parseEffect(e,t);if(!r||!Array.isArray(r.techniques))return null;n=Object.assign({},globalChunks,n);const a={};for(const e in globalDeprecations)a[e]=Object.assign({},globalDeprecations[e],s[e]);const i=Object.keys(a.identifiers).reduce((e,t)=>`|${t}`+e,"").slice(1);i.length&&(a.identifierRE=new RegExp(`\\b(${i})\\b`,"g"));const o=r.shaders=[];for(const e of r.techniques)for(const t of e.passes){const e={},r=[];t.vert&&(e.vert=t.vert,delete t.vert,r.push("vert")),t.frag&&(e.frag=t.frag,delete t.frag,r.push("frag")),t.compute&&(e.compute=t.compute,delete t.compute,r.push("compute"));const s=t.program=r.reduce((t,r)=>t.concat(`|${e[r]}`),effectName),i=stageValidation(r);if(""===i)continue;let l=o.find(e=>e.name===s);l||((l=shaderFactory.build(e,i,n,a)).name=s,o.push(l)),mapPassParam(t,l)}return r.dependencies=reduceHeaderRecord(o),r};module.exports={options:options,addChunk:addChunk,compileShader:compileShader,buildEffect:buildEffect};