"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.unload=exports.load=exports.methods=void 0;const child_process_1=require("child_process"),fs_extra_1=require("fs-extra"),path_1=require("path"),parse=require("plist").parse;let programConfig={};const NOT_UNDERLINE=["cmake","browser"];function executeProgram(e,r){return new Promise((o,t)=>{var n,a;r=r||[];let s="";if("darwin"===process.platform){if(e.endsWith(".app")){e=(0,path_1.join)(e,"/Contents/MacOS/");const r=parse((0,fs_extra_1.readFileSync)((0,path_1.join)(e,"../Info.plist"),"utf8")),o=(0,path_1.join)(e,r.CFBundleExecutable);e=o}s="open",r?(r.splice(0,0,e),r.splice(0,0,"-a")):r=["-a",e]}else s=e;console.debug(`program command : ${s} ${r.join(" ")}`);const i=(0,child_process_1.spawn)(s,r,{detached:!0,stdio:"ignore"});null===(n=i.stdout)||void 0===n||n.on("data",e=>{console.log(`[execute program] ${e}`)}),null===(a=i.stderr)||void 0===a||a.on("data",e=>{console.error(`[execute program error] ${e}`)}),i.on("error",r=>{t(`${e} exit with error: ${r.message}`)}),i.on("close",r=>{0!==r?t(`${e} exit width code ${r}`):o()}),i.unref()})}function handleArguments(e,r){if(!r||"object"!=typeof r)return[];let o=e.commandArgument?e.commandArgument.replace(/}\s+/g,"}@#").replace(/\s+\${/g,"@#${"):"";const t=e.arguments||{};let n=[];for(const e in r)if(t[e]){if("boolean"==typeof r[e]){o=o.replace(`\${${e}}`,r[e]?e:"");continue}o.includes(`\${${e}}`)?o=o.replace(`\${${e}}`,`${r[e]}`):o+=`@#${r[e]}`}return n=o.replace(/\${(.+?)}/g,"@#").replace(/(@#){2,}/g,"@#").replace(/^(\s|@#)+|(\s|@#)+$/g,"").split("@#"),r._args&&n.push(...r._args),n}async function load(){Editor.Package.getPackages({enable:!0}).forEach(exports.methods.attach),Editor.Package.__protected__.on("enable",exports.methods.attach)}function unload(){Editor.Package.__protected__.removeListener("enable",exports.methods.attach)}exports.methods={async queryProgramInfo(e){if(!e)return null;NOT_UNDERLINE.includes(e)&&(e=`${e}V2`);for(const r in programConfig)for(const o in programConfig[r])if(o===e){const e=programConfig[r][o];return{label:e.label,description:e.description,arguments:e.arguments,path:await Editor.Profile.getConfig(r,`${o}.path`)||"",commandArgument:await Editor.Profile.getConfig(r,`${o}.commandArgument`)||""}}return null},async queryPrograms(){const e={};for(const r in programConfig)for(const o in programConfig[r]){const t=programConfig[r][o],n={label:t.label,description:t.description,arguments:t.arguments,path:await Editor.Profile.getConfig(r,`${o}.path`)||"",commandArgument:await Editor.Profile.getConfig(r,`${o}.commandArgument`)||""};let a=o;"program"===r&&o.endsWith("V2")&&NOT_UNDERLINE.includes(a.replace(/(V2)?$/g,""))&&(a=a.replace(/(V2)?$/g,"")),e[r]=Object.assign({},e[r]),e[r][a]=n}return e},queryProgramConfig:()=>programConfig||{},async execute(e,r){if(e)try{const o=await exports.methods.queryProgramInfo(e);if(!o||!o.path)return console.warn(Editor.I18n.t("program.console.noProgram",{program:e}));if(!(0,fs_extra_1.existsSync)(o.path))throw new Error(Editor.I18n.t("program.console.programPathErr"));console.log("program startup..."),await executeProgram(o.path,handleArguments(o,r))}catch(e){console.error(e)}},async attach(e){if(!e.invalid&&e.info.contributions&&e.info.contributions.program){e.name,e.info;try{const r=e.info.contributions.program,o={};for(const e in r)o[e]={label:r[e].label,description:r[e].description,render:r[e].render,arguments:r[e].arguments};programConfig=Object.assign({},programConfig,{[e.name]:o})}catch(r){console.log(`[program] ${e.name} register program failed.`),console.error(r)}}}},exports.load=load,exports.unload=unload;