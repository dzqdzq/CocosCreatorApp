"use strict";var __createBinding=this&&this.__createBinding||(Object.create?function(e,i,t,r){void 0===r&&(r=t);var o=Object.getOwnPropertyDescriptor(i,t);o&&("get"in o?i.__esModule:!o.writable&&!o.configurable)||(o={enumerable:!0,get:function(){return i[t]}}),Object.defineProperty(e,r,o)}:function(e,i,t,r){void 0===r&&(r=t),e[r]=i[t]}),__setModuleDefault=this&&this.__setModuleDefault||(Object.create?function(e,i){Object.defineProperty(e,"default",{enumerable:!0,value:i})}:function(e,i){e.default=i}),__importStar=this&&this.__importStar||function(e){if(e&&e.__esModule)return e;var i={};if(null!=e)for(var t in e)"default"!==t&&Object.prototype.hasOwnProperty.call(e,t)&&__createBinding(i,e,t);return __setModuleDefault(i,e),i};Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=exports.getRightEngine=exports.rebuildImportMaps=exports.rebuild=exports.compileEngine=void 0;const build_engine_1=require("@cocos/build-engine"),utils_1=require("@editor/lib-programming/dist/utils"),child_process_1=require("child_process"),fs_extra_1=require("fs-extra"),path_1=require("path");let compiler=null,nativeCompiler=null,engineDir="",busy=!1,outDir="";const editorFeaturesCache=[],VERSION="3";async function compileEngine(e,i){engineDir=e,outDir=(0,path_1.join)(e,"bin",".cache","dev");const t=[(0,path_1.join)(outDir,"editor"),(0,path_1.join)(outDir,"preview")],r=(0,path_1.join)(outDir,"VERSION");let o=!1;try{await(0,fs_extra_1.readFile)(r,"utf8")!==VERSION&&(o=!0)}catch(e){o=!0}compiler=await generateCompiler();const n=await getIsSceneNative();let a=!1;n&&(nativeCompiler=await generateCompiler({isNative:!0}),a=await getIsDebugNative(),t.push((0,path_1.join)(engineDir,"bin/.editor"))),o?(console.debug("[EditorQuickCompiler]Version information lost."),await Promise.all(t.map(e=>{if((0,fs_extra_1.existsSync)(e))return(0,fs_extra_1.emptyDir)(e)}))):console.debug("[EditorQuickCompiler]Version information looks good."),(o||a||(null===Editor||void 0===Editor?void 0:Editor.App.dev)||i)&&!process.argv.includes("--no-quick-compile")?(await rebuild({isNativeScene:n,debugNative:a}),await(0,fs_extra_1.outputFile)(r,VERSION,{encoding:"utf8"})):console.debug("Note, quick compiler does not get launched.")}async function generateCompiler(e){const{QuickCompiler:i}=await Promise.resolve().then(()=>__importStar(require("@editor/quick-compiler"))),t=(null===Editor||void 0===Editor?void 0:Editor.Project.tmpDir)?(0,path_1.join)(engineDir,"bin",".cache","logs","log.txt"):void 0;t&&await(0,fs_extra_1.ensureDir)((0,path_1.dirname)(t));const r=["wait-for-ammo-instantiation"],o=(await build_engine_1.StatsQuery.create(engineDir)).getFeatures(),n=o.filter(e=>!r.includes(e));editorFeaturesCache.push(...n);if(null===e||void 0===e?void 0:e.isNative){const e=(0,path_1.join)(engineDir,"bin/.editor");return new i({rootDir:engineDir,outDir:e,targets:[{featureUnitPrefix:"cce:/internal/x/cc-fu/",dir:e,format:"systemjs",targets:"node 10",loose:!1,includeEditorExports:!0,includeIndex:{features:o},loader:!0}],logFile:t,platform:"NATIVE"})}return new i({rootDir:engineDir,outDir:outDir,targets:[{featureUnitPrefix:"cce:/internal/x/cc-fu/",dir:(0,path_1.join)(outDir,"editor"),format:"systemjs",usedInElectron509:!0,targets:utils_1.editorBrowserslistQuery,includeIndex:{features:n},loader:!0},{featureUnitPrefix:"cce:/internal/x/cc-fu/",dir:(0,path_1.join)(outDir,"preview"),format:"systemjs",loose:!0}],logFile:t})}async function rebuild(e){if(void 0===(null===e||void 0===e?void 0:e.isNativeScene)&&(null!==e&&void 0!==e||(e={}),e.isNativeScene=await getIsSceneNative(),e.isNativeScene&&(e.debugNative=await getIsDebugNative())),!compiler||(null===e||void 0===e?void 0:e.isNativeScene)&&!nativeCompiler)return void await compileEngine(engineDir,!0);if(busy)return void console.error("Compile engine fails: The compilation is in progress");busy=!0,console.log("Start Quick Compile");const i=Date.now();if(!compiler)return busy=!1,void console.error("Compile engine fails: The compiler does not exist.");try{e.isNativeScene&&(await nativeCompiler.build(),await rebuildNativeImportMap(),await generateEngineAddon(e),await updateAdapter()),await compiler.build(),Editor&&await rebuildImportMaps()}catch(e){throw e}finally{console.log("Quick Compile: "+(Date.now()-i)+"ms"),busy=!1}}async function rebuildImportMaps(){if(!compiler)return;const e=await getEditorShippedFeatures();await rebuildTargetImportMap(compiler,0,e);const i=await getPreviewShippedFeatures();await rebuildTargetImportMap(compiler,1,i)}async function rebuildNativeImportMap(){const e=await getEditorShippedFeatures();await rebuildTargetImportMap(nativeCompiler,0,e,"NATIVE","EDITOR")}async function rebuildTargetImportMap(e,i,t,r,o,n){const a=await getConfigurableFlagsOfFeatures(t);await e.buildImportMap(i,t,{mode:o,platform:r,out:n,features:t,configurableFlags:a})}async function getEditorShippedFeatures(){return editorFeaturesCache}async function getPreviewShippedFeatures(){return Editor?await Editor.Profile.getProject("engine","modules.includeModules"):[]}async function getConfigurableFlagsOfFeatures(e){const i={};if(Editor){const t=await Editor.Profile.getProject("engine","modules.flags");if(t)for(const[r,o]of Object.entries(t))e.includes(r)&&Object.assign(i,o)}return i}async function generateEngineAddon(e){let i;if(i=Editor?(0,path_1.join)(Editor.App.path,"../resources/3d/editor-native-scene"):(0,path_1.join)(__dirname,"../../../../../../resources/3d/editor-native-scene"),!(0,fs_extra_1.existsSync)(i))return void console.error(`build failed: editor-native-scene not exist,path: ${i}`);const t=(0,path_1.join)(engineDir,"native");if(!(0,fs_extra_1.existsSync)(t))return void console.error(`build failed: native engine not exist,path: ${t}`);const r="arm64"===process.arch;let o;o=Editor?(0,path_1.join)(Editor.App.path,"../tools/cmake/bin"):(0,path_1.join)(engineDir,"../../../tools/cmake/bin");const n=(0,path_1.join)(__dirname,"../node_modules/cmake-js/bin/cmake-js"),a="win32"===process.platform,s=a?(0,path_1.join)(i,"win"):(0,path_1.join)(i,"mac"),c={};Object.assign(c,process.env),Object.keys(c).filter(e=>e.toLowerCase().startsWith("npm_")).forEach(e=>delete c[e]),a?c.Path=process.env.PATH+";"+o:c.PATH=process.env.PATH+":"+o;let l="";try{const i=`--CDCOCOS_DIR=${(0,path_1.join)(engineDir,"../")}`,t=(0,path_1.join)(s,"build"),o=await getIsDebugLastTime();if("win32"!==process.platform){null!==o&&o!==(null===e||void 0===e?void 0:e.debugNative)&&(0,fs_extra_1.existsSync)(t)&&(console.warn("cmake configure change,now will clean build cache"),(0,fs_extra_1.rmdirSync)(t,{recursive:!0})),await setIsDebugLastTime(!!(null===e||void 0===e?void 0:e.debugNative))}const u=[i];a||(u.push("-x"),u.push("-a"),u.push(r?"arm64":"x64")),(null===e||void 0===e?void 0:e.debugNative)&&u.push("-D"),console.time("cmake build");const d=async e=>{await forkModule(n,["configure",...u],{cwd:s,env:c},{async success(i){var t;await(null===(t=null===e||void 0===e?void 0:e.onSuccess)||void 0===t?void 0:t.call(e,i))},async failed(i){var t;try{await(null===(t=null===e||void 0===e?void 0:e.onError)||void 0===t?void 0:t.call(e,i))}catch(e){e instanceof Error&&(l+=e.message+"\n")}}})};let p=!1;const g=e=>{p=!0,console.log("cmake configure success")};if(await d({onSuccess:g,async onError(e){if(l+=e+"\n",console.error(e),!(0,fs_extra_1.existsSync)(t))throw new Error(`cmake configure failed, output path ${t} is not exist `);console.warn("cmake configure error,now will clean build cache and try again"),await(0,fs_extra_1.remove)(t),await d({onSuccess:g,onError(e){console.error(e),l+=e+"\n"}})}}),!p)throw console.warn("cmake configure failed,skip build native scene"),console.timeEnd("cmake build"),l;await forkModule(n,["build",...u],{cwd:s,env:c},{success(){console.timeEnd("cmake build"),console.log("Native engine cmake build succeeded.")},failed(e){console.timeEnd("cmake build"),console.error("Native engine cmake build failed, the reason is",e)}})}catch(e){let i;e instanceof Error?i=l+=e.message+"\n":"string"==typeof e&&(i=e),console.error(i),outputErrorTxt("build-native-scene-error"+getFormat24HourTime(),i)}}async function updateAdapter(){try{let e=!0;const i=(0,path_1.join)(engineDir,"bin/.editor"),t=(0,path_1.join)(engineDir,"bin/adapter/native/web-adapter.js");if((0,fs_extra_1.existsSync)(t)){const e=(0,path_1.join)(i,"web-adapter.js");(0,fs_extra_1.copyFileSync)(t,e)}else e=!1,console.error(`${t} not exist,please build engine first`);const r=(0,path_1.join)(engineDir,"bin/adapter/native/engine-adapter.js");return(0,fs_extra_1.existsSync)(r)?(0,fs_extra_1.copyFileSync)(r,(0,path_1.join)(i,"engine-adapter.js")):(e=!1,console.error(`${r} not exist,please build engine first`)),e?console.log("update adapter success"):console.error("update adapter failed"),Promise.resolve()}catch(e){return Promise.reject(e)}}function getRightEngine(e,i){const t={version:"builtin",path:i};return e.custom&&(0,fs_extra_1.existsSync)(e.custom)?(t.version="custom",t.path=e.custom,t):t}function forkModule(e,i,t,r={}){return new Promise((o,n)=>{var a,s;null!==(a=t.execArgv)&&void 0!==a||(t.execArgv=["--max-old-space-size=8192"]),t.cwd&&(0,fs_extra_1.ensureDirSync)(t.cwd),null!==(s=t.stdio)&&void 0!==s||(t.stdio="pipe");const c=(0,child_process_1.fork)(e,i,t);let l="",u="";c.stdout&&c.stdout.on("data",e=>{l+=e}),c.stderr&&c.stderr.on("data",e=>{u+=e}),c.on("close",async e=>{0===e?r.success&&await r.success(u||l):r.failed&&await r.failed(u||l),o(e)}),c.on("error",e=>{n(e)})})}async function getIsSceneNative(){var e;let i=!0;return Editor&&(i=null!==(e=await Editor.Profile.getConfig("scene","scene.native-engine"))&&void 0!==e&&e),i}async function getIsDebugNative(){return!!await(null===Editor||void 0===Editor?void 0:Editor.Profile.getConfig("scene","scene.debug-native"))}async function getIsDebugLastTime(){return await(null===Editor||void 0===Editor?void 0:Editor.Profile.getConfig("engine","is-debug-native"))}async function setIsDebugLastTime(e){return await(null===Editor||void 0===Editor?void 0:Editor.Profile.setConfig("engine","is-debug-native",e,"global"))}function getFormat24HourTime(){const e=new Date,i=e=>e>9?e:`0${e}`,t=i(e.getDate()),r=i(e.getMonth()+1);return`${e.getFullYear()}-${r}-${t}-${i(e.getHours())}-${i(e.getMinutes())}-${i(e.getSeconds())}`}function outputErrorTxt(e,i,t){try{null!==t&&void 0!==t||(t=(null===Editor||void 0===Editor?void 0:Editor.Project.path)?(0,path_1.join)(Editor.Project.path,"temp/crash/"):(0,path_1.join)(engineDir,"bin",".editor","logs"));const r=(0,path_1.join)(t,e+".txt");(0,fs_extra_1.ensureDirSync)(t),(0,fs_extra_1.writeFileSync)(r,i,{encoding:"utf-8"})}catch(e){e instanceof Error&&console.error(`output error failed,reason is ${e.message}`)}}exports.compileEngine=compileEngine,exports.rebuild=rebuild,exports.rebuildImportMaps=rebuildImportMaps,exports.getRightEngine=getRightEngine,exports.default=__importStar(require("./index"));