"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.mounted=exports.data=exports.watch=exports.methods=exports.template=exports.style=void 0;const fs_extra_1=require("fs-extra"),path_1=require("path");let changeTimeId;function data(){return{info:null,meta:null,readonly:{value:!0},pipelines:[],pipeline:{},pipelineIndex:-1,originPipeline:null}}async function mounted(){const e=this;e.info=e.infos[0],await e.loadAll(),e.meta=e.metas[0]}exports.style=fs_extra_1.readFileSync(path_1.join(__dirname,"./style.css"),"utf8"),exports.template='\n<section class="asset-render-pipeline"\n    v-if="infos.length === 1"   \n>\n    <div class="header">\n        <ui-prop>\n            <ui-label slot="label" value="Pipelines"></ui-label>\n            <ui-select slot="content"\n                :disabled="readonly.value"\n                :value="pipelineIndex"\n                @confirm="pipelineIndex = $event.target.value"\n            >\n                <option\n                    v-for="(pipeline, index) in pipelines"\n                    :key="index + \' - \' + pipeline.name"\n                    :value="index"\n                >{{pipeline.name}}</option>\n            </ui-select>\n        </ui-prop>\n    </div>\n\n    <div class="content">\n        <template\n            v-for="item in pipeline.value"\n        >\n            <ins-prop auto="true"\n                :readonly="readonly.value"\n                :dump="item"\n                :dumps="[item]"\n            ></ins-prop>\n        </template>\n    </div>\n\n</section>\n',exports.methods={async loadPipeline(){const e=this;if(!e.meta)return;const i=await Editor.Message.request("scene","query-render-pipeline",e.info.uuid);i&&(e.pipeline=i,e.pipelineIndex=e.pipelines.findIndex(i=>i.name===e.pipeline.name)),await e.previewRenderPipeline(e.info.uuid,e.pipeline)},async loadAll(){this.pipelines=await Editor.Message.request("scene","query-all-render-pipelines")},async previewRenderPipeline(e,i){await Editor.Message.request("scene","preview-render-pipeline",e,i)},async reset(){await this.loadPipeline(),await this.previewRenderPipeline(this.info.uuid,this.pipeline)},async apply(){const e=this;await Editor.Message.request("scene","apply-render-pipeline",e.info.uuid,e.pipeline),await e.previewRenderPipeline(e.info.uuid,e.pipeline)},change(){clearTimeout(changeTimeId),changeTimeId=setTimeout(async()=>{const e=this,i=e.pipelines[e.pipelineIndex];e.pipeline.name===i.name?e.pipeline=await Editor.Message.request("scene","change-render-pipeline",e.pipeline):e.pipeline=await Editor.Message.request("scene","select-render-pipeline",e.pipelines[e.pipelineIndex].name)},50)}},exports.watch={infos(){this.info=this.infos[0]},info(){this.readonly.value=this.info&&this.info.readonly},metas(){this.meta=this.metas[0]},meta(){const e=this;requestAnimationFrame(()=>{e.loadPipeline()})}},exports.data=data,exports.mounted=mounted;