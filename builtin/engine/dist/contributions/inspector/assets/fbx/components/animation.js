"use strict";function data(){return{animationInfos:null,splitClipIndex:0,virtualControlInfo:null,updateCurrentAni:0,rawClipIndex:0,animationNameToUUIDMap:null,onEditClipInfoChanged:null}}function mounted(){this.refresh()}function getStepAndSpacing(n,i){const t=10,e=n/i;let o=e,s=1;return e<t&&(o=e*(s=Math.ceil(t/e))),{step:s,spacing:o}}Object.defineProperty(exports,"__esModule",{value:!0}),exports.mounted=exports.watch=exports.computed=exports.methods=exports.data=exports.props=exports.template=void 0,exports.template='\n<div class="animation" \n    :readonly="readonly.value"\n>\n    <div class="clips"\n        v-if="animationInfos"\n    >\n        <div class="clip" \n            v-for="(animInfo, index) in animationInfos"\n            :disabled="!animInfo.duration"\n        >\n            <div class="table">\n                <div class="header">\n                    <div class="name">Clips <i>( {{animInfo.name}} )</i> </div>\n                    <div class="time">Start</div>\n                    <div class="time end">End</div>\n                </div>\n                <div class="line"\n                    v-for="(subAnim, subIndex) in animInfo.splits"\n                    @click="onSelect(index, subIndex)"\n                    :active="rawClipIndex === index && subIndex === splitClipIndex"\n                >\n                    <div class="name">{{subAnim.name}}</div>\n                    <div class="time">{{subAnim.from.toFixed(2)}}</div>\n                    <div class="time end">{{subAnim.to.toFixed(2)}}</div>\n                </div>\n            </div>\n            <div class="add-clip mb5">\n                <div class="button">\n                    <ui-icon value="add" @click="addClip"></ui-icon>\n                    <ui-icon value="mini" @click="delClip"></ui-icon>\n                </div>\n            </div>\n        </div>\n    </div>\n\n    <div class="edit"\n        v-if="currentClipInfo && gridConfig"\n        :disabled="!rawClipInfo.duration"\n    >\n        <div class="anim-name mb5" @confirm="onClipName">\n            <ui-icon value="video"></ui-icon>\n            <ui-input :value="currentClipInfo.name"></ui-input>\n        </div>\n        <div class="clip-info mb5">\n            <div class="left">Time: {{rawClipInfo.duration.toFixed(2)}} (s)</div>\n            <div class="right">\n                <ui-num-input\n                    :value="currentClipInfo.fps"\n                    @confirm="onFpsChange"\n                ></ui-num-input>\n                FPS\n            </div>\n        </div>\n        <div class="edit-ruler">\n            <div class="grid" ref="grid">\n                <div class="label-item"\n                    v-for="minNum in (gridConfig.mod + 1)"\n                    :style="{left: gridConfig.spacing * 5 * (minNum - 1) - 6 +\'px\'}"\n                >\n                    <span class="mid-label">{{(gridConfig.labelStep * (minNum - 1)).toFixed(2)}}</span>\n                </div>\n                <div class="label-item"\n                    :style="{left: gridConfig.width + \'px\'}"\n                >{{rawClipInfo.duration.toFixed(2)}}</div>\n            </div>\n            <div class="grid"\n                :style="{\'margin-left\': gridConfig.spacing + \'px\', \'margin-right\': -gridConfig.spacing + \'px\'}"\n            >\n                <div class="start"\n                    :style="{\'left\': -gridConfig.spacing + \'px\'}"\n                ><span class="sm-grid"></span></div>\n                <div class="grid-item"\n                    :style="{\'width\': gridConfig.spacing * 5 + \'px\'}" v-for="minNum in gridConfig.mod"\n                >\n                    <span\n                        v-for="smNum in 4"\n                        class="sm-grid"\n                    ></span>\n                    <span class="mid-grid"></span>\n                </div>\n                <div class="grid-item" :style="{\'width\': gridConfig.rest * gridConfig.spacing + \'px\'}">\n                    <span\n                        v-for="smNum in gridConfig.rest"\n                        class="sm-grid"\n                    ></span>\n                </div>\n            </div>\n            <div class="control-wrap">\n                <div class="duration" :style="currentClipInfo.durationStyle"></div>\n                <div class="control left"\n                    :style="currentClipInfo.ctrlStartStyle"\n                    @mousedown="onMouseDown($event, \'left\')"\n                >\n                    <div class="box"></div>\n                    <div class="direction"></div>\n                </div>\n                <div class="control right"\n                    :style="currentClipInfo.ctrlEndStyle"\n                    @mousedown="onMouseDown($event, \'right\')"\n                >\n                    <div class="box"></div>\n                    <div class="direction"></div>\n                </div>\n                <div class="control virtual"\n                    v-if="virtualControlInfo && virtualControlInfo.type && virtualControlInfo.value!==undefined"\n                    :class="virtualControlInfo.type"\n                    :style="virtualControlInfo.style"\n                >\n                    <div class="box"></div>\n                    <div class="direction"></div>\n                    <div class="info">{{virtualControlInfo.value.toFixed(2)}}</div>\n                </div>\n            </div>\n        </div>\n        \n        <div class="cut-info" @confirm="onCutClip">\n            <div class="left">\n                <span>Start: </span>\n                <ui-num-input path="from"\n                :value="virtualControlInfo && virtualControlInfo.startFrame || currentClipInfo.from || 0"\n                :step="1"\n                :min="0"\n                :max="(rawClipInfo.duration * currentClipInfo.fps ).toFixed(0)"\n                ></ui-num-input>\n            </div>\n            <div class="clip-info">\n                <div class="left">Frames: {{(rawClipInfo.duration * currentClipInfo.fps).toFixed(0)}}</div>\n            </div>\n            <div class="right">\n                <span>End: </span>\n                <ui-num-input path="to"\n                :value="virtualControlInfo && virtualControlInfo.endFrame || currentClipInfo.to || rawClipInfo.duration.toFixed(2)"\n                :step="1"\n                :min="0"\n                :max="(rawClipInfo.duration * currentClipInfo.fps).toFixed(0)"\n                ></ui-num-input>\n            </div>\n        </div>\n        <ui-prop>\n            <span slot="label">WrapMode</span>\n            <ui-select\n                :value="currentClipInfo.wrapMode"\n                slot="content"\n                @confirm="onWrapModeChange"\n            >\n                <option value="0">Default</option>\n                <option value="1">Normal</option>\n                <option value="2">Loop</option>\n                <option value="22">PingPong</option>\n                <option value="36">Reverse</option>\n                <option value="38">LoopReverse</option>\n            </ui-select>\n        </ui-prop>\n    </div>\n</div>\n',exports.props=["readonly","meta","metas","gridWidth","gridTableWith"],exports.data=data,exports.methods={t:n=>Editor.I18n.t(`inspector.asset.fbx.${n}`),getDefault:(n,i)=>void 0===n?i:n,getInvalid(n){const i=this.metas[0].userData[n];return!this.metas.every(t=>i===t.userData[n])},delClip(){this.currentClipInfo&&(this.clipNames.delete(this.currentClipInfo.name),this.animationInfos[this.rawClipIndex].splits.splice(this.splitClipIndex,1))},addClip(){const n=this.newClipTemplate();this.clipNames.add(n.name),this.animationInfos[this.rawClipIndex].splits.push(n)},onSelect(n,i){const t=this;t.splitClipIndex=i,t.rawClipIndex=n;const e=t.getCurClipInfo();t.onEditClipInfoChanged&&t.onEditClipInfoChanged(e)},onCutClip(n){const i=n.target.getAttribute("path");this.animationInfos[this.rawClipIndex].splits[this.splitClipIndex][i]=n.target.value/this.currentClipInfo.fps},onClipName(n){const i=this;if(!i.currentClipInfo)return;let t=n.target.value;if(!t)return;i.clipNames.has(t)&&(t=i.getRightName(t));const e=i.animationInfos[i.rawClipIndex].splits[i.splitClipIndex];e.name=t,i.clipNames.delete(e.name),i.clipNames.add(t)},getRightName(n){if(!n)return null;const i=this;do{const i=n.match(/(.*)_(\d{0,3})/);i?n=i[1]+"_"+(Number(i[2])+1):n+="_1"}while(i.clipNames.has(n));return n},newClipTemplate(){const{name:n,duration:i}=this.rawClipInfo;return{name:this.getRightName(n),from:0,to:i,wrapMode:2}},onFpsChange(n){this.animationInfos[this.rawClipIndex].splits[this.splitClipIndex].fps=Number(n.target.value),this.updateCurrentAni++},onWrapModeChange(n){this.animationInfos[this.rawClipIndex].splits[this.splitClipIndex].wrapMode=Number(n.target.value),this.updateCurrentAni++},onMouseDown(n,i){const t=this,e=t.currentClipInfo;if(!e)return;const o={type:i};"right"===i?(o.style=e.ctrlEndStyle,o.value=e.to/t.currentClipInfo.fps):(o.style=e.ctrlStartStyle,o.value=e.from/t.currentClipInfo.fps),t.virtualControlInfo=o,document.addEventListener("mousemove",t.onMouseMove),document.addEventListener("mouseup",t.onMouseUp)},onMouseMove(n){const i=this;if(n.preventDefault(),!i.virtualControlInfo)return;const{type:t}=i.virtualControlInfo;let e=i.screenToGrid(n.x);if(e>i.gridConfig.width||e<0||"left"===t&&e>i.currentClipInfo.ctrlEnd||"right"===t&&e<i.currentClipInfo.ctrlStart)return;const{duration:o}=i.rawClipInfo,s=e/i.gridConfig.width*o,a=Editor.Utils.Math.clamp(s,0,o),r=i.timeToFrame(a);i.virtualControlInfo.value=a,"left"===t?(i.virtualControlInfo.startFrame=r,e-=6):i.virtualControlInfo.endFrame=r,i.virtualControlInfo.style={transform:`translateX(${e}px)`}},onMouseUp(){const n=this;if(!n.virtualControlInfo)return;document.removeEventListener("mousemove",n.onMouseMove),document.removeEventListener("mouseup",n.onMouseUp);const{value:i}=n.virtualControlInfo;let{type:t}=n.virtualControlInfo;t="right"===t?"to":"from";const e=n.animationInfos[n.rawClipIndex].splits[n.splitClipIndex];if(e[t].toFixed(2)!==i.toFixed(2)){const{duration:o}=n.rawClipInfo;e[t]=Editor.Utils.Math.clamp(parseFloat(i.toFixed(2)),0,o)}n.virtualControlInfo=null;const o=n.getCurClipInfo();n.onEditClipInfoChanged&&n.onEditClipInfoChanged(o)},screenToGrid(n){return n-this.$refs.grid.getBoundingClientRect().x},timeToFrame(n,i){return i=i||this.currentClipInfo.fps,parseInt((n*i).toFixed(0))},refresh(){const n=this;if(n.meta&&n.meta.subMetas){let i=new Map;Object.keys(n.meta.subMetas).forEach(t=>{const e=n.meta.subMetas[t];if("gltf-animation"===e.importer){const n=e.name,t=n.slice(0,n.lastIndexOf("."));i.set(t,e.uuid)}}),n.animationNameToUUIDMap=i}if(n.meta&&n.meta.userData.animationImportSettings){n.animationInfos=n.meta.userData.animationImportSettings,n.clipNames=new Set;for(const i of n.animationInfos){n.clipNames.add(i.name);for(const t of i.splits)n.clipNames.add(t.name)}n.onSelect(0,0)}else n.animationInfos=null},getCurClipInfo(){const n=this.animationInfos[this.rawClipIndex],i=n.splits[this.splitClipIndex];if(!n)return;let t=this.animationNameToUUIDMap.get(n.name),e=n.duration,o=n.fps,s=0,a=e;return i&&(s=i.from,e=(a=i.to)-s,void 0!==i.fps&&(o=i.fps)),{clipUUID:t,duration:e,fps:o,from:s,to:a}}},exports.computed={currentClipInfo(){var n,i;if(!this.animationInfos||"number"!=typeof this.updateCurrentAni)return null;const t=this.animationInfos[this.rawClipIndex].splits[this.splitClipIndex];if(!t||!this.gridTableWith)return null;const e=t.to-t.from,o=t.from/this.rawClipInfo.duration*this.gridTableWith,s=t.to/this.rawClipInfo.duration*this.gridTableWith,a=e/this.rawClipInfo.duration*this.gridTableWith,r=null!==(n=t.fps)&&void 0!==n?n:this.rawClipInfo.fps,l=null!==(i=t.wrapMode)&&void 0!==i?i:this.rawClipInfo.wrapMode;return{name:t.name,from:Number((t.from*r).toFixed(0)),to:Number((t.to*r).toFixed(0)),ctrlStart:o,ctrlEnd:s,ctrlStartStyle:{transform:`translateX(${o-6}px)`},ctrlEndStyle:{transform:`translateX(${s}px)`},durationStyle:{width:`${a}px`,transform:`translateX(${o}px)`},duration:e,fps:r,wrapMode:l}},rawClipInfo(){if(!this.animationInfos)return null;if(!this.animationInfos[this.rawClipIndex])return null;const{name:n,duration:i,fps:t}=this.animationInfos[this.rawClipIndex];return{name:n,duration:i,fps:t}},gridConfig(){if(!this.currentClipInfo)return null;let n=this.gridTableWith;const i=this.rawClipInfo,{step:t,spacing:e}=getStepAndSpacing(n,this.currentClipInfo.fps*i.duration);return n=this.currentClipInfo.fps*i.duration*e/t,{step:t,spacing:e,mod:Math.floor(this.gridTableWith/(5*e)),rest:Math.floor(this.gridTableWith%(5*e)/e),width:n,labelStep:i.duration*(5*t/(this.currentClipInfo.fps*i.duration))}}},exports.watch={meta(){this.refresh()}},exports.mounted=mounted;