"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.mounted=exports.data=exports.watch=exports.methods=exports.template=exports.style=void 0;const fs_extra_1=require("fs-extra"),path_1=require("path");function data(){return{info:null,meta:null,readonly:{value:!0},shaders:[],shadersIndex:0,glslNames:{glsl3:"GLSL 300 ES Output",glsl1:"GLSL 100 Output"},shaderNames:{vert:"Vertex Shader",frag:"Fragment Shader"},combinations:[],combinationsUnfold:!0}}function mounted(){this.info=this.infos[0],this.meta=this.metas[0]}exports.style=fs_extra_1.readFileSync(path_1.join(__dirname,"./style.css"),"utf8"),exports.template='\n<div class="asset-effect"\n    v-if="metas.length===1 && shaders.length"\n>\n    <ui-prop class="header">\n        <ui-label slot="label"\n            tooltip="Shaders"\n        >\n            Shaders\n        </ui-label>\n        <ui-select slot="content"\n            :value="shadersIndex"\n            :tooltip="shaders[shadersIndex].name"\n            @confirm.stop="shadersIndex = $event.target.value"\n        >\n            <option\n                v-for="(shader, index) in shaders"\n                :value="index"\n            >{{shader.name}}</option>\n        </ui-select>\n    </ui-prop>\n\n    <ui-section class="defines config" \n        expand-key="Precompile"\n        :expand="$root.expand(\'Precompile\', true)"\n        v-if="shaders[shadersIndex].defines && shaders[shadersIndex].defines.length"\n    >\n        <div slot="header">\n            <span>Precompile Combinations</span>\n        </div>\n        <div class="object"\n            v-if="combinationsUnfold"\n        >\n            <div class="description">\n                <ui-label>Choose all possible branches.</ui-label>\n            </div>\n            <ui-prop class="combinations"\n                v-for="(define, defineIndex) in shaders[shadersIndex].defines"\n                :key="defineIndex"\n                v-if="define._enabled===true"\n            >\n                <ui-label slot="label"\n                    :tooltip="define.name"\n                    :value="define.name"\n                ></ui-label>\n                <ui-icon value="lock" slot="label"\n                    v-if="readonly.value"\n                ></ui-icon>\n                <div slot="content">\n                    <ui-button class="checktab"\n                        v-for="(val, valIndex) in define._values"\n                        :key="valIndex"\n                        :disabled="readonly.value"\n                        :checked="combinations[shadersIndex][define.name] && combinations[shadersIndex][define.name].includes(val)"\n                        @change="checkedValue($event,define,valIndex)"\n                    >{{typeof val === \'boolean\'? val ? \'on\' : \'off\' : val.toString()}}</ui-button>\n                </div>\n            </ui-prop>\n        </div>\n    </ui-section>\n\n    <ui-section class="defines config"\n        v-if="shaders[shadersIndex]"\n        v-for="(glslName, glslKey) in glslNames"\n        :key="glslKey"\n        :expand-key="glslName"\n        :expand="$root.expand(glslName)"\n    >\n        <div slot="header">\n            <span>{{glslName}}</span>\n        </div>\n        <div class="tabs">\n            <div class="tab"\n                v-for="(shaderName, shaderKey) in shaderNames"\n                :active="shaders[shadersIndex][glslKey].activeKey === shaderKey"\n                @click="shaders[shadersIndex][glslKey].activeKey = shaderKey"\n            >{{shaderName}}</div>\n        </div>\n        <ui-code language="glsl">\n            {{shaders[shadersIndex][glslKey][shaders[shadersIndex][glslKey].activeKey]}}\n        </ui-code>\n    </ui-section>\n</div>\n',exports.methods={refresh(){const e=this;if(!e.info||"effect"!==e.info.importer)return;if(e.info.uuid!==e.metas[0].uuid)return;if(e.info.library[".json"]&&!fs_extra_1.existsSync(e.info.library[".json"]))return void console.error("Read effect json file in library failed.");const n=fs_extra_1.readJSONSync(e.info.library[".json"]);n?(e.shaders=n.shaders,e.shadersIndex=0,e.combinationsUnfold=!0,e.combinations=e.metas[0].userData.combinations&&e.metas[0].userData.combinations.slice()||[],e.shaders.forEach((n,s)=>{for(const s of Object.keys(e.glslNames))e.$set(n[s],"activeKey","vert");e.combinations[s]||e.$set(e.combinations,s,{}),n.defines.forEach(e=>{const{name:n,type:s}=e;if(n.startsWith("CC_"))e._enabled=!1;else{if(e._enabled=!0,e._values=[],"number"===s&&e.range){const[n,s]=e.range;for(let a=n;a<=s;a++)e._values.push(a)}"boolean"===s&&(e._values=[!1,!0]),"string"===s&&(e._values=e.options)}})})):console.error("Read effect json file in library failed.")},checkedValue(e,n,s){const a=this,i=n._values[s];Array.isArray(a.combinations[a.shadersIndex][n.name])||a.$set(a.combinations[a.shadersIndex],n.name,[]);const t=a.combinations[a.shadersIndex][n.name];-1!==t.indexOf(i)?t.splice(t.indexOf(i),1):t.push(i)},apply(){const e=[];this.combinations.forEach((n,s)=>{e[s]={},Object.keys(n).forEach(a=>{0!==n[a].length&&(e[s][a]=n[a])})}),this.metas[0].userData.combinations=e}},exports.watch={infos(){this.info=this.infos[0]},info(){const e=this;e.readonly.value=e.info&&e.info.readonly,requestAnimationFrame(()=>{e.refresh()})}},exports.data=data,exports.mounted=mounted;