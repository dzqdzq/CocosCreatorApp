"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.destroyed=exports.mounted=exports.data=exports.watch=exports.methods=exports.props=exports.template=exports.style=void 0;const build_1=require("./build"),ElectronModule=require("@base/electron-module"),GlPreview=ElectronModule.require("PreviewExtends").default,glPreview=new GlPreview("scene:material-preview","query-material-preview-data"),fs_extra_1=require("fs-extra"),path_1=require("path");exports.style=fs_extra_1.readFileSync(path_1.join(__dirname,"./style.css"),"utf8");let cacheData={};const cacheDot="._",previewConfig={};function data(){return{info:null,meta:null,readonly:{value:!0},originEffects:[],material:{},effects:[],effect:"",technique:-1,techniqueForCacheData:-1,data:null,techniques:[],dirtyOriginData:"",previewPrimitives:["box","sphere","capsule","cylinder","torus","cone","quad"],curPrimitive:"box",isLightOn:!0,updateTask:null,isPreviewDataDirty:!0}}function mounted(){const e=this;e.info=e.infos[0],e.meta=e.metas[0],Editor.Message.addBroadcastListener("scene:material-preview-dirty",e.updateMaterialPreview)}function destroyed(){glPreview.destroyGL(),Editor.Message.request("scene","hide-material-preview"),Editor.Message.removeBroadcastListener("scene:material-preview-dirty",this.updateMaterialPreview)}exports.template='\n<section class="asset-material"\n    v-if="infos.length === 1"\n>\n    <div class="preview"\n        v-if="from === undefined"\n    >\n        <div class="imageDiv" ref="imageDiv" style="height:200px">\n            <canvas class="image" ref="image"\n                @mousedown=onPreviewMouseDown($event)\n            ></canvas>\n        </div>\n        <div class="tools">\n            <ui-select class="primitive"\n                :value="curPrimitive"\n                @confirm="curPrimitive = $event.target.value"\n            >\n                <option\n                    v-for="type in previewPrimitives"\n                    :value="type"\n                >{{type}}</option>\n            </ui-select>\n            <ui-checkbox\n                :value="isLightOn"\n                @confirm="isLightOn = $event.target.value"\n            >\n                Light\n            </ui-checkbox>\n        </div>\n    </div>\n    <div class="header">\n        <ui-prop>\n            <ui-label slot="label" tooltip="Effect" value="Effect"></ui-label>\n            <ui-icon value="lock" slot="label"\n                v-if="readonly.value"\n            ></ui-icon>\n            <ui-select slot="content"\n                :disabled="readonly.value"\n                :value="effect"\n                @confirm="effect = $event.target.value"\n            >\n                <option\n                    v-for="type in effects"\n                    :value="type"\n                >{{type}}</option>\n            </ui-select>\n            <ui-button slot="content" class="location"\n                tooltip="i18n:inspector.asset.material.locateEffect"\n                @click="twinkleEffect()"\n            >\n                <ui-icon value="location"></ui-icon>\n            </ui-button>\n        </ui-prop>\n        <ui-prop>\n            <ui-label slot="label" tooltip="Technique" value="Technique"></ui-label>\n            <ui-icon value="lock" slot="label"\n                v-if="readonly.value"\n            ></ui-icon>\n            <ui-select slot="content"\n                :disabled="readonly.value"\n                :value="technique"\n                @confirm="technique = Number($event.target.value)"\n            >\n                <option\n                    v-for="(item, index) in techniques"\n                    :key="index + \' - \' + item.name"\n                    :value="index"\n                >{{item.name ? index + \' - \' + item.name : index}}</option>\n            </ui-select>\n        </ui-prop>\n    </div>\n\n    <div class="content">\n        <template\n            v-for="(item,index) in techniques"\n            v-if="index == technique"\n        >\n            <asset-prop auto="true"\n                v-if="item.useInstancing"\n                :readonly="readonly.value"\n                :dump="item.useInstancing"\n                @confirm.native="changeInstancing(item)"\n            ></asset-prop>\n            <asset-prop auto="true"\n                v-if="item.useBatching"\n                :readonly="readonly.value"\n                :dump="item.useBatching"\n                @confirm.native="changeBatching(item)"\n            ></asset-prop>\n            <ui-section class="pass"\n                v-for="(pass,index) in item.passes"\n                v-if="pass.propertyIndex.value === index"\n                :key="index"\n                :expand="$root.expand(expandPrefix+info.uuid+\'pass\'+index, true)"\n                :expand-key="expandPrefix+info.uuid+\'pass\'+index"\n            >\n                <div slot="header">\n                    <span class="name"\n                        :disabled="readonly.value"\n                    >Pass {{index}}</span>\n                    <template\n                        v-if="pass.switch && pass.switch.name"\n                    >\n                        <span>(</span>\n                        <ui-checkbox\n                            :disabled="readonly.value"\n                            :value="pass.switch.value"\n                            @confirm="pass.switch.value = $event.target.value"\n                        >{{pass.switch.name}}</ui-checkbox>\n                        <span>)</span>\n                    </template>\n                </div>\n               \n                <asset-prop auto="true"\n                    v-for="(item, key) in pass.childMap"\n                    :key="key"\n                    v-if="isReverseDepand(item, pass.childMap)"\n                    :readonly="readonly.value"\n                    :dump="item"\n                    :expand-prefix="expandPrefix+info.uuid+\'pass\'+index"\n                ></asset-prop>\n            </ui-section>\n        </template>\n    </div>\n</section>\n',exports.props=["from","expandPrefix"],exports.methods={t:e=>Editor.I18n.t(`inspector.asset.material.${e}`),async loadMaterial(){const e=this;if(!e.meta)return;const t=await Editor.Message.request("scene","query-material",e.info.uuid);null!==t?(e.data=t.data,e.technique=t.technique,e.effect=t.effect,e.material=t):console.warn("Material doesn't exist")},async loadAllEffect(){const e=this;e.meta&&(e.originEffects=await Editor.Message.request("scene","query-all-effects"),e.effects=Object.keys(e.originEffects).filter(t=>!e.originEffects[t].hideInEditor))},async initPreview(){const e=this;e.$refs.image&&(e.from||(await glPreview.init({width:e.$refs.image.clientWidth,height:e.$refs.image.clientHeight}),await Editor.Message.request("scene","set-material-preview-primitive",e.curPrimitive),e.$refs.image&&(this.previewMaterial(e.info.uuid,e.getData()),glPreview.initGL(e.$refs.image,{width:e.$refs.image.clientWidth,height:e.$refs.image.clientHeight}),previewConfig.width=e.$refs.image.clientWidth,previewConfig.height=e.$refs.image.clientHeight,e.updateTask&&(cancelAnimationFrame(e.updateTask),e.updateTask=null),e.update())))},async update(){const e=this,t=e.$refs.image;if(e&&t){if(e.isPreviewDataDirty){t.width=e.$refs.imageDiv.clientWidth,t.height=e.$refs.imageDiv.clientHeight;const i=await glPreview.queryPreviewData({width:e.$refs.imageDiv.clientWidth,height:e.$refs.imageDiv.clientHeight});i.width===previewConfig.width&&i.height===previewConfig.height||(glPreview.resizeGL(i.width,i.height),previewConfig.width=i.width,previewConfig.height=i.height);try{glPreview.drawGL(i.buffer,i.width,i.height)}catch(e){console.warn(e)}e.isPreviewDataDirty=!1}e.updateTask=requestAnimationFrame(async()=>{await e.update()})}else e.updateTask=null},async refresh(){const e=this;cacheData={},e.techniqueForCacheData=-1,e.effect="",await e.loadMaterial(),await e.loadAllEffect(),e.dirtyOriginData=JSON.stringify(e.getDataForDirty()),e.isPreviewDataDirty=!0,this.initPreview()},async previewMaterial(e,t){await Editor.Message.request("scene","preview-material",e,t),this.isPreviewDataDirty=!0},async change(){const e=this;e.storeCache(),e.useCache(),setTimeout(()=>{e.previewMaterial(e.info.uuid,e.getData())},300)},async reset(){return await this.refresh(),this.previewMaterial(this.info.uuid,null),!1},async apply(){const e=this;return await Editor.Message.request("scene","apply-material",e.info.uuid,e.getData()),e.dirtyOriginData=JSON.stringify(e.getDataForDirty()),e.isPreviewDataDirty=!0,!0},getData(){return{effect:this.effect,technique:this.technique,data:this.data}},getDataForDirty(){return{effect:this.effect,technique:this.technique,techniqueData:this.techniques[this.technique]}},dirty(){return this.dirtyOriginData!==JSON.stringify(this.getDataForDirty())},storeCache(){const e=this.techniqueForCacheData;if(!this.techniques[e]||!this.techniques[e].passes)return;const t=JSON.parse(JSON.stringify(this.techniques[e].passes));Object.assign(cacheData,function e(t,i){return Object.keys(t).reduce((n,a)=>{if(["children","name","default","defines","propertyIndex","extends","readonly","visible","displayName","elementTypeData","isArray","isMat","enumList","bitmaskList","enumData","isEnum","isObject","switch","pipelineStates","pro"].includes(a))return n;const s=i.length?cacheDot:"",r=i+s+a;return"object"==typeof t[a]?Object.assign(n,e(t[a],r)):(r.includes("type")||r.includes("value"))&&(n[r]=t[a]),n},{})}(t,""))},useCache(){const e=this;if(!e.techniques[e.technique])return;const t=Object.keys(cacheData).sort((e,t)=>e.length-t.length);let i=0;e:for(;i<t.length;i++){const a=t[i];if(!a)continue e;const s=a.split(cacheDot);if(0===s.length){n(a);continue e}let r=0,c=e.techniques[e.technique].passes,o="",u="";for(;r<=s.length-1;){if(void 0===c){n(u);continue e}if(c=c[o=s[r]],r+=1,u=s.slice(0,r).join(cacheDot),"type"===o){n(u),cacheData[u]!==c&&(r-=1,n(u=s.slice(0,r).join(cacheDot)));continue e}}}function n(e,n=i){if(e)for(;n<t.length;n++)n>=0&&t[n].startsWith(e)&&(t.splice(n,1),n--,i--)}e:for(const i of t){const t=i.split("._");if(0===t.length)break;let n=0,a=e.techniques[e.technique].passes;for(;n<=t.length-2;){if(void 0===a)continue e;a=a[t[n]],n+=1}const s=t[n++];a&&a!==e.techniques[e.technique].passes&&"object"==typeof a&&s in a&&(a[s]=cacheData[i])}e.updateInstancing()},twinkleEffect(){Editor.Message.send("assets","twinkle",this.originEffects[this.effect].uuid)},onPreviewMouseDown(e){Editor.Message.request("scene","on-material-preview-mouse-down",{x:e.x,y:e.y}),e.target.requestPointerLock(),document.addEventListener("mousemove",this.onPreviewMouseMove),document.addEventListener("mouseup",this.onPreviewMouseUp);this.isPreviewDataDirty=!0},onPreviewMouseMove(e){Editor.Message.request("scene","on-material-preview-mouse-move",{movementX:e.movementX,movementY:e.movementY});this.isPreviewDataDirty=!0},onPreviewMouseUp(e){Editor.Message.request("scene","on-material-preview-mouse-up",{x:e.x,y:e.y}),document.exitPointerLock(),document.removeEventListener("mousemove",this.onPreviewMouseMove),document.removeEventListener("mouseup",this.onPreviewMouseUp);this.isPreviewDataDirty=!0},isReverseDepand(e,t){let i=!0;return e&&e.defines&&e.defines.length&&e.defines.forEach(e=>{e.startsWith("!")&&(e=e.substr(1),t[e].value)&&(i=!1)}),i},updateInstancing(){const e=this,t=e.techniques[e.technique];if(!t||!t.passes)return;const i=t.passes[0];i.childMap.USE_INSTANCING?(t.useInstancing.value=i.childMap.USE_INSTANCING.value,i.childMap.USE_BATCHING&&(t.useBatching.value=i.childMap.USE_BATCHING.value,t.useBatching.visible=!t.useInstancing.value),e.changeInstancing(t)):(t.useInstancing&&(t.useInstancing.visible=!1),t.useBatching&&(t.useBatching.visible=!1))},changeInstancing(e){const t=this,i=e.useInstancing.value;e.useBatching.visible=!i,i&&t.changeBatching(e,!1),e.passes.forEach(e=>{e.childMap.USE_INSTANCING&&(e.childMap.USE_INSTANCING.value=i)})},changeBatching(e,t){void 0!==t&&(e.useBatching.value=t),e.passes.forEach(t=>{t.childMap.USE_BATCHING&&(t.childMap.USE_BATCHING.value=e.useBatching.value)})},updateMaterialPreview(){const e=this;requestAnimationFrame(()=>{e.isPreviewDataDirty=!0})}},exports.watch={async effect(e){const t=this;if(!e)return;if(t.techniques=[],e===t.material.effect)t.data=t.material.data;else{let i=await Editor.Message.request("scene","query-effect",e);Array.isArray(i)||(i=[]),t.data=i}let i,n;t.techniques=t.data.map(e=>{const t=e.passes.map(e=>{const t=build_1.buildEffect(e);return t.switch=e.switch,t.propertyIndex=e.propertyIndex,!i&&t.childMap.USE_INSTANCING&&((i=JSON.parse(JSON.stringify(t.childMap.USE_INSTANCING))).visible=!0),!n&&t.childMap.USE_BATCHING&&((n=JSON.parse(JSON.stringify(t.childMap.USE_BATCHING))).visible=!0),t});return{name:e.name,passes:t,useInstancing:i,useBatching:n}}),t.technique>=t.techniques.length&&(t.technique=0),t.useCache(),t.isPreviewDataDirty=!0},technique(e){this.techniqueForCacheData=e,this.isPreviewDataDirty=!0},curPrimitive(e){Editor.Message.request("scene","set-material-preview-primitive",e);this.isPreviewDataDirty=!0},isLightOn(e){Editor.Message.request("scene","set-material-preview-light-enable",e);this.isPreviewDataDirty=!0},infos(){this.info=this.infos[0]},info(){this.readonly.value=this.info&&this.info.readonly},metas(){this.meta=this.metas[0]},meta(e,t){JSON.stringify(e)!==JSON.stringify(t)&&this.refresh()}},exports.data=data,exports.mounted=mounted,exports.destroyed=destroyed;