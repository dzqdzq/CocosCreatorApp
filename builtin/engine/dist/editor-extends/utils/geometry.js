"use strict";function forEachFace(e,t,r){let c=0;const o=[];switch(t){case ccm.gfx.PrimitiveMode.TRIANGLE_LIST:c=e.length/3;for(let t=0;t<c;t++)o[0]=e[3*t],o[1]=e[3*t+1],o[2]=e[3*t+2],r(o);break;case ccm.gfx.PrimitiveMode.TRIANGLE_STRIP:c=e.length-2;let i=0;for(let t=0;t<c;t++)o[0]=e[t-i],o[1]=e[t+i+1],o[2]=e[t+2],r(o),i=~i;break;case ccm.gfx.PrimitiveMode.TRIANGLE_FAN:c=e.length-1;const a=e[0];for(let t=1;t<c;t++)o[0]=a,o[1]=e[t],o[2]=e[t+1],r(o);break;case ccm.gfx.PrimitiveMode.LINE_LIST:c=e.length/2;for(let t=0;t<c;t++)o[0]=e[2*t],o[1]=e[2*t+1],r(o);break;case ccm.gfx.PrimitiveMode.LINE_STRIP:c=e.length-1;for(let t=0;t<c;t++)o[0]=e[t],o[1]=e[t+1],r(o);break;case ccm.gfx.PrimitiveMode.LINE_LOOP:c=e.length;for(let t=0;t<c;t++)o[0]=e[t],o[1]=e[t+1===c?0:t+1],r(o);break;case ccm.gfx.PrimitiveMode.POINT_LIST:c=e.length;for(let t=0;t<c;t++)o[0]=e[t],r(o)}}Object.defineProperty(exports,"__esModule",{value:!0}),exports.getUintArrayCtor=exports.splitBasedOnJoints=exports.MeshSplitInfo=exports.forEachFace=exports.calculateTangents=exports.calculateNormals=void 0,exports.calculateNormals=(()=>{const{Vec3:e}=cc,t=new e,r=new e,c=new e,o=new e,i=new e,a=new e;return(n,s,l=[])=>{const f=s.length/3,m=n.length/3,d=Array(3*m).fill(0).map(()=>new e);for(let l=0;l<f;++l){const f=s[3*l+0],m=s[3*l+1],x=s[3*l+2];e.fromArray(t,n,3*f),e.fromArray(r,n,3*m),e.fromArray(c,n,3*x),e.subtract(o,r,t),e.subtract(i,c,t),e.cross(a,o,i),e.add(d[f],d[f],a),e.add(d[m],d[m],a),e.add(d[x],d[x],a)}for(let t=0;t<m;++t)e.toArray(l,e.normalize(a,d[t]),3*t);return l}})(),exports.calculateTangents=(()=>{const{Vec2:e,Vec3:t}=cc,r=new t,c=new t,o=new t,i=new t,a=new t,n=new e,s=new e,l=new e,f=new t,m=new t,d=new t,x=new t;return(I,g,u,y,p=[])=>{const A=g.length/3,S=I.length/3,h=Array(S).fill(0).map(()=>new t),T=Array(S).fill(0).map(()=>new t);for(let u=0;u<A;++u){const p=g[3*u+0],A=g[3*u+1],S=g[3*u+2];t.fromArray(r,I,3*p),t.fromArray(c,I,3*A),t.fromArray(o,I,3*S),e.fromArray(n,y,2*p),e.fromArray(s,y,2*A),e.fromArray(l,y,2*S),t.subtract(i,c,r),t.subtract(a,o,r);const E=s.x-n.x,P=l.x-n.x,L=s.y-n.y,M=l.y-n.y;let w=E*M-P*L;0!==w&&(w=1/w),t.multiplyScalar(f,t.subtract(d,t.multiplyScalar(d,i,M),t.multiplyScalar(x,a,L)),w),t.multiplyScalar(m,t.subtract(d,t.multiplyScalar(d,a,E),t.multiplyScalar(x,i,P)),w),t.add(h[p],h[p],f),t.add(h[A],h[A],f),t.add(h[S],h[S],f),t.add(T[p],T[p],m),t.add(T[A],T[A],m),t.add(T[S],T[S],m)}for(let e=0;e<S;++e){const r=h[e],c=T[e],o=t.fromArray(d,u,3*e);t.subtract(x,r,t.multiplyScalar(x,o,t.dot(r,o)/t.dot(o,o))),0==t.dot(x,x)&&(o.x||o.z?t.set(x,o.z,0,-o.x):t.set(x,0,o.x,-o.y)),t.toArray(p,t.normalize(x,x),4*e),p[4*e+3]=t.dot(t.cross(x,c,r),o)>0?1:-1}return p}})(),exports.forEachFace=forEachFace;class MeshSplitInfo{constructor(e=ccm.gfx.PrimitiveMode.TRIANGLE_LIST){this.indices=[],this.jointSet=new Set,this.primitiveMode=e}}function getUintArrayCtor(e){return e<1<<8*Uint8Array.BYTES_PER_ELEMENT?Uint8Array:e<1<<8*Uint16Array.BYTES_PER_ELEMENT?Uint16Array:Uint32Array}exports.MeshSplitInfo=MeshSplitInfo,exports.splitBasedOnJoints=(()=>{return(e,t,r,c)=>{let o;switch(r){case ccm.gfx.PrimitiveMode.TRIANGLE_LIST:case ccm.gfx.PrimitiveMode.TRIANGLE_STRIP:case ccm.gfx.PrimitiveMode.TRIANGLE_FAN:o=ccm.gfx.PrimitiveMode.TRIANGLE_LIST;break;case ccm.gfx.PrimitiveMode.LINE_LIST:case ccm.gfx.PrimitiveMode.LINE_STRIP:case ccm.gfx.PrimitiveMode.LINE_LOOP:o=ccm.gfx.PrimitiveMode.LINE_LIST;break;case ccm.gfx.PrimitiveMode.POINT_LIST:o=ccm.gfx.PrimitiveMode.POINT_LIST}if(void 0===o)return[];const i=[new MeshSplitInfo(o)];let a=i[0];return forEachFace(t,r,t=>{(function(e,t,r,c){let o=0;for(let c=0;c<r.length;c++){const i=r[c];for(let r=0;r<4;r++)e.jointSet.has(t[4*i+r])||o++}return e.jointSet.size+o<=c})(a,e,t,c)||(a=new MeshSplitInfo(o),i.push(a)),function(e,t,r){for(let c=0;c<r.length;c++){const o=r[c];for(let r=0;r<4;r++)e.jointSet.add(t[4*o+r]);e.indices.push(o)}}(a,e,t)}),i}})(),exports.getUintArrayCtor=getUintArrayCtor;