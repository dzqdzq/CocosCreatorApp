"use strict";function forEachFace(t,e,a){let i=0;var c=[];switch(e){case ccm.gfx.PrimitiveMode.TRIANGLE_LIST:i=t.length/3;for(let e=0;e<i;e++)c[0]=t[3*e],c[1]=t[3*e+1],c[2]=t[3*e+2],a(c);break;case ccm.gfx.PrimitiveMode.TRIANGLE_STRIP:i=t.length-2;let r=0;for(let e=0;e<i;e++)c[0]=t[e-r],c[1]=t[e+r+1],c[2]=t[e+2],a(c),r=~r;break;case ccm.gfx.PrimitiveMode.TRIANGLE_FAN:i=t.length-1;var o=t[0];for(let e=1;e<i;e++)c[0]=o,c[1]=t[e],c[2]=t[e+1],a(c);break;case ccm.gfx.PrimitiveMode.LINE_LIST:i=t.length/2;for(let e=0;e<i;e++)c[0]=t[2*e],c[1]=t[2*e+1],a(c);break;case ccm.gfx.PrimitiveMode.LINE_STRIP:i=t.length-1;for(let e=0;e<i;e++)c[0]=t[e],c[1]=t[e+1],a(c);break;case ccm.gfx.PrimitiveMode.LINE_LOOP:i=t.length;for(let e=0;e<i;e++)c[0]=t[e],c[1]=t[e+1===i?0:e+1],a(c);break;case ccm.gfx.PrimitiveMode.POINT_LIST:i=t.length;for(let e=0;e<i;e++)c[0]=t[e],a(c)}}Object.defineProperty(exports,"__esModule",{value:!0}),exports.splitBasedOnJoints=exports.MeshSplitInfo=exports.calculateTangents=exports.calculateNormals=void 0,exports.forEachFace=forEachFace,exports.getUintArrayCtor=getUintArrayCtor,exports.calculateNormals=(()=>{const m=cc["Vec3"],f=new m,d=new m,I=new m,g=new m,x=new m,y=new m;return(r,t,a=[])=>{var i=t.length/3,c=r.length/3,o=Array(3*c).fill(0).map(()=>new m);for(let e=0;e<i;++e){var n=t[3*e+0],l=t[3*e+1],s=t[3*e+2];m.fromArray(f,r,3*n),m.fromArray(d,r,3*l),m.fromArray(I,r,3*s),m.subtract(g,d,f),m.subtract(x,I,f),m.cross(y,g,x),m.add(o[n],o[n],y),m.add(o[l],o[l],y),m.add(o[s],o[s],y)}for(let e=0;e<c;++e)m.toArray(a,m.normalize(y,o[e]),3*e);return a}})(),exports.calculateTangents=(()=>{const{Vec2:u,Vec3:p}=cc,S=new p,v=new p,A=new p,T=new p,P=new p,h=new u,E=new u,L=new u,M=new p,w=new p,N=new p,_=new p;return(t,a,r,i,c=[])=>{var e=a.length/3,o=t.length/3,n=Array(o).fill(0).map(()=>new p),l=Array(o).fill(0).map(()=>new p);for(let r=0;r<e;++r){var s=a[3*r+0],m=a[3*r+1],f=a[3*r+2],d=(p.fromArray(S,t,3*s),p.fromArray(v,t,3*m),p.fromArray(A,t,3*f),u.fromArray(h,i,2*s),u.fromArray(E,i,2*m),u.fromArray(L,i,2*f),p.subtract(T,v,S),p.subtract(P,A,S),E.x-h.x),I=L.x-h.x,g=E.y-h.y,x=L.y-h.y;let e=d*x-I*g;0!==e&&(e=1/e),p.multiplyScalar(M,p.subtract(N,p.multiplyScalar(N,T,x),p.multiplyScalar(_,P,g)),e),p.multiplyScalar(w,p.subtract(N,p.multiplyScalar(N,P,d),p.multiplyScalar(_,T,I)),e),p.add(n[s],n[s],M),p.add(n[m],n[m],M),p.add(n[f],n[f],M),p.add(l[s],l[s],w),p.add(l[m],l[m],w),p.add(l[f],l[f],w)}for(let e=0;e<o;++e){const M=n[e],w=l[e];var y=p.fromArray(N,r,3*e);p.subtract(_,M,p.multiplyScalar(_,y,p.dot(M,y)/p.dot(y,y))),0==p.dot(_,_)&&(y.x||y.z?p.set(_,y.z,0,-y.x):p.set(_,0,y.x,-y.y)),p.toArray(c,p.normalize(_,_),4*e),c[4*e+3]=0<p.dot(p.cross(_,w,M),y)?1:-1}return c}})();class MeshSplitInfo{indices=[];jointSet=new Set;primitiveMode;constructor(e=ccm.gfx.PrimitiveMode.TRIANGLE_LIST){this.primitiveMode=e}}function getUintArrayCtor(e){return e<1<<8*Uint8Array.BYTES_PER_ELEMENT?Uint8Array:e<1<<8*Uint16Array.BYTES_PER_ELEMENT?Uint16Array:Uint32Array}exports.MeshSplitInfo=MeshSplitInfo,exports.splitBasedOnJoints=(c,e,r,o)=>{let n;switch(r){case ccm.gfx.PrimitiveMode.TRIANGLE_LIST:case ccm.gfx.PrimitiveMode.TRIANGLE_STRIP:case ccm.gfx.PrimitiveMode.TRIANGLE_FAN:n=ccm.gfx.PrimitiveMode.TRIANGLE_LIST;break;case ccm.gfx.PrimitiveMode.LINE_LIST:case ccm.gfx.PrimitiveMode.LINE_STRIP:case ccm.gfx.PrimitiveMode.LINE_LOOP:n=ccm.gfx.PrimitiveMode.LINE_LIST;break;case ccm.gfx.PrimitiveMode.POINT_LIST:n=ccm.gfx.PrimitiveMode.POINT_LIST}if(void 0===n)return[];const l=[new MeshSplitInfo(n)];let s=l[0];return forEachFace(e,r,e=>{!function(r,t,a,e){let i=0;for(let e=0;e<a.length;e++){var c=a[e];for(let e=0;e<4;e++)r.jointSet.has(t[4*c+e])||i++}return r.jointSet.size+i<=e}(s,c,e,o)&&(s=new MeshSplitInfo(n),l.push(s));var r=s,t=c,a=e;for(let e=0;e<a.length;e++){var i=a[e];for(let e=0;e<4;e++)r.jointSet.add(t[4*i+e]);r.indices.push(i)}}),l};