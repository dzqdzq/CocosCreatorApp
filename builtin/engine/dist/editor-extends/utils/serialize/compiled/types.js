"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.CustomClassNode=exports.ClassNode=exports.DictNode=exports.ArrayNode=exports.BaseNode=exports.TraceableDict=exports.TraceableItem=void 0;const cc_1=require("cc"),{DICT_JSON_LAYOUT:DICT_JSON_LAYOUT,CLASS_TYPE:CLASS_TYPE,CLASS_KEYS:CLASS_KEYS,CLASS_PROP_TYPE_OFFSET:CLASS_PROP_TYPE_OFFSET,CUSTOM_OBJ_DATA_CONTENT:CUSTOM_OBJ_DATA_CONTENT,MASK_CLASS:MASK_CLASS}=cc_1.deserialize._macros;class TraceableItem{constructor(){this.result=TraceableItem.NO_RESULT,this.tracers=[],this.keys=[]}static compareByRefCount(e,s){return s.tracers.length-e.tracers.length}traceBy(e,s){this.tracers.push(e),this.keys.push(s)}movedTo(e){for(let s=0;s<this.tracers.length;s++)this.tracers[s][this.keys[s]]=e}}exports.TraceableItem=TraceableItem,TraceableItem.NO_RESULT=Object.create(null);class TraceableDict{constructor(){this.values=new Map}trace(e,s,t){let a=this.values.get(e);return a||(a=new TraceableItem,this.values.set(e,a)),a.traceBy(s,t),a}traceString(e,s,t){this.trace(e,s,t).result=e}get(e){return this.values.get(e)}getSortedItems(){const e=Array.from(this.values.values());return e.sort(TraceableItem.compareByRefCount),e}dump(e=0){const s=this.getSortedItems();for(let t=0;t<s.length;t++)s[t].movedTo(e+t);return s.map(e=>e.result)}}exports.TraceableDict=TraceableDict,TraceableDict.PLACEHOLDER=0;class BaseNode{constructor(e){this.refCount=0,this.indexed=!1,this.shouldBeIndexed=!1,this._index=-1,this.selfType=e}get instanceIndex(){return this._index}set instanceIndex(e){if(this.indexed)throw new Error("Should not change instanceIndex on indexed object");this._index=e}get refType(){return this.indexed?1:this.selfType}static compareByRefCount(e,s){return s.refCount-e.refCount}setStatic(e,s,t){}setDynamic(e,s){++e.refCount}setAssetRefPlaceholderOnIndexed(e){}dumpRecursively(e){}}exports.BaseNode=BaseNode,BaseNode.AssetPlaceholderType=0,BaseNode.AssetPlaceholderValue=null;class ArrayNode extends BaseNode{constructor(e){super(12),this.types=new Array(e),this.datas=new Array(e)}setStatic(e,s,t){this.types[e]=s,this.datas[e]=t}setDynamic(e,s){super.setDynamic(e),this.types[s]=void 0,this.datas[s]=e}setAssetRefPlaceholderOnIndexed(e){this.types[e]=BaseNode.AssetPlaceholderType,this.datas[e]=BaseNode.AssetPlaceholderValue}dumpRecursively(e){for(let s=0;s<this.datas.length;++s){const t=this.datas[s];if(t instanceof BaseNode)if(t.indexed){const a=e.addRef(this,s,t);isFinite(a)?(this.types[s]=1,this.datas[s]=a):(this.types[s]=0,this.datas[s]=null)}else{t.instanceIndex=this.instanceIndex;const a=t.dumpRecursively(e);this.types[s]=t.refType,this.datas[s]=a}}for(let e=0;e<ArrayNode.DeriveTypes.length;++e){const[s,t]=ArrayNode.DeriveTypes[e];if(this.types.every(e=>e===s))return this.selfType=t,this.datas}return this.selfType=12,[this.datas,...this.types]}}exports.ArrayNode=ArrayNode,ArrayNode.DeriveTypes=[[0,0],[4,9],[6,3],[1,2]];class DictNode extends BaseNode{constructor(){super(11),this.data=[null],this.json=Object.create(null),this.dynamics=Object.create(null),this.data[DICT_JSON_LAYOUT]=this.json}setStatic(e,s,t){0===s?this.json[e]=t:this.data.push(e,s,t)}setDynamic(e,s){super.setDynamic(e),this.dynamics[s]=e}dumpRecursively(e){for(const s in this.dynamics){const t=this.dynamics[s];if(t.indexed){const a=e.addRef(this,s,t);isFinite(a)&&this.data.push(s,1,a)}else{t.instanceIndex=this.instanceIndex;const a=t.dumpRecursively(e);0===t.refType?this.json[s]=a:this.data.push(s,t.refType,a)}}return 1===this.data.length?(this.selfType=0,this.json):this.data}}exports.DictNode=DictNode;class ClassNode extends BaseNode{constructor(e){super(4),this.simpleKeys=new Array,this.simpleValues=[],this.advanceds=new Array,this.ctor=e}static fromData(e,s,t){const a=e[CLASS_TYPE],r=new ClassNode(a);r.dumped=t,r.simpleValues=null;const i=e[CLASS_KEYS],n=e[CLASS_PROP_TYPE_OFFSET],o=s[s.length-1];let c=MASK_CLASS+1;for(;c<o;++c){const e=i[s[c]];r.simpleKeys.push(e)}for(let a=o;a<t.length;++a){const t=i[s[a]],o=e[s[a]+n];r.advanceds.push(t,o)}return r}setStatic(e,s,t){0===s?(this.simpleKeys.push(e),this.simpleValues.push(t)):this.advanceds.push(e,s,t)}setDynamic(e,s){super.setDynamic(e),this.advanceds.push(s,void 0,e)}dumpRecursively(e){const s=this.advanceds;for(let t=s.length-3;t>=0;t-=3){const a=s[t+2];if(a instanceof BaseNode)if(a.indexed){const r=e.addRef(this,s[t],a);isFinite(r)?(s[t+1]=1,s[t+2]=r):s.splice(t,3)}else{a.instanceIndex=this.instanceIndex;const r=a.dumpRecursively(e);0===a.refType?(this.simpleKeys.push(s[t]),this.simpleValues.push(r),s.splice(t,3)):(s[t+1]=a.refType,s[t+2]=r)}}const t=TraceableDict.PLACEHOLDER;this.dumped=[t].concat(this.simpleValues);for(let e=0;e<s.length;e+=3)this.dumped.push(s[e+2]);return this.simpleValues=null,this.advanceds=this.advanceds.filter((e,s)=>s%3!=2),this.dumped}}exports.ClassNode=ClassNode;class CustomClassNode extends BaseNode{constructor(e,s){super(10),this.ctor=e,this.content=s}static fromData(e,s){const t=s[CUSTOM_OBJ_DATA_CONTENT],a=new CustomClassNode(e,t);return a.dumped=s,a}setStatic(e,s,t){throw new Error("Should not set property of CustomClass")}setDynamic(e,s){throw new Error("Should not set property of CustomClass")}dumpRecursively(e){const s=TraceableDict.PLACEHOLDER;return this.dumped=[s,this.content],this.dumped}}exports.CustomClassNode=CustomClassNode;