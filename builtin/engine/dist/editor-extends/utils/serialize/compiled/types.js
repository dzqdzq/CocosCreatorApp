"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.CustomClassNode=exports.ClassNode=exports.DictNode=exports.ArrayNode=exports.Node=exports.TraceableDict=exports.TraceableItem=void 0;const cc_1=require("cc"),{DICT_JSON_LAYOUT:DICT_JSON_LAYOUT,CLASS_TYPE:CLASS_TYPE,CLASS_KEYS:CLASS_KEYS,CLASS_PROP_TYPE_OFFSET:CLASS_PROP_TYPE_OFFSET,CUSTOM_OBJ_DATA_CONTENT:CUSTOM_OBJ_DATA_CONTENT,MASK_CLASS:MASK_CLASS}=cc_1.deserialize._macros;class TraceableItem{constructor(){this.result=TraceableItem.NO_RESULT,this.tracers=[],this.keys=[]}static compareByRefCount(e,s){return s.tracers.length-e.tracers.length}traceBy(e,s){this.tracers.push(e),this.keys.push(s)}movedTo(e){for(let s=0;s<this.tracers.length;s++)this.tracers[s][this.keys[s]]=e}}exports.TraceableItem=TraceableItem,TraceableItem.NO_RESULT=Object.create(null);class TraceableDict{constructor(){this.values=new Map}trace(e,s,t){let r=this.values.get(e);return r||(r=new TraceableItem,this.values.set(e,r)),r.traceBy(s,t),r}traceString(e,s,t){this.trace(e,s,t).result=e}get(e){return this.values.get(e)}getSortedItems(){const e=Array.from(this.values.values());return e.sort(TraceableItem.compareByRefCount),e}dump(e=0){const s=this.getSortedItems();for(let t=0;t<s.length;t++)s[t].movedTo(e+t);return s.map(e=>e.result)}}exports.TraceableDict=TraceableDict,TraceableDict.PLACEHOLDER=0;class Node{constructor(e){this.refCount=0,this.indexed=!1,this.shouldBeIndexed=!1,this._index=-1,this.selfType=e}get instanceIndex(){return this._index}set instanceIndex(e){if(this.indexed)throw new Error("Should not change instanceIndex on indexed object");this._index=e}get refType(){return this.indexed?1:this.selfType}static compareByRefCount(e,s){return s.refCount-e.refCount}setStatic(e,s,t){}setDynamic(e,s){++e.refCount}setAssetRefPlaceholderOnIndexed(e){}dumpRecursively(e){}}exports.Node=Node,Node.AssetPlaceholderType=0,Node.AssetPlaceholderValue=null;class ArrayNode extends Node{constructor(e){super(12),this.types=new Array(e),this.datas=new Array(e)}setStatic(e,s,t){this.types[e]=s,this.datas[e]=t}setDynamic(e,s){super.setDynamic(e),this.types[s]=void 0,this.datas[s]=e}setAssetRefPlaceholderOnIndexed(e){this.types[e]=Node.AssetPlaceholderType,this.datas[e]=Node.AssetPlaceholderValue}dumpRecursively(e){for(let s=0;s<this.datas.length;++s){const t=this.datas[s];if(t instanceof Node)if(t.indexed){const r=e.addRef(this,s,t);isFinite(r)?(this.types[s]=1,this.datas[s]=r):(this.types[s]=0,this.datas[s]=null)}else{t.instanceIndex=this.instanceIndex;const r=t.dumpRecursively(e);this.types[s]=t.refType,this.datas[s]=r}}for(let e=0;e<ArrayNode.DeriveTypes.length;++e){const[s,t]=ArrayNode.DeriveTypes[e];if(this.types.every(e=>e===s))return this.selfType=t,this.datas}return this.selfType=12,[this.datas,...this.types]}}exports.ArrayNode=ArrayNode,ArrayNode.DeriveTypes=[[0,0],[4,9],[6,3],[1,2]];class DictNode extends Node{constructor(){super(11),this.data=[null],this.json=Object.create(null),this.dynamics=Object.create(null),this.data[DICT_JSON_LAYOUT]=this.json}setStatic(e,s,t){0===s?this.json[e]=t:this.data.push(e,s,t)}setDynamic(e,s){super.setDynamic(e),this.dynamics[s]=e}dumpRecursively(e){for(const s in this.dynamics){const t=this.dynamics[s];if(t.indexed){const r=e.addRef(this,s,t);isFinite(r)&&this.data.push(s,1,r)}else{t.instanceIndex=this.instanceIndex;const r=t.dumpRecursively(e);0===t.refType?this.json[s]=r:this.data.push(s,t.refType,r)}}return 1===this.data.length?(this.selfType=0,this.json):this.data}}exports.DictNode=DictNode;class ClassNode extends Node{constructor(e){super(4),this.simpleKeys=new Array,this.simpleValues=[],this.advanceds=new Array,this.ctor=e}static fromData(e,s,t){const r=e[CLASS_TYPE],i=new ClassNode(r);i.dumped=t,i.simpleValues=null;const a=e[CLASS_KEYS],n=e[CLASS_PROP_TYPE_OFFSET],o=s[s.length-1];let c=MASK_CLASS+1;for(;c<o;++c){const e=a[s[c]];i.simpleKeys.push(e)}for(let r=o;r<t.length;++r){const t=a[s[r]],o=e[s[r]+n];i.advanceds.push(t,o)}return i}setStatic(e,s,t){0===s?(this.simpleKeys.push(e),this.simpleValues.push(t)):this.advanceds.push(e,s,t)}setDynamic(e,s){super.setDynamic(e),this.advanceds.push(s,void 0,e)}dumpRecursively(e){const s=this.advanceds;for(let t=s.length-3;t>=0;t-=3){const r=s[t+2];if(r instanceof Node)if(r.indexed){const i=e.addRef(this,s[t],r);isFinite(i)?(s[t+1]=1,s[t+2]=i):s.splice(t,3)}else{r.instanceIndex=this.instanceIndex;const i=r.dumpRecursively(e);0===r.refType?(this.simpleKeys.push(s[t]),this.simpleValues.push(i),s.splice(t,3)):(s[t+1]=r.refType,s[t+2]=i)}}const t=TraceableDict.PLACEHOLDER;this.dumped=[t].concat(this.simpleValues);for(let e=0;e<s.length;e+=3)this.dumped.push(s[e+2]);return this.simpleValues=null,this.advanceds=this.advanceds.filter((e,s)=>s%3!=2),this.dumped}}exports.ClassNode=ClassNode;class CustomClassNode extends Node{constructor(e,s){super(10),this.ctor=e,this.content=s}static fromData(e,s){const t=s[CUSTOM_OBJ_DATA_CONTENT],r=new CustomClassNode(e,t);return r.dumped=s,r}setStatic(e,s,t){throw new Error("Should not set property of CustomClass")}setDynamic(e,s){throw new Error("Should not set property of CustomClass")}dumpRecursively(e){const s=TraceableDict.PLACEHOLDER;return this.dumped=[s,this.content],this.dumped}}exports.CustomClassNode=CustomClassNode;