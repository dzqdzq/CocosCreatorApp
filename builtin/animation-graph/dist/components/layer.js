"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.destroyed=exports.mounted=exports.methods=exports.watch=exports.computed=exports.data=exports.components=exports.template=void 0;const validation_1=require("../clip-related/validation"),defaultType="state";function data(){return{clipAssetType:"cc.AnimationClip",graphData:{},graph:{scale:1,top:0,left:0,centerX:0,centerY:0,type:defaultType},minScale:.05,maxScale:2,mouseDownPoint:null}}function mounted(){const e=this;e.observer=new window.ResizeObserver(()=>{e.resize()}),e.observer.observe(e.$el),e.resize()}function destroyed(){this.observer&&this.observer.unobserve(this.$el)}exports.template='\n    <ui-drag-area class="layer"\n        :droppable="clipAssetType"\n        @mousedown="mouseDown($event)"\n        @wheel="wheel($event)"\n        @drop="drop($event)"\n    >\n        <grid class="grid" ref="grid"></grid>\n        <transition name="component-fade" mode="out-in"\n            v-on:before-enter="beforeEnter"\n            v-on:before-leave="beforeLeave"\n        >\n            <component class="graph" ref="component"\n                :is="graph.type"\n                :type="graph.type"\n                :style="graphStyle"\n                :graph="graphData"\n            ></component>\n        </transition>\n    </ui-drag-area>\n',exports.components={grid:require("./grid"),state:require("./state"),motion:require("./motion"),pose:require("./pose")},exports.data=data,exports.computed={graphStyle(){return{top:`${Math.ceil(this.graph.top)}px`,left:`${Math.ceil(this.graph.left)}px`,transform:`scale(${this.graph.scale})`}}},exports.watch={"graph.scale"(){this.moveViewport()},"graph.top"(){this.moveViewport()},"graph.left"(){this.moveViewport()},"graph.centerX"(){const e=this;e.$refs.component&&e.$refs.component.resize()},"graph.centerY"(){const e=this;e.$refs.component&&e.$refs.component.resize()}},exports.methods={beforeEnter(){this.$refs.grid.$el.classList.remove("animationOut"),this.$refs.grid.$el.classList.add("animationIn")},beforeLeave(){this.$refs.grid.$el.classList.remove("animationIn"),this.$refs.grid.$el.classList.add("animationOut")},async refresh(e,t){this.graph.type=e,await this.refreshViewport(t),this.graphData=t},resize(){this.graph.centerX=this.$el.offsetWidth/2,this.graph.centerY=this.$el.offsetHeight/2},clear(){this.graph.type=defaultType,this.graphData={},this.viewport()},viewport(){this.graph.scale=1,this.graph.top=0,this.graph.left=0},async bestViewport(){const e=this,t=e.$el.clientWidth,o=e.$el.clientHeight,r=e.calcComponentRect(),n=t/r.width,i=o/r.height,s=.95*(Math.min(n,i,1)||1);e.graph.scale=s,e.graph.left=(t-r.width*s)/2-r.minX*s-t*(1-s)/2,e.graph.top=(o-r.height*s)/2-r.minY*s-o*(1-s)/2,e.saveViewport()},moveViewport(){const e=this;window.cancelAnimationFrame(e.viewportAnimationId),e.viewportAnimationId=window.requestAnimationFrame(()=>{e.saveViewport()})},getViewportKey(e){var t;const o=this,r=["viewport"];if(o.$root.queryData.assetInfo&&r.push(o.$root.queryData.assetInfo.uuid),e||(e=o.graphData),null===(t=e.editorData)||void 0===t?void 0:t.id)r.push(e.editorData.id);else{const e=[];o.$root.queryData.view.crumbs.slice(0,-1).forEach(t=>{t.type&&e.push(`${t.type}-${t.value}`)}),r.push(e.join("-"))}return r.join(".")},async refreshViewport(e){const t=this;try{const o=await Editor.Profile.getTemp("animation-graph",t.getViewportKey(e));o?Object.assign(t.graph,o):t.viewport()}catch(e){console.error(`animation-graph get local viewport data error: ${e}`)}},async saveViewport(){await Editor.Profile.setTemp("animation-graph",this.getViewportKey(),{scale:this.graph.scale,top:this.graph.top,left:this.graph.left})},select(e){this.$refs.component.select(e)},wheel(e){const t=this;if(e.stopPropagation(),e.preventDefault(),!t.$refs.component)return;const o=t.$refs.component.$el.getBoundingClientRect(),r=t.graph.scale,n=0-(e.deltaX||e.deltaY)/5e3,i=0-(e.clientY-(o.y+o.height/2))*n/r,s=0-(e.clientX-(o.x+o.width/2))*n/r;let a=r,p=t.graph.top,h=t.graph.left;(a+=n)<t.minScale||a>t.maxScale||(p+=i,h+=s,t.graph.scale=a,t.graph.top=p,t.graph.left=h)},mouseDown(e){const t=this;if(!t.$refs.component)return;const o=t.$el.getBoundingClientRect(),r=t.$refs.component.$el.getBoundingClientRect(),n=o.width+(e.clientX-r.x-r.width)/t.graph.scale,i=o.height+(e.clientY-r.y-r.height)/t.graph.scale;function s(e){if(!t.mouseDownPoint||"right"!==t.mouseDownPoint.button)return;e.stopPropagation(),e.preventDefault();const{clientX:o,clientY:r,gridStartX:n,gridStartY:i,graphLeft:s,graphTop:a}=t.mouseDownPoint,p=e.clientX-o,h=e.clientY-r;0===p&&0===h||(t.mouseDownPoint.hasMoved=!0,t.$refs.grid.startX=n+p,t.$refs.grid.startY=i+h,t.$refs.grid.render(),t.graph.left=s+p,t.graph.top=a+h)}t.mouseDownPoint={hasMoved:!1,clientX:e.clientX,clientY:e.clientY,offsetX:n,offsetY:i,button:0===e.button?"left":"right",gridStartX:t.$refs.grid.startX,gridStartY:t.$refs.grid.startY,graphLeft:t.graph.left,graphTop:t.graph.top},document.addEventListener("mousemove",s),document.addEventListener("mouseup",function e(o){t.mouseDownPoint&&"right"===t.mouseDownPoint.button&&(t.mouseDownPoint.hasMoved||t.contextMenu(t.mouseDownPoint)),document.removeEventListener("mousemove",s),document.removeEventListener("mouseup",e),t.mouseDownPoint=null})},contextMenu(e){this.$refs.component.contextMenu(e)},drop(e){const t=this;t.$el.click();const o=[],{additional:r}=JSON.parse(JSON.stringify(Editor.UI.__protected__.DragArea.currentDragInfo))||{};if(r&&r.forEach(e=>{if(e.type===t.clipAssetType){if(!(0,validation_1.isValidAnimationClipForGraph)(e.value))return void console.warn(`${Editor.I18n.t("animation-graph.motion.invalidCipInfo")} {asset(${e.value})}`);o.push(e.value)}}),!o.length)return;if(!t.$refs.component)return;const n=t.$el.getBoundingClientRect(),i=t.$refs.component.$el.getBoundingClientRect(),s=n.width+(e.clientX-i.x-i.width)/t.graph.scale;let a=n.height+(e.clientY-i.y-i.height)/t.graph.scale-48;const p=o.length;for(let r=0;r<p;r++){const n=o[r];a+=32,t.$refs.component.drop(e,{offsetX:s,offsetY:a,uuid:n})}},twinkle(e,t,o){const r=this;r.$refs.component&&r.$refs.component.$attrs.type===e&&(r.$refs.component.$refs[t][0].twinkle=o)},getCenterXY(e,t=!0){let o=e.left-this.graph.centerX,r=e.top-this.graph.centerY;return t&&(o+=e.width/2,r+=e.height/2),{centerX:o,centerY:r}},getPosition(e,t=!0){let o=e.centerX+this.graph.centerX,r=e.centerY+this.graph.centerY;return t&&(o-=e.width/2,r-=e.height/2),{top:r,left:o}},calcComponentRect(){const e=this.$refs.component.nodes,t=[],o=[],r={},n={};for(const i in e){const s=e[i];0!==s.width&&0!==s.height&&(t.push(s.left),o.push(s.top),(void 0===r[s.left]||r[s.left]<s.width)&&(r[s.left]=s.width),(void 0===n[s.top]||n[s.top]<s.height)&&(n[s.top]=s.height))}const i=Math.min(...t),s=Math.max(...t),a=Math.min(...o),p=Math.max(...o),h=Math.abs(s-i)+r[s],c=Math.abs(p-a)+n[p],l=i,g=s+r[s],d=a,m=p+n[p];return{minX:i,maxX:s,minY:a,maxY:p,centerX:(l+g)/2,centerY:(d+m)/2,left:i,right:g,top:a,bottom:m,width:h,height:c}}},exports.mounted=mounted,exports.destroyed=destroyed;