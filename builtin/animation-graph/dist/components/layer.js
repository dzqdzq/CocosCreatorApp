"use strict";function data(){return{clipAssetType:"cc.AnimationClip",isSubgraph:!1,graphData:{},graph:{scale:1,top:0,left:0,centerX:0,centerY:0,type:"state"},minScale:.05,maxScale:2,mouseDownPoint:null}}function mounted(){const e=this;e.$el.hasAttribute("machine-thumbnail")||(e.observer=new window.ResizeObserver(()=>{e.resize()}),e.observer.observe(e.$el),e.resize())}function destroyed(){this.observer&&this.observer.unobserve(this.$el)}Object.defineProperty(exports,"__esModule",{value:!0}),exports.destroyed=exports.mounted=exports.methods=exports.watch=exports.computed=exports.data=exports.components=exports.template=void 0,exports.template='\n    <ui-drag-area class="layer"\n        :droppable="clipAssetType"\n        @mousedown="mouseDown($event)"\n        @wheel="wheel($event)"\n        @drop="drop($event)"\n    >\n        <grid class="grid" ref="grid"\n            v-if="!isSubgraph"\n        ></grid>\n        <transition name="component-fade" mode="out-in"\n            v-on:before-enter="beforeEnter"\n            v-on:before-leave="beforeLeave"\n        >\n            <component class="graph" ref="component"\n                :is="graph.type"\n                :type="graph.type"\n                :style="graphStyle"\n                :graph="graphData"\n            ></component>\n        </transition>\n    </ui-drag-area>\n',exports.components={grid:require("./grid"),state:require("./state"),motion:require("./motion")},exports.data=data,exports.computed={graphStyle(){return{top:`${Math.ceil(this.graph.top)}px`,left:`${Math.ceil(this.graph.left)}px`,transform:`scale(${this.graph.scale})`}}},exports.watch={"graph.scale"(){this.moveViewport()},"graph.top"(){this.moveViewport()},"graph.left"(){this.moveViewport()},"graph.centerX"(){const e=this;e.$refs.component&&e.$refs.component.resize()},"graph.centerY"(){const e=this;e.$refs.component&&e.$refs.component.resize()}},exports.methods={beforeEnter(){this.$refs.grid.$el.classList.remove("animationOut"),this.$refs.grid.$el.classList.add("animationIn")},beforeLeave(){this.$refs.grid.$el.classList.remove("animationIn"),this.$refs.grid.$el.classList.add("animationOut")},refresh(e,t,n){const o=this;o.isSubgraph=!!n,o.graph.type=e,!o.isSubgraph&&t.editorData&&t.editorData.viewport&&Object.assign(o.graph,t.editorData.viewport),o.graphData=t},resize(){this.graph.centerX=this.$el.offsetWidth/2,this.graph.centerY=this.$el.offsetHeight/2},clear(){this.graphData={}},viewport(){this.isSubgraph||(this.graph.scale=1,this.graph.top=0,this.graph.left=0)},bestViewport(){const e=this;if(e.isSubgraph)return;const t=e.$el.clientWidth,n=e.$el.clientHeight,o=e.calcComponentRect(),r=t/o.width,i=n/o.height,s=Math.min(r,i,1)||1,a=o.centerX-t/2,p=o.centerY-n/2,h={scale:s,top:0,left:0},c=[],l=[],g=e.$refs.component.nodes,d="motion"===e.$refs.component.$attrs.type;for(const t in g){const n=g[t];0!==n.width&&0!==n.height&&(n.left-=a,n.top-=p,d?l.push({level:n.level,editorData:e.getCenterXY(n)}):c.push({index:n.index,editorData:e.getCenterXY(n)}))}Editor.Message.send("scene","execute-scene-script",{name:"animation-graph",method:"bestViewport",args:[{graph:h,states:c,motions:l}]})},moveViewport(){const e=this;e.isSubgraph||(window.cancelAnimationFrame(e.viewportAnimationId),e.viewportAnimationId=window.requestAnimationFrame(()=>{Editor.Message.send("scene","execute-scene-script",{name:"animation-graph",method:"viewport",args:[{scale:e.graph.scale,top:e.graph.top,left:e.graph.left}]})}))},select(e){this.$refs.component.select(e)},wheel(e){const t=this;if(e.stopPropagation(),e.preventDefault(),!t.$refs.component)return;const n=t.$refs.component.$el.getBoundingClientRect(),o=t.graph.scale,r=0-(e.deltaX||e.deltaY)/5e3,i=0-(e.clientY-(n.y+n.height/2))*r/o,s=0-(e.clientX-(n.x+n.width/2))*r/o;let a=o,p=t.graph.top,h=t.graph.left;(a+=r)<t.minScale||a>t.maxScale||(p+=i,h+=s,t.graph.scale=a,t.graph.top=p,t.graph.left=h)},mouseDown(e){const t=this;if(!t.$refs.component)return;const n=t.$el.getBoundingClientRect(),o=t.$refs.component.$el.getBoundingClientRect(),r=n.width+(e.clientX-o.x-o.width)/t.graph.scale,i=n.height+(e.clientY-o.y-o.height)/t.graph.scale;function s(e){if(!t.mouseDownPoint||"right"!==t.mouseDownPoint.button)return;e.stopPropagation(),e.preventDefault();const{clientX:n,clientY:o,gridStartX:r,gridStartY:i,graphLeft:s,graphTop:a}=t.mouseDownPoint,p=e.clientX-n,h=e.clientY-o;0===p&&0===h||(t.mouseDownPoint.hasMoved=!0,t.$refs.grid.startX=r+p,t.$refs.grid.startY=i+h,t.$refs.grid.render(),t.graph.left=s+p,t.graph.top=a+h)}t.mouseDownPoint={hasMoved:!1,clientX:e.clientX,clientY:e.clientY,offsetX:r,offsetY:i,button:0===e.button?"left":"right",gridStartX:t.$refs.grid.startX,gridStartY:t.$refs.grid.startY,graphLeft:t.graph.left,graphTop:t.graph.top},document.addEventListener("mousemove",s),document.addEventListener("mouseup",function e(n){t.mouseDownPoint&&"right"===t.mouseDownPoint.button&&(t.mouseDownPoint.hasMoved||t.contextMenu(t.mouseDownPoint)),document.removeEventListener("mousemove",s),document.removeEventListener("mouseup",e),t.mouseDownPoint=null})},contextMenu(e){this.$refs.component.contextMenu(e)},drop(e){const t=this;t.$el.click();const n=[],{additional:o,type:r,value:i}=JSON.parse(JSON.stringify(Editor.UI.DragArea.currentDragInfo))||{};if(o&&o.forEach(e=>{e.type===t.clipAssetType&&n.push(e.value)}),r===t.clipAssetType&&i&&!n.includes(i)&&n.push(i),!n.length)return;if(!t.$refs.component)return;const s=t.$el.getBoundingClientRect(),a=t.$refs.component.$el.getBoundingClientRect();let p=s.width+(e.clientX-a.x-a.width)/t.graph.scale,h=s.height+(e.clientY-a.y-a.height)/t.graph.scale;for(let o=0;o<n.length;o++){const r=n[o];p+=32,h+=32,t.$refs.component.drop(e,{offsetX:p,offsetY:h,uuid:r})}},getCenterXY(e){return{centerX:e.left+e.width/2-this.graph.centerX,centerY:e.top+e.height/2-this.graph.centerY}},getPosition(e){const t=e.centerX-e.width/2+this.graph.centerX;return{top:e.centerY-e.height/2+this.graph.centerY,left:t}},calcComponentRect(){const e=this.$refs.component.nodes,t=[],n=[],o={},r={};for(const i in e){const s=e[i];0!==s.width&&0!==s.height&&(t.push(s.left),n.push(s.top),(void 0===o[s.left]||o[s.left]<s.width)&&(o[s.left]=s.width),(void 0===r[s.top]||r[s.top]<s.height)&&(r[s.top]=s.height))}const i=Math.min(...t),s=Math.max(...t),a=Math.min(...n),p=Math.max(...n),h=Math.abs(s-i)+o[s],c=Math.abs(p-a)+r[p],l=i,g=s+o[s],d=a,m=p+r[p];return{minX:i,maxX:s,minY:a,maxY:p,centerX:(l+g)/2,centerY:(d+m)/2,left:i,right:g,top:a,bottom:m,width:h,height:c}}},exports.mounted=mounted,exports.destroyed=destroyed;