"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.importConfig=exports.exportConfig=exports.ready=exports.template=exports.$=exports.style=void 0;const fs_1=require("fs"),path_1=require("path"),Vue=require("vue/dist/vue.js");exports.style='\n.config { display: grid; }\n.config >.table { width: 100%; }\n.config >.table .td { text-align: center; }\n\n.config >.table .td.mini { width: 40px; }\n.config >.table .td.name { width: 130px; }\n.config >.table .td.operation { width: 80px; text-align: left; }\n\n.config >.table .td .input { vertical-align: inherit; width: 100%; }\n.config >.table .td.error { text-align: left; color: var(--color-danger-fill-weaker); }\n.config >.table .td ui-button[type="icon"] { margin: 0 2px; }\n.config >.table .gray { color: var(--color-normal-contrast-emphasis); }\n.config >.table .td.first { text-align: left; }\n.config >.table .td.first .add { width: 200px; margin: 10px 0; }\n.config >.table .td.first .add > .icon { margin-right: 8px; }\n.config .transform { writing-mode: tb; }\n',exports.$={el:".config"},exports.template=(0,fs_1.readFileSync)((0,path_1.join)(__dirname,"../../static/contributions/project-physics.html"),"utf8");const component={data:{collisionMatrix:{0:1},groups:[],reverseGroups:[],state:"",stateIndex:null,error:""},methods:{t:e=>Editor.I18n.t(e),async refresh(){const e=this,t=await Editor.Profile.getProject("project","physics.collisionGroups")||[];e.groups=t.concat([{index:0,name:"DEFAULT"}]).sort((e,t)=>e.index-t.index),e.reverseGroups=e.groups.slice().reverse();const r=await Editor.Profile.getProject("project","physics.collisionMatrix");r&&(e.collisionMatrix=r)},checked(e,t){const r=this.collisionMatrix[t.toString()];return void 0!==r&&!!(r&1<<e)},onChanged(e){const t=this,r=e.currentTarget,o=r.getAttribute("y"),i=1<<Number(o);if(!o)return;let s=t.collisionMatrix[o];Array.from(r.getElementsByTagName("ui-checkbox")).forEach(e=>{const r=e.checked,o=e.getAttribute("x"),n=1<<Number(o);let c=t.collisionMatrix[o];r?(s|=n,c|=i):(s&=~n,c&=~i),t.$set(t.collisionMatrix,o,c)}),t.$set(t.collisionMatrix,o,s),Editor.Profile.setProject("project","physics.collisionMatrix",t.collisionMatrix)},startEdit(e){const t=this,r=e.path.find(e=>"TR"===e.tagName);r&&(t.stateIndex=Number(r.getAttribute("y")),t.state="edit",t.$nextTick(()=>{r.after(t.$refs.errorRow)}))},cancelEdit(){this.state="",this.error=""},saveEdit(e){const t=this,r=e.path.find(e=>"TR"===e.tagName);if(!r)return;const o=r.getElementsByClassName("name")[0].value;let i=!0;if(t.groups.forEach(e=>{o&&o!==e.name||(i=!1)}),!i)return void(t.error=t.t("project.physics.edit.error"));t.groups.forEach(e=>{e.index===t.stateIndex&&(e.name=o)});const s=t.groups.filter(e=>e.index>0).sort((e,t)=>e.index-t.index);Editor.Profile.setProject("project","physics.collisionGroups",s),t.cancelAdd(),t.refresh(),Editor.Message.send("scene","project:update-physics-group")},startAdd(){const e=this;e.state="add",e.$nextTick(()=>{e.$refs.addRow.after(e.$refs.errorRow)})},cancelAdd(){this.state="",this.error=""},saveAdd(){const e=this,t=e.$refs.addIndex.value,r=e.$refs.addName.value.trim();let o=!0;if(e.groups.forEach(e=>{(t<=0||t>=32||t===e.index)&&(o=!1),r&&r!==e.name||(o=!1)}),!o)return void(e.error=e.t("project.physics.add.error"));const i=e.groups.concat([{index:t,name:r}]).filter(e=>e.index>0).sort((e,t)=>e.index-t.index);Editor.Profile.setProject("project","physics.collisionGroups",i),e.cancelAdd(),e.refresh(),Editor.Message.send("scene","project:update-physics-group")},async deleteIndex(e){const t=this;let r=null,o=null;for(let i=0;i<t.groups.length;i++){const s=t.groups[i];if(s.index===e){r=s,o=i;break}}if(!r||!o)return;const i=t.t("project.physics.delete.warn").replace("${index}",r.index).replace("${name}",r.name);if(1===(await Editor.Dialog.warn(i,{title:t.t("project.delete"),buttons:[t.t("project.delete"),t.t("project.cancel")]})).response)return;delete t.groups[o];const s=t.groups.filter(e=>e.index>0).sort((e,t)=>e.index-t.index);Editor.Profile.setProject("project","physics.collisionGroups",s),t.refresh()},addIndexValue(){const e=this;let t=-1;for(const r of e.groups)r.index>t&&(t=r.index);return t+1}}};function ready(){component.el=this.$.el,new Vue(component).refresh()}async function exportConfig(){const e={};return e["physics.collisionMatrix"]=await Editor.Message.request("project","query-config","project","physics.collisionMatrix")||{},e["physics.collisionGroups"]=await Editor.Message.request("project","query-config","project","physics.collisionGroups")||[],e}async function importConfig(e){e["physics.collisionMatrix"]&&await Editor.Message.request("project","set-config","project","physics.collisionMatrix",e["physics.collisionMatrix"]),e["physics.collisionGroups"]&&await Editor.Message.request("project","set-config","project","physics.collisionGroups",e["physics.collisionGroups"])}exports.ready=ready,exports.exportConfig=exportConfig,exports.importConfig=importConfig;