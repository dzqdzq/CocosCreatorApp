"use strict";Object.defineProperty(exports,"__esModule",{value:!0});const controller_shape_collider_1=require("../../3d/elements/utils/controller-shape-collider");let External=require("../external"),aabb=External.GeometryUtils.aabb;const cc_1=require("cc");let gfx=cc.gfx;function setMatColor(e,t){let r=e.getComponent(cc_1.MeshRenderer);if(r){let e=r.sharedMaterials[0];e&&e.setProperty("color",t)}}let ProjectionType={ORTHO:0,PERSPECTIVE:1};class Engine2D{constructor(){this.gfx=null,this.CullMode=null,this.AttributeName=null,this.PrimitiveMode=null,this.LightType=null,this.ProjectionType=null,this.gfx=gfx,this.CullMode={NONE:gfx.CULL_NONE,BACK:gfx.CULL_BACK,FRONT:gfx.CULL_FRONT},this.AttributeName={POSITION:gfx.ATTR_POSITION,NORMAL:gfx.ATTR_NORMAL,UV:gfx.ATTR_UV},this.PrimitiveMode={TRIANGLE_LIST:gfx.PT_TRIANGLES,POINT_LIST:gfx.PT_POINTS,LINE_LIST:gfx.PT_LINES,LINE_STRIP:gfx.PT_LINE_STRIP,LINE_LOOP:gfx.PT_LINE_LOOP,TRIANGLE_STRIP:gfx.PT_TRIANGLE_STRIP,TRIANGLE_FAN:gfx.PT_TRIANGLE_FAN},this.LightType={DIRECTIONAL:cc_1.Light.Type.DIRECTIONAL,SPHERE:cc_1.Light.Type.SPHERE,SPOT:cc_1.Light.Type.SPOT},this.ProjectionType=ProjectionType}raycast(e,t,r,o,n){throw new Error("Method not implemented.")}setMaterialProperty(e,t,r){throw new Error("Method not implemented.")}updateBoundingBox(e,t,r){throw new Error("Method not implemented.")}create3DNode(e){let t=new cc.Node(e);return t.is3DNode=!0,t._objFlags|=cc.Object.Flags.DontSave|cc.Object.Flags.HideInHierarchy,t}createMesh(e){let t=new cc.Mesh,r=new gfx.VertexFormat([{name:gfx.ATTR_POSITION,type:gfx.ATTR_TYPE_FLOAT32,num:3},{name:gfx.ATTR_NORMAL,type:gfx.ATTR_TYPE_FLOAT32,num:3}]);return t.init(r,e.positions.length,!0),t.setVertices(gfx.ATTR_POSITION,e.positions),e.normals&&t.setVertices(gfx.ATTR_NORMAL,e.normals),t.setIndices(e.indices),e.minPos&&(t._minPos=e.minPos),e.maxPos&&(t._maxPos=e.maxPos),void 0!==e.primitiveType&&t.setPrimitiveType(e.primitiveType),t}addMeshToNode(e,t,r={}){let o=e.addComponent(cc_1.MeshRenderer);o.mesh=t;let n=new cc.Material;if(r.unlit?(n.effectName="__builtin-editor-gizmo-unlit",n.effect&&n.effect.getTechnique("transparent").passes[0].setDepth(!1)):t.subMeshes[0]._primitiveType<gfx.PT_TRIANGLES?r.noDepthTestForLines?(n.effectName="__builtin-editor-gizmo-unlit",n.effect&&n.effect.getTechnique("transparent").passes[0].setDepth(!1)):n.effectName="__builtin-editor-gizmo-line":n.effectName="__builtin-editor-gizmo",n.setProperty("color",e._color),n.effect){let e=n.effect.getTechnique("transparent").passes[0];r.cullMode&&e.setCullMode(r.cullMode)}o.setMaterial(0,n)}setMeshColor(e,t){e.color=t;let r=t.clone();r.a=e.opacity,setMatColor(e,r)}getMeshColor(e){return e.color}setNodeOpacity(e,t){e.opacity=t;let r=e.color;r.a=t,setMatColor(e,r)}getNodeOpacity(e){return e.opacity}getRaycastResults(e,t,r){let o=cc.v3(t,r,1),n=cc.geomUtils.intersect.raycast(e,o,(e,t,r)=>{let o=t.getComponent(controller_shape_collider_1.ControllerShapeCollider);if(o&&o.isDetectMesh){let r=t.getComponent(cc_1.MeshRenderer),o=r.mesh._subMeshes;if(r&&r.mesh&&o&&o[0]._primitiveType===gfx.PT_TRIANGLES)return cc.geomUtils.intersect.rayMesh(e,r.mesh)}return r},function(e){return null!=e.getComponent(cc_1.MeshRenderer)&&!1!==e.active});return n.ray=o,n}getModel(e){return e.getComponent(cc_1.MeshRenderer)}updateVBAttr(e,t,r){e.setVertices(t,r)}updateIB(e,t){}getBoundingBox(e){let t=null;if(e instanceof cc_1.MeshRenderer){let r=e.mesh;r&&(t=aabb.fromPoints(aabb.create(),r._minPos,r._maxPos))}else console.error("target is not a cc.MeshRenderer");return t}getRootBoneNode(e){let t=null;if(e instanceof cc_1.SkinnedMeshRenderer){let r=e._joints;r&&r.length>0&&(t=r[0])}else console.error("target is not a cc.SkinnedMeshRenderer");return t}getRootBindPose(e){let t=null;if(e instanceof cc_1.SkinnedMeshRenderer){let r=e.skeleton;r&&(t=r.bindposes[0])}else console.error("target is not a cc.SkinnedMeshRenderer");return t}getCameraData(e){let t=null;return e instanceof cc_1.Camera?(t={},e.ortho?t.projection=this.ProjectionType.ORTHO:t.projection=this.ProjectionType.PERSPECTIVE,t.orthoHeight=e.orthoSize,t.fov=e.fov,t.aspect=cc.winSize.width/cc.winSize.height,t.near=e.nearClip,t.far=e.farClip):console.error("target is not a cc.Camera"),t}setCameraData(e,t){e instanceof cc_1.Camera?(t.fov&&(e.fov=t.fov),t.far&&(e.farClip=t.far),t.orthoHeight&&(e.orthoSize=t.orthoHeight)):console.error("target is not a cc.Camera")}getLightData(e){let t=null;return e instanceof cc_1.Light?((t={}).type=e.type,t.range=e.range,t.spotAngle=e.spotAngle):console.error("target is not a cc.Light"),t}setLightData(e,t){e instanceof cc_1.Light?(t.range&&(e.range=t.range),t.spotAngle&&(e.spotAngle=t.spotAngle)):console.error("target is not a cc.Light")}}module.exports=new Engine2D;