"use strict";var __importDefault=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(exports,"__esModule",{value:!0}),exports.Engine2D=void 0;const controller_shape_collider_1=require("../../3d/elements/utils/controller-shape-collider"),external_1=__importDefault(require("../external")),cc_1=require("cc"),aabb=external_1.default.GeometryUtils.aabb,gfx=cc.gfx;function setMatColor(e,t){const o=e.getComponent(cc_1.MeshRenderer);if(o){const e=o.sharedMaterials[0];e&&e.setProperty("color",t)}}const ProjectionType={ORTHO:0,PERSPECTIVE:1};class Engine2D{constructor(){this.gfx=null,this.CullMode=null,this.AttributeName=null,this.PrimitiveMode=null,this.LightType=null,this.ProjectionType=null,this.gfx=gfx,this.CullMode={NONE:gfx.CULL_NONE,BACK:gfx.CULL_BACK,FRONT:gfx.CULL_FRONT},this.AttributeName={POSITION:gfx.ATTR_POSITION,NORMAL:gfx.ATTR_NORMAL,UV:gfx.ATTR_UV},this.PrimitiveMode={TRIANGLE_LIST:gfx.PT_TRIANGLES,POINT_LIST:gfx.PT_POINTS,LINE_LIST:gfx.PT_LINES,LINE_STRIP:gfx.PT_LINE_STRIP,LINE_LOOP:gfx.PT_LINE_LOOP,TRIANGLE_STRIP:gfx.PT_TRIANGLE_STRIP,TRIANGLE_FAN:gfx.PT_TRIANGLE_FAN},this.LightType={DIRECTIONAL:cc_1.Light.Type.DIRECTIONAL,SPHERE:cc_1.Light.Type.SPHERE,SPOT:cc_1.Light.Type.SPOT},this.ProjectionType=ProjectionType}raycast(e,t,o,r,n){throw new Error("Method not implemented.")}setMaterialProperty(e,t,o){throw new Error("Method not implemented.")}updateBoundingBox(e,t,o){throw new Error("Method not implemented.")}create3DNode(e){const t=new cc.Node(e);return t.is3DNode=!0,t.objFlags|=cc.Object.Flags.DontSave|cc.Object.Flags.HideInHierarchy,t}createMesh(e){const t=new cc.Mesh,o=new gfx.VertexFormat([{name:gfx.ATTR_POSITION,type:gfx.ATTR_TYPE_FLOAT32,num:3},{name:gfx.ATTR_NORMAL,type:gfx.ATTR_TYPE_FLOAT32,num:3}]);return t.init(o,e.positions.length,!0),t.setVertices(gfx.ATTR_POSITION,e.positions),e.normals&&t.setVertices(gfx.ATTR_NORMAL,e.normals),t.setIndices(e.indices),e.minPos&&(t._minPos=e.minPos),e.maxPos&&(t._maxPos=e.maxPos),void 0!==e.primitiveType&&t.setPrimitiveType(e.primitiveType),t}addMeshToNode(e,t,o={}){const r=e.addComponent(cc_1.MeshRenderer);r.mesh=t;const n=new cc.Material;if(o.unlit?(n.effectName="__builtin-editor-gizmo-unlit",n.effect&&n.effect.getTechnique("transparent").passes[0].setDepth(!1)):t.subMeshes[0]._primitiveType<gfx.PT_TRIANGLES?o.noDepthTestForLines?(n.effectName="__builtin-editor-gizmo-unlit",n.effect&&n.effect.getTechnique("transparent").passes[0].setDepth(!1)):n.effectName="__builtin-editor-gizmo-line":n.effectName="__builtin-editor-gizmo",n.setProperty("color",e._color),n.effect){const e=n.effect.getTechnique("transparent").passes[0];o.cullMode&&e.setCullMode(o.cullMode)}r.setMaterial(0,n)}setMeshColor(e,t){e.color=t;const o=t.clone();o.a=e.opacity,setMatColor(e,o)}getMeshColor(e){return e.color}setNodeOpacity(e,t){e.opacity=t;const o=e.color;o.a=t,setMatColor(e,o)}getNodeOpacity(e){return e.opacity}getRaycastResults(e,t,o){const r=cc.v3(t,o,1),n=cc.geomUtils.intersect.raycast(e,r,(e,t,o)=>{const r=t.getComponent(controller_shape_collider_1.ControllerShapeCollider);if(r&&r.isDetectMesh){const o=t.getComponent(cc_1.MeshRenderer),r=o.mesh._subMeshes;if(o&&o.mesh&&r&&r[0]._primitiveType===gfx.PT_TRIANGLES)return cc.geomUtils.intersect.rayMesh(e,o.mesh)}return o},function(e){return null!=e.getComponent(cc_1.MeshRenderer)&&!1!==e.active});return n.ray=r,n}getModel(e){return e.getComponent(cc_1.MeshRenderer)}updateVBAttr(e,t,o){e.setVertices(t,o)}updateIB(e,t){}getBoundingBox(e){let t=null;if(e instanceof cc_1.MeshRenderer){const o=e.mesh;o&&(t=aabb.fromPoints(aabb.create(),o._minPos,o._maxPos))}else console.error("target is not a cc.MeshRenderer");return t}getRootBoneNode(e){let t=null;if(e instanceof cc_1.SkinnedMeshRenderer){const o=e._joints;o&&o.length>0&&(t=o[0])}else console.error("target is not a cc.SkinnedMeshRenderer");return t}getRootBindPose(e){let t=null;if(e instanceof cc_1.SkinnedMeshRenderer){const o=e.skeleton;o&&(t=o.bindposes[0])}else console.error("target is not a cc.SkinnedMeshRenderer");return t}getCameraData(e){let t=null;if(e instanceof cc_1.Camera){t={},e.ortho?t.projection=this.ProjectionType.ORTHO:t.projection=this.ProjectionType.PERSPECTIVE,t.orthoHeight=e.orthoSize,t.fov=e.fov;const o=cc.view.getDesignResolutionSize();t.aspect=o.width/o.height,t.near=e.nearClip,t.far=e.farClip}else console.error("target is not a cc.Camera");return t}setCameraData(e,t){e instanceof cc_1.Camera?(t.fov&&(e.fov=t.fov),t.far&&(e.farClip=t.far),t.orthoHeight&&(e.orthoSize=t.orthoHeight)):console.error("target is not a cc.Camera")}getLightData(e){let t=null;return e instanceof cc_1.Light?((t={}).type=e.type,t.range=e.range,t.spotAngle=e.spotAngle):console.error("target is not a cc.Light"),t}setLightData(e,t){e instanceof cc_1.Light?(t.range&&(e.range=t.range),t.spotAngle&&(e.spotAngle=t.spotAngle)):console.error("target is not a cc.Light")}}exports.Engine2D=Engine2D,exports.default=new Engine2D;