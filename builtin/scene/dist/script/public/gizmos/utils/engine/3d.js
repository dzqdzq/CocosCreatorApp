"use strict";var __importDefault=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(exports,"__esModule",{value:!0}),exports.Engine3D=exports.HighlightFace=void 0;const cc_1=require("cc"),raycast_1=__importDefault(require("../../../../utils/raycast")),external_1=__importDefault(require("../external")),aabb=external_1.default.GeometryUtils.aabb,CameraTool=external_1.default.EditorCamera,flat=(e,t)=>e.map(t).reduce((e,t)=>e.concat(t),[]),cmp=(e,t)=>e.distance-t.distance,ray=cc_1.geometry.Ray.create(),triangles=cc_1.gfx.PrimitiveMode.TRIANGLE_LIST;function setNodeMaterialProperty(e,t,o){e&&e.modelComp&&e.modelComp.material&&e.modelComp.material.setProperty(t,o)}const vbMap=new Map,ibMap=new Map;var HighlightFace;!function(e){e[e.NONE=0]="NONE",e[e.UP=1]="UP",e[e.DOWN=2]="DOWN",e[e.LEFT=3]="LEFT",e[e.RIGHT=4]="RIGHT",e[e.FRONT=5]="FRONT",e[e.BACK=6]="BACK"}(HighlightFace=exports.HighlightFace||(exports.HighlightFace={}));class Engine3D{static createInstance(){var e;return null!==(e=this.instance)&&void 0!==e?e:new Engine3D}constructor(){Engine3D.instance=this,this.panPlaneLayer=cc_1.Layers.Enum.EDITOR,this.CullMode=cc_1.gfx.CullMode,this.AttributeName=cc_1.gfx.AttributeName,this.PrimitiveMode=cc_1.gfx.PrimitiveMode,this.LightType=cc_1.Light.Type,this.ProjectionType=cc_1.Camera.ProjectionType,this.FOVAxis=cc_1.Camera.FOVAxis}create3DNode(e){const t=new cc.Node(e);return t._layer=cc.Layers.Enum.GIZMOS,t.modelColor=cc.color(),t}createMesh(e,t={}){const o={primitiveMode:e.primitiveType,positions:flat(e.positions,e=>[e.x,e.y,e.z]),indices:e.indices,minPos:e.minPos,maxPos:e.maxPos};e.normals&&(o.normals=flat(e.normals,e=>[e.x,e.y,e.z])),e.uvs&&(o.uvs=flat(e.uvs,e=>[e.x,e.y]));let r=o.customAttributes;if(t.dashed){r||(r=[]);const t=[];for(let o=0;o<e.positions.length;o+=2){const r=e.positions[o],s=e.positions[o+1];t[o]=0===o?0:t[o-1],t[o+1]=t[o]+cc_1.Vec3.distance(r,s)}r.push({attr:new cc_1.gfx.Attribute("a_lineDistance",cc_1.gfx.Format.R32F),values:t})}o.customAttributes=r;const s=cc_1.utils.createMesh(o),n=s.renderingSubMeshes[0],a=n.geometricInfo;a&&(a.doubleSided=e.doubleSided);const i=s.struct.vertexBundles[0].view;i&&(n.vBuffer=s.data.buffer.slice(i.offset,i.offset+i.length),vbMap.set(n,n.vBuffer));const c=s.struct.primitives[0].indexView;return c&&(n.iBuffer=s.data.buffer.slice(c.offset,c.offset+c.length),ibMap.set(n,n.iBuffer)),s}transformToDynamicGeometry(e){var t;return{primitiveMode:e.primitiveType,positions:Float32Array.from(flat(e.positions,e=>[e.x,e.y,e.z])),indices32:Uint32Array.from(null!==(t=e.indices)&&void 0!==t?t:[]),minPos:e.minPos,maxPos:e.maxPos}}createDynamicMesh(e,t){const o=e.transformToDynamicGeometry();e.normals&&(o.normals=Float32Array.from(flat(e.normals,e=>[e.x,e.y,e.z]))),e.uvs&&(o.uvs=Float32Array.from(flat(e.uvs,e=>[e.x,e.y])));let r=o.customAttributes;if(null===t||void 0===t?void 0:t.dashed){r||(r=[]);const t=[];for(let o=0;o<e.positions.length;o+=2){const r=e.positions[o],s=e.positions[o+1];t[o]=0===o?0:t[o-1],t[o+1]=t[o]+cc_1.Vec3.distance(r,s)}r.push({attr:new cc_1.gfx.Attribute("a_lineDistance",cc_1.gfx.Format.R32F),values:Float32Array.from(t)})}o.customAttributes=r;const s=cc_1.utils.MeshUtils.createDynamicMesh(0,o,void 0,t),n=s.renderingSubMeshes[0],a=n.geometricInfo;a&&(a.doubleSided=e.doubleSided);const i=s.struct.vertexBundles[0].view;i&&(n.vBuffer=s.data.buffer.slice(i.offset,i.offset+i.length),vbMap.set(n,n.vBuffer));const c=s.struct.primitives[0].indexView;return c&&(n.iBuffer=s.data.buffer.slice(c.offset,c.offset+c.length),ibMap.set(n,n.iBuffer)),s}updateDynamicMesh(e,t,o){var r;const s=o.transformToDynamicGeometry();null===(r=e.mesh)||void 0===r||r.updateSubMesh(t,s)}addMeshToNode(e,t,o={},r){const s=e.addComponent(cc_1.MeshRenderer),n={};o.forwardPipeline&&(n.USE_FORWARD_PIPELINE=!0),o.dashed&&(n.USE_DASHED_LINE=!0),o.instancing&&(n.USE_INSTANCING=!0),o.useLightProbe&&(n.CC_USE_LIGHT_PROBE=!0),s.mesh=t;const a=s.onEnable.bind(s);s.onEnable=(()=>{a()});const i=t.renderingSubMeshes[0].primitiveMode;let c=0,l="internal/editor/gizmo";o.effectName?l=o.effectName:c=o.technique?o.technique:o.unlit?1:o.texture?3:i<triangles?o.noDepthTestForLines?1:2:o.depthTestForTriangles?4:0;const d=null!==r&&void 0!==r?r:new cc_1.Material,u={};o.cullMode&&(u.rasterizerState={cullMode:o.cullMode}),i!==triangles&&(u.primitive=i),o.priority&&(u.priority=o.priority),0===d.hash&&d.initialize({effectName:l,technique:c,states:u,defines:n}),void 0!==o.alpha&&e.modelColor&&(e.modelColor.a=o.alpha),d.setProperty("mainColor",e.modelColor),s.material=d,e.modelComp=s}setMeshSHCoefficients(e,t){const o=new cc_1.Vec4,r=["cc_sh_linear_const_r","cc_sh_linear_const_g","cc_sh_linear_const_b","cc_sh_quadratic_r","cc_sh_quadratic_g","cc_sh_quadratic_b","cc_sh_quadratic_a"];for(let s=0;s<r.length;s++){const n=4*s;o.set(t[n],t[n+1],t[n+2],t[n+3]),setNodeMaterialProperty(e,r[s],o)}}setMeshColor(e,t){let o=t.a;e.modelColor&&(o=e.modelColor.a),e.modelColor=t.clone(),e.modelColor.a=o,setNodeMaterialProperty(e,"mainColor",e.modelColor)}getMeshColor(e){return e.modelColor}setNodeOpacity(e,t){e.modelColor&&(e.modelColor.a=t),setNodeMaterialProperty(e,"mainColor",e.modelColor)}getNodeOpacity(e){var t,o;return null!==(o=null===(t=e.modelColor)||void 0===t?void 0:t.a)&&void 0!==o?o:0}setMaterialProperty(e,t,o){setNodeMaterialProperty(e,t,o)}getRaycastResults(e,t,o,r=1/0,s){const n=e.scene.renderScene,a=CameraTool.camera.camera;null===a||void 0===a||a.screenPointToRay(ray,t,o);let i=[];return raycast_1.default.raycastAllModels(n,ray,e._layer,r,!1,s)&&(i=raycast_1.default.rayResultModels).sort(cmp),i.ray=ray,i}getRaycastResultsByNodes(e,t,o,r=1/0,s,n){let a=[];const i=CameraTool.camera.camera;null===i||void 0===i||i.screenPointToRay(ray,t,o);const c=(e,t)=>{e.getComponents(cc_1.MeshRenderer).forEach(e=>t(e)),e.children.length>0&&e.children.forEach(e=>{c(e,t)})};return e.forEach(e=>{c(e,t=>{t.model&&raycast_1.default.raycastSingleModel(ray,t.model,e._layer,r,s,n)&&((a=a.concat(raycast_1.default.rayResultSingleModel)).sort(cmp),a.ray=ray)})}),a}raycast(e,t,o,r,s,n=1/0,a){if(!t.enabled)return null;t.screenPointToRay(ray,r,s);let i=[];return raycast_1.default.raycastAllModels(e,ray,o,n,!1,a)&&(i=raycast_1.default.rayResultModels).sort(cmp),i.ray=ray,i}raycastAllColliders(e,t,o){let r=[];return e.enabled?(e.screenPointToRay(ray,t,o),raycast_1.default.raycastAllColliders(ray)&&(r=raycast_1.default.raycastColliderResults).sort(cmp),r.ray=ray,r):r}getModel(e){return e.getComponent(cc_1.MeshRenderer)}updatePositions(e,t){const o=e.model&&e.model.subModels[0];if(!o||!o.inputAssembler||!o.subMesh)return;const{subMesh:r}=o,s=flat(t,e=>[e.x,e.y,e.z]);Engine3D.instance.updateVBAttr(e,cc_1.gfx.AttributeName.ATTR_POSITION,s),r.geometricInfo&&(r.geometricInfo.positions.length>=s.length?r.geometricInfo.positions.set(s):r.geometricInfo.positions=new Float32Array(s))}updateVBAttr(e,t,o){const r=e.model&&e.model.subModels[0];if(!r||!r.inputAssembler||!r.subMesh)return;const{inputAssembler:s,subMesh:n}=r;let a=n.vBuffer,i=0,c=cc_1.gfx.Format.UNKNOWN;for(const e of s.attributes){if(e.name===t){c=e.format;break}i+=cc_1.gfx.FormatInfos[e.format].size}const l=s.vertexBuffers[0];if(!c||!l)return;const d=l.stride*o.length/cc_1.gfx.FormatInfos[c].count;a.byteLength<d&&(a=new ArrayBuffer(d),vbMap.set(n,a),l.resize(d)),cc_1.utils.writeBuffer(new DataView(a),o,c,i,l.stride),l.update(a)}updateIB(e,t){const o=e.model&&e.model.subModels[0];if(!o||!o.inputAssembler||!o.subMesh)return;const{inputAssembler:r,subMesh:s}=o;let n=ibMap.get(s);const a=r.indexBuffer;if(a)if(r.indexCount===t.length)new Uint16Array(n).set(t),a.update(n),s.geometricInfo&&s.geometricInfo.indices&&s.geometricInfo.indices.set(t);else{const e=t.length*a.stride;if(e>n.byteLength&&(n=new ArrayBuffer(e),ibMap.set(s,n),a.resize(e)),new Uint16Array(n).set(t),a.update(n),r.indexCount=t.length,s.geometricInfo&&s.geometricInfo.indices){const e=new Uint16Array(t);s.geometricInfo.indices=e}}}updateBoundingBox(e,t,o){const r=e.model;r&&r.createBoundingShape(t,o)}getBoundingBox(e){var t;let o=null;if(e instanceof cc_1.MeshRenderer){if(e instanceof cc_1.SkinnedMeshRenderer)o=e.model&&e.model.worldBounds;else if(!(o=e.model&&e.model.modelBounds)){const t=e.mesh;t&&t.minPosition&&t.maxPosition&&(o=aabb.fromPoints(aabb.create(),t.minPosition,t.maxPosition))}}else if(e instanceof cc_1.SpriteRenderer){if(!(o=e.model&&e.model.modelBounds)){const r=null===(t=e.spriteFrame)||void 0===t?void 0:t.mesh;r&&r.struct.minPosition&&r.struct.maxPosition&&(o=aabb.fromPoints(aabb.create(),r.struct.minPosition,r.struct.maxPosition))}}else console.error("target is not a cc.MeshRenderer");return o}getRootBoneNode(e){let t=null;return e instanceof cc_1.SkinnedMeshRenderer?t=e.skinningRoot:console.error("target is not a cc.SkinnedMeshRenderer"),t}getRootBindPose(e){let t=null;if(e instanceof cc_1.SkinnedMeshRenderer){const o=e.skinningRoot,r=e.skeleton;if(o&&r){const e=r.joints.findIndex(e=>""===e);void 0!==e&&(t=r.bindposes[e])}}else console.error("target is not a cc.SkinnedMeshRenderer");return t}getCameraData(e){let t=null;if(e instanceof cc_1.Camera){(t={}).projection=e.projection,t.orthoHeight=e.orthoHeight,t.fov=e.fov;const o=e.camera?e.camera.width:800,r=e.camera?e.camera.height:600;t.aspect=o/r,t.near=e.near,t.far=e.far,t.fovAxis=e.fovAxis}else console.error("target is not a cc.Camera");return t}setCameraData(e,t){e instanceof cc_1.Camera?(t.fov&&(e.fov=t.fov),t.far&&(e.far=t.far),t.orthoHeight&&(e.orthoHeight=t.orthoHeight)):console.error("target is not a cc.Camera")}getLightData(e){let t=null;return e instanceof cc_1.Light?((t={}).type=e.type,t.range=e.range,t.spotAngle=e.spotAngle):console.error("target is not a cc.Light"),t}setLightData(e,t){e instanceof cc_1.Light?(t.range&&(e.range=t.range),t.spotAngle&&(e.spotAngle=t.spotAngle)):console.error("target is not a cc.Light")}}exports.Engine3D=Engine3D,exports.default=Engine3D.createInstance();