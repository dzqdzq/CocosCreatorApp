"use strict";var __importDefault=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(exports,"__esModule",{value:!0});const external_1=__importDefault(require("../external")),aabb=external_1.default.GeometryUtils.aabb,CameraTool=external_1.default.EditorCamera,cc_1=require("cc"),raycast_1=__importDefault(require("../../../../utils/raycast")),flat=(e,t)=>e.map(t).reduce((e,t)=>e.concat(t),[]),cmp=(e,t)=>e.distance-t.distance,ray=cc_1.geometry.Ray.create(),triangles=cc_1.gfx.PrimitiveMode.TRIANGLE_LIST;function setNodeMaterialProperty(e,t,o){e&&e.modelComp&&e.modelComp.material.setProperty(t,o)}class Engine3D{constructor(){this.panPlaneLayer=null,this.CullMode=null,this.AttributeName=null,this.PrimitiveMode=null,this.LightType=null,this.ProjectionType=null,this.FOVAxis=null,this.panPlaneLayer=cc.Layers.Enum.EDITOR,this.CullMode={NONE:cc_1.gfx.CullMode.NONE,BACK:cc_1.gfx.CullMode.BACK,FRONT:cc_1.gfx.CullMode.FRONT},this.AttributeName={POSITION:cc_1.gfx.AttributeName.ATTR_POSITION,NORMAL:cc_1.gfx.AttributeName.ATTR_NORMAL,UV:cc_1.gfx.AttributeName.ATTR_TEX_COORD},this.PrimitiveMode={TRIANGLE_LIST:cc_1.gfx.PrimitiveMode.TRIANGLE_LIST,POINT_LIST:cc_1.gfx.PrimitiveMode.POINT_LIST,LINE_LIST:cc_1.gfx.PrimitiveMode.LINE_LIST,LINE_STRIP:cc_1.gfx.PrimitiveMode.LINE_STRIP,LINE_LOOP:cc_1.gfx.PrimitiveMode.LINE_LOOP,TRIANGLE_STRIP:cc_1.gfx.PrimitiveMode.TRIANGLE_STRIP,TRIANGLE_FAN:cc_1.gfx.PrimitiveMode.TRIANGLE_FAN},this.LightType={DIRECTIONAL:cc_1.Light.Type.DIRECTIONAL,SPHERE:cc_1.Light.Type.SPHERE,SPOT:cc_1.Light.Type.SPOT},this.ProjectionType={ORTHO:cc_1.Camera.ProjectionType.ORTHO,PERSPECTIVE:cc_1.Camera.ProjectionType.PERSPECTIVE},this.FOVAxis={VERTICAL:cc_1.Camera.FOVAxis.VERTICAL,HORIZONTAL:cc_1.Camera.FOVAxis.HORIZONTAL}}create3DNode(e){const t=new cc.Node(e);return t._layer=cc.Layers.Enum.GIZMOS,t.modelColor=cc.color(),t}createMesh(e,t={}){let o={primitiveMode:e.primitiveType,positions:flat(e.positions,e=>[e.x,e.y,e.z]),indices:e.indices,minPos:e.minPos,maxPos:e.maxPos};e.normals&&(o.normals=flat(e.normals,e=>[e.x,e.y,e.z])),e.uvs&&(o.uvs=flat(e.uvs,e=>[e.x,e.y]));let r=o.customAttributes;if(t.dashed){r||(r=[]);let t=[];for(let o=0;o<e.positions.length;o+=2){let r=e.positions[o],i=e.positions[o+1];t[o]=0===o?0:t[o-1],t[o+1]=t[o]+cc_1.Vec3.distance(r,i)}r.push({attr:new cc_1.gfx.Attribute("a_lineDistance",cc_1.gfx.Format.R32F),values:t})}o.customAttributes=r;const i=cc.utils.createMesh(o),n=i.renderingSubMeshes[0],s=n.geometricInfo;s&&(s.doubleSided=e.doubleSided);const a=i.struct.vertexBundles[0].view;a&&(n.vBuffer=i.data.buffer.slice(a.offset,a.offset+a.length));const c=i.struct.primitives[0].indexView;return c&&(n.iBuffer=i.data.buffer.slice(c.offset,c.offset+c.length)),i}addMeshToNode(e,t,o={}){const r=e.addComponent(cc_1.MeshRenderer),i={};o.forwardPipeline&&(i.USE_FORWARD_PIPELINE=!0),o.dashed&&(i.USE_DASHED_LINE=!0),r.mesh=t;const n=r.onEnable.bind(r);r.onEnable=(()=>{n()});const s=t.renderingSubMeshes[0].primitiveMode;let a=0,c="editor/gizmo";o.effectName?c=o.effectName:o.unlit?a=1:o.texture?a=3:s<triangles&&(a=o.noDepthTestForLines?1:2);const l=new cc.Material,d={};o.cullMode&&(d.rasterizerState={cullMode:o.cullMode}),s!==triangles&&(d.primitive=s),o.priority&&(d.priority=o.priority),l.initialize({effectName:c,technique:a,states:d,defines:i}),void 0!==o.alpha&&(e.modelColor.a=o.alpha),l.setProperty("mainColor",e.modelColor),r.material=l,e.modelComp=r}setMeshColor(e,t){let o=t.a;e.modelColor&&(o=e.modelColor.a),e.modelColor=t.clone(),e.modelColor.a=o,setNodeMaterialProperty(e,"mainColor",e.modelColor)}getMeshColor(e){return e.modelColor}setNodeOpacity(e,t){e.modelColor.a=t,setNodeMaterialProperty(e,"mainColor",e.modelColor)}getNodeOpacity(e){return e.modelColor.a}setMaterialProperty(e,t,o){setNodeMaterialProperty(e,t,o)}getRaycastResults(e,t,o){const r=e.scene.renderScene;CameraTool.camera.camera.screenPointToRay(ray,t,o);let i=[];return raycast_1.default.raycastAllModels(r,ray,e._layer)&&(i=raycast_1.default.rayResultModels).sort(cmp),i.ray=ray,i}raycast(e,t,o,r,i){if(!t.enabled)return null;t.screenPointToRay(ray,r,i);let n=[];return raycast_1.default.raycastAllModels(e,ray,o)&&(n=raycast_1.default.rayResultModels).sort(cmp),n.ray=ray,n}getModel(e){return e.getComponent(cc_1.MeshRenderer)}updatePositions(e,t){const o=e.model&&e.model.subModels[0];if(!o||!o.inputAssembler||!o.subMesh)return;const{subMesh:r}=o,i=flat(t,e=>[e.x,e.y,e.z]);module.exports.updateVBAttr(e,cc_1.gfx.AttributeName.ATTR_POSITION,i),r.geometricInfo&&(r.geometricInfo.positions.length>=i.length?r.geometricInfo.positions.set(i):r.geometricInfo.positions=new Float32Array(i))}updateVBAttr(e,t,o){const r=e.model&&e.model.subModels[0];if(!r||!r.inputAssembler||!r.subMesh)return;const{inputAssembler:i,subMesh:n}=r;let s=n.vBuffer,a=0,c=cc_1.gfx.Format.UNKNOWN;for(const e of i.attributes){if(e.name===t){c=e.format;break}a+=cc_1.gfx.FormatInfos[e.format].size}const l=i.vertexBuffers[0];if(!c||!l)return;let d=l.stride*o.length/cc_1.gfx.FormatInfos[c].count;s.byteLength<d&&(s=n.vBuffer=new ArrayBuffer(d),l.resize(d)),cc_1.utils.writeBuffer(new DataView(s),o,c,a,l.stride),l.update(s)}updateIB(e,t){const o=e.model&&e.model.subModels[0];if(!o||!o.inputAssembler||!o.subMesh)return;const{inputAssembler:r,subMesh:i}=o;let n=i.iBuffer;const s=r.indexBuffer;if(s)if(r.indexCount===t.length)new Uint16Array(n).set(t),s.update(n),i.geometricInfo&&i.geometricInfo.indices&&i.geometricInfo.indices.set(t);else{const e=t.length*s.stride;if(e>n.byteLength&&(n=i.iBuffer=new ArrayBuffer(e),s.resize(e)),new Uint16Array(n).set(t),s.update(n),r.indexCount=t.length,i.geometricInfo&&i.geometricInfo.indices){const e=new Uint16Array(t);i.geometricInfo.indices=e}}}updateBoundingBox(e,t,o){const r=e.model;if(!r)return;r.createBoundingShape(t,o);const i=r.mesh;i&&i.struct&&(i.struct.minPosition=t,i.struct.maxPosition=o)}getBoundingBox(e){let t=null;if(e instanceof cc_1.MeshRenderer){if(e instanceof cc_1.SkinnedMeshRenderer)t=e.model&&e.model.worldBounds;else if(!(t=e.model&&e.model.modelBounds)){const o=e.mesh;o&&o.minPosition&&o.maxPosition&&(t=aabb.fromPoints(aabb.create(),o.minPosition,o.maxPosition))}}else console.error("target is not a cc.MeshRenderer");return t}getRootBoneNode(e){let t=null;return e instanceof cc_1.SkinnedMeshRenderer?t=e.skinningRoot:console.error("target is not a cc.SkinnedMeshRenderer"),t}getRootBindPose(e){let t=null;if(e instanceof cc_1.SkinnedMeshRenderer){const o=e.skinningRoot,r=e.skeleton;if(o&&r){const e=r.joints.findIndex(e=>""===e);void 0!==e&&(t=r.bindposes[e])}}else console.error("target is not a cc.SkinnedMeshRenderer");return t}getCameraData(e){let t=null;if(e instanceof cc_1.Camera){(t={}).projection=e.projection,t.orthoHeight=e.orthoHeight,t.fov=e.fov;const o=e.camera?e.camera.width:800,r=e.camera?e.camera.height:600;t.aspect=o/r,t.near=e.near,t.far=e.far,t.fovAxis=e.fovAxis}else console.error("target is not a cc.Camera");return t}setCameraData(e,t){e instanceof cc_1.Camera?(t.fov&&(e.fov=t.fov),t.far&&(e.far=t.far),t.orthoHeight&&(e.orthoHeight=t.orthoHeight)):console.error("target is not a cc.Camera")}getLightData(e){let t=null;return e instanceof cc_1.Light?((t={}).type=e.type,t.range=e.range,t.spotAngle=e.spotAngle):console.error("target is not a cc.Light"),t}setLightData(e,t){e instanceof cc_1.Light?(t.range&&(e.range=t.range),t.spotAngle&&(e.spotAngle=t.spotAngle)):console.error("target is not a cc.Light")}}module.exports=new Engine3D;