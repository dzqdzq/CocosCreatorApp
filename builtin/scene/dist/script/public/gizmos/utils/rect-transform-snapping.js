"use strict";var __importDefault=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(exports,"__esModule",{value:!0}),exports.rectTransformSnapping=exports.RectTransformSnapping=exports.SnapGuidelineGroup=exports.SnapGuideline=void 0;const cc_1=require("cc"),node_1=__importDefault(require("../../../utils/node"));class SnapGuideline{constructor(e,i,n){this.lineVertices=[],this.value=e,this.axis=i,this.lineVertices=n}}exports.SnapGuideline=SnapGuideline;class SnapGuidelineGroup{constructor(){this.currentGuidelines=[],this.guidelines=new Map}clear(){this.guidelines.clear()}addGuideline(e){let i=[];this.guidelines.has(e.value)?i=this.guidelines.get(e.value):this.guidelines.set(e.value,i),i.push(e)}snapToGuidelines(e,i){const n=this.guidelines.keys();if(this.guidelines.size<=0)return e;let t,s=Number.MAX_VALUE;for(const i of n){const n=Math.abs(e-i);n<s&&(t=i,s=n)}return void 0!==t&&s<=i&&(e=t,this.currentGuidelines=this.currentGuidelines.concat(this.guidelines.get(t))),e}}exports.SnapGuidelineGroup=SnapGuidelineGroup;class RectTransformSnapping{constructor(){this.enableSnapping=!0,this.enableGridSnapping=!0,this.snapThreshold=4,this.nodeSnapGuidelineGroups=[new SnapGuidelineGroup,new SnapGuidelineGroup],this.sidesAndMiddle=[0,.5,1],this.guidelineColor=new cc.Color(255,71,0),this.canvasSnapColor=new cc.Color(255,190,75),this.canvasSnapGuidelineGroups=[new SnapGuidelineGroup,new SnapGuidelineGroup],this.shapeInfos=[],this.currentMatchMinDistInfos=[],this.gridSpacingX=100,this.gridSpacingY=100,this.gridColor=cc.Color.GRAY,this.gridSnapGuidelineGroups=[new SnapGuidelineGroup,new SnapGuidelineGroup]}getPureDataObject(){return{enableSnapping:this.enableSnapping,snapThreshold:this.snapThreshold}}initFromData(e){this.enableSnapping=e.enableSnapping,this.snapThreshold=e.snapThreshold}lerp(e,i,n){return e+(i-e)*n}getWorldRectEx(e){const i=node_1.default.getWorldBounds(e);return{minPos:new cc.Vec3(i.x,i.y,0),maxPos:new cc.Vec3(i.x+i.width,i.y+i.height,0),center:new cc.Vec3(i.x+i.width/2,i.y+i.height/2,0),width:i.width,height:i.height}}snapToGuidelinesOnAxis(e,i,n,t){return("x"===t?e[0]:e[1]).snapToGuidelines(i,n)}getNodeGuidelinePos(e,i,n){const t=[cc.v3(),cc.v3()];let s="x";"x"===i?s="y":"y"===i&&(s="x");const o=this.getWorldRectEx(e),a=o.minPos,r=o.maxPos;return t[0][s]=a[s],t[1][s]=r[s],t[0][i]=this.lerp(a[i],r[i],n),t[1][i]=t[0][i],t}getNodeSnapGuidelines(e,i,n,t){const s=[];return e&&e.children.forEach(e=>{var o;if(e===i)return;const a=null===(o=e.getComponent(cc_1.UITransform))||void 0===o?void 0:o.contentSize;!a||a.width<=0||a.height<=0||(0===t?(s.push(new SnapGuideline(this.getWorldRectEx(e).minPos[n],n,this.getNodeGuidelinePos(e,n,0))),s.push(new SnapGuideline(this.getWorldRectEx(e).maxPos[n],n,this.getNodeGuidelinePos(e,n,1)))):1===t?s.push(new SnapGuideline(this.getWorldRectEx(e).center[n],n,this.getNodeGuidelinePos(e,n,.5))):2===t&&(s.push(new SnapGuideline(this.getWorldRectEx(e).maxPos[n],n,this.getNodeGuidelinePos(e,n,1))),s.push(new SnapGuideline(this.getWorldRectEx(e).minPos[n],n,this.getNodeGuidelinePos(e,n,0)))))}),s}clearCurrentNodeGuidelines(){this.nodeSnapGuidelineGroups[0].currentGuidelines=[],this.nodeSnapGuidelineGroups[1].currentGuidelines=[]}snapToNodeGuidelinesOnAxis(e,i,n){return this.snapToGuidelinesOnAxis(this.nodeSnapGuidelineGroups,e,i,n)}snapPosToNodeGuidelines(e,i,n){this.clearCurrentNodeGuidelines();const t=i.width/2,s=i.height/2,o=e.clone();return o.x=this.snapToNodeGuidelinesOnAxis(o.x-t,n.x,"x")+t,o.x=this.snapToNodeGuidelinesOnAxis(o.x+t,n.x,"x")-t,o.y=this.snapToNodeGuidelinesOnAxis(o.y-s,n.y,"y")+s,o.y=this.snapToNodeGuidelinesOnAxis(o.y+s,n.y,"y")-s,o.x=this.snapToNodeGuidelinesOnAxis(o.x,n.x,"x"),o.y=this.snapToNodeGuidelinesOnAxis(o.y,n.y,"y"),o}snapSizeToNodeGuidelines(e,i,n){return this.clearCurrentNodeGuidelines(),0!==i.x&&(i.x=this.snapToNodeGuidelinesOnAxis(e.x+i.x,n.x,"x")-e.x),0!==i.y&&(i.y=this.snapToNodeGuidelinesOnAxis(e.y+i.y,n.y,"y")-e.y),i}calculateNodeSnapGuidelines(e,i){for(let e=0;e<2;e++)this.nodeSnapGuidelineGroups[e].clear();if(!e)return;let n=[];const t=["x","y"];for(let s=0;s<2;s++)for(let o=0;o<this.sidesAndMiddle.length;o++)(n=this.getNodeSnapGuidelines(e,i,t[s],o)).forEach(e=>{e.checkNode=i,this.nodeSnapGuidelineGroups[s].addGuideline(e)})}generateWorldRect(e,i){const n=i.width/2,t=i.height/2;return{minPos:new cc.Vec3(e.x-n,e.y-t,e.z),maxPos:new cc.Vec3(e.x+n,e.y+t,e.z),center:e,width:i.width,height:i.height}}checkEqualSpacingOnSide(e,i,n){const t=e[i];if(!t||t.length<=0)return null;const s=[],o=t[0],a=o.minDist,r=o.targetShapeInfo,h=null===r||void 0===r?void 0:r.distInfo[i];let c=-1,d=0,u=0;return h&&h.length>0&&h.forEach(e=>{d=e.minDist-a,Math.abs(d)<=n&&(u=d,c=e.minDist,s.push(e))}),c>0?("right"!==i&&"top"!==i||(u=-u),{matchDist:c,matchDeltaDist:u,sideMinDistShapeInfo:r,matchSideDistInfos:s}):void 0}checkEqualSpacingOnAxis(e,i,n,t){let s=[],o=[],a=[];"x"===n?a=["left","right"]:"y"===n&&(a=["top","bottom"]);let r=!1,h=0;if(a.forEach(n=>{const a=this.checkEqualSpacingOnSide(e,n,t);a&&(r=!0,h=i+a.matchDeltaDist,s=a.matchSideDistInfos,o=[a.sideMinDistShapeInfo])}),!r){const s=e[a[0]],c=e[a[1]],d=s[0],u=c[0];if(d&&u){const e=(d.minDistPosA[n]+u.minDistPosB[n])/2;Math.abs(i-e)<=t&&(h=e,r=!0,o.push(d.targetShapeInfo,u.targetShapeInfo))}}return r?{newValue:h,matchDistInfos:s,matchShapeInfos:o}:null}snapPosToEqualSpacing(e,i,n){this.currentMatchMinDistInfos=[];const t=this.generateWorldRect(e,i),s=this.generateShapeInfo(t);for(let e=0;e<this.shapeInfos.length;e++){const i=this.shapeInfos[e],{distInfoA:n,distInfoB:t}=this.gatherDistInfo(s,i);this.concatDistInfo(s.distInfo,n)}const o=e.clone(),a=s.distInfo;function r(e,i){return e.minDist-i.minDist}const h=[],c=a.left,d=a.right,u=a.top,l=a.bottom;if(c.length>0||d.length>0){c.sort(r),d.sort(r);const e=this.checkEqualSpacingOnAxis(a,o.x,"x",n.x);e&&(o.x=e.newValue,this.currentMatchMinDistInfos.push(...e.matchDistInfos),h.push(...e.matchShapeInfos))}if(u.length>0&&u.length>0){u.sort(r),l.sort(r);const e=this.checkEqualSpacingOnAxis(a,o.y,"y",n.y);e&&(o.y=e.newValue,this.currentMatchMinDistInfos.push(...e.matchDistInfos),h.push(...e.matchShapeInfos))}const p=this.generateWorldRect(o,i);return h.forEach(e=>{if(!e)return;const i=this.getDistInfoOfRect(p,e.worldRect);i&&this.currentMatchMinDistInfos.push(i)}),o}calculateSpacingSnapGuidelines(e,i){const n=this.gatherShapeInfos(e,i);if(n){for(let e=0;e<n.length-1;e++){const i=n[e];for(let t=e;t<n.length;t++){const e=n[t],{distInfoA:s,distInfoB:o}=this.gatherDistInfo(i,e);this.concatDistInfo(i.distInfo,s),this.concatDistInfo(e.distInfo,o)}}this.shapeInfos=n}}gatherDistInfo(e,i){const n=e.worldRect,t=i.worldRect,s={left:[],right:[],top:[],bottom:[]},o={left:[],right:[],top:[],bottom:[]},a=this.getDistInfoOfRect(n,t);if(a){const r=Object.assign({targetShapeInfo:i},a),h=Object.assign({targetShapeInfo:e},a);"x"===a.axis?n.center.x>t.center.x?(s.left.push(r),o.right.push(h)):(s.right.push(r),o.left.push(h)):"y"===a.axis&&(n.center.y>t.center.y?(s.bottom.push(r),o.top.push(h)):(s.top.push(r),o.bottom.push(h)))}return{distInfoA:s,distInfoB:o}}concatDistInfo(e,i){e.left=e.left.concat(i.left),e.right=e.right.concat(i.right),e.top=e.top.concat(i.top),e.bottom=e.bottom.concat(i.bottom)}gatherShapeInfos(e,i){const n=[];return e?(e.children.forEach((e,t)=>{var s;if(e===i)return;const o=null===(s=e.getComponent(cc_1.UITransform))||void 0===s?void 0:s.contentSize;if(!o||o.width<=0||o.height<=0)return;const a=this.getWorldRectEx(e);n.push(this.generateShapeInfo(a))}),n):null}generateShapeInfo(e){return{worldRect:e,distInfo:{left:[],right:[],top:[],bottom:[]}}}getDistInfoOfRect(e,i){let n,t,s=-1,o="x";const a=e.center,r=i.center,h=Math.abs(a.x-r.x),c=Math.abs(a.y-r.y);function d(e,i){return e-i}if(h<(e.width+i.width)/2&&c>=(e.height+i.height)/2){s=c-(e.height+i.height)/2;let h=e,u=i;a.y<r.y&&(h=i,u=e);const l=[h.minPos.x,h.minPos.x+h.width,u.maxPos.x,u.maxPos.x-u.width];l.sort(d);const p=(l[1]+l[2])/2;n=new cc.Vec3(p,h.minPos.y,0),t=new cc.Vec3(p,u.maxPos.y,0),o="y"}else if(h>=(e.width+i.width)/2&&c<(e.height+i.height)/2){s=h-(e.width+i.width)/2;let c=e,u=i;a.x>r.x&&(c=i,u=e);const l=[c.maxPos.y,c.maxPos.y-c.height,u.minPos.y,u.minPos.y+u.height];l.sort(d);const p=(l[1]+l[2])/2;n=new cc.Vec3(c.maxPos.x,p,0),t=new cc.Vec3(u.minPos.x,p,0),o="x"}return s>0?{minDist:s,minDistPosA:n,minDistPosB:t,axis:o}:null}calculateGridSnapGuidelines(){const e=cc.engine.getDesignResolutionSize();for(let i=0;i<e.width;i+=this.gridSpacingX){const n=new cc.Vec2(i,0),t=new cc.Vec2(i,e.height),s=new SnapGuideline(i,"x",[n,t]);this.gridSnapGuidelineGroups[0].addGuideline(s)}for(let i=0;i<e.height;i+=this.gridSpacingY){const n=new cc.Vec2(0,i),t=new cc.Vec2(e.width,i),s=new SnapGuideline(i,"y",[n,t]);this.gridSnapGuidelineGroups[1].addGuideline(s)}}clearCurrentGridGuidelines(){this.gridSnapGuidelineGroups[0].currentGuidelines=[],this.gridSnapGuidelineGroups[1].currentGuidelines=[]}snapToGridGuidelinesOnAxis(e,i,n){return this.snapToGuidelinesOnAxis(this.gridSnapGuidelineGroups,e,i,n)}snapPosToGridSnapGuidelines(e,i,n){this.clearCurrentGridGuidelines();const t=i.width/2,s=i.height/2,o=e.clone();return o.x=this.snapToGridGuidelinesOnAxis(o.x-t,n.x,"x")+t,o.x=this.snapToGridGuidelinesOnAxis(o.x+t,n.x,"x")-t,o.y=this.snapToGridGuidelinesOnAxis(o.y-s,n.y,"y")+s,o.y=this.snapToGridGuidelinesOnAxis(o.y+s,n.y,"y")-s,o}snapSizeToGridGuidelines(e,i,n){return this.clearCurrentGridGuidelines(),0!==i.x&&(i.x=this.snapToGridGuidelinesOnAxis(e.x+i.x,n.x,"x")-e.x),0!==i.y&&(i.y=this.snapToGridGuidelinesOnAxis(e.y+i.y,n.y,"y")-e.y),i}calculateCanvasSnapGuidelines(){const e=cc.view.getDesignResolutionSize(),i=e.width/2,n=e.width,t=e.height/2,s=e.height;[0,i,n].forEach(i=>{this.canvasSnapGuidelineGroups[0].addGuideline(new SnapGuideline(i,"x",[new cc_1.Vec3(i,0),new cc_1.Vec3(i,e.height)]))}),[0,t,s].forEach(i=>{this.canvasSnapGuidelineGroups[1].addGuideline(new SnapGuideline(i,"x",[new cc_1.Vec3(0,i),new cc_1.Vec3(e.width,i)]))})}clearCurrentCanvasGuidelines(){this.canvasSnapGuidelineGroups[0].currentGuidelines=[],this.canvasSnapGuidelineGroups[1].currentGuidelines=[]}snapToCanvasSnapGuidelinesOnAxis(e,i,n){return this.snapToGuidelinesOnAxis(this.canvasSnapGuidelineGroups,e,i,n)}snapPosToCanvasSnapGuidelines(e,i,n){this.clearCurrentCanvasGuidelines();const t=i.width/2,s=i.height/2,o=e.clone();return o.x=this.snapToCanvasSnapGuidelinesOnAxis(o.x-t,n.x,"x")+t,o.x=this.snapToCanvasSnapGuidelinesOnAxis(o.x+t,n.x,"x")-t,o.y=this.snapToCanvasSnapGuidelinesOnAxis(o.y-s,n.y,"y")+s,o.y=this.snapToCanvasSnapGuidelinesOnAxis(o.y+s,n.y,"y")-s,o.x=this.snapToCanvasSnapGuidelinesOnAxis(o.x,n.x,"x"),o.y=this.snapToCanvasSnapGuidelinesOnAxis(o.y,n.y,"y"),o}}exports.RectTransformSnapping=RectTransformSnapping;const rectTransformSnapping=new RectTransformSnapping;exports.rectTransformSnapping=rectTransformSnapping;