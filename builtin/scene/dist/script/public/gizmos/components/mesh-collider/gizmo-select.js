"use strict";var __importDefault=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(exports,"__esModule",{value:!0});const cc_1=require("cc"),external_1=__importDefault(require("../../utils/external")),base_1=require("../base"),controller_mesh_1=__importDefault(require("./controller-mesh")),NodeUtils=external_1.default.NodeUtils,tempQuat_a=new cc_1.Quat;class MeshColliderGizmo extends base_1.SelectGizmo{_controller;init(){this._controller=new controller_mesh_1.default(this.getGizmoRoot())}onShow(){this.updateControllerData()}onHide(){this._controller.hide()}updateControllerData(){if(this._isInitialized&&null!==this.target&&this.target instanceof cc_1.MeshCollider){var e=this.target.node,t=NodeUtils.getWorldScale3D(e),r=NodeUtils.getWorldPosition3D(e),o=tempQuat_a,e=(NodeUtils.getWorldRotation3D(e,o),this._controller.setScale(t),this._controller.setPosition(r),this._controller.setRotation(o),this.target),t=e.mesh;if(t){this._controller.show();var r=this.calcMeshData(t),i=r.points,l=e.center;for(let e=0;e<i.length;e+=3)i[e]+=l.x,i[e+1]+=l.y,i[e+2]+=l.z;this._controller.updateData(i,r.indices)}else this._controller.hide()}}calcMeshData(t){let r=[],o=[];var i=t?.renderingSubMeshes.length;for(let e=0;e<i;e++){var l,s=t.renderingSubMeshes[e],a=s.geometricInfo;a&&(s=s.primitiveMode,l=a.positions,a=a.indices,l=this._generateWireFrameData(l,r.length/3,a,s))&&(r=r.concat(l.positions),o=o.concat(l.edgeIndices))}return{points:r,indices:o}}_generateWireFrameData(e,r,o,t){if(!o)return console.error("indexBuffer of mesh is undefined"),null;let i=[];var l=[];if(t===cc_1.gfx.PrimitiveMode.TRIANGLE_LIST){i=Array.from(e);var s=o.length/3;for(let e=0;e<s;e++){var a=o[3*e+0]+r,n=o[3*e+1]+r,c=o[3*e+2]+r;l.push(a,n,n,c,c,a)}}else if(t===cc_1.gfx.PrimitiveMode.TRIANGLE_STRIP){i=Array.from(e);var d=o.length-2;let t=0;for(let e=0;e<d;e++){var h=o[e-t]+r,_=o[e+t+1]+r,u=o[e+2]+r;l.push(h,_,_,u,u,h),t=~t}}else if(t===cc_1.gfx.PrimitiveMode.TRIANGLE_FAN){i=Array.from(e);var f=o.length-2,g=o[0]+r;for(let e=0;e<f;e+=1){var m=o[e+1]+r,p=o[e+2]+r;l.push(g,m,m,p,p,g)}}return{positions:i,edgeIndices:l}}onTargetUpdate(){this.updateControllerData()}onNodeChanged(){this.updateControllerData()}}exports.default=MeshColliderGizmo;