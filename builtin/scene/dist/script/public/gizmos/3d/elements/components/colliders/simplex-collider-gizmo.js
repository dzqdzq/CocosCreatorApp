"use strict";var __importDefault=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(exports,"__esModule",{value:!0});const cc_1=require("cc"),gizmo_base_1=__importDefault(require("../../gizmo-base")),external_1=__importDefault(require("../../../../utils/external")),point_controller_1=__importDefault(require("../../controller/point-controller")),line_controller_1=__importDefault(require("../../controller/line-controller")),triangle_controller_1=__importDefault(require("../../controller/triangle-controller")),tetrahedron_cotroller_1=__importDefault(require("../../controller/tetrahedron-cotroller")),NodeUtils=external_1.default.NodeUtils,tempVec3_a=new cc_1.Vec3,tempVec3_b=new cc_1.Vec3,tempVec3_c=new cc_1.Vec3,tempVec3_d=new cc_1.Vec3,tempQuat_a=new cc_1.Quat;class SimplexColliderGizmo extends gizmo_base_1.default{constructor(){super(...arguments),this._shapeControllers={},this._activeController=null}init(){}createControllerByShape(e){let t=this.getGizmoRoot(),l=null;switch(e){case cc_1.SimplexCollider.ESimplexType.VERTEX:l=new point_controller_1.default(t);break;case cc_1.SimplexCollider.ESimplexType.LINE:l=new line_controller_1.default(t);break;case cc_1.SimplexCollider.ESimplexType.TRIANGLE:l=new triangle_controller_1.default(t);break;case cc_1.SimplexCollider.ESimplexType.TETRAHEDRON:l=new tetrahedron_cotroller_1.default(t);break;default:console.error("Invalid Type:",e)}return l&&l.setColor(cc_1.Color.GREEN),l}getControllerByShape(e){let t=this._shapeControllers[e];return t||(t=this.createControllerByShape(e),this._shapeControllers[e]=t),t}onShow(){this.updateControllerData()}onHide(){this._activeController&&this._activeController.hide()}updateControllerData(){var e,t,l,r,c;if(this._isInited&&null!==this.target&&this.target instanceof cc_1.SimplexCollider){let o=this.node;const i=this.target;null===(e=this._activeController)||void 0===e||e.hide(),this._activeController=this.getControllerByShape(i.shapeType);let a=NodeUtils.getWorldScale3D(o),_=NodeUtils.getWorldPosition3D(o);const n=tempQuat_a;switch(NodeUtils.getWorldRotation3D(o,n),null===(t=this._activeController)||void 0===t||t.setScale(a),null===(l=this._activeController)||void 0===l||l.setPosition(_),null===(r=this._activeController)||void 0===r||r.setRotation(n),i.shapeType){case cc_1.SimplexCollider.ESimplexType.VERTEX:cc_1.Vec3.add(tempVec3_a,i.center,i.vertex0),this._activeController.updateData(tempVec3_a);break;case cc_1.SimplexCollider.ESimplexType.LINE:cc_1.Vec3.add(tempVec3_a,i.center,i.vertex0),cc_1.Vec3.add(tempVec3_b,i.center,i.vertex1),this._activeController.updateData(tempVec3_a,tempVec3_b);break;case cc_1.SimplexCollider.ESimplexType.TRIANGLE:cc_1.Vec3.add(tempVec3_a,i.center,i.vertex0),cc_1.Vec3.add(tempVec3_b,i.center,i.vertex1),cc_1.Vec3.add(tempVec3_c,i.center,i.vertex2),this._activeController.updateData(tempVec3_a,tempVec3_b,tempVec3_c);break;case cc_1.SimplexCollider.ESimplexType.TETRAHEDRON:cc_1.Vec3.add(tempVec3_a,i.center,i.vertex0),cc_1.Vec3.add(tempVec3_b,i.center,i.vertex1),cc_1.Vec3.add(tempVec3_c,i.center,i.vertex2),cc_1.Vec3.add(tempVec3_d,i.center,i.vertex3),this._activeController.updateData(tempVec3_a,tempVec3_b,tempVec3_c,tempVec3_d)}null===(c=this._activeController)||void 0===c||c.show()}}onTargetUpdate(){this.updateControllerData()}onNodeChanged(){this.updateControllerData()}}exports.default=SimplexColliderGizmo;