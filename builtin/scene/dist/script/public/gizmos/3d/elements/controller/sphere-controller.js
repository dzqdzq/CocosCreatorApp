"use strict";var __importDefault=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(exports,"__esModule",{value:!0});const editable_controller_1=__importDefault(require("./editable-controller")),controller_shape_1=__importDefault(require("../utils/controller-shape")),controller_utils_1=__importDefault(require("../utils/controller-utils")),engine_1=__importDefault(require("../../../utils/engine")),external_1=__importDefault(require("../../../utils/external")),cc_1=require("cc"),{setNodeOpacity:setNodeOpacity,getModel:getModel,updatePositions:updatePositions,setMeshColor:setMeshColor,getNodeOpacity:getNodeOpacity}=engine_1.default,NodeUtils=external_1.default.NodeUtils,EditorCamera=external_1.default.EditorCamera,EditorMath=external_1.default.EditorMath,axisDirMap=controller_utils_1.default.axisDirectionMap,AxisName=controller_utils_1.default.AxisName,tempVec3_a=new cc_1.Vec3,tempVec3_b=new cc_1.Vec3,tempQuat_a=new cc_1.Quat;class SphereController extends editable_controller_1.default{constructor(e){super(e),this._center=new cc_1.Vec3,this._radius=100,this._deltaRadius=0,this._circleDataMap={},this._borderCircle=null,this._borderCircelMR=null,this._mouseDeltaPos=new cc_1.Vec2,this._curDistScalar=0,this._controlDir=new cc_1.Vec3,this._color=cc.Color.WHITE,this._editHandleKeys=Object.keys(axisDirMap),this.initShape()}get radius(){return this._radius}set radius(e){this.updateSize(this._center,e)}setColor(e){Object.keys(this._circleDataMap).forEach(t=>{const r=this._circleDataMap[t];setMeshColor(r.frontArcMR.node,e);const i=getNodeOpacity(r.backArcMR.node),s=e.clone();s.a=i,setMeshColor(r.backArcMR.node,s)}),setMeshColor(this._borderCircle,e),this.setEditHandlesColor(e),this._color=e}createCircleByAxis(e,t,r){const i=axisDirMap[e],s=axisDirMap[t],a=controller_utils_1.default.arc(this._center,i,s,2*Math.PI,this._radius,r);a.name="arc_"+e+"_front",a.parent=this.shape;const o=controller_utils_1.default.arc(this._center,i,s,2*Math.PI,this._radius,r);o.name="arc_"+e+"_back",o.parent=this.shape,setNodeOpacity(o,30);const c={};c.frontArcMR=getModel(a),c.backArcMR=getModel(o),c.normalDir=i,c.fromDir=s,this._circleDataMap[e]=c}createBorderCircle(){this._borderCircle=controller_utils_1.default.circle(this._center,new cc_1.Vec3(0,0,1),this._radius,this._color),this._borderCircle.name="borderCircle",this._borderCircle.parent=this.shape,this._borderCircelMR=getModel(this._borderCircle)}_updateEditHandle(e){const t=this._handleDataMap[e].topNode,r=axisDirMap[e],i=new cc_1.Vec3;cc_1.Vec3.multiplyScalar(i,r,this._radius);const s=new cc_1.Vec3(i);s.add(this._center),cc_1.Vec3.multiply(s,s,this.getScale()),t.setPosition(s.x,s.y,s.z)}initShape(){this.createShapeNode("SphereController"),this._circleDataMap={},this.createCircleByAxis("x","z",this._color),this.createCircleByAxis("y","x",this._color),this.createCircleByAxis("z","x",this._color),this.createBorderCircle(),this.hide(),EditorCamera.camera.node.on("transform-changed",this.onEditorCameraMoved,this)}updateSize(e,t){this._center=e,this._radius=t,this._edit&&this.updateEditHandles(),this.updateShape()}updateShape(){const e=EditorCamera.camera.node,t=NodeUtils.getWorldPosition3D(e),r=new cc_1.Mat4;this.shape.getWorldMatrix(r),cc.Mat4.invert(r,r),cc_1.Vec3.transformMat4(t,t,r);const i=tempVec3_b;cc_1.Vec3.subtract(i,this._center,t);const s=cc_1.Vec3.lengthSqr(i),a=this._radius*this._radius,o=a*a/s,c=o/a;if(c<1){this._borderCircle.active=!0;const e=Math.sqrt(a-o),t=cc_1.Vec3.multiplyScalar(tempVec3_a,i,a/s),r=cc_1.Vec3.subtract(tempVec3_a,this._center,t),c=controller_shape_1.default.calcCirclePoints(r,i,e);updatePositions(this._borderCircelMR,c)}else this._borderCircle.active=!1;Object.keys(this._circleDataMap).forEach(e=>{const t=this._circleDataMap[e].normalDir,r=this._circleDataMap[e].frontArcMR,s=this._circleDataMap[e].backArcMR;if(c<1){let a=controller_utils_1.default.angle(i,t);a=90-Math.min(a,180-a);const c=Math.tan(a*EditorMath.D2R),l=Math.sqrt(o+c*c*o)/this._radius;if(l<1){const e=Math.asin(l);cc_1.Vec3.cross(tempVec3_a,t,i);const a=tempVec3_a;a.normalize();const o=tempQuat_a;cc_1.Quat.fromAxisAngle(o,t,e),cc_1.Vec3.transformQuat(a,a,o),this.updateArcMesh(r,this._center,t,a,2*(EditorMath.HALF_PI-e),this._radius),r.node.active=!0,this.updateArcMesh(s,this._center,t,a,2*(EditorMath.HALF_PI-e)-EditorMath.TWO_PI,this._radius)}else this.updateArcMesh(s,this._center,t,this._circleDataMap[e].fromDir,EditorMath.TWO_PI,this._radius),r.node.active=!1}else this.updateArcMesh(s,this._center,t,this._circleDataMap[e].fromDir,EditorMath.TWO_PI,this._radius),r.node.active=!1}),this.adjustEditHandlesSize()}updateArcMesh(e,t,r,i,s,a){const o=controller_shape_1.default.calcArcPoints(t,r,i,s,a);updatePositions(e,o)}onEditorCameraMoved(){this.updateShape()}onMouseDown(e){this._mouseDeltaPos=cc.v2(0,0),this._curDistScalar=super.getDistScalar(),this._controlDir=new cc_1.Vec3(0,0,0),this.onControllerMouseDown&&this.onControllerMouseDown(e)}onMouseMove(e){if(this._isMouseDown){this._mouseDeltaPos.x+=e.moveDeltaX,this._mouseDeltaPos.y+=e.moveDeltaY;const t=axisDirMap[e.handleName];this._controlDir=t,this._deltaRadius=this.getAlignAxisMoveDistance(this.localToWorldDir(t),this._mouseDeltaPos)*this._curDistScalar,this.onControllerMouseMove&&this.onControllerMouseMove(e)}}onMouseUp(e){this.onControllerMouseUp&&this.onControllerMouseUp(e)}onMouseLeave(e){this.onMouseUp(e)}getDeltaRadius(){return this._deltaRadius}getControlDir(){return this._controlDir}}exports.default=SphereController;