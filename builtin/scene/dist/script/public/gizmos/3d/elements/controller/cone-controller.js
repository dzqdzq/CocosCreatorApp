"use strict";var __importDefault=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(exports,"__esModule",{value:!0});const editable_controller_1=__importDefault(require("./editable-controller")),controller_shape_1=__importDefault(require("../utils/controller-shape")),controller_utils_1=__importDefault(require("../utils/controller-utils")),{AttributeName:AttributeName,setMeshColor:setMeshColor,getModel:getModel,updatePositions:updatePositions}=require("../../../utils/engine/index"),cc_1=require("cc"),external_1=__importDefault(require("../../../utils/external")),controller_utils_2=__importDefault(require("../utils/controller-utils")),EditorMath=external_1.default.EditorMath,axisDirMap=controller_utils_1.default.axisDirectionMap,AxisName=controller_utils_1.default.AxisName,tempVec3A=new cc_1.Vec3,tempVec3B=new cc_1.Vec3,tempVec3C=new cc_1.Vec3,tempVec3D=new cc_1.Vec3,tempVec3E=new cc_1.Vec3,tempQuatA=new cc_1.Quat;class ConeController extends editable_controller_1.default{constructor(e){super(e),this._oriDir=cc.v3(0,0,-1),this._center=cc.v3(),this._radius=100,this._height=100,this._halfHeight=this._height/2,this._deltaRadius=0,this._deltaHeight=0,this._circleFromDir=new cc_1.Vec3(1,0,0),this._sideLineMR=null,this._lowerCapMR=null,this._sideLineNode=null,this._lowerCapNode=null,this._mouseDeltaPos=new cc_1.Vec2,this._curDistScalar=0,this._directionAxis=[new cc_1.Vec3(1,0,0),new cc_1.Vec3(0,1,0),new cc_1.Vec3(0,0,1)],this._direction=cc_1.EAxisDirection.Y_AXIS,this._editHandleKeys=[AxisName.x,AxisName.z,AxisName.neg_x,AxisName.neg_y,AxisName.neg_z],this.initShape()}get radius(){return this._radius}set radius(e){this.updateSize(this._center,e,this._height)}get height(){return this._height}set height(e){this.updateSize(this._center,this._radius,e)}get direction(){return this._direction}set direction(e){this._direction=e}setColor(e){setMeshColor(this._sideLineNode,e),setMeshColor(this._lowerCapNode,e),this.setEditHandlesColor(e),this._color=e}_updateEditHandle(e){const t=this._handleDataMap[e].topNode,i=axisDirMap[e],s=tempVec3A.set(this._directionAxis[this._direction]),c=tempVec3B;if(c.set(0,0,0),"neg_y"===e)cc_1.Vec3.multiplyScalar(c,s,-this._halfHeight);else if(cc_1.Vec3.multiplyScalar(c,i,this._radius),cc_1.Vec3.multiplyScalar(tempVec3C,cc_1.Vec3.UNIT_Y,-this._halfHeight),c.add(tempVec3C),this._direction!==cc_1.EAxisDirection.Y_AXIS){const e=tempQuatA;cc_1.Quat.rotationTo(e,cc_1.Vec3.UNIT_Y,s),cc_1.Vec3.transformQuat(c,c,e)}c.add(this._center),cc_1.Vec3.multiply(c,c,this.getScale()),t.setPosition(c)}initShape(){this.createShapeNode("ConeController"),this._circleFromDir=cc.v3(1,0,0);const e=this.getSideLinesData(this._center,this._radius,this._height);this._sideLineNode=controller_utils_1.default.createShapeByData(e,this._color,{name:"sideLines",forwardPipeline:!0}),this._sideLineNode.parent=this.shape,this._sideLineMR=getModel(this._sideLineNode);const t=this.getLowerCapData(this._center,this._radius,this._height);this._lowerCapNode=controller_utils_2.default.createShapeByData(t,this._color,{name:"lowerCap"}),this._lowerCapNode.parent=this.shape,this._lowerCapMR=getModel(this._lowerCapNode),this.hide()}getSideLinesData(e,t,i){const s=[],c=[],o=i/2;return s.push(new cc_1.Vec3(0,o,0)),s.push(new cc_1.Vec3(t,-o,0)),s.push(new cc_1.Vec3(0,o,0)),s.push(new cc_1.Vec3(-t,-o,0)),s.push(new cc_1.Vec3(0,o,0)),s.push(new cc_1.Vec3(0,-o,t)),s.push(new cc_1.Vec3(0,o,-0)),s.push(new cc_1.Vec3(0,-o,-t)),s.forEach((t,i)=>{if(this._direction!==cc_1.EAxisDirection.Y_AXIS){const e=this._directionAxis[this._direction],i=tempQuatA;cc_1.Quat.rotationTo(i,cc_1.Vec3.UNIT_Y,e),cc_1.Vec3.transformQuat(t,t,i)}cc_1.Vec3.add(t,t,e),c.push(i)}),controller_shape_1.default.calcLinesData(s,c,!1)}getLowerCapData(e,t,i){let s;const c=i/2,o=cc_1.Vec3.copy(tempVec3A,cc_1.Vec3.UNIT_Y),r=cc_1.Vec3.copy(tempVec3B,cc_1.Vec3.UNIT_X),a=cc_1.Vec3.copy(tempVec3C,cc_1.Vec3.UNIT_Z),_=tempVec3D,h=tempVec3E.set(0,-c,0);if(this._direction!==cc_1.EAxisDirection.Y_AXIS){const e=this._directionAxis[this._direction],t=tempQuatA;cc_1.Quat.rotationTo(t,cc_1.Vec3.UNIT_Y,e),cc_1.Vec3.transformQuat(h,h,t),cc_1.Vec3.transformQuat(o,o,t),cc_1.Vec3.transformQuat(r,r,t),cc_1.Vec3.transformQuat(a,a,t)}return cc_1.Vec3.add(_,e,h),s=controller_shape_1.default.calcArcData(_,o,r,this._twoPI,t)}updateSize(e,t,i){this._center=e,this._radius=t,this._height=i,this._halfHeight=this._height/2;const s=this.getSideLinesData(this._center,this._radius,this._height);updatePositions(this._sideLineMR,s.positions);const c=this.getLowerCapData(this._center,this._radius,this._height);updatePositions(this._lowerCapMR,c.positions),this._edit&&this.updateEditHandles(),this.adjustEditHandlesSize()}onMouseDown(e){this._mouseDeltaPos=cc.v2(0,0),this._curDistScalar=super.getDistScalar(),this._deltaRadius=0,this._deltaHeight=0,this.onControllerMouseDown&&this.onControllerMouseDown(e)}onMouseMove(e){if(this._isMouseDown){this._mouseDeltaPos.x+=e.moveDeltaX,this._mouseDeltaPos.y+=e.moveDeltaY;const t=axisDirMap[e.handleName],i=tempVec3A.set(this._directionAxis[this._direction]),s=tempQuatA;cc_1.Quat.rotationTo(s,cc_1.Vec3.UNIT_Y,i),cc_1.Vec3.transformQuat(i,t,s);const c=this.getAlignAxisMoveDistance(this.localToWorldDir(i),this._mouseDeltaPos)*this._curDistScalar;"neg_y"===e.handleName?this._deltaHeight=c:this._deltaRadius=c,this.onControllerMouseMove&&this.onControllerMouseMove(e)}}onMouseUp(e){this.onControllerMouseUp&&this.onControllerMouseUp(e)}onMouseLeave(e){this.onMouseUp(e)}getDeltaRadius(){return this._deltaRadius}getDeltaHeight(){return this._deltaHeight}}exports.default=ConeController;