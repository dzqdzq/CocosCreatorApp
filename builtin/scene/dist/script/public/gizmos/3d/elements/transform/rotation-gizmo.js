"use strict";var __importDefault=this&&this.__importDefault||function(t){return t&&t.__esModule?t:{default:t}};Object.defineProperty(exports,"__esModule",{value:!0});const Utils=require("../../../utils"),external_1=__importDefault(require("../../../utils/external")),cc_1=require("cc"),NodeUtils=external_1.default.NodeUtils,GizmoUtils=Utils.GizmoUtils,transform_gizmo_1=__importDefault(require("./transform-gizmo")),rotation_controller_1=__importDefault(require("../controller/rotation-controller")),transform_tool_data_1=require("../../../utils/transform-tool-data"),EditorMath=external_1.default.EditorMath,GizmoConfig=require("../../../gizmo-config"),q_a=new cc_1.Quat,q_b=new cc_1.Quat,q_c=new cc_1.Quat,v3_a=new cc_1.Vec3,v3_b=new cc_1.Vec3,q_d=new cc_1.Quat;function minAngularDistance(t,o){return Math.min(Math.abs(t.x-o.x),Math.abs((t.x<0?360+t.x:t.x)-(o.x<0?360+o.x:o.x)))+Math.min(Math.abs(t.y-o.y),Math.abs((t.y<0?360+t.y:t.y)-(o.y<0?360+o.y:o.y)))+Math.min(Math.abs(t.z-o.z),Math.abs((t.z<0?360+t.z:t.z)-(o.z<0?360+o.z:o.z)))}class RotationGizmo extends transform_gizmo_1.default{constructor(){super(...arguments),this._rotList=[],this._offsetList=[],this._center=new cc_1.Vec3(0,0),this._rotating=!1,this._keydownDelta=null,this._curDeltaAngle=0,this._curDeltaRotation=new cc_1.Quat}init(){this.createController()}layer(){return"foreground"}createController(){const t=new rotation_controller_1.default(this.getGizmoRoot());t.onControllerMouseDown=this.onControllerMouseDown.bind(this),t.onControllerMouseMove=this.onControllerMouseMove.bind(this),t.onControllerMouseUp=this.onControllerMouseUp.bind(this),this._controller=t}onControllerMouseDown(){this._rotating=!0,this._rotList=[],this._curDeltaAngle=0,this._curDeltaRotation.set(0,0,0,1);const t=this.topNodes;for(let o=0;o<t.length;++o)if(GizmoConfig.isCreator2x&&this._controller.is2D)this._rotList.push(t[o].angle);else{const e=NodeUtils.getWorldRotation3D(t[o]);this._rotList.push(e)}if("center"===transform_tool_data_1.transformToolData.pivot){this._center=GizmoUtils.getCenterWorldPos3D(this.target),this._offsetList.length=0;for(let o=0;o<t.length;++o){const e=NodeUtils.getWorldPosition3D(t[o]),r=new cc_1.Vec3(e);r.subtract(this._center),this._offsetList.push(r)}}const o=transform_tool_data_1.transformToolData.snapConfigs,e=Math.max(o.rotation,5);this._controller.setGraduation(e),Utils.requestPointerLock()}onControllerMouseMove(t){this.updateDataFromController(t)}onControllerMouseUp(){if("center"===transform_tool_data_1.transformToolData.pivot){const t=GizmoUtils.getCenterWorldPos3D(this.target);this._controller.setPosition(t),this._controller.setRotation(cc_1.Quat.IDENTITY)}this._rotating=!1,this._controller.updated&&this.onControlEnd("rotation"),this.updateControllerTransform(),Utils.exitPointerLock(),this._controller.hideGraduation(),this._curDeltaRotation.set(0,0,0,1)}onGizmoKeyDown(t){if(!this.target)return;const o=t.key.toLowerCase();if("arrowleft"!==o&&"arrowright"!==o&&"arrowup"!==o&&"arrowdown"!==o)return;this._rotating=!0;let e=t.shiftKey?10:1;if("arrowright"!==o&&"arrowdown"!==o||(e*=-1),!this._keydownDelta){this._keydownDelta=0;const t=this.topNodes;this._rotList=[];for(let o=0;o<t.length;++o)this._rotList.push(t[o].angle)}this._keydownDelta+=e,this._curDeltaAngle=this._keydownDelta;const r=EditorMath.deg2rad(this._curDeltaAngle);cc_1.Quat.fromAxisAngle(this._curDeltaRotation,cc_1.Vec3.UNIT_Z,r),this.onControlUpdate("rotation"),this.updateRotationByZDeltaAngle(this._keydownDelta),Utils.repaintEngine()}onGizmoKeyUp(t){if(!this.target)return;const o=t.key.toLowerCase();if("arrowleft"===o||"arrowright"===o||"arrowup"===o||"arrowdown"===o){if("center"===transform_tool_data_1.transformToolData.pivot){const t=GizmoUtils.getCenterWorldPos3D(this.target);this._controller.setPosition(t),this._controller.setRotation(cc_1.Quat.IDENTITY)}this._keydownDelta=null,this._rotating=!1,this.onControlEnd("rotation"),this.updateControllerTransform(),Utils.repaintEngine()}}updateDataFromController(t){GizmoConfig.isCreator2x&&this._controller.is2D?this.updateDataFromController2D(t):this.updateDataFromController3D(t)}getLocalRotFromWorldRot(t,o,e){return t.parent?(t.parent.getWorldRotation(q_c),cc_1.Quat.multiply(e,cc_1.Quat.conjugate(q_c,q_c),o)):e=o,e}repeat(t,o){return t-Math.floor(t/o)*o}setNodeWorldRotation3D(t,o){const e=q_b;this.getLocalRotFromWorldRot(t,o,e);const r=t.eulerAngles;cc_1.Quat.toEuler(v3_a,e,!1),cc_1.Quat.toEuler(v3_b,e,!0);const a=minAngularDistance(v3_a,r)<minAngularDistance(v3_b,r)?v3_a:v3_b;a.x=this.repeat(a.x-r.x+180,360)+r.x-180,a.y=this.repeat(a.y-r.y+180,360)+r.y-180,a.z=this.repeat(a.z-r.z+180,360)+r.z-180,NodeUtils.makeVec3InPrecision(a,3),t.eulerAngles=a}checkSnap(t,o,e,r){this._curDeltaAngle=this.getSnappedValue(o,r);const a=EditorMath.deg2rad(this._curDeltaAngle);return cc_1.Quat.fromAxisAngle(t,e,a),t}updateDataFromController3D(t){if(this._controller.updated){let o;this.onControlUpdate("rotation");const e=q_b,r=this._controller;this._curDeltaAngle=r.getDeltaAngle();const a=r.getDeltaRotation(),i=this.topNodes,n=transform_tool_data_1.transformToolData.snapConfigs;if((t.ctrlKey||n.isRotationSnapEnabled)&&(this.checkSnap(a,r.getDeltaAngle(),r.getHandleAxisDir(),n.rotation),r.showGraduation()),cc_1.Quat.copy(this._curDeltaRotation,a),"center"===transform_tool_data_1.transformToolData.pivot)for(o=0;o<i.length;++o){const t=this._rotList[o];if(null===t)return;"global"===transform_tool_data_1.transformToolData.coordinate?cc_1.Quat.multiply(e,a,t):cc_1.Quat.multiply(e,t,a);const r=v3_b;cc_1.Vec3.transformQuat(r,this._offsetList[o],a),v3_a.set(this._center),v3_a.add(r),NodeUtils.setWorldPosition3D(i[o],v3_a),this.setNodeWorldRotation3D(i[o],e)}else for(o=0;o<i.length;++o)"global"===transform_tool_data_1.transformToolData.coordinate?cc_1.Quat.multiply(e,a,this._rotList[o]):cc_1.Quat.multiply(e,this._rotList[o],a),this.setNodeWorldRotation3D(i[o],e)}}updateDataFromController2D(t){if(this._controller.updated){this.onControlUpdate("rotation");let o=this._controller.getDeltaAngle();const e=transform_tool_data_1.transformToolData.snapConfigs;(t.ctrlKey||e.isRotationSnapEnabled)&&(o=this.getSnappedValue(o,e.rotation)),this.updateRotationByZDeltaAngle(o)}}updateRotationByZDeltaAngle(t){let o;t=EditorMath.toPrecision(t,3);const e=q_a,r=this.topNodes;if("center"===transform_tool_data_1.transformToolData.pivot)for(o=0;o<r.length;++o){const a=this._rotList[o];if(null===a)return;const i=a+t;r[o].angle=i,cc_1.Quat.fromEuler(e,0,0,t);const n=new cc.Vec3;cc_1.Vec3.transformQuat(n,this._offsetList[o],e),v3_a.set(this._center),v3_a.add(n),NodeUtils.setWorldPosition3D(r[o],v3_a)}else for(o=0;o<r.length;++o){const e=this._rotList[o]+t;r[o].angle=e}}updateControllerTransform(){const t=this.node;if(!t)return;let o;const e=q_a;if(cc_1.Quat.identity(e),"center"===transform_tool_data_1.transformToolData.pivot){if(this._rotating)return;o=GizmoUtils.getCenterWorldPos3D(this.target)}else o=NodeUtils.getWorldPosition3D(t);const r=this._controller;"global"===transform_tool_data_1.transformToolData.coordinate?this._rotating&&cc_1.Quat.copy(e,this._curDeltaRotation):(NodeUtils.getWorldRotation3D(t,e),this._controller.setRotation(e)),this._rotating&&r.updateRotationIndicator(r.transformAxisDir,r.indicatorStartDir,EditorMath.deg2rad(this._curDeltaAngle)),this._controller.setPosition(o),this._controller.setRotation(e)}}exports.default=RotationGizmo;