"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.TerrainEditorSculpt=void 0;const cc_1=require("cc"),terrain_brush_1=require("./terrain-brush"),terrain_editor_mode_1=require("./terrain-editor-mode"),terrain_operation_1=require("./terrain-operation"),clamp=cc_1.math.clamp;class TerrainEditorSculpt extends terrain_editor_mode_1.TerrainEditorMode{constructor(r){super(r),this._undo=null;const t=new terrain_brush_1.TerrainCircleBrush;t.strength=5;const e=new terrain_brush_1.TerrainImageBrush;e.strength=5,this._brushes=[t,e],this._currentBrush=this._brushes[0]}setCurrentBrush(r){const t=this._currentBrush.position,e=this._currentBrush.radius,i=this._currentBrush.strength;this._currentBrush=this._brushes[r],this._currentBrush.position=t,this._currentBrush.radius=e,this._currentBrush.strength=i}getCurrentBrush(){return this._currentBrush}getBrush(r){return this._brushes[r]}setBrushImage(r){this.getBrush(terrain_brush_1.TerrainBrushType.IMAGE).image=r,null!==r?this.setCurrentBrush(terrain_brush_1.TerrainBrushType.IMAGE):this.setCurrentBrush(terrain_brush_1.TerrainBrushType.CIRCLE)}onUpdate(r,t,e){null!=this._undo&&(this._updateHeight(r,t,e),r.isTerrainChange=!0)}onUpdateBrushPosition(r,t){const e=this._currentBrush;e.update(r,t);for(const t of r.getBlocks()){const i=t.getIndex(),n=new cc_1.Rect;n.x=i[0]*cc_1.TERRAIN_BLOCK_TILE_COMPLEXITY*r.info.tileSize,n.y=i[1]*cc_1.TERRAIN_BLOCK_TILE_COMPLEXITY*r.info.tileSize,n.width=cc_1.TERRAIN_BLOCK_TILE_COMPLEXITY*r.info.tileSize,n.height=cc_1.TERRAIN_BLOCK_TILE_COMPLEXITY*r.info.tileSize;const s=new cc_1.Rect;s.x=e.position.x-e.radius,s.y=e.position.z-e.radius,s.width=2*e.radius,s.height=2*e.radius,n.intersects(s)?t.setBrushMaterial(e.material):t.setBrushMaterial(null)}}onMouseDown(){this._undo=new terrain_operation_1.TerrainHeightUndoRedo(this.gizmo._target)}onMouseUp(){this._undo&&cce.SceneFacadeManager.snapshot(this._undo),this._undo=null}_updateHeight(r,t,e){const i=this._currentBrush;let n=i.position.x-i.radius,s=i.position.z-i.radius,o=i.position.x+i.radius,u=i.position.z+i.radius;if(n/=r.info.tileSize,s/=r.info.tileSize,o/=r.info.tileSize,u/=r.info.tileSize,n=Math.floor(n),s=Math.floor(s),o=Math.floor(o),u=Math.floor(u),n>r.info.vertexCount[0]-1||o<0)return;if(s>r.info.vertexCount[1]-1||u<0)return;n=clamp(n,0,r.info.vertexCount[0]-1),s=clamp(s,0,r.info.vertexCount[1]-1),o=clamp(o,0,r.info.vertexCount[0]-1),u=clamp(u,0,r.info.vertexCount[1]-1);const h=new terrain_operation_1.TerrainHeightOperation(r);this._undo&&this._undo.redoOperations.push(h);const a=r.gizmo.isSmooth;for(let _=s;_<=u;++_)for(let s=n;s<=o;++s){let n=r.getHeightClamp(s-1,_-1),o=r.getHeightClamp(s,_),u=r.getHeightClamp(s+1,_+1);null!=this._undo&&this._undo.push(s,_,o);const c=s*r.info.tileSize,l=_*r.info.tileSize,d=i.getDelta(c,l)*t;e||a?a&&!e?o+=3*d*((n+o+u)/3-o):o-=d:o+=d,h.push(s,_,o)}h.apply(),r.manager&&r.manager.onSculpt(r.node)}}exports.TerrainEditorSculpt=TerrainEditorSculpt;