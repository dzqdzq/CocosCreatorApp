"use strict";var __importDefault=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(exports,"__esModule",{value:!0});const gizmo_base_1=__importDefault(require("../../../gizmo-base")),external_1=__importDefault(require("../../../../../utils/external")),cc_1=require("cc"),polygon_controller_1=require("../../../controller/polygon-controller"),line_controller_1=__importDefault(require("../../../controller/line-controller")),utils_1=__importDefault(require("../../../../../utils")),NodeUtils=external_1.default.NodeUtils,EditorMath=external_1.default.EditorMath,HandleType=polygon_controller_1.PolygonController.PolygonHandleType,tempVec3_a=new cc_1.Vec3,tempQuat_a=new cc_1.Quat,tempMat4=new cc_1.Mat4,tempVec2=new cc_1.Vec2;class PolygonCollider2DGizmo extends gizmo_base_1.default{constructor(){super(...arguments),this._offset=new cc_1.Vec2,this._ctrlKey=!1,this._metaKey=!1,this._propPath=null,this._3dPoints=[],this._points=[],this._curHoverInHandleType=HandleType.None,this._curHoverInElemIndex=-1,this._isDeletePointKeyDown=!1}get isDeletePointKeyDown(){return this._isDeletePointKeyDown}set isDeletePointKeyDown(e){this._isDeletePointKeyDown=e,e?this.curHoverInHandleType===HandleType.Point&&(utils_1.default.changePointer("alias"),this.highlightDeleteLine(!0)):(this.curHoverInHandleType===HandleType.Point&&utils_1.default.changePointer("default"),this.highlightDeleteLine(!1))}get curHoverInHandleType(){return this._curHoverInHandleType}set curHoverInHandleType(e){switch(this._curHoverInHandleType=e,e){case HandleType.None:case HandleType.Area:utils_1.default.changePointer("default"),this.highlightDeleteLine(!1);break;case HandleType.Point:this.isDeletePointKeyDown?(utils_1.default.changePointer("alias"),this.highlightDeleteLine(!0)):(utils_1.default.changePointer("default"),this.highlightDeleteLine(!1));break;case HandleType.Line:utils_1.default.changePointer("copy"),this.highlightDeleteLine(!1)}}highlightDeleteLine(e){if(e){if(this._curHoverInElemIndex>=0){const e=this.target.points,t=this._controller.points;if(e.length<2)return;if(2===e.length)this._leftDeleteLine.updateData(t[0],t[1]),this._leftDeleteLine.show();else{const e=this._curHoverInElemIndex,o=0===e?t.length-1:e-1,n=e===t.length-1?0:e+1;this._leftDeleteLine.updateData(t[o],t[e]),this._rightDeleteLine.updateData(t[e],t[n]),this._leftDeleteLine.show(),this._rightDeleteLine.show(),cce.Engine.repaintInEditMode()}}}else this._leftDeleteLine.hide(),this._rightDeleteLine.hide(),cce.Engine.repaintInEditMode()}init(){this.createController()}onShow(){this._controller.show(),this.updateController()}onHide(){this._controller.hide()}createController(){const e=this.getGizmoRoot();this._controller=new polygon_controller_1.PolygonController(e),this._controller.editable=!0,this._controller.setColor(new cc.Color(107,194,53)),this._controller.setEditHandlesColor(new cc.Color(107,194,53)),this._controller.onControllerMouseDown=this.onControllerMouseDown.bind(this),this._controller.onControllerMouseMove=this.onControllerMouseMove.bind(this),this._controller.onControllerMouseUp=this.onControllerMouseUp.bind(this),this._controller.onControllerHoverIn=this.onControllerHoverIn.bind(this),this._controller.onControllerHoverOut=this.onControllerHoverOut.bind(this),this._leftDeleteLine=new line_controller_1.default(e),this._leftDeleteLine.setColor(cc_1.Color.RED),this._leftDeleteLine.hide(),this._rightDeleteLine=new line_controller_1.default(e),this._rightDeleteLine.setColor(cc_1.Color.RED),this._rightDeleteLine.hide()}onControllerMouseDown(){const e=this._controller.getHandleData();if(e)if(e.type===HandleType.Line){const t=e.hitPos;if(t){this._propPath=this.getCompPropPath("points"),this.onControlUpdate(this._propPath);const o=this.target.points;this.worldToLocalPos(tempVec3_a,t);const n=this.target.offset,i=EditorMath.toPrecision(tempVec3_a.x-n.x,1),l=EditorMath.toPrecision(tempVec3_a.y-n.y,1);o.splice(e.index+1,0,new cc_1.Vec2(i,l)),this.target.points=o,this.onComponentChanged(this.node)}}else if(e.type===HandleType.Point){if(this.onControlUpdate(this._propPath),this._propPath=this.getCompPropPath("points"),this.isDeletePointKeyDown){const t=this.target.points;t.splice(e.index,1),this.target.points=t,this.onComponentChanged(this.node),this.curHoverInHandleType=HandleType.None,this._curHoverInElemIndex=-1}this._points=[],this.target.points.forEach(e=>{this._points.push(e.clone())})}else e.type===HandleType.Area&&(this._offset=this.target.offset.clone(),this._propPath=this.getCompPropPath("offset"))}onControllerMouseMove(e){if(this._ctrlKey=e.ctrlKey,this._metaKey=e.metaKey,this.isDeletePointKeyDown=this._ctrlKey||this._metaKey,this._controller.updated){const e=this._controller.getHandleData();e.type===HandleType.Point?(this.onControlUpdate(this._propPath),this.handlePoints(e)):e.type===HandleType.Area&&(this.onControlUpdate(this._propPath),this.handleAreaMove(e.deltaPos))}}onControllerMouseUp(){this.onControlEnd(this._propPath)}onControllerHoverIn(e){var t,o;"l"===e.handleName.charAt(0)?(this.curHoverInHandleType=HandleType.Line,this._curHoverInElemIndex=null===(t=e.customData)||void 0===t?void 0:t.index):"p"===e.handleName.charAt(0)?(this.curHoverInHandleType=HandleType.Point,this._curHoverInElemIndex=null===(o=e.customData)||void 0===o?void 0:o.index):e.handleName===HandleType.Area&&(this.curHoverInHandleType=HandleType.Area)}onControllerHoverOut(e){"l"===e.handleName.charAt(0)?this.curHoverInHandleType===HandleType.Line&&(this.curHoverInHandleType=HandleType.None,this._curHoverInElemIndex=-1):"p"===e.handleName.charAt(0)?this.curHoverInHandleType===HandleType.Point&&(this.curHoverInHandleType=HandleType.None,this._curHoverInElemIndex=-1):e.handleName===HandleType.Area&&this.curHoverInHandleType===HandleType.Area&&(this.curHoverInHandleType=HandleType.None)}onKeyDown(e){this._ctrlKey=e.ctrlKey,this._metaKey=e.metaKey,this.isDeletePointKeyDown=this._ctrlKey||this._metaKey}onKeyUp(e){this._ctrlKey=e.ctrlKey,this._metaKey=e.metaKey,this.isDeletePointKeyDown=this._ctrlKey||this._metaKey}worldToLocalPos(e,t){const o=this.node;o&&(o.getWorldMatrix(tempMat4),cc_1.Mat4.invert(tempMat4,tempMat4),cc_1.Vec3.transformMat4(e,t,tempMat4))}handleAreaMove(e){const t=this.node,o=e.clone();t&&(t.getWorldMatrix(tempMat4),cc_1.Mat4.invert(tempMat4,tempMat4),tempMat4.m12=tempMat4.m13=0,cc_1.Vec3.transformMat4(o,o,tempMat4)),NodeUtils.makeVec3InPrecision(o,1),o.z=0,tempVec2.set(this._offset),tempVec2.add2f(o.x,o.y),this.target.offset.set(tempVec2),this.onComponentChanged(t)}handlePoints(e){const t=e.index;if(t<0)return;const o=e.deltaPos.clone(),n=this.node;n&&(n.getWorldMatrix(tempMat4),cc_1.Mat4.invert(tempMat4,tempMat4),tempMat4.m12=tempMat4.m13=0,cc_1.Vec3.transformMat4(o,o,tempMat4));const i=this.target.points,l=this._points[t];let r=l.x+o.x,s=l.y+o.y;r=EditorMath.toPrecision(r,1),s=EditorMath.toPrecision(s,1),i[t].set(r,s),this.target.points=i,this.onComponentChanged(n)}updateControllerData(){if(!this._isInited||null===this.target)return;const e=this.target;if(e){const t=e.offset,o=tempVec3_a;o.x=t.x,o.y=t.y,o.z=0;const n=this.node;if(n&&n.getWorldMatrix(tempMat4),this._3dPoints.length<e.points.length){const t=e.points.length-this._3dPoints.length;for(let e=0;e<t;e++)this._3dPoints.push(new cc_1.Vec3(0,0,0))}else this._3dPoints.length=e.points.length;e.points.forEach((e,t)=>{this._3dPoints[t].set(e.x+o.x,e.y+o.y,0),cc_1.Vec3.transformMat4(this._3dPoints[t],this._3dPoints[t],tempMat4)}),this._controller.updateData(this._3dPoints),this._controller.edit=e.editing}else this._controller.hide()}updateController(){this.updateControllerData()}onTargetUpdate(){this.updateController()}onNodeChanged(){this.updateController()}}exports.default=PolygonCollider2DGizmo;