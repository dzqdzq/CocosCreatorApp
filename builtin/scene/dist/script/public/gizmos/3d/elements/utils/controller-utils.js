"use strict";var __importDefault=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(exports,"__esModule",{value:!0});const cc_1=require("cc"),{createMesh:createMesh}=require("../../../utils/engine"),external_1=__importDefault(require("../../../utils/external")),controller_shape_1=__importDefault(require("./controller-shape")),controller_shape_collider_1=require("./controller-shape-collider"),NodeUtils=external_1.default.NodeUtils,{CullMode:CullMode,create3DNode:create3DNode,addMeshToNode:addMeshToNode,setMeshColor:setMeshColor,setNodeOpacity:setNodeOpacity}=require("../../../utils/engine"),EditorMath=external_1.default.EditorMath;var AxisName;!function(e){e.x="x",e.y="y",e.z="z",e.neg_x="neg_x",e.neg_y="neg_y",e.neg_z="neg_z"}(AxisName||(AxisName={}));class ControllerUtils{static arrow(e,t,a,c,r={}){const o=create3DNode("arrow");let n=5;void 0!==r.bodyBBSize&&null!==r.bodyBBSize&&(n=r.bodyBBSize);const l={noDepthTestForLines:!0};Object.assign(l,r);const s=controller_shape_1.default.calcLineData(new cc_1.Vec3(0,0,0),new cc_1.Vec3(0,a,0)),i=this.createShapeByData(s,c,l);if(i.name="ArrowLine",i.parent=o,setMeshColor(i,c),n>0){const e=controller_shape_1.default.calcCylinderData(n,n,a,l),t=this.createShapeByData(e,c,l);t.name="ArrowBody",t.parent=o,setNodeOpacity(t,0),t.setPosition(new cc_1.Vec3(0,a/2,0));const r=t.addComponent(controller_shape_collider_1.ControllerShapeCollider);r.isDetectMesh=!0,r.isRender=!1}const h={cullMode:CullMode.BACK};Object.assign(h,r);const d=controller_shape_1.default.calcConeData(t,e),_=this.createShapeByData(d,c,h);return _.parent=o,_.name="ArrowHead",_.setPosition(new cc_1.Vec3(0,a+e/2,0)),_.addComponent(controller_shape_collider_1.ControllerShapeCollider).isDetectMesh=!1,o}static quad(e,t,a,c=new cc_1.Vec3(0,0,1),r=cc_1.Color.RED,o={}){const n=controller_shape_1.default.calcQuadData(e,t,a,c),l=this.createShapeByData(n,r,o);return l.name="Quad",l}static borderPlane(e,t,a,c){const r=e/2,o=t/2,n=create3DNode("borderPlane"),l=controller_shape_1.default.calcQuadData(new cc_1.Vec3,e,t),s=this.createShapeByData(l,a,{unlit:!0});s.name="Plane",setNodeOpacity(s,c),s.parent=n,s.addComponent(controller_shape_collider_1.ControllerShapeCollider).isDetectMesh=!1;const i=(e,t,a)=>{const c=controller_shape_1.default.calcLineData(e,t),r=this.createShapeByData(c,a,{alpha:200,noDepthTestForLines:!0});return r.name="BorderLine",r.parent=n,r};return i(new cc_1.Vec3(0,t/2,0),new cc_1.Vec3(r,t/2,0),a),i(new cc_1.Vec3(r,o,0),new cc_1.Vec3(r,0,0),a),n}static circle(e,t,a,c){const r=controller_shape_1.default.calcCircleData(e,t,a),o=this.createShapeByData(r,c);return o.name="Circle",o}static torus(e,t,a,c){const r=controller_shape_1.default.torus(e,t,a),o={cullMode:CullMode.BACK},n=this.createShapeByData(r,c,o);n.name="Torus";const l=n.addComponent(controller_shape_collider_1.ControllerShapeCollider);return l.isDetectMesh=!0,l.isRender=!1,n}static cube(e,t,a,c,r={}){const o=controller_shape_1.default.calcCubeData(e,t,a),n={cullMode:CullMode.BACK};Object.assign(n,r);const l=this.createShapeByData(o,c,n);return l.name="Cube",l.addComponent(controller_shape_collider_1.ControllerShapeCollider).isDetectMesh=!1,l}static scaleSlider(e,t,a,c={}){const r=create3DNode("scaleSlider"),o=this.cube(e,e,e,a,c);o.name="ScaleSliderHead",o.parent=r,o.setPosition(0,t+e/2,0);const n={noDepthTestForLines:!0};Object.assign(n,c);const l=controller_shape_1.default.lineWithBoundingBox(t),s=this.createShapeByData(l,a,n);return s.name="ScaleSliderBody",s.parent=r,s.eulerAngles=new cc_1.Vec3(0,0,90),s.addComponent(controller_shape_collider_1.ControllerShapeCollider).isDetectMesh=!1,r}static getCameraDistanceFactor(e,t){const a=NodeUtils.getWorldPosition3D(t);return cc_1.Vec3.distance(e,a)}static lineTo(e,t,a=cc_1.Color.RED,c={}){const r=controller_shape_1.default.calcLineData(e,t),o=this.createShapeByData(r,a,c);return o.name="Line",o}static disc(e,t,a,c=cc_1.Color.RED,r={}){const o=controller_shape_1.default.calcDiscData(e,t,a),n=this.createShapeByData(o,c,r);return n.name="Disc",n}static sector(e,t,a,c,r,o=cc_1.Color.RED,n={}){const l=controller_shape_1.default.calcSectorData(e,t,a,c,r,60),s=this.createShapeByData(l,o,n);return s.name="Sector",s}static arc(e,t,a,c,r,o=cc_1.Color.RED,n={}){const l=controller_shape_1.default.calcArcData(e,t,a,c,r),s=this.createShapeByData(l,o,n);return s.name="Arc",s}static arcDirectionLine(e,t,a,c,r,o,n,l=cc_1.Color.RED){const s=controller_shape_1.default.arcDirectionLine(e,t,a,c,r,o,n),i=this.createShapeByData(s,l);return i.name="ArcDirectionLine",i}static lines(e,t,a=cc_1.Color.RED,c={}){const r=controller_shape_1.default.calcLinesData(e,t),o=this.createShapeByData(r,a,c);return o.name="Lines",o}static wireframeBox(e,t,a,c={}){const r=controller_shape_1.default.wireframeBox(e,t),o=this.createShapeByData(r,a,c);return o.name="WireFrameBox",o}static frustum(e,t,a,c,r,o,n,l={}){const s=controller_shape_1.default.calcFrustum(e,t,a,c,r,o,!0),i=this.createShapeByData(s,n,l);return i.name="Frustum",i}static rectangle(e,t,a,c,r={}){const o=controller_shape_1.default.calcRectangleData(e,t,a),n=this.createShapeByData(o,c,r);return n.name="Rectangle",n}static angle(e,t){const a=Math.sqrt(cc_1.Vec3.lengthSqr(e)*cc_1.Vec3.lengthSqr(t));if(a<EditorMath.EPSILON)return 0;const c=EditorMath.clamp(cc_1.Vec3.dot(e,t)/a,-1,1);return Math.acos(c)*EditorMath.R2D}static sphere(e,t,a,c={}){const r=controller_shape_1.default.calcSphereData(e,t,c),o=this.createShapeByData(r,a,c);return o.name="SphereShape",o}static octahedron(e,t,a,c,r=.2,o,n={}){const l=controller_shape_1.default.calcOctahedronData(e,t,a,c,r),s=this.createShapeByData(l,o,n);return s.name="OctahedronShape",s}static createShapeByData(e,t,a={}){const c=create3DNode(a.name);return addMeshToNode(c,createMesh(e,a),a),setMeshColor(c,t),c}}ControllerUtils.AxisName=AxisName,ControllerUtils.axisDirectionMap={x:new cc_1.Vec3(1,0,0),y:new cc_1.Vec3(0,1,0),z:new cc_1.Vec3(0,0,1),neg_x:new cc_1.Vec3(-1,0,0),neg_y:new cc_1.Vec3(0,-1,0),neg_z:new cc_1.Vec3(0,0,-1)},exports.default=ControllerUtils;