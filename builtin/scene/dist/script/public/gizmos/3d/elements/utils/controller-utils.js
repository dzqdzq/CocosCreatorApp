"use strict";var __importDefault=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(exports,"__esModule",{value:!0});const cc_1=require("cc"),{createMesh:createMesh}=require("../../../utils/engine"),external_1=__importDefault(require("../../../utils/external")),controller_shape_1=__importDefault(require("./controller-shape")),controller_shape_collider_1=require("./controller-shape-collider"),NodeUtils=external_1.default.NodeUtils,{CullMode:CullMode,create3DNode:create3DNode,addMeshToNode:addMeshToNode,setMeshColor:setMeshColor,setNodeOpacity:setNodeOpacity}=require("../../../utils/engine"),EditorMath=external_1.default.EditorMath,MVec3=EditorMath.MVec3;var AxisName;!function(e){e.x="x",e.y="y",e.z="z",e.neg_x="neg_x",e.neg_y="neg_y",e.neg_z="neg_z"}(AxisName||(AxisName={}));class ControllerUtils{static arrow(e,t,a,r,c={}){const o=create3DNode("arrow");let l=5;void 0!==c.bodyBBSize&&null!==c.bodyBBSize&&(l=c.bodyBBSize);const n={alpha:200,noDepthTestForLines:!0};Object.assign(n,c);const s=controller_shape_1.default.calcLineData(new cc_1.Vec3(0,0,0),new cc_1.Vec3(0,a,0)),i=this.createShapeByData(s,r,n);if(i.name="ArrowLine",i.parent=o,setMeshColor(i,r),l>0){let e=controller_shape_1.default.calcCylinderData(l,l,a,n);const t=this.createShapeByData(e,r,n);t.name="ArrowBody",t.parent=o,setNodeOpacity(t,0),t.setPosition(new cc_1.Vec3(0,a/2,0));const c=t.addComponent(controller_shape_collider_1.ControllerShapeCollider);c.isDetectMesh=!0,c.isRender=!1}const d={cullMode:CullMode.BACK};Object.assign(d,c);let h=controller_shape_1.default.calcConeData(t,e);const _=this.createShapeByData(h,r,d);return _.parent=o,_.name="ArrowHead",_.setPosition(new cc_1.Vec3(0,a+e/2,0)),_.addComponent(controller_shape_collider_1.ControllerShapeCollider).isDetectMesh=!1,o}static quad(e,t,a,r=new cc_1.Vec3(0,0,1),c=cc_1.Color.RED,o={}){const l=controller_shape_1.default.calcQuadData(e,t,a,r),n=this.createShapeByData(l,c,o);return n.name="Quad",n}static borderPlane(e,t,a,r){const c=e/2,o=t/2,l=create3DNode("borderPlane"),n=controller_shape_1.default.calcQuadData(new cc_1.Vec3,e,t),s=this.createShapeByData(n,a,{unlit:!0});s.name="Plane",setNodeOpacity(s,r),s.parent=l,s.addComponent(controller_shape_collider_1.ControllerShapeCollider).isDetectMesh=!1;let i=(e,t,a)=>{const r=controller_shape_1.default.calcLineData(e,t),c=this.createShapeByData(r,a,{alpha:200,noDepthTestForLines:!0});return c.name="BorderLine",c.parent=l,c};return i(new cc_1.Vec3(0,t/2,0),new cc_1.Vec3(c,t/2,0),a),i(new cc_1.Vec3(c,o,0),new cc_1.Vec3(c,0,0),a),l}static circle(e,t,a,r){const c=controller_shape_1.default.calcCircleData(e,t,a),o=this.createShapeByData(c,r);return o.name="Circle",o}static torus(e,t,a,r){const c=controller_shape_1.default.torus(e,t,a),o={cullMode:CullMode.BACK},l=this.createShapeByData(c,r,o);l.name="Torus";const n=l.addComponent(controller_shape_collider_1.ControllerShapeCollider);return n.isDetectMesh=!0,n.isRender=!1,l}static cube(e,t,a,r,c={}){const o=controller_shape_1.default.calcCubeData(e,t,a),l={cullMode:CullMode.BACK};Object.assign(l,c);const n=this.createShapeByData(o,r,l);return n.name="Cube",n.addComponent(controller_shape_collider_1.ControllerShapeCollider).isDetectMesh=!1,n}static scaleSlider(e,t,a,r={}){const c=create3DNode("scaleSlider"),o=this.cube(e,e,e,a,r);o.name="ScaleSliderHead",o.parent=c,o.setPosition(0,t+e/2,0);const l={noDepthTestForLines:!0};Object.assign(l,r);const n=controller_shape_1.default.lineWithBoundingBox(t),s=this.createShapeByData(n,a,l);return s.name="ScaleSliderBody",s.parent=c,s.eulerAngles=new cc_1.Vec3(0,0,90),s.addComponent(controller_shape_collider_1.ControllerShapeCollider).isDetectMesh=!1,c}static getCameraDistanceFactor(e,t){const a=NodeUtils.getWorldPosition3D(t);return MVec3.distance(e,a)}static lineTo(e,t,a=cc_1.Color.RED,r={}){const c=controller_shape_1.default.calcLineData(e,t),o=this.createShapeByData(c,a,r);return o.name="Line",o}static disc(e,t,a,r=cc_1.Color.RED,c={}){const o=controller_shape_1.default.calcDiscData(e,t,a),l=this.createShapeByData(o,r,c);return l.name="Disc",l}static sector(e,t,a,r,c,o=cc_1.Color.RED,l={}){const n=controller_shape_1.default.calcSectorData(e,t,a,r,c,60),s=this.createShapeByData(n,o,l);return s.name="Sector",s}static arc(e,t,a,r,c,o=cc_1.Color.RED,l={}){const n=controller_shape_1.default.calcArcData(e,t,a,r,c),s=this.createShapeByData(n,o,l);return s.name="Arc",s}static arcDirectionLine(e,t,a,r,c,o,l,n=cc_1.Color.RED){const s=controller_shape_1.default.arcDirectionLine(e,t,a,r,c,o,l),i=this.createShapeByData(s,n);return i.name="ArcDirectionLine",i}static lines(e,t,a=cc_1.Color.RED,r={}){const c=controller_shape_1.default.calcLinesData(e,t),o=this.createShapeByData(c,a,r);return o.name="Lines",o}static wireframeBox(e,t,a,r={}){const c=controller_shape_1.default.wireframeBox(e,t),o=this.createShapeByData(c,a,r);return o.name="WireFrameBox",o}static frustum(e,t,a,r,c,o,l,n={}){const s=controller_shape_1.default.calcFrustum(e,t,a,r,c,o,!0),i=this.createShapeByData(s,l,n);return i.name="Frustum",i}static rectangle(e,t,a,r,c={}){const o=controller_shape_1.default.calcRectangleData(e,t,a),l=this.createShapeByData(o,r,c);return l.name="Rectangle",l}static angle(e,t){const a=Math.sqrt(MVec3.lengthSqr(e)*MVec3.lengthSqr(t));if(a<EditorMath.EPSILON)return 0;const r=EditorMath.clamp(MVec3.dot(e,t)/a,-1,1);return Math.acos(r)*EditorMath.R2D}static sphere(e,t,a,r={}){let c=controller_shape_1.default.calcSphereData(e,t,r);const o=this.createShapeByData(c,a,r);return o.name="SphereShape",o}static createShapeByData(e,t,a={}){const r=create3DNode(a.name);return addMeshToNode(r,createMesh(e,a),a),setMeshColor(r,t),r}}ControllerUtils.YELLOW=new cc_1.Color(255,255,0),ControllerUtils.AxisName=AxisName,ControllerUtils.axisDirectionMap={x:new cc_1.Vec3(1,0,0),y:new cc_1.Vec3(0,1,0),z:new cc_1.Vec3(0,0,1),neg_x:new cc_1.Vec3(-1,0,0),neg_y:new cc_1.Vec3(0,-1,0),neg_z:new cc_1.Vec3(0,0,-1)},exports.default=ControllerUtils;