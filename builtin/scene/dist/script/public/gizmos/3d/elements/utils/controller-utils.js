"use strict";var __importDefault=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(exports,"__esModule",{value:!0});const cc_1=require("cc"),defines_1=require("../../../defines"),external_1=__importDefault(require("../../../utils/external")),controller_shape_1=__importDefault(require("./controller-shape")),controller_shape_collider_1=require("./controller-shape-collider"),engine_1=__importDefault(require("../../../utils/engine")),NodeUtils=external_1.default.NodeUtils,{CullMode:CullMode,create3DNode:create3DNode,addMeshToNode:addMeshToNode,setMeshColor:setMeshColor,setNodeOpacity:setNodeOpacity,createMesh:createMesh,createDynamicMesh:createDynamicMesh,updateDynamicMesh:updateDynamicMesh}=engine_1.default,EditorMath=external_1.default.EditorMath;var AxisName;!function(e){e.x="x",e.y="y",e.z="z",e.neg_x="neg_x",e.neg_y="neg_y",e.neg_z="neg_z"}(AxisName||(AxisName={}));class ControllerUtils{static arrow(e,t,a,c,r={}){const o=create3DNode("arrow");let n=5;void 0!==r.bodyBBSize&&null!==r.bodyBBSize&&(n=r.bodyBBSize);const l={noDepthTestForLines:!0};Object.assign(l,r);const s=controller_shape_1.default.calcLineData(new cc_1.Vec3(0,0,0),new cc_1.Vec3(0,a,0)),i=this.createShapeByData(s,c,l);if(i.name="ArrowLine",i.parent=o,setMeshColor(i,c),n>0){const e=controller_shape_1.default.calcCylinderData(n,n,a,l),t=this.createShapeByData(e,c,l);t.name="ArrowBody",t.parent=o,setNodeOpacity(t,0),t.setPosition(new cc_1.Vec3(0,a/2,0));const r=t.addComponent(controller_shape_collider_1.ControllerShapeCollider);r.isDetectMesh=!0,r.isRender=!1}const d={cullMode:CullMode.BACK};Object.assign(d,r);const h=controller_shape_1.default.calcConeData(t,e),_=this.createShapeByData(h,c,d);return _.parent=o,_.name="ArrowHead",_.setPosition(new cc_1.Vec3(0,a+e/2,0)),_.addComponent(controller_shape_collider_1.ControllerShapeCollider).isDetectMesh=!1,o}static quad(e,t,a,c=new cc_1.Vec3(0,0,1),r=cc_1.Color.RED,o={}){const n=controller_shape_1.default.calcQuadData(e,t,a,c,o.needBoundingBox),l=this.createShapeByData(n,r,o);return l.name="Quad",l}static borderPlane(e,t,a,c){const r=e/2,o=t/2,n=create3DNode("borderPlane"),l=controller_shape_1.default.calcQuadData(new cc_1.Vec3,e,t),s=this.createShapeByData(l,a,{unlit:!0});s.name="Plane",setNodeOpacity(s,c),s.parent=n,s.addComponent(controller_shape_collider_1.ControllerShapeCollider).isDetectMesh=!1;const i=(e,t,a)=>{const c=controller_shape_1.default.calcLineData(e,t),r=this.createShapeByData(c,a,{alpha:200,noDepthTestForLines:!0});return r.name="BorderLine",r.parent=n,r};return i(new cc_1.Vec3(0,t/2,0),new cc_1.Vec3(r,t/2,0),a),i(new cc_1.Vec3(r,o,0),new cc_1.Vec3(r,0,0),a),n}static circle(e,t,a,c){const r=controller_shape_1.default.calcCircleData(e,t,a),o=this.createShapeByData(r,c);return o.name="Circle",o}static torus(e,t,a,c){const r=controller_shape_1.default.torus(e,t,a),o={cullMode:CullMode.BACK},n=this.createShapeByData(r,c,o);n.name="Torus";const l=n.addComponent(controller_shape_collider_1.ControllerShapeCollider);return l.isDetectMesh=!0,l.isRender=!1,n}static cube(e,t,a,c,r,o={}){var n;const l=controller_shape_1.default.calcCubeData(e,t,a,r);null!==(n=o.cullMode)&&void 0!==n||(o.cullMode=CullMode.BACK);const s=this.createShapeByData(l,c,o);return s.name="Cube",s.addComponent(controller_shape_collider_1.ControllerShapeCollider).isDetectMesh=!1,s}static scaleSlider(e,t,a,c={}){const r=create3DNode("scaleSlider"),o=this.cube(e,e,e,a,void 0,c);o.name="ScaleSliderHead",o.parent=r,o.setPosition(0,t+e/2,0);const n={noDepthTestForLines:!0};Object.assign(n,c);const l=controller_shape_1.default.lineWithBoundingBox(t),s=this.createShapeByData(l,a,n);return s.name="ScaleSliderBody",s.parent=r,s.eulerAngles=new cc_1.Vec3(0,0,90),s.addComponent(controller_shape_collider_1.ControllerShapeCollider).isDetectMesh=!1,r}static getCameraDistanceFactor(e,t){const a=NodeUtils.getWorldPosition3D(t);return cc_1.Vec3.distance(e,a)}static lineTo(e,t,a=cc_1.Color.RED,c={}){const r=controller_shape_1.default.calcLineData(e,t),o=this.createShapeByData(r,a,c);return o.name="Line",o}static disc(e,t,a,c=cc_1.Color.RED,r={}){const o=controller_shape_1.default.calcDiscData(e,t,a),n=this.createShapeByData(o,c,r);return n.name="Disc",n}static sector(e,t,a,c,r,o=cc_1.Color.RED,n={}){const l=controller_shape_1.default.calcSectorData(e,t,a,c,r,60),s=this.createShapeByData(l,o,n);return s.name="Sector",s}static arc(e,t,a,c,r,o=cc_1.Color.RED,n={}){const l=controller_shape_1.default.calcArcData(e,t,a,c,r),s=this.createShapeByData(l,o,n);return s.name="Arc",s}static arcDirectionLine(e,t,a,c,r,o,n,l=cc_1.Color.RED){const s=controller_shape_1.default.arcDirectionLine(e,t,a,c,r,o,n),i=this.createShapeByData(s,l);return i.name="ArcDirectionLine",i}static lines(e,t,a=cc_1.Color.RED,c={}){const r=controller_shape_1.default.calcLinesData(e,t),o=this.createShapeByData(r,a,c);return o.name="Lines",o}static wireframeBox(e,t,a,c={}){const r=controller_shape_1.default.wireframeBox(e,t),o=this.createShapeByData(r,a,c);return o.name="WireFrameBox",o}static frustum(e,t,a,c,r,o,n,l={}){const s=controller_shape_1.default.calcFrustum(e,t,a,c,r,o,!0),i=this.createShapeByData(s,n,l);return i.name="Frustum",i}static rectangle(e,t,a,c,r={}){const o=controller_shape_1.default.calcRectangleData(e,t,a),n=this.createShapeByData(o,c,r);return n.name="Rectangle",n}static angle(e,t){const a=Math.sqrt(cc_1.Vec3.lengthSqr(e)*cc_1.Vec3.lengthSqr(t));if(a<EditorMath.EPSILON)return 0;const c=EditorMath.clamp(cc_1.Vec3.dot(e,t)/a,-1,1);return Math.acos(c)*EditorMath.R2D}static sphere(e,t,a,c={},r){const o=controller_shape_1.default.calcSphereData(e,t,c),n=this.createShapeByData(o,a,c,r);return n.name="SphereShape",n}static octahedron(e,t,a,c,r=.2,o,n={}){const l=controller_shape_1.default.calcOctahedronData(e,t,a,c,r),s=this.createShapeByData(l,o,n);return s.name="OctahedronShape",s}static createShapeByData(e,t,a={},c){const r=create3DNode(a.name);return addMeshToNode(r,createMesh(e,a),a,c),setMeshColor(r,t),r}static create3DNode(e){return create3DNode(e)}static drawLines(e,t,a,c=cc_1.Color.RED){const r=controller_shape_1.default.calcLinesData(t,a);let o=e.getComponent(cc_1.MeshRenderer);o?updateDynamicMesh(o,0,new defines_1.DynamicMeshPrimitive(r)):(addMeshToNode(e,createDynamicMesh(new defines_1.DynamicMeshPrimitive(r),{maxSubMeshes:1,maxSubMeshVertices:1024e3,maxSubMeshIndices:1024e3}),{depthTestForTriangles:!0,priority:127}),o=e.getComponent(cc_1.MeshRenderer)),o.onGeometryChanged(),setMeshColor(e,c)}static findMinPosition(e){return(0,cc_1.v3)(Math.min(...e.map(e=>e.x)),Math.min(...e.map(e=>e.y)),Math.min(...e.map(e=>e.z)))}static findMaxPosition(e){return(0,cc_1.v3)(Math.max(...e.map(e=>e.x)),Math.max(...e.map(e=>e.y)),Math.max(...e.map(e=>e.z)))}}ControllerUtils.AxisName=AxisName,ControllerUtils.axisDirectionMap={x:new cc_1.Vec3(1,0,0),y:new cc_1.Vec3(0,1,0),z:new cc_1.Vec3(0,0,1),neg_x:new cc_1.Vec3(-1,0,0),neg_y:new cc_1.Vec3(0,-1,0),neg_z:new cc_1.Vec3(0,0,-1)},exports.default=ControllerUtils;const flat=(e,t)=>e.map(t).reduce((e,t)=>e.concat(t),[]);