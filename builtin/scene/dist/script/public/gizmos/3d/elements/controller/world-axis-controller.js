"use strict";var __importDefault=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(exports,"__esModule",{value:!0});const controller_base_1=__importDefault(require("./controller-base")),controller_utils_1=__importDefault(require("../utils/controller-utils")),external_1=__importDefault(require("../../../utils/external")),cc_1=require("cc"),misc_1=__importDefault(require("../../../utils/misc")),{setNodeOpacity:setNodeOpacity}=require("../../../utils/engine"),NodeUtils=external_1.default.NodeUtils,EditorCamera=external_1.default.EditorCamera,EditorMath=external_1.default.EditorMath,MVec3=EditorMath.MVec3,axisDirMap=controller_utils_1.default.axisDirectionMap,AxisName=controller_utils_1.default.AxisName,SceneGizmoLayer=cc.Layers.Enum.SCENE_GIZMO,ORTHO=cc_1.Camera.ProjectionType.ORTHO,PERSPECTIVE=cc_1.Camera.ProjectionType.PERSPECTIVE,camera_forward=new cc_1.Vec3(0,0,-1),tempVec3_a=new cc_1.Vec3,tempVec3_b=new cc_1.Vec3,tempQuat_a=new cc_1.Quat;class WorldAxisController extends controller_base_1.default{constructor(e,t){super(e),this._defaultSize=2,this._sceneGizmoCamera=null,this._cameraOffset=new cc_1.Vec3(0,0,40),this._viewDist=40,this._sceneGizmoCamera=t,this.initShape()}createAxis(e,t,a){let r=controller_utils_1.default.arrow(5,2,6,t,{forwardPipeline:!0,bodyBBSize:0});r.name=e+"Axis",r.children.forEach(e=>{e.layer=SceneGizmoLayer}),r.name=e+"Axis",r.parent=this.shape,NodeUtils.setEulerAngles(r,a),this.initHandle(r,e)}initShape(){this.createShapeNode("WorldAxisController"),this.createAxis("x",cc.Color.RED,cc.v3(0,0,-90)),this.createAxis("y",cc.Color.GREEN,cc.v3()),this.createAxis("z",cc.Color.BLUE,cc.v3(90,0,0));const e=new cc.Color(230,230,230);this.createAxis("neg_x",e,cc.v3(0,0,90)),this.createAxis("neg_y",e,cc.v3(0,0,180)),this.createAxis("neg_z",e,cc.v3(-90,0,0));let t=controller_utils_1.default.cube(5,5,5,e,{forwardPipeline:!0});t.name="Center",t.parent=this.shape,t.layer=SceneGizmoLayer,this.initHandle(t,"center"),this.registerCameraMovedEvent(),this.hide()}onMouseUp(e){if("center"===e.handleName)EditorCamera.changeProjection();else{let t=axisDirMap[e.handleName];EditorCamera.rotateCameraToDir(t)}}onHoverIn(e){this.setHandleColor(e.handleName,controller_utils_1.default.YELLOW)}onHoverOut(){this.resetHandleColor()}onEditorCameraMoved(){let e=tempQuat_a;EditorCamera._camera.node.getWorldRotation(e),MVec3.transformQuat(tempVec3_a,camera_forward,e),Object.keys(this._handleDataMap).forEach(e=>{let t=this._handleDataMap[e],a=axisDirMap[e];if(a){let e=255*misc_1.default.LimitLerp(1,0,Math.abs(MVec3.dot(tempVec3_a,a)),.9,1),r=t.rendererNodes;r&&r.forEach((a,r)=>{e<10?a.active=!1:(a.active=!0,setNodeOpacity(a,e),t.oriOpacitys[r]=e)})}});let t=this._sceneGizmoCamera.node;MVec3.transformQuat(tempVec3_b,this._cameraOffset,e),MVec3.add(tempVec3_b,this.getPosition(),tempVec3_b),t.setWorldPosition(tempVec3_b),MVec3.transformQuat(tempVec3_b,MVec3.UNIT_Y,e),MVec3.normalize(tempVec3_b,tempVec3_b),t.lookAt(this.getPosition(),tempVec3_b)}onCameraProjectionChanged(e){if(this._sceneGizmoCamera.projection=e,e===PERSPECTIVE)this._sceneGizmoCamera.node.getWorldRotation(tempQuat_a),MVec3.transformQuat(tempVec3_a,MVec3.UNIT_Z,tempQuat_a),MVec3.normalize(tempVec3_a,tempVec3_a),MVec3.multiplyScalar(tempVec3_a,tempVec3_a,this._viewDist),MVec3.add(tempVec3_a,this.getPosition(),tempVec3_a),this._sceneGizmoCamera.node.setWorldPosition(tempVec3_a);else{let e=this._sceneGizmoCamera._fov,t=Math.tan(e/2*Math.PI/180)*this._viewDist;this._sceneGizmoCamera.orthoHeight=t}}}exports.default=WorldAxisController;