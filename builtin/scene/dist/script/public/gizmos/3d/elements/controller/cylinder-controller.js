"use strict";var __importDefault=this&&this.__importDefault||function(t){return t&&t.__esModule?t:{default:t}};Object.defineProperty(exports,"__esModule",{value:!0});const controller_shape_1=__importDefault(require("../utils/controller-shape")),controller_utils_1=__importDefault(require("../utils/controller-utils")),editable_controller_1=__importDefault(require("./editable-controller")),{AttributeName:AttributeName,setMeshColor:setMeshColor,getModel:getModel,updatePositions:updatePositions}=require("../../../utils/engine"),cc_1=require("cc"),axisDirMap=controller_utils_1.default.axisDirectionMap,AxisName=controller_utils_1.default.AxisName,tempVec3_a=new cc_1.Vec3,tempVec3_b=new cc_1.Vec3,tempVec3_c=new cc_1.Vec3,tempVec3_d=new cc_1.Vec3,tempVec3_e=new cc_1.Vec3,tempQuat_a=new cc_1.Quat;class CylinderController extends editable_controller_1.default{constructor(t){super(t),this._oriDir=cc.v3(0,1,0),this._direction=cc_1.EAxisDirection.Y_AXIS,this._center=cc.v3(),this._radius=100,this._height=100,this._halfHeight=this._height/2,this._deltaRadius=0,this._deltaHeight=0,this._mouseDeltaPos=new cc_1.Vec2,this._curDistScalar=0,this._upperCapMC=[],this._lowerCapMC=[],this._sideLineMC=null,this._upperCapNode=[],this._lowerCapNode=[],this._sideLineNode=null,this._up=new cc_1.Vec3(0,1,0),this._right=new cc_1.Vec3(1,0,0),this._forward=new cc_1.Vec3(0,0,1),this._directionAxis=[new cc_1.Vec3(1,0,0),new cc_1.Vec3(0,1,0),new cc_1.Vec3(0,0,1)],this._editHandleKeys=Object.keys(axisDirMap),this.initShape()}get radius(){return this._radius}set radius(t){this.updateSize(this._center,t,this._height)}get height(){return this._height}set height(t){this.updateSize(this._center,this._radius,t)}get direction(){return this._direction}set direction(t){this._direction=t}setColor(t){this._upperCapNode.forEach(e=>{setMeshColor(e,t)}),this._lowerCapNode.forEach(e=>{setMeshColor(e,t)}),setMeshColor(this._sideLineNode,t),this.setEditHandlesColor(t),this._color=t}_updateEditHandle(t){const e=this._handleDataMap[t].topNode,i=axisDirMap[t],s=tempVec3_a.set(this._directionAxis[this._direction]),c=tempVec3_b;if(c.set(0,0,0),"y"===t)cc_1.Vec3.multiplyScalar(c,s,this._halfHeight);else if("neg_y"===t)cc_1.Vec3.multiplyScalar(c,s,-this._halfHeight);else if(cc_1.Vec3.multiplyScalar(c,i,this._radius),this._direction!==cc_1.EAxisDirection.Y_AXIS){const t=tempQuat_a;cc_1.Quat.rotationTo(t,this._up,s),cc_1.Vec3.transformQuat(c,c,t)}c.add(this._center),cc_1.Vec3.multiply(c,c,this.getScale()),e.setPosition(c)}initShape(){this.createShapeNode("CylinderController"),this.getUpperCapData(this._center,this._radius,this._height).forEach((t,e)=>{this._upperCapNode[e]=controller_utils_1.default.createShapeByData(t,this._color),this._upperCapNode[e].parent=this.shape,this._upperCapMC[e]=getModel(this._upperCapNode[e])}),this.getLowerCapData(this._center,this._radius,this._height).forEach((t,e)=>{this._lowerCapNode[e]=controller_utils_1.default.createShapeByData(t,this._color),this._lowerCapNode[e].parent=this.shape,this._lowerCapMC[e]=getModel(this._lowerCapNode[e])});const t=this.getSideLinesData(this._center,this._radius,this._height);this._sideLineNode=controller_utils_1.default.createShapeByData(t,this._color),this._sideLineNode.parent=this.shape,this._sideLineMC=getModel(this._sideLineNode),this.hide()}updateSize(t,e,i){this._center=t,this._radius=e,this._height=i,this._halfHeight=i/2,this.getUpperCapData(this._center,this._radius,this._height).forEach((t,e)=>{updatePositions(this._upperCapMC[e],t.positions)}),this.getLowerCapData(this._center,this._radius,this._height).forEach((t,e)=>{updatePositions(this._lowerCapMC[e],t.positions)});const s=this.getSideLinesData(this._center,this._radius,this._height);updatePositions(this._sideLineMC,s.positions),this._edit&&this.updateEditHandles(),this.adjustEditHandlesSize()}onMouseDown(t){this._mouseDeltaPos=cc.v2(0,0),this._curDistScalar=super.getDistScalar(),this._deltaRadius=0,this._deltaHeight=0,this.onControllerMouseDown&&this.onControllerMouseDown(t)}onMouseMove(t){if(this._isMouseDown){this._mouseDeltaPos.x+=t.moveDeltaX,this._mouseDeltaPos.y+=t.moveDeltaY;const e=axisDirMap[t.handleName],i=tempVec3_a.set(this._directionAxis[this._direction]),s=tempQuat_a;cc_1.Quat.rotationTo(s,this._up,i),cc_1.Vec3.transformQuat(i,e,s);const c=this.getAlignAxisMoveDistance(this.localToWorldDir(i),this._mouseDeltaPos)*this._curDistScalar;"y"===t.handleName||"neg_y"===t.handleName?this._deltaHeight=c:this._deltaRadius=c,this.onControllerMouseMove&&this.onControllerMouseMove(t)}}onMouseUp(t){this.onControllerMouseUp&&this.onControllerMouseUp(t)}onMouseLeave(t){this.onMouseUp(t)}getDeltaRadius(){return this._deltaRadius}getDeltaHeight(){return this._deltaHeight}getUpperCapData(t,e,i){const s=[],c=i/2,o=cc_1.Vec3.copy(tempVec3_a,this._up),a=cc_1.Vec3.copy(tempVec3_b,this._right),r=cc_1.Vec3.copy(tempVec3_c,this._forward),_=tempVec3_d,h=tempVec3_e.set(0,c,0);if(this._direction!==cc_1.EAxisDirection.Y_AXIS){const t=this._directionAxis[this._direction],e=tempQuat_a;cc_1.Quat.rotationTo(e,this._up,t),cc_1.Vec3.transformQuat(h,h,e),cc_1.Vec3.transformQuat(o,o,e),cc_1.Vec3.transformQuat(a,a,e),cc_1.Vec3.transformQuat(r,r,e)}return cc_1.Vec3.add(_,t,h),s[0]=controller_shape_1.default.calcArcData(_,o,a,this._twoPI,e),s}getLowerCapData(t,e,i){const s=[],c=i/2,o=cc_1.Vec3.copy(tempVec3_a,this._up),a=cc_1.Vec3.copy(tempVec3_b,this._right),r=cc_1.Vec3.copy(tempVec3_c,this._forward),_=tempVec3_d,h=tempVec3_e.set(0,-c,0);if(this._direction!==cc_1.EAxisDirection.Y_AXIS){const t=this._directionAxis[this._direction],e=tempQuat_a;cc_1.Quat.rotationTo(e,this._up,t),cc_1.Vec3.transformQuat(h,h,e),cc_1.Vec3.transformQuat(o,o,e),cc_1.Vec3.transformQuat(a,a,e),cc_1.Vec3.transformQuat(r,r,e)}return cc_1.Vec3.add(_,t,h),s[0]=controller_shape_1.default.calcArcData(_,o,a,this._twoPI,e),s}getSideLinesData(t,e,i){const s=[],c=[],o=i/2;return s.push(new cc_1.Vec3(e,o,0)),s.push(new cc_1.Vec3(e,-o,0)),s.push(new cc_1.Vec3(-e,o,0)),s.push(new cc_1.Vec3(-e,-o,0)),s.push(new cc_1.Vec3(0,o,e)),s.push(new cc_1.Vec3(0,-o,e)),s.push(new cc_1.Vec3(0,o,-e)),s.push(new cc_1.Vec3(0,-o,-e)),s.forEach((e,i)=>{if(this._direction!==cc_1.EAxisDirection.Y_AXIS){const t=this._directionAxis[this._direction],i=tempQuat_a;cc_1.Quat.rotationTo(i,this._up,t),cc_1.Vec3.transformQuat(e,e,i)}cc_1.Vec3.add(e,e,t),c.push(i)}),controller_shape_1.default.calcLinesData(s,c,!1)}}exports.default=CylinderController;