"use strict";var __importDefault=this&&this.__importDefault||function(t){return t&&t.__esModule?t:{default:t}};Object.defineProperty(exports,"__esModule",{value:!0});const controller_shape_1=__importDefault(require("../utils/controller-shape")),controller_utils_1=__importDefault(require("../utils/controller-utils")),editable_controller_1=__importDefault(require("./editable-controller")),{AttributeName:AttributeName,setMeshColor:setMeshColor,getModel:getModel,updatePositions:updatePositions}=require("../../../utils/engine"),cc_1=require("cc"),external_1=__importDefault(require("../../../utils/external")),quat_1=require("../../../../../utils/math/quat"),EditorMath=external_1.default.EditorMath,MVec3=EditorMath.MVec3,axisDirMap=controller_utils_1.default.axisDirectionMap,AxisName=controller_utils_1.default.AxisName,tempVec3_a=new cc_1.Vec3,tempVec3_b=new cc_1.Vec3,tempVec3_c=new cc_1.Vec3,tempVec3_d=new cc_1.Vec3,tempVec3_e=new cc_1.Vec3,tempQuat_a=new cc_1.Quat;class CylinderController extends editable_controller_1.default{constructor(t){super(t),this._oriDir=cc.v3(0,1,0),this._direction=cc_1.EAxisDirection.Y_AXIS,this._center=cc.v3(),this._radius=100,this._height=100,this._halfHeight=this._height/2,this._deltaRadius=0,this._deltaHeight=0,this._mouseDeltaPos=new cc_1.Vec2,this._curDistScalar=0,this._upperCapMC=[],this._lowerCapMC=[],this._sideLineMC=null,this._upperCapNode=[],this._lowerCapNode=[],this._sideLineNode=null,this._up=new cc_1.Vec3(0,1,0),this._right=new cc_1.Vec3(1,0,0),this._forward=new cc_1.Vec3(0,0,1),this._directionAxis=[new cc_1.Vec3(1,0,0),new cc_1.Vec3(0,1,0),new cc_1.Vec3(0,0,1)],this._editHandleKeys=Object.keys(axisDirMap),this.initShape()}get radius(){return this._radius}set radius(t){this.updateSize(this._center,t,this._height)}get height(){return this._height}set height(t){this.updateSize(this._center,this._radius,t)}get direction(){return this._direction}set direction(t){this._direction=t}setColor(t){this._upperCapNode.forEach(e=>{setMeshColor(e,t)}),this._lowerCapNode.forEach(e=>{setMeshColor(e,t)}),setMeshColor(this._sideLineNode,t),this.setEditHandlesColor(t),this._color=t}_updateEditHandle(t){const e=this._handleDataMap[t].topNode,i=axisDirMap[t],s=tempVec3_a.set(this._directionAxis[this._direction]),a=tempVec3_b;if(a.set(0,0,0),"y"===t)MVec3.multiplyScalar(a,s,this._halfHeight);else if("neg_y"===t)MVec3.multiplyScalar(a,s,-this._halfHeight);else if(MVec3.multiplyScalar(a,i,this._radius),this._direction!==cc_1.EAxisDirection.Y_AXIS){const t=tempQuat_a;quat_1.MQuat.rotationTo(t,this._up,s),MVec3.transformQuat(a,a,t)}a.add(this._center),MVec3.multiply(a,a,this.getScale()),e.setPosition(a)}initShape(){this.createShapeNode("CylinderController"),this.getUpperCapData(this._center,this._radius,this._height).forEach((t,e)=>{this._upperCapNode[e]=controller_utils_1.default.createShapeByData(t,this._color),this._upperCapNode[e].parent=this.shape,this._upperCapMC[e]=getModel(this._upperCapNode[e])}),this.getLowerCapData(this._center,this._radius,this._height).forEach((t,e)=>{this._lowerCapNode[e]=controller_utils_1.default.createShapeByData(t,this._color),this._lowerCapNode[e].parent=this.shape,this._lowerCapMC[e]=getModel(this._lowerCapNode[e])});const t=this.getSideLinesData(this._center,this._radius,this._height);this._sideLineNode=controller_utils_1.default.createShapeByData(t,this._color),this._sideLineNode.parent=this.shape,this._sideLineMC=getModel(this._sideLineNode),this.hide()}updateSize(t,e,i){this._center=t,this._radius=e,this._height=i,this._halfHeight=i/2,this.getUpperCapData(this._center,this._radius,this._height).forEach((t,e)=>{updatePositions(this._upperCapMC[e],t.positions)}),this.getLowerCapData(this._center,this._radius,this._height).forEach((t,e)=>{updatePositions(this._lowerCapMC[e],t.positions)});const s=this.getSideLinesData(this._center,this._radius,this._height);updatePositions(this._sideLineMC,s.positions),this._edit&&this.updateEditHandles(),this.adjustEditHandlesSize()}onMouseDown(t){this._mouseDeltaPos=cc.v2(0,0),this._curDistScalar=super.getDistScalar(),this._deltaRadius=0,this._deltaHeight=0,this.onControllerMouseDown&&this.onControllerMouseDown(t)}onMouseMove(t){if(this._isMouseDown){this._mouseDeltaPos.x+=t.moveDeltaX,this._mouseDeltaPos.y+=t.moveDeltaY;const e=axisDirMap[t.handleName],i=tempVec3_a.set(this._directionAxis[this._direction]),s=tempQuat_a;quat_1.MQuat.rotationTo(s,this._up,i),MVec3.transformQuat(i,e,s);const a=this.getAlignAxisMoveDistance(this.localToWorldDir(i),this._mouseDeltaPos)*this._curDistScalar;"y"===t.handleName||"neg_y"===t.handleName?this._deltaHeight=a:this._deltaRadius=a,this.onControllerMouseMove&&this.onControllerMouseMove(t)}}onMouseUp(t){this.onControllerMouseUp&&this.onControllerMouseUp(t)}onMouseLeave(t){this.onMouseUp(t)}getDeltaRadius(){return this._deltaRadius}getDeltaHeight(){return this._deltaHeight}getUpperCapData(t,e,i){const s=[],a=i/2,o=MVec3.copy(tempVec3_a,this._up),r=MVec3.copy(tempVec3_b,this._right),c=MVec3.copy(tempVec3_c,this._forward),h=tempVec3_d,_=tempVec3_e.set(0,a,0);if(this._direction!==cc_1.EAxisDirection.Y_AXIS){const t=this._directionAxis[this._direction],e=tempQuat_a;quat_1.MQuat.rotationTo(e,this._up,t),MVec3.transformQuat(_,_,e),MVec3.transformQuat(o,o,e),MVec3.transformQuat(r,r,e),MVec3.transformQuat(c,c,e)}return MVec3.add(h,t,_),s[0]=controller_shape_1.default.calcArcData(h,o,r,this._twoPI,e),s}getLowerCapData(t,e,i){const s=[],a=i/2,o=MVec3.copy(tempVec3_a,this._up),r=MVec3.copy(tempVec3_b,this._right),c=MVec3.copy(tempVec3_c,this._forward),h=tempVec3_d,_=tempVec3_e.set(0,-a,0);if(this._direction!==cc_1.EAxisDirection.Y_AXIS){const t=this._directionAxis[this._direction],e=tempQuat_a;quat_1.MQuat.rotationTo(e,this._up,t),MVec3.transformQuat(_,_,e),MVec3.transformQuat(o,o,e),MVec3.transformQuat(r,r,e),MVec3.transformQuat(c,c,e)}return MVec3.add(h,t,_),s[0]=controller_shape_1.default.calcArcData(h,o,r,this._twoPI,e),s}getSideLinesData(t,e,i){const s=[],a=[],o=i/2;return s.push(new cc_1.Vec3(e,o,0)),s.push(new cc_1.Vec3(e,-o,0)),s.push(new cc_1.Vec3(-e,o,0)),s.push(new cc_1.Vec3(-e,-o,0)),s.push(new cc_1.Vec3(0,o,e)),s.push(new cc_1.Vec3(0,-o,e)),s.push(new cc_1.Vec3(0,o,-e)),s.push(new cc_1.Vec3(0,-o,-e)),s.forEach((e,i)=>{if(this._direction!==cc_1.EAxisDirection.Y_AXIS){const t=this._directionAxis[this._direction],i=tempQuat_a;quat_1.MQuat.rotationTo(i,this._up,t),MVec3.transformQuat(e,e,i)}MVec3.add(e,e,t),a.push(i)}),controller_shape_1.default.calcLinesData(s,a,!1)}}exports.default=CylinderController;