"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.TerrainImageBrush=exports.TerrainCircleBrush=exports.eTerrainCircleBrushType=exports.TerrainBrushData=exports.TerrainBrush=exports.TerrainBrushType=void 0;const cc_1=require("cc");var TerrainBrushType,eTerrainCircleBrushType;!function(e){e[e.CIRCLE=0]="CIRCLE",e[e.IMAGE=1]="IMAGE",e[e._MAX=2]="_MAX"}(TerrainBrushType=exports.TerrainBrushType||(exports.TerrainBrushType={}));class TerrainBrush{constructor(){this.material=null,this.position=new cc_1.Vec3(0,0,0),this.radius=5,this.strength=1}getDelta(e,t){return 0}update(e,t){this.position=t}}exports.TerrainBrush=TerrainBrush;class TerrainBrushData{constructor(){this.bmin=[0,0],this.bmax=[0,0]}width(){return this.bmax[0]-this.bmax[0]+1}height(){return this.bmax[1]-this.bmax[1]+1}}exports.TerrainBrushData=TerrainBrushData,function(e){e[e.Linear=0]="Linear",e[e.Smooth=1]="Smooth",e[e.Spherical=2]="Spherical",e[e.Tip=3]="Tip"}(eTerrainCircleBrushType=exports.eTerrainCircleBrushType||(exports.eTerrainCircleBrushType={}));class TerrainCircleBrush extends TerrainBrush{constructor(){super(),this.type=eTerrainCircleBrushType.Linear,this.falloff=.5,this._updateMaterial()}setType(e){this.type!==e&&(this.type=e,this._updateMaterial())}getType(){return this.type}_updateMaterial(){const e=cc.EffectAsset.get("editor/terrain-circle-brush");null!=e&&(this.material=new cc_1.Material,this.material.initialize({effectAsset:e,defines:this._getTypeDefine()}))}_getTypeDefine(){switch(this.type){case eTerrainCircleBrushType.Linear:return{LINEAR:1};case eTerrainCircleBrushType.Smooth:return{SMOOTH:1};case eTerrainCircleBrushType.Spherical:return{SPHERICAL:1};case eTerrainCircleBrushType.Tip:return{TIP:1}}return{LINEAR:1}}static _calculateFalloff_Linear(e,t,r){return e<=t?1:e>t+r?0:Math.max(0,1-(e-t)/r)}static _calculateFalloff_Spherical(e,t,r){const i=this._calculateFalloff_Linear(e,t,r);return i*i*(3-2*i)}static _calculateFalloff_Smooth(e,t,r){if(e<=t)return 1;if(e>t+r)return 0;const i=(e-t)/r;return Math.sqrt(1-i*i)}static _calculateFalloff_Tip(e,t,r){if(e<=t)return 1;if(e>t+r)return 0;const i=(r+t-e)/r;return 1-Math.sqrt(1-i*i)}getDelta(e,t){const r=e-this.position.x,i=t-this.position.z,a=Math.sqrt(r*r+i*i),s=(1-this.falloff)*this.radius,h=this.falloff*this.radius;let l=0;switch(this.type){case eTerrainCircleBrushType.Linear:l=TerrainCircleBrush._calculateFalloff_Linear(a,s,h);break;case eTerrainCircleBrushType.Smooth:l=TerrainCircleBrush._calculateFalloff_Smooth(a,s,h);break;case eTerrainCircleBrushType.Spherical:l=TerrainCircleBrush._calculateFalloff_Spherical(a,s,h);break;case eTerrainCircleBrushType.Tip:l=TerrainCircleBrush._calculateFalloff_Tip(a,s,h)}return l*this.strength}update(e,t){if(super.update(e,t),null!=this.material){const r=(1-this.falloff)*this.radius,i=this.falloff*this.radius,a=new cc_1.Vec3;cc_1.Vec3.add(a,e.node.getWorldPosition(),t);const s=new cc_1.Vec4;s.x=r,s.y=i;for(let t=0;t<e.blockCount[0];++t)for(let r=0;r<e.blockCount[1];++r){const i=e.getBlock(t,r);if(i._getBrushMaterial()!=this.material)continue;if(null==i._getBrushPass())continue;const h=i.material;null!=h&&(h.setProperty("BrushPos",a),h.setProperty("BrushParams",s))}}}}exports.TerrainCircleBrush=TerrainCircleBrush;class TerrainImageBrush extends TerrainBrush{constructor(){super(),this._image=null,this._pixelData=null;const e=cc.EffectAsset.get("editor/terrain-image-brush");null!=e&&(this.material=new cc_1.Material,this.material.initialize({effectAsset:e}))}set image(e){if(this._image==e)return;if(this._image=e,this._pixelData=null,null===this._image)return;const t=document.createElement("canvas"),r=t.getContext("2d");if(null===r)return;t.width=this._image.width,t.height=this._image.height;const i=this._image.mipmaps[0].data;r.drawImage(i,0,0,this._image.width,this._image.height);const a=r.getImageData(0,0,this._image.width,this._image.height);this._pixelData=new Array,this._pixelData.length=this._image.width*this._image.height;for(let e=0;e<this._pixelData.length;++e)this._pixelData[e]=a.data[4*e+0]/255}get image(){return this._image}static getColor(e,t,r,i,a){return i=cc_1.clamp(i,0,t-1),e[(a=cc_1.clamp(a,0,r-1))*t+i]}static sampleImage(e,t,r,i,a){i*=t-1,a*=r-1;const s=Math.floor(i),h=Math.floor(a),l=s+1,n=h+1,c=i-s,u=a-h,o=this.getColor(e,t,r,s,h),p=this.getColor(e,t,r,l,h),T=this.getColor(e,t,r,s,n),g=o+(p-o)*c;return g+(T+(this.getColor(e,t,r,l,n)-T)*c-g)*u}sample(e,t){return null===this._pixelData||null===this._image?1:TerrainImageBrush.sampleImage(this._pixelData,this._image.width,this._image.height,e,t)}getDelta(e,t){const r=this.position.x-e,i=this.position.z-t,a=r/this.radius*.5+.5,s=i/this.radius*.5+.5;return a<0||a>1||s<0||s>1?0:this.sample(a,s)*this.strength}update(e,t){if(super.update(e,t),null!==this.material){const r=this.radius,i=1,a=new cc_1.Vec3;cc_1.Vec3.add(a,e.node.getWorldPosition(),t);const s=new cc_1.Vec4;s.x=r,s.y=i;for(let t=0;t<e.blockCount[0];++t)for(let r=0;r<e.blockCount[1];++r){const i=e.getBlock(t,r);if(i._getBrushMaterial()!=this.material)continue;if(null==i._getBrushPass())continue;const h=i.material;null!=h&&(h.setProperty("BrushPos",a),h.setProperty("BrushParams",s),null!==this._image?h.setProperty("BrushImage",this._image):h.setProperty("BrushImage",cc_1.builtinResMgr.get("grey-texture")))}}}}exports.TerrainImageBrush=TerrainImageBrush;