"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.TerrainImageBrush=exports.TerrainCircleBrush=exports.eTerrainCircleBrushType=exports.TerrainBrushData=exports.TerrainBrush=exports.TerrainEdModifierKeyState=exports.TerrainBrushType=void 0;const cc_1=require("cc");var TerrainBrushType,eTerrainCircleBrushType;!function(t){t[t.CIRCLE=0]="CIRCLE",t[t.IMAGE=1]="IMAGE",t[t._MAX=2]="_MAX"}(TerrainBrushType=exports.TerrainBrushType||(exports.TerrainBrushType={}));class TerrainEdModifierKeyState{constructor(){this.siftPressed=!1}}exports.TerrainEdModifierKeyState=TerrainEdModifierKeyState;class TerrainBrush{constructor(){this.material=null,this.position=new cc_1.Vec3(0,0,0),this.radius=5,this.strength=1,this._setHeight=0,this._rotation=0}get rotation(){return this._rotation/180*Math.PI}getDelta(t,e){return 0}getBound(t,e){const i=this.position.x-this.radius,r=this.position.z-this.radius,a=this.position.x+this.radius,s=this.position.z+this.radius;t.x=i,t.y=r,e.x=a,e.y=s}update(t,e){this.position=e}}exports.TerrainBrush=TerrainBrush;class TerrainBrushData{constructor(){this.bmin=[0,0],this.bmax=[0,0]}width(){return this.bmax[0]-this.bmax[0]+1}height(){return this.bmax[1]-this.bmax[1]+1}}exports.TerrainBrushData=TerrainBrushData,function(t){t[t.Linear=0]="Linear",t[t.Smooth=1]="Smooth",t[t.Spherical=2]="Spherical",t[t.Tip=3]="Tip"}(eTerrainCircleBrushType=exports.eTerrainCircleBrushType||(exports.eTerrainCircleBrushType={}));class TerrainCircleBrush extends TerrainBrush{constructor(){super(),this.type=eTerrainCircleBrushType.Linear,this.falloff=.5,this._updateMaterial()}setType(t){this.type!==t&&(this.type=t,this._updateMaterial())}getType(){return this.type}_updateMaterial(){const t=cc.EffectAsset.get("internal/editor/terrain-circle-brush");null!=t&&(this.material=new cc_1.Material,this.material.initialize({effectAsset:t,defines:this._getTypeDefine()}))}_getTypeDefine(){switch(this.type){case eTerrainCircleBrushType.Linear:return{LINEAR:1};case eTerrainCircleBrushType.Smooth:return{SMOOTH:1};case eTerrainCircleBrushType.Spherical:return{SPHERICAL:1};case eTerrainCircleBrushType.Tip:return{TIP:1}}}static _calculateFalloff_Linear(t,e,i){return t<=e?1:t>e+i?0:Math.max(0,1-(t-e)/i)}static _calculateFalloff_Spherical(t,e,i){const r=this._calculateFalloff_Linear(t,e,i);return r*r*(3-2*r)}static _calculateFalloff_Smooth(t,e,i){if(t<=e)return 1;if(t>e+i)return 0;const r=(t-e)/i;return Math.sqrt(1-r*r)}static _calculateFalloff_Tip(t,e,i){if(t<=e)return 1;if(t>e+i)return 0;const r=(i+e-t)/i;return 1-Math.sqrt(1-r*r)}getDelta(t,e){const i=t-this.position.x,r=e-this.position.z,a=Math.sqrt(i*i+r*r),s=(1-this.falloff)*this.radius,h=this.falloff*this.radius;let n=0;switch(this.type){case eTerrainCircleBrushType.Linear:n=TerrainCircleBrush._calculateFalloff_Linear(a,s,h);break;case eTerrainCircleBrushType.Smooth:n=TerrainCircleBrush._calculateFalloff_Smooth(a,s,h);break;case eTerrainCircleBrushType.Spherical:n=TerrainCircleBrush._calculateFalloff_Spherical(a,s,h);break;case eTerrainCircleBrushType.Tip:n=TerrainCircleBrush._calculateFalloff_Tip(a,s,h)}return n*this.strength}update(t,e){if(super.update(t,e),null!=this.material){const i=(1-this.falloff)*this.radius,r=this.falloff*this.radius,a=new cc_1.Vec4,s=new cc_1.Vec4;a.x=t.node.getWorldPosition().x+e.x,a.y=t.node.getWorldPosition().y+e.y,a.z=t.node.getWorldPosition().z+e.z,s.x=i,s.y=r;for(let e=0;e<t.blockCount[0];++e)for(let i=0;i<t.blockCount[1];++i){const r=t.getBlock(e,i);if(r._getBrushMaterial()!=this.material)continue;if(null==r._getBrushPass())continue;const h=r.material;null!=h&&(h.setProperty("BrushPos",a),h.setProperty("BrushParams",s))}}}}exports.TerrainCircleBrush=TerrainCircleBrush;class TerrainImageBrush extends TerrainBrush{constructor(){super(),this._image=null,this._pixelData=null;const t=cc.EffectAsset.get("internal/editor/terrain-image-brush");null!=t&&(this.material=new cc_1.Material,this.material.initialize({effectAsset:t}))}set image(t){if(this._image==t)return;if(this._image=t,this._pixelData=null,null===this._image)return;const e=document.createElement("canvas"),i=e.getContext("2d");if(!i)return;e.width=this._image.width,e.height=this._image.height;const r=this._image.mipmaps[0].data,a=r._src;if(a){const t=document.createElement("img");t.addEventListener("load",()=>{document.body.removeChild(t),i.drawImage(t,0,0,t.width,t.height);const e=i.getImageData(0,0,t.width,t.height);this._pixelData=new Array,this._pixelData.length=t.width*t.height;for(let t=0;t<this._pixelData.length;++t)this._pixelData[t]=e.data[4*t+0]/255}),t.addEventListener("error",()=>{document.body.removeChild(t)}),t.src=`file://${a}`,t.style.display="none",document.body.appendChild(t)}else{i.drawImage(r,0,0,this._image.width,this._image.height);const t=i.getImageData(0,0,this._image.width,this._image.height);this._pixelData=new Array,this._pixelData.length=this._image.width*this._image.height;for(let e=0;e<this._pixelData.length;++e)this._pixelData[e]=t.data[4*e+0]/255}}get image(){return this._image}static getColor(t,e,i,r,a){return r=(0,cc_1.clamp)(r,0,e-1),t[(a=(0,cc_1.clamp)(a,0,i-1))*e+r]}static sampleImage(t,e,i,r,a){r*=e-1,a*=i-1;const s=Math.floor(r),h=Math.floor(a),n=s+1,o=h+1,l=r-s,c=a-h,u=this.getColor(t,e,i,s,h),p=this.getColor(t,e,i,n,h),m=this.getColor(t,e,i,s,o),d=u+(p-u)*l;return d+(m+(this.getColor(t,e,i,n,o)-m)*l-d)*c}sample(t,e){return null===this._pixelData||null===this._image?1:TerrainImageBrush.sampleImage(this._pixelData,this._image.width,this._image.height,t,e)}getDelta(t,e){let i=this.position.x-t,r=this.position.z-e;if(0!=this.rotation){const t=Math.sin(this.rotation),e=Math.cos(this.rotation),a=i*-t+r*e;i=i*e+r*t,r=a}const a=i/this.radius*.5+.5,s=r/this.radius*.5+.5;return a<0||a>1||s<0||s>1?0:this.sample(a,s)*this.strength}getBound(t,e){const i=-this.radius,r=-this.radius,a=this.radius,s=this.radius;if(0!=this.rotation){const h=Math.sin(this.rotation),n=Math.cos(this.rotation),o=n,l=-h,c=h,u=n,p=new cc_1.Vec2;p.x=i*o+r*l,p.y=i*c+r*u;const m=new cc_1.Vec2;m.x=a*o+r*l,m.y=a*c+r*u;const d=new cc_1.Vec2;d.x=a*o+r*l,d.y=a*c+r*u;const g=new cc_1.Vec2;g.x=a*o+s*l,g.y=a*c+s*u,t.x=p.x,t.y=p.y,t.x=Math.min(t.x,d.x),t.y=Math.min(t.y,d.y),t.x=Math.min(t.x,m.x),t.y=Math.min(t.y,m.y),t.x=Math.min(t.x,g.x),t.y=Math.min(t.y,g.y),e.x=p.x,e.y=p.y,e.x=Math.max(e.x,d.x),e.y=Math.max(e.y,d.y),e.x=Math.max(e.x,m.x),e.y=Math.max(e.y,m.y),e.x=Math.max(e.x,g.x),e.y=Math.max(e.y,g.y)}t.x=i+this.position.x,t.y=r+this.position.z,e.x=a+this.position.x,e.y=s+this.position.z}update(t,e){if(super.update(t,e),null!==this.material){const i=this.radius,r=1,a=new cc_1.Vec4,s=new cc_1.Vec4;a.x=t.node.getWorldPosition().x+e.x,a.y=t.node.getWorldPosition().y+e.y,a.z=t.node.getWorldPosition().z+e.z,s.x=i,s.y=r,s.z=this.rotation;for(let e=0;e<t.blockCount[0];++e)for(let i=0;i<t.blockCount[1];++i){const r=t.getBlock(e,i);if(r._getBrushMaterial()!=this.material)continue;if(null==r._getBrushPass())continue;const h=r.material;null!=h&&(h.setProperty("BrushPos",a),h.setProperty("BrushParams",s),null!==this._image?h.setProperty("BrushImage",this._image):h.setProperty("BrushImage",cc_1.builtinResMgr.get("grey-texture")))}}}}exports.TerrainImageBrush=TerrainImageBrush;