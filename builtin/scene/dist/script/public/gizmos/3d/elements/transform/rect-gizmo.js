"use strict";var __importDefault=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(exports,"__esModule",{value:!0});const Utils=require("../../../utils"),external_1=__importDefault(require("../../../utils/external")),cc_1=require("cc"),NodeUtils=external_1.default.NodeUtils,EditorMath=external_1.default.EditorMath,transform_gizmo_1=__importDefault(require("./transform-gizmo")),rectangle_controller_1=require("../controller/rectangle-controller"),rect_transform_snapping_1=require("../../../utils/rect-transform-snapping"),lines_controller_1=__importDefault(require("../controller/lines-controller")),transform_tool_data_1=require("../../../utils/transform-tool-data"),tempVec2=new cc_1.Vec2,tempVec3=new cc_1.Vec3,tempMat4=new cc_1.Mat4,tempQuat_a=new cc_1.Quat;function boundsToRect(e){return new cc_1.Rect(e[1].x,e[1].y,e[3].x-e[1].x,e[3].y-e[1].y)}class RectGizmo extends transform_gizmo_1.default{constructor(){super(...arguments),this._worldPosList=[],this._localPosList=[],this._sizeList=[],this._anchorList=[],this._rectList=[],this._validTarget=[],this._tempRect=new cc_1.Rect,this._editRect=new cc_1.Rect,this._altKey=!1,this._snapDistVec2=new cc_1.Vec2}init(){this.createController()}layer(){return"foreground"}createController(){const e=this.getGizmoRoot(),t=new rectangle_controller_1.RectangleController(e,{needAnchor:!0});t.editable=!0,t.setColor(new cc.Color(0,153,255)),t.setEditHandlesColor(new cc.Color(0,153,255)),t.onControllerMouseDown=this.onControllerMouseDown.bind(this),t.onControllerMouseMove=this.onControllerMouseMove.bind(this),t.onControllerMouseUp=this.onControllerMouseUp.bind(this),this._controller=t,this._nodeSnapLinesCtrl=new lines_controller_1.default(e),this._canvasSnapLinesCtrl=new lines_controller_1.default(e),this._equalSpacingLinesCtrl=new lines_controller_1.default(e,{dashed:!0})}onControllerMouseDown(){this._worldPosList.length=0,this._localPosList.length=0,this._sizeList.length=0,this._anchorList.length=0,this._rectList.length=0,this._validTarget.length=0;for(let e=0;e<this.target.length;e++){const t=this.target[e],n=t.getComponent(cc_1.UITransform);n&&(this._validTarget.push(n),this._worldPosList.push(NodeUtils.getWorldPosition3D(t)),this._localPosList.push(t.getPosition()),this._sizeList.push(n.contentSize.clone()),this._anchorList.push(n.anchorPoint.clone()),this._rectList.push(NodeUtils.getWorldBounds(t)))}const e=this._validTarget.map(e=>e.node),t=this.getBounds(!1,!1,e);this._tempRect=boundsToRect(t);const n=transform_tool_data_1.transformToolData.scale2D,i=rect_transform_snapping_1.rectTransformSnapping.snapThreshold/n;if(this._snapDistVec2.x=i,this._snapDistVec2.y=i,rect_transform_snapping_1.rectTransformSnapping.enableSnapping){const e=this.target[0];e&&(rect_transform_snapping_1.rectTransformSnapping.calculateNodeSnapGuidelines(e.parent,e),rect_transform_snapping_1.rectTransformSnapping.calculateCanvasSnapGuidelines(),rect_transform_snapping_1.rectTransformSnapping.calculateSpacingSnapGuidelines(e.parent,e))}}onControllerMouseMove(){this.updateDataFromController()}onControllerMouseUp(){this._controller.updated&&this.onControlEnd("position"),this.clearNodeSnappingGuideline(),this.clearCanvasSnappingGuideline(),this.clearEqualSpacingGuideline()}onGizmoKeyDown(e){this._altKey=e.altKey}onGizmoKeyUp(e){this._altKey=e.altKey}handleAreaMove(e){for(let t=0;t<this._validTarget.length;t++){const n=this._validTarget[t].node,i=(this._localPosList[t],this._worldPosList[t]);let o=new cc_1.Vec3;if(cc_1.Vec3.add(o,i,e),0===t&&rect_transform_snapping_1.rectTransformSnapping.enableSnapping){const e=this._rectList[t];o=rect_transform_snapping_1.rectTransformSnapping.snapPosToNodeGuidelines(o,e,this._snapDistVec2),this.drawNodeSnappingGuideline(),o=rect_transform_snapping_1.rectTransformSnapping.snapPosToCanvasSnapGuidelines(o,e,this._snapDistVec2),this.drawCanvasSnappingGuideline(),o=rect_transform_snapping_1.rectTransformSnapping.snapPosToEqualSpacing(o,e,this._snapDistVec2),this.drawEqualSpacingGuideline()}o.x=EditorMath.toPrecision(o.x,3),o.y=EditorMath.toPrecision(o.y,3),NodeUtils.setWorldPosition(n,o)}}handleAnchorMove(e){if(this._validTarget.length>1)return;const t=this._validTarget[0],n=t.node,i=this._sizeList[0],o=this._anchorList[0],r=this._worldPosList[0],s=e.clone();NodeUtils.makeVec3InPrecision(s,3),tempVec3.set(r),tempVec3.add(s),n.setWorldPosition(tempVec3),n.getWorldMatrix(tempMat4),cc_1.Mat4.invert(tempMat4,tempMat4),tempMat4.m12=tempMat4.m13=0,cc_1.Vec3.transformMat4(s,s,tempMat4),tempVec2.x=s.x/i.width,tempVec2.y=s.y/i.height,tempVec2.add(o),t.anchorPoint=tempVec2}getSizePoint(e){const t=new cc.Vec2,n=this._rectList[0];return e===rectangle_controller_1.RectHandleType.Right||e===rectangle_controller_1.RectHandleType.TopRight||e===rectangle_controller_1.RectHandleType.BottomRight?t.x=n.x+n.width:t.x=n.x,e===rectangle_controller_1.RectHandleType.BottomLeft||e===rectangle_controller_1.RectHandleType.Bottom||e===rectangle_controller_1.RectHandleType.BottomRight?t.y=n.y:t.y=n.y+n.height,t}modifyPosDeltaWithAnchor(e,t,n,i,o){e===rectangle_controller_1.RectHandleType.Right||e===rectangle_controller_1.RectHandleType.TopRight||e===rectangle_controller_1.RectHandleType.BottomRight?(o&&(n.x/=1-i.x),t.x=n.x*i.x):(o&&(n.x/=i.x),t.x=-n.x*(1-i.x)),e===rectangle_controller_1.RectHandleType.Bottom||e===rectangle_controller_1.RectHandleType.BottomRight||e===rectangle_controller_1.RectHandleType.BottomLeft?(o&&(n.y/=i.y),t.y=-n.y*(1-i.y)):(o&&(n.y/=1-i.y),t.y=n.y*i.y)}formatSizeDelta(e,t){e!==rectangle_controller_1.RectHandleType.Left&&e!==rectangle_controller_1.RectHandleType.TopLeft&&e!==rectangle_controller_1.RectHandleType.BottomLeft||(t.x=-t.x),e!==rectangle_controller_1.RectHandleType.Bottom&&e!==rectangle_controller_1.RectHandleType.BottomRight&&e!==rectangle_controller_1.RectHandleType.BottomLeft||(t.y=-t.y)}handleOneTargetSize(e,t,n){const i=this._sizeList[0],o=t.clone();let r=new cc_1.Vec2(t.x,t.y);const s=this._localPosList[0],a=this._validTarget[0],c=a.node,l=this._anchorList[0];if(rect_transform_snapping_1.rectTransformSnapping.enableSnapping&&(this.formatSizeDelta(e,r),r=rect_transform_snapping_1.rectTransformSnapping.snapSizeToNodeGuidelines(this.getSizePoint(e),r,this._snapDistVec2),this.formatSizeDelta(e,r),this.drawNodeSnappingGuideline()),r.x=EditorMath.toPrecision(r.x,3),r.y=EditorMath.toPrecision(r.y,3),this.modifyPosDeltaWithAnchor(e,o,r,l,n),c.parent&&(c.parent.getWorldMatrix(tempMat4),cc_1.Mat4.invert(tempMat4,tempMat4),tempMat4.m12=tempMat4.m13=0,cc_1.Vec3.transformMat4(o,o,tempMat4)),!n){const e=tempQuat_a;c.getRotation(e),cc_1.Vec3.transformQuat(o,o,e),o.z=0,tempVec3.set(s),tempVec3.add(o),c.setPosition(tempVec3)}const h=new cc_1.Vec3;c.getWorldScale(h),r.x=r.x/h.x,r.y=r.y/h.y;const p=i.width+r.x,_=i.height+r.y;a.contentSize=cc.size(p,_)}handleMultiTargetSize(e,t,n){const i=this._tempRect,o=new cc_1.Vec2(t.x,t.y),r=t.clone(),s=new cc_1.Vec2(0,0);o.x=EditorMath.toPrecision(o.x,3),o.y=EditorMath.toPrecision(o.y,3),this.modifyPosDeltaWithAnchor(e,r,o,s,!1);const a=i.clone();a.x=i.x+r.x,a.y=i.y+r.y,a.width=i.width+o.x,a.height=i.height+o.y,this._editRect=a;for(let e=0,t=this._validTarget.length;e<t;e++){const t=this._validTarget[e],n=t.node,r=this._worldPosList[e],s=(r.x-i.x)/i.width,c=(r.y-i.y)/i.height,l=new cc_1.Vec3(a.x+s*a.width,a.y+c*a.height,r.z);n.setWorldPosition(l);const h=this._rectList[e],p=h.width/i.width,_=h.height/i.height,d=this._sizeList[e],u=o.clone();u.x=u.x*p,u.y=u.y*_;const g=new cc_1.Vec3;n.getWorldScale(g),u.x=u.x/g.x,u.y=u.y/g.y,t.contentSize=cc.size(d.width+u.x,d.height+u.y)}}getBounds(e,t,n){let i,o=Number.MAX_VALUE,r=-Number.MAX_VALUE,s=Number.MAX_VALUE,a=-Number.MAX_VALUE;function c(e){e.x>r&&(r=e.x),e.x<o&&(o=e.x),e.y>a&&(a=e.y),e.y<s&&(s=e.y)}return n.forEach(e=>{if(e.getComponent(cc_1.UITransform)){const t=NodeUtils.getWorldOrientedBounds(e);c(t[0]),c(t[1]),c(t[2]),c(t[3])}}),e&&(i=o,o=r,r=i),t&&(i=s,s=a,a=i),[new cc_1.Vec2(o,a),new cc_1.Vec2(o,s),new cc_1.Vec2(r,s),new cc_1.Vec2(r,a)]}updateDataFromController(){if(this._controller.updated){this.onControlUpdate("position");const e=this._controller,t=e.getCurHandleType(),n=e.getDeltaSize();if(t===rectangle_controller_1.RectHandleType.Area)this.handleAreaMove(n);else if(t===rectangle_controller_1.RectHandleType.Anchor)this.handleAnchorMove(n);else{const e=this._altKey;this.target.length>1?this.handleMultiTargetSize(t,n,e):this.handleOneTargetSize(t,n,e)}}}updateControllerTransform(){this.updateControllerData()}updateControllerData(){if(!this._isInited||null==this.target)return;const e=this._controller;if(e.checkEdit(),1===this.target.length){const t=this.target[0],n=NodeUtils.getWorldPosition3D(t),i=tempQuat_a;NodeUtils.getWorldRotation3D(t,i);const o=NodeUtils.getWorldScale3D(t);e.setPosition(n),e.setRotation(i),e.setScale(o);const r=t.getComponent(cc_1.UITransform);if(r){const t=r.contentSize,n=r.anchorPoint,i=new cc_1.Vec3;i.x=(.5-n.x)*t.width,i.y=(.5-n.y)*t.height,e.updateSize(i,new cc_1.Vec2(t.width,t.height))}else e.hide()}else{const t=!1,n=!1,i=boundsToRect(this.getBounds(t,n,this.nodes)),o=new cc_1.Vec3(i.x+i.width/2,i.y+i.height/2,0);e.setPosition(o),e.setRotation(cc_1.Quat.IDENTITY),e.setScale(new cc_1.Vec3(1,1,1)),e.updateSize(new cc_1.Vec3,new cc_1.Vec2(i.width,i.height))}}drawNodeGuidelineGroup(e){if(!e)return;const t=e.currentGuidelines;if(!t||t.length<=0)return;const n=rect_transform_snapping_1.rectTransformSnapping.guidelineColor,i=[];t.forEach(e=>{const t=e.lineVertices.slice(),n=e.checkNode;if(!n)return;function o(e){return function(t,n){return t[e]-n[e]}}const r=rect_transform_snapping_1.rectTransformSnapping.getWorldRectEx(n),s=r.center,a=r.width/2,c=r.height/2;"x"===e.axis?(t.push(new cc_1.Vec3(e.value,s.y+c,s.z)),t.push(new cc_1.Vec3(e.value,s.y-c,s.z)),t.sort(o("y"))):"y"===e.axis&&(t.push(new cc_1.Vec3(s.x+a,e.value,s.z)),t.push(new cc_1.Vec3(s.x-a,e.value,s.z)),t.sort(o("x"))),i.push(t[0]),i.push(t[t.length-1])}),this.drawGuidelines(this._nodeSnapLinesCtrl,i,n)}drawNodeSnappingGuideline(){this.clearNodeSnappingGuideline();const e=rect_transform_snapping_1.rectTransformSnapping.nodeSnapGuidelineGroups;this.drawNodeGuidelineGroup(e[0]),this.drawNodeGuidelineGroup(e[1])}clearNodeSnappingGuideline(){this._nodeSnapLinesCtrl.clearData()}getDrawLineVertices(e){if(!e)return null;const t=e.currentGuidelines;if(!t||t.length<=0)return null;const n=[];return t.forEach(e=>{const t=e.lineVertices;n.push(t[0]),n.push(t[t.length-1])}),n}drawGuidelineGroup(e,t,n=cc_1.Color.RED){if(!e)return;const i=e.currentGuidelines;if(!i||i.length<=0)return;const o=[];i.forEach(e=>{const t=e.lineVertices;o.push(t[0]),o.push(t[t.length-1])}),t.setColor(n);const r=[];o.forEach((e,t)=>{r.push(t)}),t.updateData(o,r)}drawGuidelines(e,t,n=cc_1.Color.RED){e.setColor(n);const i=[];t.forEach((e,t)=>{i.push(t)}),e.updateData(t,i)}drawCanvasSnappingGuideline(){this.clearCanvasSnappingGuideline();const e=rect_transform_snapping_1.rectTransformSnapping.canvasSnapGuidelineGroups,t=rect_transform_snapping_1.rectTransformSnapping.canvasSnapColor,n=[];let i=this.getDrawLineVertices(e[0]);i&&n.push(...i),(i=this.getDrawLineVertices(e[1]))&&n.push(...i),this.drawGuidelines(this._canvasSnapLinesCtrl,n,t)}clearCanvasSnappingGuideline(){this._canvasSnapLinesCtrl.clearData()}drawEqualSpacingGuideline(){this.clearEqualSpacingGuideline();const e=rect_transform_snapping_1.rectTransformSnapping.currentMatchMinDistInfos,t=rect_transform_snapping_1.rectTransformSnapping.guidelineColor,n=[];e.forEach(e=>{const t=e.minDistPosA,i=e.minDistPosB;n.push(t),n.push(i),"x"===e.axis?(n.push(new cc_1.Vec3(t.x,t.y+10)),n.push(new cc_1.Vec3(t.x,t.y-10)),n.push(new cc_1.Vec3(i.x,i.y+10)),n.push(new cc_1.Vec3(i.x,i.y-10))):"y"===e.axis&&(n.push(new cc_1.Vec3(t.x-10,t.y)),n.push(new cc_1.Vec3(t.x+10,t.y)),n.push(new cc_1.Vec3(i.x-10,i.y)),n.push(new cc_1.Vec3(i.x+10,i.y)))}),this.drawGuidelines(this._equalSpacingLinesCtrl,n,t)}clearEqualSpacingGuideline(){this._equalSpacingLinesCtrl.clearData()}}exports.default=RectGizmo;