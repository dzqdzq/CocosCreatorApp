"use strict";var __importDefault=this&&this.__importDefault||function(t){return t&&t.__esModule?t:{default:t}};Object.defineProperty(exports,"__esModule",{value:!0});const Utils=require("../../../utils"),external_1=__importDefault(require("../../../utils/external")),cc_1=require("cc"),NodeUtils=external_1.default.NodeUtils,EditorMath=external_1.default.EditorMath,transform_gizmo_1=__importDefault(require("./transform-gizmo")),rectangle_controller_1=__importDefault(require("../controller/rectangle-controller")),HandleType=rectangle_controller_1.default.RectHandleType,tempVec2=new cc_1.Vec2,tempVec3=new cc_1.Vec3,tempMat4=new cc_1.Mat4,tempQuat_a=new cc_1.Quat;function boundsToRect(t){return new cc_1.Rect(t[1].x,t[1].y,t[3].x-t[1].x,t[3].y-t[1].y)}class RectGizmo extends transform_gizmo_1.default{constructor(){super(...arguments),this._worldPosList=[],this._localPosList=[],this._sizeList=[],this._anchorList=[],this._rectList=[],this._validTarget=[],this._tempRect=new cc_1.Rect,this._editRect=new cc_1.Rect,this._altKey=!1}init(){this.createController()}layer(){return"foreground"}createController(){let t=new rectangle_controller_1.default(this.getGizmoRoot(),{needAnchor:!0});t.editable=!0,t.setColor(new cc.Color(0,153,255)),t.setEditHandlesColor(new cc.Color(0,153,255)),t.onControllerMouseDown=this.onControllerMouseDown.bind(this),t.onControllerMouseMove=this.onControllerMouseMove.bind(this),t.onControllerMouseUp=this.onControllerMouseUp.bind(this),this._controller=t}onControllerMouseDown(){this._worldPosList.length=0,this._localPosList.length=0,this._sizeList.length=0,this._anchorList.length=0,this._rectList.length=0,this._validTarget.length=0;for(let t=0;t<this.target.length;t++){let e=this.target[t],o=e.getComponent(cc_1.UITransform);o&&(this._validTarget.push(o),this._worldPosList.push(NodeUtils.getWorldPosition3D(e)),this._localPosList.push(e.getPosition()),this._sizeList.push(o.contentSize.clone()),this._anchorList.push(o.anchorPoint.clone()),this._rectList.push(NodeUtils.getWorldBounds(e)))}let t=this._validTarget.map(t=>t.node),e=this.getBounds(!1,!1,t);this._tempRect=boundsToRect(e)}onControllerMouseMove(){this.updateDataFromController()}onControllerMouseUp(){this._controller.updated&&this.onControlEnd("position")}onGizmoKeyDown(t){this._altKey=t.altKey}onGizmoKeyUp(t){this._altKey=t.altKey}handleAreaMove(t){for(let e=0;e<this._validTarget.length;e++){let o=this._validTarget[e].node,i=this._localPosList[e],s=t.clone();o.parent&&(o.parent.getWorldMatrix(tempMat4),cc_1.Mat4.invert(tempMat4,tempMat4),tempMat4.m12=tempMat4.m13=0,cc_1.Vec3.transformMat4(s,s,tempMat4)),NodeUtils.makeVec3InPrecision(s,3),s.z=0,tempVec3.set(i),tempVec3.add(s),o.setPosition(tempVec3),this.broadcastNodeChangeMessage(o)}}handleAnchorMove(t){if(this._validTarget.length>1)return;let e=this._validTarget[0],o=e.node,i=this._sizeList[0],s=this._anchorList[0],n=this._worldPosList[0],r=t.clone();NodeUtils.makeVec3InPrecision(r,3),tempVec3.set(n),tempVec3.add(r),o.setWorldPosition(tempVec3),o.getWorldMatrix(tempMat4),cc_1.Mat4.invert(tempMat4,tempMat4),tempMat4.m12=tempMat4.m13=0,cc_1.Vec3.transformMat4(r,r,tempMat4),tempVec2.x=r.x/i.width,tempVec2.y=r.y/i.height,tempVec2.add(s),e.anchorPoint=tempVec2,this.broadcastNodeChangeMessage(o)}modifyPosDeltaWithAnchor(t,e,o,i,s){t===HandleType.Right||t===HandleType.TopRight||t===HandleType.BottomRight?(s&&(o.x/=1-i.x),e.x=o.x*i.x):(s&&(o.x/=i.x),e.x=-o.x*(1-i.x)),t===HandleType.Bottom||t===HandleType.BottomRight||t===HandleType.BottomLeft?(s&&(o.y/=i.y),e.y=-o.y*(1-i.y)):(s&&(o.y/=1-i.y),e.y=o.y*i.y)}handleOneTargetSize(t,e,o){let i=this._sizeList[0],s=e.clone(),n=new cc_1.Vec2(e.x,e.y),r=this._localPosList[0],l=this._validTarget[0],a=l.node,c=this._anchorList[0];if(n.x=EditorMath.toPrecision(n.x,3),n.y=EditorMath.toPrecision(n.y,3),this.modifyPosDeltaWithAnchor(t,s,n,c,o),a.parent&&(a.parent.getWorldMatrix(tempMat4),cc_1.Mat4.invert(tempMat4,tempMat4),tempMat4.m12=tempMat4.m13=0,cc_1.Vec3.transformMat4(s,s,tempMat4)),!o){let t=tempQuat_a;a.getRotation(t),cc_1.Vec3.transformQuat(s,s,t),s.z=0,tempVec3.set(r),tempVec3.add(s),a.setPosition(tempVec3)}let h=new cc_1.Vec3;a.getWorldScale(h),n.x=n.x/h.x,n.y=n.y/h.y;let d=i.width+n.x,_=i.height+n.y;l.contentSize=cc.size(d,_),this.broadcastNodeChangeMessage(a)}handleMultiTargetSize(t,e,o){let i=this._tempRect,s=new cc_1.Vec2(e.x,e.y),n=e.clone(),r=new cc_1.Vec2(0,0);s.x=EditorMath.toPrecision(s.x,3),s.y=EditorMath.toPrecision(s.y,3),this.modifyPosDeltaWithAnchor(t,n,s,r,!1);let l=i.clone();l.x=i.x+n.x,l.y=i.y+n.y,l.width=i.width+s.x,l.height=i.height+s.y,this._editRect=l;for(let t=0,e=this._validTarget.length;t<e;t++){let e=this._validTarget[t],o=e.node,n=this._worldPosList[t],r=(n.x-i.x)/i.width,a=(n.y-i.y)/i.height,c=new cc_1.Vec3(l.x+r*l.width,l.y+a*l.height,n.z);o.setWorldPosition(c);let h=this._rectList[t],d=h.width/i.width,_=h.height/i.height,p=this._sizeList[t],m=s.clone();m.x=m.x*d,m.y=m.y*_;let g=new cc_1.Vec3;o.getWorldScale(g),m.x=m.x/g.x,m.y=m.y/g.y,e.contentSize=cc.size(p.width+m.x,p.height+m.y),this.broadcastNodeChangeMessage(o)}}getBounds(t,e,o){let i,s=Number.MAX_VALUE,n=-Number.MAX_VALUE,r=Number.MAX_VALUE,l=-Number.MAX_VALUE;function a(t){t.x>n&&(n=t.x),t.x<s&&(s=t.x),t.y>l&&(l=t.y),t.y<r&&(r=t.y)}return o.forEach(t=>{if(t.getComponent(cc_1.UITransform)){let e=NodeUtils.getWorldOrientedBounds(t);a(e[0]),a(e[1]),a(e[2]),a(e[3])}}),t&&(i=s,s=n,n=i),e&&(i=r,r=l,l=i),[new cc_1.Vec2(s,l),new cc_1.Vec2(s,r),new cc_1.Vec2(n,r),new cc_1.Vec2(n,l)]}updateDataFromController(){if(this._controller.updated){this.onControlUpdate("position");let t=this._controller,e=t.getCurHandleType(),o=t.getDeltaSize();if(e===HandleType.Area)this.handleAreaMove(o);else if(e===HandleType.Anchor)this.handleAnchorMove(o);else{let t=this._altKey;this.target.length>1?this.handleMultiTargetSize(e,o,t):this.handleOneTargetSize(e,o,t)}}}updateControllerTransform(){this.updateControllerData()}updateControllerData(){if(!this._isInited||null==this.target)return;let t=this._controller;if(t.checkEdit(),1===this.target.length){let e=this.target[0],o=NodeUtils.getWorldPosition3D(e);const i=tempQuat_a;NodeUtils.getWorldRotation3D(e,i);let s=NodeUtils.getWorldScale3D(e);t.setPosition(o),t.setRotation(i),t.setScale(s);let n=e.getComponent(cc_1.UITransform);if(n){let e=n.contentSize,o=n.anchorPoint,i=new cc_1.Vec3;i.x=(.5-o.x)*e.width,i.y=(.5-o.y)*e.height,t.updateSize(i,new cc_1.Vec2(e.width,e.height))}else t.hide()}else{let e=!1,o=!1,i=boundsToRect(this.getBounds(e,o,this.nodes)),s=new cc_1.Vec3(i.x+i.width/2,i.y+i.height/2,0);t.setPosition(s),t.setRotation(cc_1.Quat.IDENTITY),t.setScale(new cc_1.Vec3(1,1,1)),t.updateSize(new cc_1.Vec3,new cc_1.Vec2(i.width,i.height))}}}exports.default=RectGizmo;