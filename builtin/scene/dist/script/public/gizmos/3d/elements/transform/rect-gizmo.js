"use strict";var __importDefault=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(exports,"__esModule",{value:!0});const cc_1=require("cc"),external_1=__importDefault(require("../../../utils/external")),NodeUtils=external_1.default.NodeUtils,EditorMath=external_1.default.EditorMath,window_1=require("../../../../../utils/window"),rect_transform_snapping_1=require("../../../utils/rect-transform-snapping"),transform_tool_data_1=require("../../../utils/transform-tool-data"),lines_controller_1=__importDefault(require("../controller/lines-controller")),rectangle_controller_1=require("../controller/rectangle-controller"),transform_gizmo_1=__importDefault(require("./transform-gizmo")),tempVec2=new cc_1.Vec2,tempVec3=new cc_1.Vec3,tempMat4=new cc_1.Mat4,tempQuat_a=new cc_1.Quat;function boundsToRect(e){return new cc_1.Rect(e[1].x,e[1].y,e[3].x-e[1].x,e[3].y-e[1].y)}class RectGizmo extends transform_gizmo_1.default{constructor(){super(...arguments),this._worldPosList=[],this._localPosList=[],this._sizeList=[],this._anchorList=[],this._rectList=[],this._validTarget=[],this._tempRect=new cc_1.Rect,this._editRect=new cc_1.Rect,this._altKey=!1,this._snapDistVec2=new cc_1.Vec2,this._shiftKey=!1}init(){this.createController()}layer(){return"foreground"}isNodeAnchorLocked(e){return!!e&&e.components.some(e=>e._objFlags&cc_1.CCObject.Flags.IsAnchorLocked)}isNodeContentSizeLocked(e){return!!e&&e.components.some(e=>e._objFlags&cc_1.CCObject.Flags.IsSizeLocked)}createController(){const e=this.getGizmoRoot(),t=new rectangle_controller_1.RectangleController(e,{needAnchor:!0});t.editable=!0,t.setColor(new cc.Color(0,153,255)),t.setEditHandlesColor(new cc.Color(0,153,255)),t.onControllerMouseDown=this.onControllerMouseDown.bind(this),t.onControllerMouseMove=this.onControllerMouseMove.bind(this),t.onControllerMouseUp=this.onControllerMouseUp.bind(this),this._controller=t,this._nodeSnapLinesCtrl=new lines_controller_1.default(e),this._canvasSnapLinesCtrl=new lines_controller_1.default(e),this._equalSpacingLinesCtrl=new lines_controller_1.default(e,{dashed:!0})}onControllerMouseDown(){var e;this._controller&&(null===(e=this.target)||void 0===e?void 0:e.length)&&(this._controller.contentSizeLocked=this.target.some(e=>this.isNodeContentSizeLocked(e)),this._controller.anchorLocked=this.target.some(e=>this.isNodeAnchorLocked(e))),this._worldPosList.length=0,this._localPosList.length=0,this._sizeList.length=0,this._anchorList.length=0,this._rectList.length=0,this._validTarget.length=0;for(let e=0;e<this.target.length;e++){const t=this.target[e],n=t.getComponent(cc_1.UITransform);n&&(this._validTarget.push(n),this._worldPosList.push(NodeUtils.getWorldPosition3D(t)),this._localPosList.push(t.getPosition()),this._sizeList.push(n.contentSize.clone()),this._anchorList.push(n.anchorPoint.clone()),this._rectList.push(NodeUtils.getWorldBounds(t)))}const t=this._validTarget.map(e=>e.node),n=this.getBounds(!1,!1,t);this._tempRect=boundsToRect(n);const i=transform_tool_data_1.transformToolData.scale2D,o=rect_transform_snapping_1.rectTransformSnapping.snapThreshold/i;if(this._snapDistVec2.x=o,this._snapDistVec2.y=o,rect_transform_snapping_1.rectTransformSnapping.enableSnapping){const e=this.target[0];e&&(rect_transform_snapping_1.rectTransformSnapping.calculateNodeSnapGuidelines(e.parent,e),rect_transform_snapping_1.rectTransformSnapping.calculateCanvasSnapGuidelines(),rect_transform_snapping_1.rectTransformSnapping.calculateSpacingSnapGuidelines(e.parent,e))}}onControllerMouseMove(){this.updateDataFromController()}onControllerMouseUp(e){var t;if(this._controller.updated)this.onControlEnd("position");else{const n=cce.Selection.query();if(1===n.length){const i=(0,window_1.getMainWindowSize)().height-e.y,o=NodeUtils.getRaycastResultNodes(cce.Camera.getCamera(),e.x,i,cc_1.Layers.makeMaskExclude([cc_1.Layers.BitMask.GIZMOS,cc_1.Layers.Enum.SCENE_GIZMO])),r=n[0];for(let e=0;e<o.length;e++)if(o[e]&&r===o[e].uuid){e===o.length-1?(cce.Selection.unselect(r),cce.Selection.select(o[0].uuid)):(null===(t=o[e+1])||void 0===t?void 0:t.uuid)&&(cce.Selection.unselect(r),cce.Selection.select(o[e+1].uuid));break}}}this.clearNodeSnappingGuideline(),this.clearCanvasSnappingGuideline(),this.clearEqualSpacingGuideline()}onGizmoKeyDown(e){return this._altKey=e.altKey,this._shiftKey=e.shiftKey,super.onGizmoKeyDown(e)}onGizmoKeyUp(e){const t=this._controller.getCurHandleType(),n=this._controller.isCorner(t)||this._controller.isBorder(t);return this._altKey&&!e.altKey&&n&&this._controller.reset(),this._altKey=e.altKey,this._shiftKey=e.shiftKey,super.onGizmoKeyUp(e)}handleAreaMove(e){for(let t=0;t<this._validTarget.length;t++){const n=this._validTarget[t].node,i=(this._localPosList[t],this._worldPosList[t]);let o=new cc_1.Vec3;if(cc_1.Vec3.add(o,i,e),0===t&&rect_transform_snapping_1.rectTransformSnapping.enableSnapping){const e=this._rectList[t];o=rect_transform_snapping_1.rectTransformSnapping.snapPosToNodeGuidelines(o,e,this._snapDistVec2),this.drawNodeSnappingGuideline(),o=rect_transform_snapping_1.rectTransformSnapping.snapPosToCanvasSnapGuidelines(o,e,this._snapDistVec2),this.drawCanvasSnappingGuideline(),o=rect_transform_snapping_1.rectTransformSnapping.snapPosToEqualSpacing(o,e,this._snapDistVec2),this.drawEqualSpacingGuideline()}o.x=EditorMath.toPrecision(o.x,3),o.y=EditorMath.toPrecision(o.y,3),NodeUtils.setWorldPosition(n,o)}}handleAnchorMove(e){if(this._validTarget.length>1)return;const t=this._validTarget[0],n=t.node,i=this._sizeList[0],o=this._anchorList[0],r=this._worldPosList[0],s=e.clone();NodeUtils.makeVec3InPrecision(s,3),tempVec3.set(r),tempVec3.add(s),n.setWorldPosition(tempVec3),n.getWorldMatrix(tempMat4),cc_1.Mat4.invert(tempMat4,tempMat4),tempMat4.m12=tempMat4.m13=0,cc_1.Vec3.transformMat4(s,s,tempMat4),tempVec2.x=s.x/i.width,tempVec2.y=s.y/i.height,tempVec2.add(o),t.anchorPoint=tempVec2}getSizePoint(e){const t=new cc.Vec2,n=this._rectList[0];return e===rectangle_controller_1.RectHandleType.Right||e===rectangle_controller_1.RectHandleType.TopRight||e===rectangle_controller_1.RectHandleType.BottomRight?t.x=n.x+n.width:t.x=n.x,e===rectangle_controller_1.RectHandleType.BottomLeft||e===rectangle_controller_1.RectHandleType.Bottom||e===rectangle_controller_1.RectHandleType.BottomRight?t.y=n.y:t.y=n.y+n.height,t}modifyPosDeltaWithAnchor(e,t,n,i,o){e===rectangle_controller_1.RectHandleType.Right||e===rectangle_controller_1.RectHandleType.TopRight||e===rectangle_controller_1.RectHandleType.BottomRight?(o&&(n.x/=1-i.x),t.x=n.x*i.x):(o&&(n.x/=i.x),t.x=-n.x*(1-i.x)),e===rectangle_controller_1.RectHandleType.Bottom||e===rectangle_controller_1.RectHandleType.BottomRight||e===rectangle_controller_1.RectHandleType.BottomLeft?(o&&(n.y/=i.y),t.y=-n.y*(1-i.y)):(o&&(n.y/=1-i.y),t.y=n.y*i.y)}formatSizeDelta(e,t){e!==rectangle_controller_1.RectHandleType.Left&&e!==rectangle_controller_1.RectHandleType.TopLeft&&e!==rectangle_controller_1.RectHandleType.BottomLeft||(t.x=-t.x),e!==rectangle_controller_1.RectHandleType.Bottom&&e!==rectangle_controller_1.RectHandleType.BottomRight&&e!==rectangle_controller_1.RectHandleType.BottomLeft||(t.y=-t.y)}handleOneTargetSize(e,t,n,i){const o=this._sizeList[0],r=t.clone();let s=new cc_1.Vec2(t.x,t.y);const c=this._localPosList[0],a=this._validTarget[0],l=a.node,h=this._anchorList[0];if(rect_transform_snapping_1.rectTransformSnapping.enableSnapping&&(this.formatSizeDelta(e,s),s=rect_transform_snapping_1.rectTransformSnapping.snapSizeToNodeGuidelines(this.getSizePoint(e),s,this._snapDistVec2),this.formatSizeDelta(e,s),this.drawNodeSnappingGuideline()),s.x=EditorMath.toPrecision(s.x,3),s.y=EditorMath.toPrecision(s.y,3),this.modifyPosDeltaWithAnchor(e,r,s,h,n),l.parent&&(l.parent.getWorldMatrix(tempMat4),cc_1.Mat4.invert(tempMat4,tempMat4),tempMat4.m12=tempMat4.m13=0,cc_1.Vec3.transformMat4(r,r,tempMat4)),!n){const e=tempQuat_a;l.getRotation(e),cc_1.Vec3.transformQuat(r,r,e),r.z=0,tempVec3.set(c),tempVec3.add(r),l.setPosition(tempVec3)}const _=new cc_1.Vec3;l.getWorldScale(_),s.x=s.x/_.x,s.y=s.y/_.y;let p=o.height,d=o.width;if(i){if(s.x)if(d=o.width+s.x,o.width){p=d/o.width*o.y}else p=d;else if(s.y)if(p=o.height+s.y,o.height){d=p/o.height*o.x}else d=p}else p=o.height+s.y,d=o.width+s.x;a.contentSize=cc.size(d,p)}handleMultiTargetSize(e,t,n){const i=this._tempRect,o=new cc_1.Vec2(t.x,t.y),r=t.clone(),s=new cc_1.Vec2(0,0);o.x=EditorMath.toPrecision(o.x,3),o.y=EditorMath.toPrecision(o.y,3),this.modifyPosDeltaWithAnchor(e,r,o,s,!1);const c=i.clone();c.x=i.x+r.x,c.y=i.y+r.y,c.width=i.width+o.x,c.height=i.height+o.y,this._editRect=c;for(let e=0,t=this._validTarget.length;e<t;e++){const t=this._validTarget[e],n=t.node,r=this._worldPosList[e],s=(r.x-i.x)/i.width,a=(r.y-i.y)/i.height,l=new cc_1.Vec3(c.x+s*c.width,c.y+a*c.height,r.z);n.setWorldPosition(l);const h=this._rectList[e],_=h.width/i.width,p=h.height/i.height,d=this._sizeList[e],u=o.clone();u.x=u.x*_,u.y=u.y*p;const g=new cc_1.Vec3;n.getWorldScale(g),u.x=u.x/g.x,u.y=u.y/g.y,t.contentSize=cc.size(d.width+u.x,d.height+u.y)}}getBounds(e,t,n){let i,o=Number.MAX_VALUE,r=-Number.MAX_VALUE,s=Number.MAX_VALUE,c=-Number.MAX_VALUE;function a(e){e.x>r&&(r=e.x),e.x<o&&(o=e.x),e.y>c&&(c=e.y),e.y<s&&(s=e.y)}return n.forEach(e=>{if(e.getComponent(cc_1.UITransform)){const t=NodeUtils.getWorldOrientedBounds(e);a(t[0]),a(t[1]),a(t[2]),a(t[3])}}),e&&(i=o,o=r,r=i),t&&(i=s,s=c,c=i),[new cc_1.Vec2(o,c),new cc_1.Vec2(o,s),new cc_1.Vec2(r,s),new cc_1.Vec2(r,c)]}updateDataFromController(){if(this._controller.updated){this.onControlUpdate("position");const e=this._controller,t=e.getCurHandleType(),n=e.getDeltaSize();if(t===rectangle_controller_1.RectHandleType.Area)this.handleAreaMove(n);else if(t===rectangle_controller_1.RectHandleType.Anchor)this.handleAnchorMove(n);else{const e=this._altKey,i=this._shiftKey;this.target.length>1?this.handleMultiTargetSize(t,n,e):this.handleOneTargetSize(t,n,e,i)}}}updateControllerTransform(){this.updateControllerData()}updateControllerData(){if(!this._isInited||null==this.target)return;const e=this._controller;if(e.checkEdit(),1===this.target.length){const t=this.target[0],n=NodeUtils.getWorldPosition3D(t),i=tempQuat_a;NodeUtils.getWorldRotation3D(t,i);const o=NodeUtils.getWorldScale3D(t);e.setPosition(n),e.setRotation(i),e.setScale(o);const r=t.getComponent(cc_1.UITransform);if(r){const t=r.contentSize,n=r.anchorPoint,i=new cc_1.Vec3;i.x=(.5-n.x)*t.width,i.y=(.5-n.y)*t.height,e.updateSize(i,new cc_1.Vec2(t.width,t.height))}else e.hide()}else{const t=!1,n=!1,i=boundsToRect(this.getBounds(t,n,this.nodes)),o=new cc_1.Vec3(i.x+i.width/2,i.y+i.height/2,0);e.setPosition(o),e.setRotation(cc_1.Quat.IDENTITY),e.setScale(new cc_1.Vec3(1,1,1)),e.updateSize(new cc_1.Vec3,new cc_1.Vec2(i.width,i.height))}}drawNodeGuidelineGroup(e){if(!e)return;const t=e.currentGuidelines;if(!t||t.length<=0)return;const n=rect_transform_snapping_1.rectTransformSnapping.guidelineColor,i=[];t.forEach(e=>{const t=e.lineVertices.slice(),n=e.checkNode;if(!n)return;function o(e){return function(t,n){return t[e]-n[e]}}const r=rect_transform_snapping_1.rectTransformSnapping.getWorldRectEx(n),s=r.center,c=r.width/2,a=r.height/2;"x"===e.axis?(t.push(new cc_1.Vec3(e.value,s.y+a,s.z)),t.push(new cc_1.Vec3(e.value,s.y-a,s.z)),t.sort(o("y"))):"y"===e.axis&&(t.push(new cc_1.Vec3(s.x+c,e.value,s.z)),t.push(new cc_1.Vec3(s.x-c,e.value,s.z)),t.sort(o("x"))),i.push(t[0]),i.push(t[t.length-1])}),this.drawGuidelines(this._nodeSnapLinesCtrl,i,n)}drawNodeSnappingGuideline(){this.clearNodeSnappingGuideline();const e=rect_transform_snapping_1.rectTransformSnapping.nodeSnapGuidelineGroups;this.drawNodeGuidelineGroup(e[0]),this.drawNodeGuidelineGroup(e[1])}clearNodeSnappingGuideline(){this._nodeSnapLinesCtrl.clearData()}getDrawLineVertices(e){if(!e)return null;const t=e.currentGuidelines;if(!t||t.length<=0)return null;const n=[];return t.forEach(e=>{const t=e.lineVertices;n.push(t[0]),n.push(t[t.length-1])}),n}drawGuidelineGroup(e,t,n=cc_1.Color.RED){if(!e)return;const i=e.currentGuidelines;if(!i||i.length<=0)return;const o=[];i.forEach(e=>{const t=e.lineVertices;o.push(t[0]),o.push(t[t.length-1])}),t.setColor(n);const r=[];o.forEach((e,t)=>{r.push(t)}),t.updateData(o,r)}drawGuidelines(e,t,n=cc_1.Color.RED){e.setColor(n);const i=[];t.forEach((e,t)=>{i.push(t)}),e.updateData(t,i)}drawCanvasSnappingGuideline(){this.clearCanvasSnappingGuideline();const e=rect_transform_snapping_1.rectTransformSnapping.canvasSnapGuidelineGroups,t=rect_transform_snapping_1.rectTransformSnapping.canvasSnapColor,n=[];let i=this.getDrawLineVertices(e[0]);i&&n.push(...i),(i=this.getDrawLineVertices(e[1]))&&n.push(...i),this.drawGuidelines(this._canvasSnapLinesCtrl,n,t)}clearCanvasSnappingGuideline(){this._canvasSnapLinesCtrl.clearData()}drawEqualSpacingGuideline(){this.clearEqualSpacingGuideline();const e=rect_transform_snapping_1.rectTransformSnapping.currentMatchMinDistInfos,t=rect_transform_snapping_1.rectTransformSnapping.guidelineColor,n=[];e.forEach(e=>{const t=e.minDistPosA,i=e.minDistPosB;n.push(t),n.push(i),"x"===e.axis?(n.push(new cc_1.Vec3(t.x,t.y+10)),n.push(new cc_1.Vec3(t.x,t.y-10)),n.push(new cc_1.Vec3(i.x,i.y+10)),n.push(new cc_1.Vec3(i.x,i.y-10))):"y"===e.axis&&(n.push(new cc_1.Vec3(t.x-10,t.y)),n.push(new cc_1.Vec3(t.x+10,t.y)),n.push(new cc_1.Vec3(i.x-10,i.y)),n.push(new cc_1.Vec3(i.x+10,i.y)))}),this.drawGuidelines(this._equalSpacingLinesCtrl,n,t)}clearEqualSpacingGuideline(){this._equalSpacingLinesCtrl.clearData()}}exports.default=RectGizmo;