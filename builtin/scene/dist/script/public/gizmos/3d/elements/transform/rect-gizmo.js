"use strict";var __importDefault=this&&this.__importDefault||function(t){return t&&t.__esModule?t:{default:t}};Object.defineProperty(exports,"__esModule",{value:!0});const Utils=require("../../../utils"),external_1=__importDefault(require("../../../utils/external")),cc_1=require("cc"),NodeUtils=external_1.default.NodeUtils,EditorMath=external_1.default.EditorMath,transform_gizmo_1=__importDefault(require("./transform-gizmo")),rectangle_controller_1=__importDefault(require("../controller/rectangle-controller")),HandleType=rectangle_controller_1.default.RectHandleType,tempVec2=new cc_1.Vec2,tempVec3=new cc_1.Vec3,tempMat4=new cc_1.Mat4,tempQuat_a=new cc_1.Quat;function boundsToRect(t){return new cc_1.Rect(t[1].x,t[1].y,t[3].x-t[1].x,t[3].y-t[1].y)}class RectGizmo extends transform_gizmo_1.default{constructor(){super(...arguments),this._worldPosList=[],this._localPosList=[],this._sizeList=[],this._anchorList=[],this._rectList=[],this._validTarget=[],this._tempRect=new cc_1.Rect,this._editRect=new cc_1.Rect,this._altKey=!1}init(){this.createController()}layer(){return"foreground"}createController(){const t=new rectangle_controller_1.default(this.getGizmoRoot(),{needAnchor:!0});t.editable=!0,t.setColor(new cc.Color(0,153,255)),t.setEditHandlesColor(new cc.Color(0,153,255)),t.onControllerMouseDown=this.onControllerMouseDown.bind(this),t.onControllerMouseMove=this.onControllerMouseMove.bind(this),t.onControllerMouseUp=this.onControllerMouseUp.bind(this),this._controller=t}onControllerMouseDown(){this._worldPosList.length=0,this._localPosList.length=0,this._sizeList.length=0,this._anchorList.length=0,this._rectList.length=0,this._validTarget.length=0;for(let t=0;t<this.target.length;t++){const e=this.target[t],o=e.getComponent(cc_1.UITransform);o&&(this._validTarget.push(o),this._worldPosList.push(NodeUtils.getWorldPosition3D(e)),this._localPosList.push(e.getPosition()),this._sizeList.push(o.contentSize.clone()),this._anchorList.push(o.anchorPoint.clone()),this._rectList.push(NodeUtils.getWorldBounds(e)))}const t=this._validTarget.map(t=>t.node),e=this.getBounds(!1,!1,t);this._tempRect=boundsToRect(e)}onControllerMouseMove(){this.updateDataFromController()}onControllerMouseUp(){this._controller.updated&&this.onControlEnd("position")}onGizmoKeyDown(t){this._altKey=t.altKey}onGizmoKeyUp(t){this._altKey=t.altKey}handleAreaMove(t){for(let e=0;e<this._validTarget.length;e++){const o=this._validTarget[e].node,i=this._localPosList[e],n=t.clone();o.parent&&(o.parent.getWorldMatrix(tempMat4),cc_1.Mat4.invert(tempMat4,tempMat4),tempMat4.m12=tempMat4.m13=0,cc_1.Vec3.transformMat4(n,n,tempMat4)),NodeUtils.makeVec3InPrecision(n,3),n.z=0,tempVec3.set(i),tempVec3.add(n),o.setPosition(tempVec3)}}handleAnchorMove(t){if(this._validTarget.length>1)return;const e=this._validTarget[0],o=e.node,i=this._sizeList[0],n=this._anchorList[0],s=this._worldPosList[0],c=t.clone();NodeUtils.makeVec3InPrecision(c,3),tempVec3.set(s),tempVec3.add(c),o.setWorldPosition(tempVec3),o.getWorldMatrix(tempMat4),cc_1.Mat4.invert(tempMat4,tempMat4),tempMat4.m12=tempMat4.m13=0,cc_1.Vec3.transformMat4(c,c,tempMat4),tempVec2.x=c.x/i.width,tempVec2.y=c.y/i.height,tempVec2.add(n),e.anchorPoint=tempVec2}modifyPosDeltaWithAnchor(t,e,o,i,n){t===HandleType.Right||t===HandleType.TopRight||t===HandleType.BottomRight?(n&&(o.x/=1-i.x),e.x=o.x*i.x):(n&&(o.x/=i.x),e.x=-o.x*(1-i.x)),t===HandleType.Bottom||t===HandleType.BottomRight||t===HandleType.BottomLeft?(n&&(o.y/=i.y),e.y=-o.y*(1-i.y)):(n&&(o.y/=1-i.y),e.y=o.y*i.y)}handleOneTargetSize(t,e,o){const i=this._sizeList[0],n=e.clone(),s=new cc_1.Vec2(e.x,e.y),c=this._localPosList[0],r=this._validTarget[0],l=r.node,a=this._anchorList[0];if(s.x=EditorMath.toPrecision(s.x,3),s.y=EditorMath.toPrecision(s.y,3),this.modifyPosDeltaWithAnchor(t,n,s,a,o),l.parent&&(l.parent.getWorldMatrix(tempMat4),cc_1.Mat4.invert(tempMat4,tempMat4),tempMat4.m12=tempMat4.m13=0,cc_1.Vec3.transformMat4(n,n,tempMat4)),!o){const t=tempQuat_a;l.getRotation(t),cc_1.Vec3.transformQuat(n,n,t),n.z=0,tempVec3.set(c),tempVec3.add(n),l.setPosition(tempVec3)}const h=new cc_1.Vec3;l.getWorldScale(h),s.x=s.x/h.x,s.y=s.y/h.y;const d=i.width+s.x,_=i.height+s.y;r.contentSize=cc.size(d,_)}handleMultiTargetSize(t,e,o){const i=this._tempRect,n=new cc_1.Vec2(e.x,e.y),s=e.clone(),c=new cc_1.Vec2(0,0);n.x=EditorMath.toPrecision(n.x,3),n.y=EditorMath.toPrecision(n.y,3),this.modifyPosDeltaWithAnchor(t,s,n,c,!1);const r=i.clone();r.x=i.x+s.x,r.y=i.y+s.y,r.width=i.width+n.x,r.height=i.height+n.y,this._editRect=r;for(let t=0,e=this._validTarget.length;t<e;t++){const e=this._validTarget[t],o=e.node,s=this._worldPosList[t],c=(s.x-i.x)/i.width,l=(s.y-i.y)/i.height,a=new cc_1.Vec3(r.x+c*r.width,r.y+l*r.height,s.z);o.setWorldPosition(a);const h=this._rectList[t],d=h.width/i.width,_=h.height/i.height,p=this._sizeList[t],m=n.clone();m.x=m.x*d,m.y=m.y*_;const u=new cc_1.Vec3;o.getWorldScale(u),m.x=m.x/u.x,m.y=m.y/u.y,e.contentSize=cc.size(p.width+m.x,p.height+m.y)}}getBounds(t,e,o){let i,n=Number.MAX_VALUE,s=-Number.MAX_VALUE,c=Number.MAX_VALUE,r=-Number.MAX_VALUE;function l(t){t.x>s&&(s=t.x),t.x<n&&(n=t.x),t.y>r&&(r=t.y),t.y<c&&(c=t.y)}return o.forEach(t=>{if(t.getComponent(cc_1.UITransform)){const e=NodeUtils.getWorldOrientedBounds(t);l(e[0]),l(e[1]),l(e[2]),l(e[3])}}),t&&(i=n,n=s,s=i),e&&(i=c,c=r,r=i),[new cc_1.Vec2(n,r),new cc_1.Vec2(n,c),new cc_1.Vec2(s,c),new cc_1.Vec2(s,r)]}updateDataFromController(){if(this._controller.updated){this.onControlUpdate("position");const t=this._controller,e=t.getCurHandleType(),o=t.getDeltaSize();if(e===HandleType.Area)this.handleAreaMove(o);else if(e===HandleType.Anchor)this.handleAnchorMove(o);else{const t=this._altKey;this.target.length>1?this.handleMultiTargetSize(e,o,t):this.handleOneTargetSize(e,o,t)}}}updateControllerTransform(){this.updateControllerData()}updateControllerData(){if(!this._isInited||null==this.target)return;const t=this._controller;if(t.checkEdit(),1===this.target.length){const e=this.target[0],o=NodeUtils.getWorldPosition3D(e),i=tempQuat_a;NodeUtils.getWorldRotation3D(e,i);const n=NodeUtils.getWorldScale3D(e);t.setPosition(o),t.setRotation(i),t.setScale(n);const s=e.getComponent(cc_1.UITransform);if(s){const e=s.contentSize,o=s.anchorPoint,i=new cc_1.Vec3;i.x=(.5-o.x)*e.width,i.y=(.5-o.y)*e.height,t.updateSize(i,new cc_1.Vec2(e.width,e.height))}else t.hide()}else{const e=!1,o=!1,i=boundsToRect(this.getBounds(e,o,this.nodes)),n=new cc_1.Vec3(i.x+i.width/2,i.y+i.height/2,0);t.setPosition(n),t.setRotation(cc_1.Quat.IDENTITY),t.setScale(new cc_1.Vec3(1,1,1)),t.updateSize(new cc_1.Vec3,new cc_1.Vec2(i.width,i.height))}}}exports.default=RectGizmo;