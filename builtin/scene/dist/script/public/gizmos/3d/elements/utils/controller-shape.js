"use strict";var __importDefault=this&&this.__importDefault||function(c){return c&&c.__esModule?c:{default:c}};Object.defineProperty(exports,"__esModule",{value:!0});const{PrimitiveMode:PrimitiveMode}=require("../../../utils/engine"),cc_1=require("cc"),external_1=__importDefault(require("../../../utils/external")),EditorMath=external_1.default.EditorMath,MVec3=EditorMath.MVec3,MQuat=EditorMath.MQuat,Utils=require("../../../utils"),v3_forward=new cc_1.Vec3(0,0,1),tempVec3=new cc_1.Vec3,tempVec3_a=new cc_1.Vec3,tempVec3_b=new cc_1.Vec3,tempQuat_a=new cc_1.Quat;class ControllerShape{constructor(){this.calcRectanglePoints=function(c,e,t){const n=new cc_1.Vec3(t.x/2,0,0),a=new cc_1.Vec3(0,t.y/2,0);MVec3.transformQuat(n,n,e),MVec3.transformQuat(a,a,e);const i=[];i[0]=new cc_1.Vec3(c),i[0].add(n),i[0].add(a),i[1]=new cc_1.Vec3(c),i[1].add(n),i[1].subtract(a),i[2]=new cc_1.Vec3(c),i[2].subtract(n),i[2].subtract(a),i[3]=new cc_1.Vec3(c),i[3].subtract(n),i[3].add(a);const r=[];for(let c=1;c<4;c++)r.push(c-1,c);return r.push(0,3),{vertices:i,indices:r}},this.calcSphereData=function(c,e=.5,t={}){const n=void 0!==t.segments?t.segments:32,a=[],i=[],r=[],s=[],o=new cc_1.Vec3(-e,-e,-e),l=new cc_1.Vec3(e,e,e),_=e;for(let t=0;t<=n;++t){const o=t*Math.PI/n,l=Math.sin(o),_=-Math.cos(o);for(let o=0;o<=n;++o){const V=2*o*Math.PI/n-Math.PI/2,m=Math.sin(V)*l,u=_,w=Math.cos(V)*l,d=o/n,h=t/n;if(a.push(new cc_1.Vec3(c.x+m*e,c.y+u*e,c.z+w*e)),i.push(new cc_1.Vec3(m,u,w)),r.push(cc.v2(d,h)),t<n&&o<n){const c=n+1,e=c*t+o,a=c*(t+1)+o,i=c*(t+1)+o+1,r=c*t+o+1;s.push(e,r,a),s.push(r,i,a)}}}return{positions:a,indices:s,normals:i,uvs:r,minPos:o,maxPos:l,boundingRadius:_}}}calcCylinderData(c=.5,e=.5,t=2,n={}){const a=.5*t,i=n.radialSegments||16,r=n.heightSegments||1,s=void 0===n.capped||n.capped,o=n.arc||2*Math.PI;let l=0;s||(c>0&&l++,e>0&&l++);let _=(i+1)*(r+1);s&&(_+=(i+1)*l+i*l);let V=i*r*2*3;s&&(V+=i*l*3);const m=new Array(V),u=new Array(_),w=new Array(_),d=new Array(_),h=Math.max(c,e),p=new cc_1.Vec3(-h,-a,-h),M=new cc_1.Vec3(h,a,h);let f=0,P=0;function y(t){let n,r;const s=t?c:e,l=t?1:-1;n=f;for(let c=1;c<=i;++c)u[f]=new cc_1.Vec3(0,a*l,0),w[f]=new cc_1.Vec3(0,l,0),d[f]=cc.v2(.5,.5),++f;r=f;for(let c=0;c<=i;++c){const e=c/i*o,t=Math.cos(e),n=Math.sin(e);u[f]=new cc_1.Vec3(s*n,a*l,s*t),w[f]=new cc_1.Vec3(0,l,0),d[f]=cc.v2(.5-.5*n*l,.5+.5*t),++f}for(let c=0;c<i;++c){const e=n+c,a=r+c;t?(m[P]=a+1,m[++P]=e,m[++P]=a,++P):(m[P]=e,m[++P]=a+1,m[++P]=a,++P)}}return function(){const n=[],s=(c-e)/t;for(let l=0;l<=r;l++){const _=[],V=l/r,m=V*(c-e)+e;for(let c=0;c<=i;++c){const e=c/i,n=e*o,r=Math.sin(n),l=Math.cos(n);u[f]=new cc_1.Vec3(m*r,V*t-a,m*l),w[f]=new cc_1.Vec3(r,-s,l),w[f].normalize(),d[f]=cc.v2(2*(1-e)%1,V),_.push(f),++f}n.push(_)}for(let c=0;c<r;++c)for(let e=0;e<i;++e){const t=n[c][e],a=n[c+1][e],i=n[c+1][e+1],r=n[c][e+1];m[P]=t,m[++P]=r,m[++P]=a,m[++P]=r,m[++P]=i,m[++P]=a,++P}}(),s&&(e>0&&y(!1),c>0&&y(!0)),{positions:u,normals:w,uvs:d,indices:m,minPos:p,maxPos:M}}calcConeData(c,e,t={}){return this.calcCylinderData(0,c,e,t)}calcQuadData(c,e,t,n=new cc_1.Vec3(0,0,1)){const a=e/2,i=t/2,r=[],s=tempQuat_a;MQuat.rotationTo(s,v3_forward,n),r[0]=new cc_1.Vec3(c),r[0].add(MVec3.transformQuat(tempVec3,new cc_1.Vec3(-a,i,0),s)),r[1]=new cc_1.Vec3(c),r[1].add(MVec3.transformQuat(tempVec3,new cc_1.Vec3(-a,-i,0),s)),r[2]=new cc_1.Vec3(c),r[2].add(MVec3.transformQuat(tempVec3,new cc_1.Vec3(a,-i,0),s)),r[3]=new cc_1.Vec3(c),r[3].add(MVec3.transformQuat(tempVec3,new cc_1.Vec3(a,i,0),s));const o=new cc_1.Vec3(c);o.add(MVec3.transformQuat(tempVec3,new cc_1.Vec3(-a,-i,-.01),s));const l=new cc_1.Vec3(c);l.add(MVec3.transformQuat(tempVec3,new cc_1.Vec3(a,i,.01),s));const _=[cc.v2(0,1),cc.v2(0,0),cc.v2(1,0),cc.v2(1,1)];return{positions:r,normals:Array(4).fill(n),indices:[0,3,1,3,2,1],minPos:o,maxPos:l,uvs:_,doubleSided:!0}}lineWithBoundingBox(c,e=3){return{positions:[new cc_1.Vec3,new cc_1.Vec3(c,0,0)],normals:Array(2).fill(new cc_1.Vec3(0,1,0)),indices:[0,1],minPos:new cc_1.Vec3(0,-e,-e),maxPos:new cc_1.Vec3(c,e,e),primitiveType:PrimitiveMode.LINE_LIST}}calcCubeData(c,e,t,n={}){const a=n.widthSegments?n.widthSegments:1,i=n.heightSegments?n.heightSegments:1,r=n.lengthSegments?n.lengthSegments:1,s=.5*c,o=.5*e,l=.5*t,_=[new cc_1.Vec3(-s,-o,l),new cc_1.Vec3(s,-o,l),new cc_1.Vec3(s,o,l),new cc_1.Vec3(-s,o,l),new cc_1.Vec3(s,-o,-l),new cc_1.Vec3(-s,-o,-l),new cc_1.Vec3(-s,o,-l),new cc_1.Vec3(s,o,-l)],V=[[2,3,1],[4,5,7],[7,6,2],[1,0,4],[1,4,2],[5,0,6]],m=[new cc_1.Vec3(0,0,1),new cc_1.Vec3(0,0,-1),new cc_1.Vec3(0,1,0),new cc_1.Vec3(0,-1,0),new cc_1.Vec3(1,0,0),new cc_1.Vec3(-1,0,0)],u=[],w=[],d=[],h=[],p=new cc_1.Vec3(-s,-o,-l),M=new cc_1.Vec3(s,o,l);function f(c,e,t){let n,a,i,r;const s=u.length,o=V[c],l=m[c],p=new cc_1.Vec3,M=new cc_1.Vec3;for(r=0;r<=t;r++)for(i=0;i<=e;i++){n=i/e,a=r/t,MVec3.lerp(p,_[o[0]],_[o[1]],n),MVec3.lerp(M,_[o[0]],_[o[2]],a),M.subtract(_[o[0]]);const c=new cc_1.Vec3(p);if(c.add(M),u.push(c),w.push(l.clone()),d.push(cc.v2(n,a)),i<e&&r<t){const c=e+1,t=i+r*c,n=i+(r+1)*c,a=i+1+(r+1)*c,o=i+1+r*c;h.push(s+t,s+o,s+n),h.push(s+n,s+o,s+a)}}}return f(0,a,i),f(4,r,i),f(1,a,i),f(5,r,i),f(3,a,r),f(2,a,r),{positions:u,indices:h,normals:w,minPos:p,maxPos:M}}torus(c,e,t={}){const n=t.radialSegments||30,a=t.tubularSegments||20,i=t.arc||2*Math.PI,r=[],s=[],o=[],l=[],_=new cc_1.Vec3(-c-e,-e,-c-e),V=new cc_1.Vec3(c+e,e,c+e);for(let t=0;t<=n;t++)for(let _=0;_<=a;_++){const V=_/a,m=t/n,u=V*i,w=m*Math.PI*2,d=(c+e*Math.cos(w))*Math.sin(u),h=e*Math.sin(w),p=(c+e*Math.cos(w))*Math.cos(u),M=Math.sin(u)*Math.cos(w),f=Math.sin(w),P=Math.cos(u)*Math.cos(w);if(r.push(new cc_1.Vec3(d,h,p)),s.push(new cc_1.Vec3(M,f,P)),o.push(cc.v2(V,m)),_<a&&t<n){const c=a+1,e=c*t+_,n=c*(t+1)+_,i=c*(t+1)+_+1,r=c*t+_+1;l.push(e,r,n),l.push(r,i,n)}}return{positions:r,indices:l,normals:s,uvs:o,minPos:_,maxPos:V}}calcArcPoints(c,e,t,n,a,i=60){MVec3.normalize(tempVec3_a,t),MVec3.normalize(tempVec3_b,e);const r=tempQuat_a,s=i;MQuat.fromAxisAngle(r,tempVec3_b,n/(s-1));const o=tempVec3;MVec3.multiplyScalar(o,tempVec3_a,a);const l=[];for(let e=0;e<s;e++)l[e]=new cc_1.Vec3(c),l[e].add(o),MVec3.transformQuat(o,o,r);return l}getBiNormalByNormal(c){const e=new cc_1.Vec3;return MVec3.cross(e,c,new cc_1.Vec3(0,1,0)),MVec3.lengthSqr(e)<.001&&MVec3.cross(e,c,new cc_1.Vec3(1,0,0)),e}calcCirclePoints(c,e,t,n=60){const a=this.getBiNormalByNormal(e);return this.calcArcPoints(c,e,a,EditorMath.TWO_PI,t,n)}calcDiscPoints(c,e,t,n=60){const a=this.getBiNormalByNormal(e);return this.calcSectorPoints(c,e,a,EditorMath.TWO_PI,t,n)}calcSectorPoints(c,e,t,n,a,i){let r=[];r.push(c);const s=this.calcArcPoints(c,e,t,n,a,i);return r=r.concat(s)}calcSectorData(c,e,t,n,a,i){return{positions:this.calcSectorPoints(c,e,t,n,a,i),normals:Array(i+1).fill(new cc_1.Vec3(e)),indices:[...Array(i+1).keys()],primitiveType:PrimitiveMode.TRIANGLE_FAN}}arcDirectionLine(c,e,t,n,a,i,r){const s=[],o=[],l=this.calcArcPoints(c,e,t,n,a,r),_=new cc_1.Vec3;MVec3.multiplyScalar(_,e,i);for(let c=0;c<l.length;c++){const e=new cc_1.Vec3;MVec3.add(e,l[c],_),s.push(l[c],e),o.push(2*c,2*c+1)}for(let c=1;c<l.length;c++)s.push(l[c-1]),o.push(s.length-1),s.push(l[c]),o.push(s.length-1);return{positions:s,normals:Array(s.length).fill(new cc_1.Vec3(0,1,1)),indices:o,primitiveType:PrimitiveMode.LINE_LIST}}calcBoxPoints(c,e){const t=new cc_1.Vec3;MVec3.multiplyScalar(t,e,.5);const n=[];return n[0]=new cc_1.Vec3(c),n[0].add(new cc_1.Vec3(-t.x,-t.y,-t.z)),n[1]=new cc_1.Vec3(c),n[1].add(new cc_1.Vec3(-t.x,t.y,-t.z)),n[2]=new cc_1.Vec3(c),n[2].add(new cc_1.Vec3(t.x,t.y,-t.z)),n[3]=new cc_1.Vec3(c),n[3].add(new cc_1.Vec3(t.x,-t.y,-t.z)),n[4]=new cc_1.Vec3(c),n[4].add(new cc_1.Vec3(-t.x,-t.y,t.z)),n[5]=new cc_1.Vec3(c),n[5].add(new cc_1.Vec3(-t.x,t.y,t.z)),n[6]=new cc_1.Vec3(c),n[6].add(new cc_1.Vec3(t.x,t.y,t.z)),n[7]=new cc_1.Vec3(c),n[7].add(new cc_1.Vec3(t.x,-t.y,t.z)),n}wireframeBox(c,e){const t=this.calcBoxPoints(c,e),n=[];for(let c=1;c<4;c++)n.push(c-1,c);n.push(0,3);for(let c=5;c<8;c++)n.push(c-1,c);n.push(4,7);for(let c=0;c<4;c++)n.push(c,c+4);return{positions:t,normals:Array(t.length).fill(new cc_1.Vec3(0,1,0)),indices:n,primitiveType:PrimitiveMode.LINE_LIST}}calcFrustum(c,e,t,n,a,i,r){const s=[],o=[];let l,_,V,m;c?_=m=(l=V=e)*n:r?(_=(l=Math.tan(EditorMath.deg2rad(t/2))*a)*n,m=(V=Math.tan(EditorMath.deg2rad(t/2))*i)*n):(l=(_=Math.tan(EditorMath.deg2rad(t/2))*a)/n,V=(m=Math.tan(EditorMath.deg2rad(t/2))*i)/n),s[0]=new cc_1.Vec3(-_,-l,-a),s[1]=new cc_1.Vec3(-_,l,-a),s[2]=new cc_1.Vec3(_,l,-a),s[3]=new cc_1.Vec3(_,-l,-a),s[4]=new cc_1.Vec3(-m,-V,-i),s[5]=new cc_1.Vec3(-m,V,-i),s[6]=new cc_1.Vec3(m,V,-i),s[7]=new cc_1.Vec3(m,-V,-i);for(let c=1;c<4;c++)o.push(c-1,c);o.push(0,3);for(let c=5;c<8;c++)o.push(c-1,c);o.push(4,7);for(let c=0;c<4;c++)o.push(c,c+4);return{positions:s,indices:o,normals:Array(s.length).fill(new cc_1.Vec3(0,1,0)),primitiveType:PrimitiveMode.LINE_LIST}}calcRectangleData(c,e,t){const n=this.calcRectanglePoints(c,e,t);return{positions:n.vertices,normals:Array(n.vertices.length).fill(new cc_1.Vec3(0,1,0)),indices:n.indices,primitiveType:PrimitiveMode.LINE_LIST}}calcArcData(c,e,t,n,a,i=60){MVec3.normalize(tempVec3_a,t),MVec3.normalize(tempVec3_b,e);const r=tempQuat_a,s=i;MQuat.fromAxisAngle(r,tempVec3_b,n/(s-1));const o=new cc_1.Vec3;MVec3.multiplyScalar(o,tempVec3_a,a);const l=[];for(let e=0;e<s;e++)l[e]=new cc_1.Vec3(c),l[e].add(o),MVec3.transformQuat(o,o,r);return{positions:l,normals:Array(i).fill(new cc_1.Vec3(tempVec3_b)),indices:[...Array(i).keys()],primitiveType:PrimitiveMode.LINE_STRIP}}calcCircleData(c,e,t,n=60){const a=this.getBiNormalByNormal(e);return this.calcArcData(c,e,a,EditorMath.TWO_PI,t,n)}calcLinesData(c,e,t=!0){let n={positions:c,normals:Array(c.length).fill(new cc_1.Vec3(0,1,0)),indices:e,primitiveType:PrimitiveMode.LINE_LIST};if(t){let e=new cc_1.Vec3,t=new cc_1.Vec3;if(c.length>0){e.set(c[0]),t.set(c[0]);for(let n=1;n<c.length;n++)cc_1.Vec3.min(e,e,c[n]),cc_1.Vec3.max(t,t,c[n])}n.minPos=e,n.maxPos=t}return n}calcDiscData(c,e,t,n=60){const a=this.getBiNormalByNormal(e);let i=new cc_1.Vec3(t,t,0),r=new cc_1.Vec3(-t,-t,0);return MQuat.rotationTo(tempQuat_a,cc_1.Vec3.UNIT_Z,e),i.add(c),MVec3.transformQuat(i,i,tempQuat_a),r.add(c),MVec3.transformQuat(r,r,tempQuat_a),{positions:this.calcSectorPoints(c,e,a,EditorMath.TWO_PI,t,n),normals:Array(n+1).fill(new cc_1.Vec3(e)),indices:[...Array(n+1).keys()],primitiveType:PrimitiveMode.TRIANGLE_FAN,minPos:r,maxPos:i}}calcLineData(c,e){let t=new cc_1.Vec3,n=new cc_1.Vec3;return cc_1.Vec3.min(t,c,e),cc_1.Vec3.max(n,c,e),{positions:[new cc_1.Vec3(c.x,c.y,c.z),new cc_1.Vec3(e.x,e.y,e.z)],normals:Array(2).fill(new cc_1.Vec3(0,1,0)),indices:[0,1],minPos:t,maxPos:n,primitiveType:PrimitiveMode.LINE_LIST}}calcPolygonData(c,e){let t,n=new cc_1.Vec3,a=new cc_1.Vec3;return c.forEach(c=>{cc_1.Vec3.min(n,n,c),cc_1.Vec3.max(a,a,c)}),t=e||[...c.keys()],{positions:c,normals:Array(c.length).fill(new cc_1.Vec3(0,1,0)),indices:t,minPos:n,maxPos:a,primitiveType:PrimitiveMode.TRIANGLE_LIST}}}exports.default=new ControllerShape;