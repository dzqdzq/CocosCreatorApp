"use strict";var __importDefault=this&&this.__importDefault||function(c){return c&&c.__esModule?c:{default:c}};Object.defineProperty(exports,"__esModule",{value:!0});const engine_1=__importDefault(require("../../../utils/engine")),cc_1=require("cc"),external_1=__importDefault(require("../../../utils/external")),{PrimitiveMode:PrimitiveMode}=engine_1.default,EditorMath=external_1.default.EditorMath,v3_forward=new cc_1.Vec3(0,0,1),tempVec3=new cc_1.Vec3,tempVec3_a=new cc_1.Vec3,tempVec3_b=new cc_1.Vec3,tempQuat_a=new cc_1.Quat;class ControllerShape{constructor(){this.calcRectanglePoints=function(c,e,t){const n=new cc_1.Vec3(t.x/2,0,0),a=new cc_1.Vec3(0,t.y/2,0);cc_1.Vec3.transformQuat(n,n,e),cc_1.Vec3.transformQuat(a,a,e);const o=[];o[0]=c.clone(),o[0].add(n),o[0].add(a),o[1]=c.clone(),o[1].add(n),o[1].subtract(a),o[2]=c.clone(),o[2].subtract(n),o[2].subtract(a),o[3]=c.clone(),o[3].subtract(n),o[3].add(a);const s=[];for(let c=1;c<4;c++)s.push(c-1,c);return s.push(0,3),{vertices:o,indices:s}},this.calcSphereData=function(c,e=.5,t={}){const n=void 0!==t.segments?t.segments:32,a=[],o=[],s=[],i=[],r=new cc_1.Vec3(-e,-e,-e),l=new cc_1.Vec3(e,e,e),_=e;for(let t=0;t<=n;++t){const r=t*Math.PI/n,l=Math.sin(r),_=-Math.cos(r);for(let r=0;r<=n;++r){const V=2*r*Math.PI/n-Math.PI/2,m=Math.sin(V)*l,u=_,h=Math.cos(V)*l,d=r/n,p=t/n;if(a.push(new cc_1.Vec3(c.x+m*e,c.y+u*e,c.z+h*e)),o.push(new cc_1.Vec3(m,u,h)),s.push(cc.v2(d,p)),t<n&&r<n){const c=n+1,e=c*t+r,a=c*(t+1)+r,o=c*(t+1)+r+1,s=c*t+r+1;i.push(e,s,a),i.push(s,o,a)}}}return{positions:a,indices:i,normals:o,uvs:s,minPos:r,maxPos:l,boundingRadius:_}}}calcCylinderData(c=.5,e=.5,t=2,n={}){const a=.5*t,o=n.radialSegments||16,s=n.heightSegments||1,i=void 0===n.capped||n.capped,r=n.arc||2*Math.PI;let l=0;i||(c>0&&l++,e>0&&l++);let _=(o+1)*(s+1);i&&(_+=(o+1)*l+o*l);let V=o*s*2*3;i&&(V+=o*l*3);const m=new Array(V),u=new Array(_),h=new Array(_),d=new Array(_),p=Math.max(c,e),w=new cc_1.Vec3(-p,-a,-p),f=new cc_1.Vec3(p,a,p);let y=0,P=0;function g(t){const n=t?c:e,s=t?1:-1,i=y;for(let c=1;c<=o;++c)u[y]=new cc_1.Vec3(0,a*s,0),h[y]=new cc_1.Vec3(0,s,0),d[y]=cc.v2(.5,.5),++y;const l=y;for(let c=0;c<=o;++c){const e=c/o*r,t=Math.cos(e),i=Math.sin(e);u[y]=new cc_1.Vec3(n*i,a*s,n*t),h[y]=new cc_1.Vec3(0,s,0),d[y]=cc.v2(.5-.5*i*s,.5+.5*t),++y}for(let c=0;c<o;++c){const e=i+c,n=l+c;t?(m[P]=n+1,m[++P]=e,m[++P]=n,++P):(m[P]=e,m[++P]=n+1,m[++P]=n,++P)}}return function(){const n=[],i=(c-e)/t;for(let l=0;l<=s;l++){const _=[],V=l/s,m=V*(c-e)+e;for(let c=0;c<=o;++c){const e=c/o,n=e*r,s=Math.sin(n),l=Math.cos(n);u[y]=new cc_1.Vec3(m*s,V*t-a,m*l),h[y]=new cc_1.Vec3(s,-i,l),h[y].normalize(),d[y]=cc.v2(2*(1-e)%1,V),_.push(y),++y}n.push(_)}for(let c=0;c<s;++c)for(let e=0;e<o;++e){const t=n[c][e],a=n[c+1][e],o=n[c+1][e+1],s=n[c][e+1];m[P]=t,m[++P]=s,m[++P]=a,m[++P]=s,m[++P]=o,m[++P]=a,++P}}(),i&&(e>0&&g(!1),c>0&&g(!0)),{positions:u,normals:h,uvs:d,indices:m,minPos:w,maxPos:f}}calcConeData(c,e,t={}){return this.calcCylinderData(0,c,e,t)}calcPositionData(c,e,t,n=new cc_1.Vec3(0,0,1),a=!0){const o=e/2,s=t/2,i=[],r=tempQuat_a;let l,_;return cc_1.Quat.rotationTo(r,v3_forward,n),i[0]=c.clone(),i[0].add(cc_1.Vec3.transformQuat(tempVec3,new cc_1.Vec3(-o,s,0),r)),i[1]=c.clone(),i[1].add(cc_1.Vec3.transformQuat(tempVec3,new cc_1.Vec3(-o,-s,0),r)),i[2]=c.clone(),i[2].add(cc_1.Vec3.transformQuat(tempVec3,new cc_1.Vec3(o,-s,0),r)),i[3]=c.clone(),i[3].add(cc_1.Vec3.transformQuat(tempVec3,new cc_1.Vec3(o,s,0),r)),a&&((l=c.clone()).add(cc_1.Vec3.transformQuat(tempVec3,new cc_1.Vec3(-o,-s,-.01),r)),(_=c.clone()).add(cc_1.Vec3.transformQuat(tempVec3,new cc_1.Vec3(o,s,.01),r))),{positions:i,minPos:l,maxPos:_}}calcQuadData(c,e,t,n=new cc_1.Vec3(0,0,1),a=!0){const o=[cc.v2(0,1),cc.v2(0,0),cc.v2(1,0),cc.v2(1,1)],{positions:s,minPos:i,maxPos:r}=this.calcPositionData(c,e,t,n,a);return{positions:s,normals:Array(4).fill(n),indices:[0,3,1,3,2,1],minPos:i,maxPos:r,uvs:o,doubleSided:!0}}lineWithBoundingBox(c,e=3){return{positions:[new cc_1.Vec3,new cc_1.Vec3(c,0,0)],normals:Array(2).fill(new cc_1.Vec3(0,1,0)),indices:[0,1],minPos:new cc_1.Vec3(0,-e,-e),maxPos:new cc_1.Vec3(c,e,e),primitiveType:PrimitiveMode.LINE_LIST}}calcCubeData(c,e,t,n,a={}){const o=a.widthSegments?a.widthSegments:1,s=a.heightSegments?a.heightSegments:1,i=a.lengthSegments?a.lengthSegments:1,r=.5*c,l=.5*e,_=.5*t,V=[new cc_1.Vec3(-r,-l,_),new cc_1.Vec3(r,-l,_),new cc_1.Vec3(r,l,_),new cc_1.Vec3(-r,l,_),new cc_1.Vec3(r,-l,-_),new cc_1.Vec3(-r,-l,-_),new cc_1.Vec3(-r,l,-_),new cc_1.Vec3(r,l,-_)],m=[[2,3,1],[4,5,7],[7,6,2],[1,0,4],[1,4,2],[5,0,6]],u=[new cc_1.Vec3(0,0,1),new cc_1.Vec3(0,0,-1),new cc_1.Vec3(0,1,0),new cc_1.Vec3(0,-1,0),new cc_1.Vec3(1,0,0),new cc_1.Vec3(-1,0,0)],h=[],d=[],p=[],w=[],f=new cc_1.Vec3(-r,-l,-_),y=new cc_1.Vec3(r,l,_);function P(c,e,t){let a,o,s,i;const r=h.length,l=m[c],_=u[c],f=tempVec3_a,y=tempVec3_b;for(i=0;i<=t;i++)for(s=0;s<=e;s++){a=s/e,o=i/t,cc_1.Vec3.lerp(f,V[l[0]],V[l[1]],a),cc_1.Vec3.lerp(y,V[l[0]],V[l[2]],o),y.subtract(V[l[0]]);const c=new cc_1.Vec3(f),m=_.clone();if(c.add(y),d.push(m),n&&cc_1.Vec3.add(c,n,c),h.push(c),p.push(cc.v2(a,o)),s<e&&i<t){const c=e+1,t=s+i*c,n=s+(i+1)*c,a=s+1+(i+1)*c,o=s+1+i*c;w.push(r+t,r+o,r+n),w.push(r+n,r+o,r+a)}}}return P(0,o,s),P(4,i,s),P(1,o,s),P(5,i,s),P(3,o,i),P(2,o,i),{positions:h,indices:w,normals:d,minPos:f,maxPos:y}}torus(c,e,t={}){const n=t.radialSegments||30,a=t.tubularSegments||20,o=t.arc||2*Math.PI,s=[],i=[],r=[],l=[],_=new cc_1.Vec3(-c-e,-e,-c-e),V=new cc_1.Vec3(c+e,e,c+e);for(let t=0;t<=n;t++)for(let _=0;_<=a;_++){const V=_/a,m=t/n,u=V*o,h=m*Math.PI*2,d=(c+e*Math.cos(h))*Math.sin(u),p=e*Math.sin(h),w=(c+e*Math.cos(h))*Math.cos(u),f=Math.sin(u)*Math.cos(h),y=Math.sin(h),P=Math.cos(u)*Math.cos(h);if(s.push(new cc_1.Vec3(d,p,w)),i.push(new cc_1.Vec3(f,y,P)),r.push(cc.v2(V,m)),_<a&&t<n){const c=a+1,e=c*t+_,n=c*(t+1)+_,o=c*(t+1)+_+1,s=c*t+_+1;l.push(e,s,n),l.push(s,o,n)}}return{positions:s,indices:l,normals:i,uvs:r,minPos:_,maxPos:V}}calcArcPoints(c,e,t,n,a,o=60){cc_1.Vec3.normalize(tempVec3_a,t),cc_1.Vec3.normalize(tempVec3_b,e);const s=tempQuat_a,i=o;cc_1.Quat.fromAxisAngle(s,tempVec3_b,n/(i-1));const r=tempVec3;cc_1.Vec3.multiplyScalar(r,tempVec3_a,a);const l=[];for(let e=0;e<i;e++)l[e]=c.clone(),l[e].add(r),cc_1.Vec3.transformQuat(r,r,s);return l}getBiNormalByNormal(c){const e=new cc_1.Vec3;return cc_1.Vec3.cross(e,c,new cc_1.Vec3(0,1,0)),cc_1.Vec3.lengthSqr(e)<.001&&cc_1.Vec3.cross(e,c,new cc_1.Vec3(1,0,0)),e}calcCirclePoints(c,e,t,n=60){const a=this.getBiNormalByNormal(e);return this.calcArcPoints(c,e,a,EditorMath.TWO_PI,t,n)}calcDiscPoints(c,e,t,n=60){const a=this.getBiNormalByNormal(e);return this.calcSectorPoints(c,e,a,EditorMath.TWO_PI,t,n)}calcSectorPoints(c,e,t,n,a,o){let s=[];s.push(c);const i=this.calcArcPoints(c,e,t,n,a,o);return s=s.concat(i)}indicesFanToList(c){const e=Array(3*(c.length-2)).fill(0);for(let t=1;t<c.length-1;t++)e[3*(t-1)]=0,e[3*(t-1)+1]=t,e[3*(t-1)+2]=t+1;return e}calcSectorData(c,e,t,n,a,o){return{positions:this.calcSectorPoints(c,e,t,n,a,o),normals:Array(o+1).fill(e.clone()),indices:this.indicesFanToList([...Array(o+1).keys()]),primitiveType:PrimitiveMode.TRIANGLE_LIST}}arcDirectionLine(c,e,t,n,a,o,s){const i=[],r=[],l=this.calcArcPoints(c,e,t,n,a,s),_=new cc_1.Vec3;cc_1.Vec3.multiplyScalar(_,e,o);for(let c=0;c<l.length;c++){const e=new cc_1.Vec3;cc_1.Vec3.add(e,l[c],_),i.push(l[c],e),r.push(2*c,2*c+1)}for(let c=1;c<l.length;c++)i.push(l[c-1]),r.push(i.length-1),i.push(l[c]),r.push(i.length-1);return{positions:i,normals:Array(i.length).fill(new cc_1.Vec3(0,1,1)),indices:r,primitiveType:PrimitiveMode.LINE_LIST}}calcBoxPoints(c,e){const t=new cc_1.Vec3;cc_1.Vec3.multiplyScalar(t,e,.5);const n=[];return n[0]=new cc_1.Vec3(c),n[0].add(new cc_1.Vec3(-t.x,-t.y,-t.z)),n[1]=new cc_1.Vec3(c),n[1].add(new cc_1.Vec3(-t.x,t.y,-t.z)),n[2]=new cc_1.Vec3(c),n[2].add(new cc_1.Vec3(t.x,t.y,-t.z)),n[3]=new cc_1.Vec3(c),n[3].add(new cc_1.Vec3(t.x,-t.y,-t.z)),n[4]=new cc_1.Vec3(c),n[4].add(new cc_1.Vec3(-t.x,-t.y,t.z)),n[5]=new cc_1.Vec3(c),n[5].add(new cc_1.Vec3(-t.x,t.y,t.z)),n[6]=new cc_1.Vec3(c),n[6].add(new cc_1.Vec3(t.x,t.y,t.z)),n[7]=new cc_1.Vec3(c),n[7].add(new cc_1.Vec3(t.x,-t.y,t.z)),n}wireframeBox(c,e){const t=this.calcBoxPoints(c,e),n=[];for(let c=1;c<4;c++)n.push(c-1,c);n.push(0,3);for(let c=5;c<8;c++)n.push(c-1,c);n.push(4,7);for(let c=0;c<4;c++)n.push(c,c+4);return{positions:t,normals:Array(t.length).fill(new cc_1.Vec3(0,1,0)),indices:n,primitiveType:PrimitiveMode.LINE_LIST}}calcFrustum(c,e,t,n,a,o,s){const i=[],r=[];let l,_,V,m;c?_=m=(l=V=e)*n:s?(_=(l=Math.tan(EditorMath.deg2rad(t/2))*a)*n,m=(V=Math.tan(EditorMath.deg2rad(t/2))*o)*n):(l=(_=Math.tan(EditorMath.deg2rad(t/2))*a)/n,V=(m=Math.tan(EditorMath.deg2rad(t/2))*o)/n),i[0]=new cc_1.Vec3(-_,-l,-a),i[1]=new cc_1.Vec3(-_,l,-a),i[2]=new cc_1.Vec3(_,l,-a),i[3]=new cc_1.Vec3(_,-l,-a),i[4]=new cc_1.Vec3(-m,-V,-o),i[5]=new cc_1.Vec3(-m,V,-o),i[6]=new cc_1.Vec3(m,V,-o),i[7]=new cc_1.Vec3(m,-V,-o);for(let c=1;c<4;c++)r.push(c-1,c);r.push(0,3);for(let c=5;c<8;c++)r.push(c-1,c);r.push(4,7);for(let c=0;c<4;c++)r.push(c,c+4);return{positions:i,indices:r,normals:Array(i.length).fill(new cc_1.Vec3(0,1,0)),primitiveType:PrimitiveMode.LINE_LIST}}calcRectangleData(c,e,t){const n=this.calcRectanglePoints(c,e,t);return{positions:n.vertices,normals:Array(n.vertices.length).fill(new cc_1.Vec3(0,1,0)),indices:n.indices,primitiveType:PrimitiveMode.LINE_LIST}}calcArcData(c,e,t,n,a,o=60){cc_1.Vec3.normalize(tempVec3_a,t),cc_1.Vec3.normalize(tempVec3_b,e);const s=tempQuat_a,i=o;cc_1.Quat.fromAxisAngle(s,tempVec3_b,n/(i-1));const r=new cc_1.Vec3;cc_1.Vec3.multiplyScalar(r,tempVec3_a,a);const l=[];for(let e=0;e<i;e++)l[e]=c.clone(),l[e].add(r),cc_1.Vec3.transformQuat(r,r,s);return{positions:l,normals:Array(o).fill(new cc_1.Vec3(tempVec3_b)),indices:[...Array(o).keys()],primitiveType:PrimitiveMode.LINE_STRIP}}calcCircleData(c,e,t,n=60){const a=this.getBiNormalByNormal(e);return this.calcArcData(c,e,a,EditorMath.TWO_PI,t,n)}calcLinesData(c,e,t=!0){const n={positions:c,normals:Array(c.length).fill(new cc_1.Vec3(0,1,0)),indices:e,primitiveType:PrimitiveMode.LINE_LIST};if(t){const e=new cc_1.Vec3,t=new cc_1.Vec3;if(c.length>0){e.set(c[0]),t.set(c[0]);for(let n=1;n<c.length;n++)cc_1.Vec3.min(e,e,c[n]),cc_1.Vec3.max(t,t,c[n])}n.minPos=e,n.maxPos=t}return n}calcDiscData(c,e,t,n=60){const a=this.getBiNormalByNormal(e),o=new cc_1.Vec3(t,t,0),s=new cc_1.Vec3(-t,-t,0);return cc_1.Quat.rotationTo(tempQuat_a,cc_1.Vec3.UNIT_Z,e),cc_1.Vec3.add(o,o,c),cc_1.Vec3.transformQuat(o,o,tempQuat_a),cc_1.Vec3.add(s,s,c),cc_1.Vec3.transformQuat(s,s,tempQuat_a),{positions:this.calcSectorPoints(c,e,a,EditorMath.TWO_PI,t,n),normals:Array(n+1).fill(e.clone()),indices:this.indicesFanToList([...Array(n+1).keys()]),primitiveType:PrimitiveMode.TRIANGLE_LIST,minPos:s,maxPos:o}}calcLineData(c,e){const t=new cc_1.Vec3,n=new cc_1.Vec3;cc_1.Vec3.min(t,c,e),cc_1.Vec3.max(n,c,e),cc_1.Vec3.subtract(tempVec3,n,t);const a=[];return["x","y","z"].forEach(c=>{0===tempVec3[c]&&a.push(c)}),2===a.length&&a.forEach(c=>{t[c]-=.5,n[c]+=.5}),{positions:[new cc_1.Vec3(c.x,c.y,c.z),new cc_1.Vec3(e.x,e.y,e.z)],normals:Array(2).fill(new cc_1.Vec3(0,1,0)),indices:[0,1],minPos:t,maxPos:n,primitiveType:PrimitiveMode.LINE_LIST}}calcPolygonData(c,e){const t=new cc_1.Vec3,n=new cc_1.Vec3;let a;return c.forEach(c=>{cc_1.Vec3.min(t,t,c),cc_1.Vec3.max(n,n,c)}),a=e||[...c.keys()],{positions:c,normals:Array(c.length).fill(new cc_1.Vec3(0,1,0)),indices:a,minPos:t,maxPos:n,primitiveType:PrimitiveMode.TRIANGLE_LIST}}calcOctahedronData(c,e,t,n,a=.2){const o=t/2,s=n/2,i=new cc_1.Vec3,r=new cc_1.Vec3,l=[new cc_1.Vec3(0,0,0),new cc_1.Vec3(0,1,0),new cc_1.Vec3(o,a,s),new cc_1.Vec3(-o,a,s),new cc_1.Vec3(-o,a,-s),new cc_1.Vec3(o,a,-s)],_=cc_1.Vec3.subtract(new cc_1.Vec3,e,c),V=cc_1.Vec3.len(_);cc_1.Vec3.normalize(_,_);const m=cc_1.Quat.rotationTo(new cc_1.Quat,cc_1.Vec3.UNIT_Y,_),u=cc_1.Mat4.fromRTS(new cc_1.Mat4,m,c,new cc_1.Vec3(V,V,V));for(let c=0;c<l.length;++c){const e=l[c];cc_1.Vec3.transformMat4(e,e,u),cc_1.Vec3.min(i,i,e),cc_1.Vec3.max(r,r,e)}const h=[2,3,0,3,4,0,4,5,0,5,2,0,1,3,2,1,4,3,1,5,4,1,2,5],d=h.length,p=new Array(3*d).fill(0);for(let c=0;c<d;++c){const e=h[c];p[3*c]=l[e].x,p[3*c+1]=l[e].y,p[3*c+2]=l[e].z}const w=external_1.default.GeometryUtils.calculateNormals(p,Array.from({length:d},(c,e)=>e),new Array(p.length).fill(0)),f=[];for(let c=0;c<w.length;c+=3)f.push(new cc_1.Vec3(w[c],w[c+1],w[c+2]));const y=h.map(c=>l[c]),P=[...Array(y.length).keys()];return{primitiveType:PrimitiveMode.TRIANGLE_LIST,positions:y,normals:f,indices:P,minPos:i,maxPos:r}}}exports.default=new ControllerShape;