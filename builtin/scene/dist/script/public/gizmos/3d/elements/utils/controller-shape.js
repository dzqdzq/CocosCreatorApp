"use strict";var __importDefault=this&&this.__importDefault||function(c){return c&&c.__esModule?c:{default:c}};Object.defineProperty(exports,"__esModule",{value:!0});const{PrimitiveMode:PrimitiveMode}=require("../../../utils/engine"),cc_1=require("cc"),external_1=__importDefault(require("../../../utils/external")),EditorMath=external_1.default.EditorMath,Utils=require("../../../utils"),v3_forward=new cc_1.Vec3(0,0,1),tempVec3=new cc_1.Vec3,tempVec3_a=new cc_1.Vec3,tempVec3_b=new cc_1.Vec3,tempQuat_a=new cc_1.Quat;class ControllerShape{constructor(){this.calcRectanglePoints=function(c,e,t){const n=new cc_1.Vec3(t.x/2,0,0),a=new cc_1.Vec3(0,t.y/2,0);cc_1.Vec3.transformQuat(n,n,e),cc_1.Vec3.transformQuat(a,a,e);const r=[];r[0]=new cc_1.Vec3(c),r[0].add(n),r[0].add(a),r[1]=new cc_1.Vec3(c),r[1].add(n),r[1].subtract(a),r[2]=new cc_1.Vec3(c),r[2].subtract(n),r[2].subtract(a),r[3]=new cc_1.Vec3(c),r[3].subtract(n),r[3].add(a);const s=[];for(let c=1;c<4;c++)s.push(c-1,c);return s.push(0,3),{vertices:r,indices:s}},this.calcSphereData=function(c,e=.5,t={}){const n=void 0!==t.segments?t.segments:32,a=[],r=[],s=[],i=[],o=new cc_1.Vec3(-e,-e,-e),_=new cc_1.Vec3(e,e,e),l=e;for(let t=0;t<=n;++t){const o=t*Math.PI/n,_=Math.sin(o),l=-Math.cos(o);for(let o=0;o<=n;++o){const V=2*o*Math.PI/n-Math.PI/2,m=Math.sin(V)*_,w=l,u=Math.cos(V)*_,h=o/n,d=t/n;if(a.push(new cc_1.Vec3(c.x+m*e,c.y+w*e,c.z+u*e)),r.push(new cc_1.Vec3(m,w,u)),s.push(cc.v2(h,d)),t<n&&o<n){const c=n+1,e=c*t+o,a=c*(t+1)+o,r=c*(t+1)+o+1,s=c*t+o+1;i.push(e,s,a),i.push(s,r,a)}}}return{positions:a,indices:i,normals:r,uvs:s,minPos:o,maxPos:_,boundingRadius:l}}}calcCylinderData(c=.5,e=.5,t=2,n={}){const a=.5*t,r=n.radialSegments||16,s=n.heightSegments||1,i=void 0===n.capped||n.capped,o=n.arc||2*Math.PI;let _=0;i||(c>0&&_++,e>0&&_++);let l=(r+1)*(s+1);i&&(l+=(r+1)*_+r*_);let V=r*s*2*3;i&&(V+=r*_*3);const m=new Array(V),w=new Array(l),u=new Array(l),h=new Array(l),d=Math.max(c,e),p=new cc_1.Vec3(-d,-a,-d),f=new cc_1.Vec3(d,a,d);let y=0,P=0;function M(t){let n,s;const i=t?c:e,_=t?1:-1;n=y;for(let c=1;c<=r;++c)w[y]=new cc_1.Vec3(0,a*_,0),u[y]=new cc_1.Vec3(0,_,0),h[y]=cc.v2(.5,.5),++y;s=y;for(let c=0;c<=r;++c){const e=c/r*o,t=Math.cos(e),n=Math.sin(e);w[y]=new cc_1.Vec3(i*n,a*_,i*t),u[y]=new cc_1.Vec3(0,_,0),h[y]=cc.v2(.5-.5*n*_,.5+.5*t),++y}for(let c=0;c<r;++c){const e=n+c,a=s+c;t?(m[P]=a+1,m[++P]=e,m[++P]=a,++P):(m[P]=e,m[++P]=a+1,m[++P]=a,++P)}}return function(){const n=[],i=(c-e)/t;for(let _=0;_<=s;_++){const l=[],V=_/s,m=V*(c-e)+e;for(let c=0;c<=r;++c){const e=c/r,n=e*o,s=Math.sin(n),_=Math.cos(n);w[y]=new cc_1.Vec3(m*s,V*t-a,m*_),u[y]=new cc_1.Vec3(s,-i,_),u[y].normalize(),h[y]=cc.v2(2*(1-e)%1,V),l.push(y),++y}n.push(l)}for(let c=0;c<s;++c)for(let e=0;e<r;++e){const t=n[c][e],a=n[c+1][e],r=n[c+1][e+1],s=n[c][e+1];m[P]=t,m[++P]=s,m[++P]=a,m[++P]=s,m[++P]=r,m[++P]=a,++P}}(),i&&(e>0&&M(!1),c>0&&M(!0)),{positions:w,normals:u,uvs:h,indices:m,minPos:p,maxPos:f}}calcConeData(c,e,t={}){return this.calcCylinderData(0,c,e,t)}calcQuadData(c,e,t,n=new cc_1.Vec3(0,0,1)){const a=e/2,r=t/2,s=[],i=tempQuat_a;cc_1.Quat.rotationTo(i,v3_forward,n),s[0]=new cc_1.Vec3(c),s[0].add(cc_1.Vec3.transformQuat(tempVec3,new cc_1.Vec3(-a,r,0),i)),s[1]=new cc_1.Vec3(c),s[1].add(cc_1.Vec3.transformQuat(tempVec3,new cc_1.Vec3(-a,-r,0),i)),s[2]=new cc_1.Vec3(c),s[2].add(cc_1.Vec3.transformQuat(tempVec3,new cc_1.Vec3(a,-r,0),i)),s[3]=new cc_1.Vec3(c),s[3].add(cc_1.Vec3.transformQuat(tempVec3,new cc_1.Vec3(a,r,0),i));const o=new cc_1.Vec3(c);o.add(cc_1.Vec3.transformQuat(tempVec3,new cc_1.Vec3(-a,-r,-.01),i));const _=new cc_1.Vec3(c);_.add(cc_1.Vec3.transformQuat(tempVec3,new cc_1.Vec3(a,r,.01),i));const l=[cc.v2(0,1),cc.v2(0,0),cc.v2(1,0),cc.v2(1,1)];return{positions:s,normals:Array(4).fill(n),indices:[0,3,1,3,2,1],minPos:o,maxPos:_,uvs:l,doubleSided:!0}}lineWithBoundingBox(c,e=3){return{positions:[new cc_1.Vec3,new cc_1.Vec3(c,0,0)],normals:Array(2).fill(new cc_1.Vec3(0,1,0)),indices:[0,1],minPos:new cc_1.Vec3(0,-e,-e),maxPos:new cc_1.Vec3(c,e,e),primitiveType:PrimitiveMode.LINE_LIST}}calcCubeData(c,e,t,n={}){const a=n.widthSegments?n.widthSegments:1,r=n.heightSegments?n.heightSegments:1,s=n.lengthSegments?n.lengthSegments:1,i=.5*c,o=.5*e,_=.5*t,l=[new cc_1.Vec3(-i,-o,_),new cc_1.Vec3(i,-o,_),new cc_1.Vec3(i,o,_),new cc_1.Vec3(-i,o,_),new cc_1.Vec3(i,-o,-_),new cc_1.Vec3(-i,-o,-_),new cc_1.Vec3(-i,o,-_),new cc_1.Vec3(i,o,-_)],V=[[2,3,1],[4,5,7],[7,6,2],[1,0,4],[1,4,2],[5,0,6]],m=[new cc_1.Vec3(0,0,1),new cc_1.Vec3(0,0,-1),new cc_1.Vec3(0,1,0),new cc_1.Vec3(0,-1,0),new cc_1.Vec3(1,0,0),new cc_1.Vec3(-1,0,0)],w=[],u=[],h=[],d=[],p=new cc_1.Vec3(-i,-o,-_),f=new cc_1.Vec3(i,o,_);function y(c,e,t){let n,a,r,s;const i=w.length,o=V[c],_=m[c],p=new cc_1.Vec3,f=new cc_1.Vec3;for(s=0;s<=t;s++)for(r=0;r<=e;r++){n=r/e,a=s/t,cc_1.Vec3.lerp(p,l[o[0]],l[o[1]],n),cc_1.Vec3.lerp(f,l[o[0]],l[o[2]],a),f.subtract(l[o[0]]);const c=new cc_1.Vec3(p);if(c.add(f),w.push(c),u.push(_.clone()),h.push(cc.v2(n,a)),r<e&&s<t){const c=e+1,t=r+s*c,n=r+(s+1)*c,a=r+1+(s+1)*c,o=r+1+s*c;d.push(i+t,i+o,i+n),d.push(i+n,i+o,i+a)}}}return y(0,a,r),y(4,s,r),y(1,a,r),y(5,s,r),y(3,a,s),y(2,a,s),{positions:w,indices:d,normals:u,minPos:p,maxPos:f}}torus(c,e,t={}){const n=t.radialSegments||30,a=t.tubularSegments||20,r=t.arc||2*Math.PI,s=[],i=[],o=[],_=[],l=new cc_1.Vec3(-c-e,-e,-c-e),V=new cc_1.Vec3(c+e,e,c+e);for(let t=0;t<=n;t++)for(let l=0;l<=a;l++){const V=l/a,m=t/n,w=V*r,u=m*Math.PI*2,h=(c+e*Math.cos(u))*Math.sin(w),d=e*Math.sin(u),p=(c+e*Math.cos(u))*Math.cos(w),f=Math.sin(w)*Math.cos(u),y=Math.sin(u),P=Math.cos(w)*Math.cos(u);if(s.push(new cc_1.Vec3(h,d,p)),i.push(new cc_1.Vec3(f,y,P)),o.push(cc.v2(V,m)),l<a&&t<n){const c=a+1,e=c*t+l,n=c*(t+1)+l,r=c*(t+1)+l+1,s=c*t+l+1;_.push(e,s,n),_.push(s,r,n)}}return{positions:s,indices:_,normals:i,uvs:o,minPos:l,maxPos:V}}calcArcPoints(c,e,t,n,a,r=60){cc_1.Vec3.normalize(tempVec3_a,t),cc_1.Vec3.normalize(tempVec3_b,e);const s=tempQuat_a,i=r;cc_1.Quat.fromAxisAngle(s,tempVec3_b,n/(i-1));const o=tempVec3;cc_1.Vec3.multiplyScalar(o,tempVec3_a,a);const _=[];for(let e=0;e<i;e++)_[e]=new cc_1.Vec3(c),_[e].add(o),cc_1.Vec3.transformQuat(o,o,s);return _}getBiNormalByNormal(c){const e=new cc_1.Vec3;return cc_1.Vec3.cross(e,c,new cc_1.Vec3(0,1,0)),cc_1.Vec3.lengthSqr(e)<.001&&cc_1.Vec3.cross(e,c,new cc_1.Vec3(1,0,0)),e}calcCirclePoints(c,e,t,n=60){const a=this.getBiNormalByNormal(e);return this.calcArcPoints(c,e,a,EditorMath.TWO_PI,t,n)}calcDiscPoints(c,e,t,n=60){const a=this.getBiNormalByNormal(e);return this.calcSectorPoints(c,e,a,EditorMath.TWO_PI,t,n)}calcSectorPoints(c,e,t,n,a,r){let s=[];s.push(c);const i=this.calcArcPoints(c,e,t,n,a,r);return s=s.concat(i)}calcSectorData(c,e,t,n,a,r){return{positions:this.calcSectorPoints(c,e,t,n,a,r),normals:Array(r+1).fill(new cc_1.Vec3(e)),indices:[...Array(r+1).keys()],primitiveType:PrimitiveMode.TRIANGLE_FAN}}arcDirectionLine(c,e,t,n,a,r,s){const i=[],o=[],_=this.calcArcPoints(c,e,t,n,a,s),l=new cc_1.Vec3;cc_1.Vec3.multiplyScalar(l,e,r);for(let c=0;c<_.length;c++){const e=new cc_1.Vec3;cc_1.Vec3.add(e,_[c],l),i.push(_[c],e),o.push(2*c,2*c+1)}for(let c=1;c<_.length;c++)i.push(_[c-1]),o.push(i.length-1),i.push(_[c]),o.push(i.length-1);return{positions:i,normals:Array(i.length).fill(new cc_1.Vec3(0,1,1)),indices:o,primitiveType:PrimitiveMode.LINE_LIST}}calcBoxPoints(c,e){const t=new cc_1.Vec3;cc_1.Vec3.multiplyScalar(t,e,.5);const n=[];return n[0]=new cc_1.Vec3(c),n[0].add(new cc_1.Vec3(-t.x,-t.y,-t.z)),n[1]=new cc_1.Vec3(c),n[1].add(new cc_1.Vec3(-t.x,t.y,-t.z)),n[2]=new cc_1.Vec3(c),n[2].add(new cc_1.Vec3(t.x,t.y,-t.z)),n[3]=new cc_1.Vec3(c),n[3].add(new cc_1.Vec3(t.x,-t.y,-t.z)),n[4]=new cc_1.Vec3(c),n[4].add(new cc_1.Vec3(-t.x,-t.y,t.z)),n[5]=new cc_1.Vec3(c),n[5].add(new cc_1.Vec3(-t.x,t.y,t.z)),n[6]=new cc_1.Vec3(c),n[6].add(new cc_1.Vec3(t.x,t.y,t.z)),n[7]=new cc_1.Vec3(c),n[7].add(new cc_1.Vec3(t.x,-t.y,t.z)),n}wireframeBox(c,e){const t=this.calcBoxPoints(c,e),n=[];for(let c=1;c<4;c++)n.push(c-1,c);n.push(0,3);for(let c=5;c<8;c++)n.push(c-1,c);n.push(4,7);for(let c=0;c<4;c++)n.push(c,c+4);return{positions:t,normals:Array(t.length).fill(new cc_1.Vec3(0,1,0)),indices:n,primitiveType:PrimitiveMode.LINE_LIST}}calcFrustum(c,e,t,n,a,r,s){const i=[],o=[];let _,l,V,m;c?l=m=(_=V=e)*n:s?(l=(_=Math.tan(EditorMath.deg2rad(t/2))*a)*n,m=(V=Math.tan(EditorMath.deg2rad(t/2))*r)*n):(_=(l=Math.tan(EditorMath.deg2rad(t/2))*a)/n,V=(m=Math.tan(EditorMath.deg2rad(t/2))*r)/n),i[0]=new cc_1.Vec3(-l,-_,-a),i[1]=new cc_1.Vec3(-l,_,-a),i[2]=new cc_1.Vec3(l,_,-a),i[3]=new cc_1.Vec3(l,-_,-a),i[4]=new cc_1.Vec3(-m,-V,-r),i[5]=new cc_1.Vec3(-m,V,-r),i[6]=new cc_1.Vec3(m,V,-r),i[7]=new cc_1.Vec3(m,-V,-r);for(let c=1;c<4;c++)o.push(c-1,c);o.push(0,3);for(let c=5;c<8;c++)o.push(c-1,c);o.push(4,7);for(let c=0;c<4;c++)o.push(c,c+4);return{positions:i,indices:o,normals:Array(i.length).fill(new cc_1.Vec3(0,1,0)),primitiveType:PrimitiveMode.LINE_LIST}}calcRectangleData(c,e,t){const n=this.calcRectanglePoints(c,e,t);return{positions:n.vertices,normals:Array(n.vertices.length).fill(new cc_1.Vec3(0,1,0)),indices:n.indices,primitiveType:PrimitiveMode.LINE_LIST}}calcArcData(c,e,t,n,a,r=60){cc_1.Vec3.normalize(tempVec3_a,t),cc_1.Vec3.normalize(tempVec3_b,e);const s=tempQuat_a,i=r;cc_1.Quat.fromAxisAngle(s,tempVec3_b,n/(i-1));const o=new cc_1.Vec3;cc_1.Vec3.multiplyScalar(o,tempVec3_a,a);const _=[];for(let e=0;e<i;e++)_[e]=new cc_1.Vec3(c),_[e].add(o),cc_1.Vec3.transformQuat(o,o,s);return{positions:_,normals:Array(r).fill(new cc_1.Vec3(tempVec3_b)),indices:[...Array(r).keys()],primitiveType:PrimitiveMode.LINE_STRIP}}calcCircleData(c,e,t,n=60){const a=this.getBiNormalByNormal(e);return this.calcArcData(c,e,a,EditorMath.TWO_PI,t,n)}calcLinesData(c,e,t=!0){let n={positions:c,normals:Array(c.length).fill(new cc_1.Vec3(0,1,0)),indices:e,primitiveType:PrimitiveMode.LINE_LIST};if(t){let e=new cc_1.Vec3,t=new cc_1.Vec3;if(c.length>0){e.set(c[0]),t.set(c[0]);for(let n=1;n<c.length;n++)cc_1.Vec3.min(e,e,c[n]),cc_1.Vec3.max(t,t,c[n])}n.minPos=e,n.maxPos=t}return n}calcDiscData(c,e,t,n=60){const a=this.getBiNormalByNormal(e);let r=new cc_1.Vec3(t,t,0),s=new cc_1.Vec3(-t,-t,0);return cc_1.Quat.rotationTo(tempQuat_a,cc_1.Vec3.UNIT_Z,e),r.add(c),cc_1.Vec3.transformQuat(r,r,tempQuat_a),s.add(c),cc_1.Vec3.transformQuat(s,s,tempQuat_a),{positions:this.calcSectorPoints(c,e,a,EditorMath.TWO_PI,t,n),normals:Array(n+1).fill(new cc_1.Vec3(e)),indices:[...Array(n+1).keys()],primitiveType:PrimitiveMode.TRIANGLE_FAN,minPos:s,maxPos:r}}calcLineData(c,e){let t=new cc_1.Vec3,n=new cc_1.Vec3;return cc_1.Vec3.min(t,c,e),cc_1.Vec3.max(n,c,e),{positions:[new cc_1.Vec3(c.x,c.y,c.z),new cc_1.Vec3(e.x,e.y,e.z)],normals:Array(2).fill(new cc_1.Vec3(0,1,0)),indices:[0,1],minPos:t,maxPos:n,primitiveType:PrimitiveMode.LINE_LIST}}calcPolygonData(c,e){let t,n=new cc_1.Vec3,a=new cc_1.Vec3;return c.forEach(c=>{cc_1.Vec3.min(n,n,c),cc_1.Vec3.max(a,a,c)}),t=e||[...c.keys()],{positions:c,normals:Array(c.length).fill(new cc_1.Vec3(0,1,0)),indices:t,minPos:n,maxPos:a,primitiveType:PrimitiveMode.TRIANGLE_LIST}}calcOctahedronData(c,e,t,n,a=.2){const r=t/2,s=n/2;let i=new cc_1.Vec3,o=new cc_1.Vec3;const _=[new cc_1.Vec3(0,0,0),new cc_1.Vec3(0,1,0),new cc_1.Vec3(r,a,s),new cc_1.Vec3(-r,a,s),new cc_1.Vec3(-r,a,-s),new cc_1.Vec3(r,a,-s)],l=cc_1.Vec3.subtract(new cc_1.Vec3,e,c),V=cc_1.Vec3.len(l);cc_1.Vec3.normalize(l,l);const m=cc_1.Quat.rotationTo(new cc_1.Quat,cc_1.Vec3.UNIT_Y,l),w=cc_1.Mat4.fromRTS(new cc_1.Mat4,m,c,new cc_1.Vec3(V,V,V));for(let c=0;c<_.length;++c){const e=_[c];cc_1.Vec3.transformMat4(e,e,w),cc_1.Vec3.min(i,i,e),cc_1.Vec3.max(o,o,e)}const u=[2,3,0,3,4,0,4,5,0,5,2,0,1,3,2,1,4,3,1,5,4,1,2,5],h=u.length,d=new Array(3*h).fill(0);for(let c=0;c<h;++c){const e=u[c];d[3*c]=_[e].x,d[3*c+1]=_[e].y,d[3*c+2]=_[e].z}const p=external_1.default.GeometryUtils.calculateNormals(d,Array.from({length:h},(c,e)=>e),new Array(d.length).fill(0)),f=[];for(let c=0;c<p.length;c+=3)f.push(new cc_1.Vec3(p[c],p[c+1],p[c+2]));const y=u.map(c=>_[c]),P=[...Array(y.length).keys()];return{primitiveType:PrimitiveMode.TRIANGLE_LIST,positions:y,normals:f,indices:P,minPos:i,maxPos:o}}}exports.default=new ControllerShape;