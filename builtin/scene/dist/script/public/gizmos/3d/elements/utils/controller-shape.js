"use strict";var __importDefault=this&&this.__importDefault||function(c){return c&&c.__esModule?c:{default:c}};Object.defineProperty(exports,"__esModule",{value:!0});const engine_1=__importDefault(require("../../../utils/engine")),cc_1=require("cc"),external_1=__importDefault(require("../../../utils/external")),{PrimitiveMode:PrimitiveMode}=engine_1.default,EditorMath=external_1.default.EditorMath,v3_forward=new cc_1.Vec3(0,0,1),tempVec3=new cc_1.Vec3,tempVec3_a=new cc_1.Vec3,tempVec3_b=new cc_1.Vec3,tempQuat_a=new cc_1.Quat;class ControllerShape{constructor(){this.calcRectanglePoints=function(c,e,t){const n=new cc_1.Vec3(t.x/2,0,0),a=new cc_1.Vec3(0,t.y/2,0);cc_1.Vec3.transformQuat(n,n,e),cc_1.Vec3.transformQuat(a,a,e);const r=[];r[0]=c.clone(),r[0].add(n),r[0].add(a),r[1]=c.clone(),r[1].add(n),r[1].subtract(a),r[2]=c.clone(),r[2].subtract(n),r[2].subtract(a),r[3]=c.clone(),r[3].subtract(n),r[3].add(a);const o=[];for(let c=1;c<4;c++)o.push(c-1,c);return o.push(0,3),{vertices:r,indices:o}},this.calcSphereData=function(c,e=.5,t={}){const n=void 0!==t.segments?t.segments:32,a=[],r=[],o=[],s=[],i=new cc_1.Vec3(-e,-e,-e),l=new cc_1.Vec3(e,e,e),_=e;for(let t=0;t<=n;++t){const i=t*Math.PI/n,l=Math.sin(i),_=-Math.cos(i);for(let i=0;i<=n;++i){const V=2*i*Math.PI/n-Math.PI/2,m=Math.sin(V)*l,u=_,h=Math.cos(V)*l,d=i/n,p=t/n;if(a.push(new cc_1.Vec3(c.x+m*e,c.y+u*e,c.z+h*e)),r.push(new cc_1.Vec3(m,u,h)),o.push(cc.v2(d,p)),t<n&&i<n){const c=n+1,e=c*t+i,a=c*(t+1)+i,r=c*(t+1)+i+1,o=c*t+i+1;s.push(e,o,a),s.push(o,r,a)}}}return{positions:a,indices:s,normals:r,uvs:o,minPos:i,maxPos:l,boundingRadius:_}}}calcCylinderData(c=.5,e=.5,t=2,n={}){const a=.5*t,r=n.radialSegments||16,o=n.heightSegments||1,s=void 0===n.capped||n.capped,i=n.arc||2*Math.PI;let l=0;s||(c>0&&l++,e>0&&l++);let _=(r+1)*(o+1);s&&(_+=(r+1)*l+r*l);let V=r*o*2*3;s&&(V+=r*l*3);const m=new Array(V),u=new Array(_),h=new Array(_),d=new Array(_),p=Math.max(c,e),w=new cc_1.Vec3(-p,-a,-p),f=new cc_1.Vec3(p,a,p);let y=0,P=0;function g(t){const n=t?c:e,o=t?1:-1,s=y;for(let c=1;c<=r;++c)u[y]=new cc_1.Vec3(0,a*o,0),h[y]=new cc_1.Vec3(0,o,0),d[y]=cc.v2(.5,.5),++y;const l=y;for(let c=0;c<=r;++c){const e=c/r*i,t=Math.cos(e),s=Math.sin(e);u[y]=new cc_1.Vec3(n*s,a*o,n*t),h[y]=new cc_1.Vec3(0,o,0),d[y]=cc.v2(.5-.5*s*o,.5+.5*t),++y}for(let c=0;c<r;++c){const e=s+c,n=l+c;t?(m[P]=n+1,m[++P]=e,m[++P]=n,++P):(m[P]=e,m[++P]=n+1,m[++P]=n,++P)}}return function(){const n=[],s=(c-e)/t;for(let l=0;l<=o;l++){const _=[],V=l/o,m=V*(c-e)+e;for(let c=0;c<=r;++c){const e=c/r,n=e*i,o=Math.sin(n),l=Math.cos(n);u[y]=new cc_1.Vec3(m*o,V*t-a,m*l),h[y]=new cc_1.Vec3(o,-s,l),h[y].normalize(),d[y]=cc.v2(2*(1-e)%1,V),_.push(y),++y}n.push(_)}for(let c=0;c<o;++c)for(let e=0;e<r;++e){const t=n[c][e],a=n[c+1][e],r=n[c+1][e+1],o=n[c][e+1];m[P]=t,m[++P]=o,m[++P]=a,m[++P]=o,m[++P]=r,m[++P]=a,++P}}(),s&&(e>0&&g(!1),c>0&&g(!0)),{positions:u,normals:h,uvs:d,indices:m,minPos:w,maxPos:f}}calcConeData(c,e,t={}){return this.calcCylinderData(0,c,e,t)}calcQuadData(c,e,t,n=new cc_1.Vec3(0,0,1),a=!0){const r=e/2,o=t/2,s=[],i=tempQuat_a;cc_1.Quat.rotationTo(i,v3_forward,n),s[0]=c.clone(),s[0].add(cc_1.Vec3.transformQuat(tempVec3,new cc_1.Vec3(-r,o,0),i)),s[1]=c.clone(),s[1].add(cc_1.Vec3.transformQuat(tempVec3,new cc_1.Vec3(-r,-o,0),i)),s[2]=c.clone(),s[2].add(cc_1.Vec3.transformQuat(tempVec3,new cc_1.Vec3(r,-o,0),i)),s[3]=c.clone(),s[3].add(cc_1.Vec3.transformQuat(tempVec3,new cc_1.Vec3(r,o,0),i));let l,_;a&&((l=c.clone()).add(cc_1.Vec3.transformQuat(tempVec3,new cc_1.Vec3(-r,-o,-.01),i)),(_=c.clone()).add(cc_1.Vec3.transformQuat(tempVec3,new cc_1.Vec3(r,o,.01),i)));const V=[cc.v2(0,1),cc.v2(0,0),cc.v2(1,0),cc.v2(1,1)];return{positions:s,normals:Array(4).fill(n),indices:[0,3,1,3,2,1],minPos:l,maxPos:_,uvs:V,doubleSided:!0}}lineWithBoundingBox(c,e=3){return{positions:[new cc_1.Vec3,new cc_1.Vec3(c,0,0)],normals:Array(2).fill(new cc_1.Vec3(0,1,0)),indices:[0,1],minPos:new cc_1.Vec3(0,-e,-e),maxPos:new cc_1.Vec3(c,e,e),primitiveType:PrimitiveMode.LINE_LIST}}calcCubeData(c,e,t,n,a={}){const r=a.widthSegments?a.widthSegments:1,o=a.heightSegments?a.heightSegments:1,s=a.lengthSegments?a.lengthSegments:1,i=.5*c,l=.5*e,_=.5*t,V=[new cc_1.Vec3(-i,-l,_),new cc_1.Vec3(i,-l,_),new cc_1.Vec3(i,l,_),new cc_1.Vec3(-i,l,_),new cc_1.Vec3(i,-l,-_),new cc_1.Vec3(-i,-l,-_),new cc_1.Vec3(-i,l,-_),new cc_1.Vec3(i,l,-_)],m=[[2,3,1],[4,5,7],[7,6,2],[1,0,4],[1,4,2],[5,0,6]],u=[new cc_1.Vec3(0,0,1),new cc_1.Vec3(0,0,-1),new cc_1.Vec3(0,1,0),new cc_1.Vec3(0,-1,0),new cc_1.Vec3(1,0,0),new cc_1.Vec3(-1,0,0)],h=[],d=[],p=[],w=[],f=new cc_1.Vec3(-i,-l,-_),y=new cc_1.Vec3(i,l,_);function P(c,e,t){let a,r,o,s;const i=h.length,l=m[c],_=u[c],f=tempVec3_a,y=tempVec3_b;for(s=0;s<=t;s++)for(o=0;o<=e;o++){a=o/e,r=s/t,cc_1.Vec3.lerp(f,V[l[0]],V[l[1]],a),cc_1.Vec3.lerp(y,V[l[0]],V[l[2]],r),y.subtract(V[l[0]]);const c=new cc_1.Vec3(f),m=_.clone();if(c.add(y),d.push(m),n&&cc_1.Vec3.add(c,n,c),h.push(c),p.push(cc.v2(a,r)),o<e&&s<t){const c=e+1,t=o+s*c,n=o+(s+1)*c,a=o+1+(s+1)*c,r=o+1+s*c;w.push(i+t,i+r,i+n),w.push(i+n,i+r,i+a)}}}return P(0,r,o),P(4,s,o),P(1,r,o),P(5,s,o),P(3,r,s),P(2,r,s),{positions:h,indices:w,normals:d,minPos:f,maxPos:y}}torus(c,e,t={}){const n=t.radialSegments||30,a=t.tubularSegments||20,r=t.arc||2*Math.PI,o=[],s=[],i=[],l=[],_=new cc_1.Vec3(-c-e,-e,-c-e),V=new cc_1.Vec3(c+e,e,c+e);for(let t=0;t<=n;t++)for(let _=0;_<=a;_++){const V=_/a,m=t/n,u=V*r,h=m*Math.PI*2,d=(c+e*Math.cos(h))*Math.sin(u),p=e*Math.sin(h),w=(c+e*Math.cos(h))*Math.cos(u),f=Math.sin(u)*Math.cos(h),y=Math.sin(h),P=Math.cos(u)*Math.cos(h);if(o.push(new cc_1.Vec3(d,p,w)),s.push(new cc_1.Vec3(f,y,P)),i.push(cc.v2(V,m)),_<a&&t<n){const c=a+1,e=c*t+_,n=c*(t+1)+_,r=c*(t+1)+_+1,o=c*t+_+1;l.push(e,o,n),l.push(o,r,n)}}return{positions:o,indices:l,normals:s,uvs:i,minPos:_,maxPos:V}}calcArcPoints(c,e,t,n,a,r=60){cc_1.Vec3.normalize(tempVec3_a,t),cc_1.Vec3.normalize(tempVec3_b,e);const o=tempQuat_a,s=r;cc_1.Quat.fromAxisAngle(o,tempVec3_b,n/(s-1));const i=tempVec3;cc_1.Vec3.multiplyScalar(i,tempVec3_a,a);const l=[];for(let e=0;e<s;e++)l[e]=c.clone(),l[e].add(i),cc_1.Vec3.transformQuat(i,i,o);return l}getBiNormalByNormal(c){const e=new cc_1.Vec3;return cc_1.Vec3.cross(e,c,new cc_1.Vec3(0,1,0)),cc_1.Vec3.lengthSqr(e)<.001&&cc_1.Vec3.cross(e,c,new cc_1.Vec3(1,0,0)),e}calcCirclePoints(c,e,t,n=60){const a=this.getBiNormalByNormal(e);return this.calcArcPoints(c,e,a,EditorMath.TWO_PI,t,n)}calcDiscPoints(c,e,t,n=60){const a=this.getBiNormalByNormal(e);return this.calcSectorPoints(c,e,a,EditorMath.TWO_PI,t,n)}calcSectorPoints(c,e,t,n,a,r){let o=[];o.push(c);const s=this.calcArcPoints(c,e,t,n,a,r);return o=o.concat(s)}indicesFanToList(c){const e=Array(3*(c.length-2)).fill(0);for(let t=1;t<c.length-1;t++)e[3*(t-1)]=0,e[3*(t-1)+1]=t,e[3*(t-1)+2]=t+1;return e}calcSectorData(c,e,t,n,a,r){return{positions:this.calcSectorPoints(c,e,t,n,a,r),normals:Array(r+1).fill(e.clone()),indices:this.indicesFanToList([...Array(r+1).keys()]),primitiveType:PrimitiveMode.TRIANGLE_LIST}}arcDirectionLine(c,e,t,n,a,r,o){const s=[],i=[],l=this.calcArcPoints(c,e,t,n,a,o),_=new cc_1.Vec3;cc_1.Vec3.multiplyScalar(_,e,r);for(let c=0;c<l.length;c++){const e=new cc_1.Vec3;cc_1.Vec3.add(e,l[c],_),s.push(l[c],e),i.push(2*c,2*c+1)}for(let c=1;c<l.length;c++)s.push(l[c-1]),i.push(s.length-1),s.push(l[c]),i.push(s.length-1);return{positions:s,normals:Array(s.length).fill(new cc_1.Vec3(0,1,1)),indices:i,primitiveType:PrimitiveMode.LINE_LIST}}calcBoxPoints(c,e){const t=new cc_1.Vec3;cc_1.Vec3.multiplyScalar(t,e,.5);const n=[];return n[0]=new cc_1.Vec3(c),n[0].add(new cc_1.Vec3(-t.x,-t.y,-t.z)),n[1]=new cc_1.Vec3(c),n[1].add(new cc_1.Vec3(-t.x,t.y,-t.z)),n[2]=new cc_1.Vec3(c),n[2].add(new cc_1.Vec3(t.x,t.y,-t.z)),n[3]=new cc_1.Vec3(c),n[3].add(new cc_1.Vec3(t.x,-t.y,-t.z)),n[4]=new cc_1.Vec3(c),n[4].add(new cc_1.Vec3(-t.x,-t.y,t.z)),n[5]=new cc_1.Vec3(c),n[5].add(new cc_1.Vec3(-t.x,t.y,t.z)),n[6]=new cc_1.Vec3(c),n[6].add(new cc_1.Vec3(t.x,t.y,t.z)),n[7]=new cc_1.Vec3(c),n[7].add(new cc_1.Vec3(t.x,-t.y,t.z)),n}wireframeBox(c,e){const t=this.calcBoxPoints(c,e),n=[];for(let c=1;c<4;c++)n.push(c-1,c);n.push(0,3);for(let c=5;c<8;c++)n.push(c-1,c);n.push(4,7);for(let c=0;c<4;c++)n.push(c,c+4);return{positions:t,normals:Array(t.length).fill(new cc_1.Vec3(0,1,0)),indices:n,primitiveType:PrimitiveMode.LINE_LIST}}calcFrustum(c,e,t,n,a,r,o){const s=[],i=[];let l,_,V,m;c?_=m=(l=V=e)*n:o?(_=(l=Math.tan(EditorMath.deg2rad(t/2))*a)*n,m=(V=Math.tan(EditorMath.deg2rad(t/2))*r)*n):(l=(_=Math.tan(EditorMath.deg2rad(t/2))*a)/n,V=(m=Math.tan(EditorMath.deg2rad(t/2))*r)/n),s[0]=new cc_1.Vec3(-_,-l,-a),s[1]=new cc_1.Vec3(-_,l,-a),s[2]=new cc_1.Vec3(_,l,-a),s[3]=new cc_1.Vec3(_,-l,-a),s[4]=new cc_1.Vec3(-m,-V,-r),s[5]=new cc_1.Vec3(-m,V,-r),s[6]=new cc_1.Vec3(m,V,-r),s[7]=new cc_1.Vec3(m,-V,-r);for(let c=1;c<4;c++)i.push(c-1,c);i.push(0,3);for(let c=5;c<8;c++)i.push(c-1,c);i.push(4,7);for(let c=0;c<4;c++)i.push(c,c+4);return{positions:s,indices:i,normals:Array(s.length).fill(new cc_1.Vec3(0,1,0)),primitiveType:PrimitiveMode.LINE_LIST}}calcRectangleData(c,e,t){const n=this.calcRectanglePoints(c,e,t);return{positions:n.vertices,normals:Array(n.vertices.length).fill(new cc_1.Vec3(0,1,0)),indices:n.indices,primitiveType:PrimitiveMode.LINE_LIST}}calcArcData(c,e,t,n,a,r=60){cc_1.Vec3.normalize(tempVec3_a,t),cc_1.Vec3.normalize(tempVec3_b,e);const o=tempQuat_a,s=r;cc_1.Quat.fromAxisAngle(o,tempVec3_b,n/(s-1));const i=new cc_1.Vec3;cc_1.Vec3.multiplyScalar(i,tempVec3_a,a);const l=[];for(let e=0;e<s;e++)l[e]=c.clone(),l[e].add(i),cc_1.Vec3.transformQuat(i,i,o);return{positions:l,normals:Array(r).fill(new cc_1.Vec3(tempVec3_b)),indices:[...Array(r).keys()],primitiveType:PrimitiveMode.LINE_STRIP}}calcCircleData(c,e,t,n=60){const a=this.getBiNormalByNormal(e);return this.calcArcData(c,e,a,EditorMath.TWO_PI,t,n)}calcLinesData(c,e,t=!0){const n={positions:c,normals:Array(c.length).fill(new cc_1.Vec3(0,1,0)),indices:e,primitiveType:PrimitiveMode.LINE_LIST};if(t){const e=new cc_1.Vec3,t=new cc_1.Vec3;if(c.length>0){e.set(c[0]),t.set(c[0]);for(let n=1;n<c.length;n++)cc_1.Vec3.min(e,e,c[n]),cc_1.Vec3.max(t,t,c[n])}n.minPos=e,n.maxPos=t}return n}calcDiscData(c,e,t,n=60){const a=this.getBiNormalByNormal(e),r=new cc_1.Vec3(t,t,0),o=new cc_1.Vec3(-t,-t,0);return cc_1.Quat.rotationTo(tempQuat_a,cc_1.Vec3.UNIT_Z,e),cc_1.Vec3.add(r,r,c),cc_1.Vec3.transformQuat(r,r,tempQuat_a),cc_1.Vec3.add(o,o,c),cc_1.Vec3.transformQuat(o,o,tempQuat_a),{positions:this.calcSectorPoints(c,e,a,EditorMath.TWO_PI,t,n),normals:Array(n+1).fill(e.clone()),indices:this.indicesFanToList([...Array(n+1).keys()]),primitiveType:PrimitiveMode.TRIANGLE_LIST,minPos:o,maxPos:r}}calcLineData(c,e){const t=new cc_1.Vec3,n=new cc_1.Vec3;cc_1.Vec3.min(t,c,e),cc_1.Vec3.max(n,c,e),cc_1.Vec3.subtract(tempVec3,n,t);const a=[];return["x","y","z"].forEach(c=>{0===tempVec3[c]&&a.push(c)}),2===a.length&&a.forEach(c=>{t[c]-=.5,n[c]+=.5}),{positions:[new cc_1.Vec3(c.x,c.y,c.z),new cc_1.Vec3(e.x,e.y,e.z)],normals:Array(2).fill(new cc_1.Vec3(0,1,0)),indices:[0,1],minPos:t,maxPos:n,primitiveType:PrimitiveMode.LINE_LIST}}calcPolygonData(c,e){const t=new cc_1.Vec3,n=new cc_1.Vec3;let a;return c.forEach(c=>{cc_1.Vec3.min(t,t,c),cc_1.Vec3.max(n,n,c)}),a=e||[...c.keys()],{positions:c,normals:Array(c.length).fill(new cc_1.Vec3(0,1,0)),indices:a,minPos:t,maxPos:n,primitiveType:PrimitiveMode.TRIANGLE_LIST}}calcOctahedronData(c,e,t,n,a=.2){const r=t/2,o=n/2,s=new cc_1.Vec3,i=new cc_1.Vec3,l=[new cc_1.Vec3(0,0,0),new cc_1.Vec3(0,1,0),new cc_1.Vec3(r,a,o),new cc_1.Vec3(-r,a,o),new cc_1.Vec3(-r,a,-o),new cc_1.Vec3(r,a,-o)],_=cc_1.Vec3.subtract(new cc_1.Vec3,e,c),V=cc_1.Vec3.len(_);cc_1.Vec3.normalize(_,_);const m=cc_1.Quat.rotationTo(new cc_1.Quat,cc_1.Vec3.UNIT_Y,_),u=cc_1.Mat4.fromRTS(new cc_1.Mat4,m,c,new cc_1.Vec3(V,V,V));for(let c=0;c<l.length;++c){const e=l[c];cc_1.Vec3.transformMat4(e,e,u),cc_1.Vec3.min(s,s,e),cc_1.Vec3.max(i,i,e)}const h=[2,3,0,3,4,0,4,5,0,5,2,0,1,3,2,1,4,3,1,5,4,1,2,5],d=h.length,p=new Array(3*d).fill(0);for(let c=0;c<d;++c){const e=h[c];p[3*c]=l[e].x,p[3*c+1]=l[e].y,p[3*c+2]=l[e].z}const w=external_1.default.GeometryUtils.calculateNormals(p,Array.from({length:d},(c,e)=>e),new Array(p.length).fill(0)),f=[];for(let c=0;c<w.length;c+=3)f.push(new cc_1.Vec3(w[c],w[c+1],w[c+2]));const y=h.map(c=>l[c]),P=[...Array(y.length).keys()];return{primitiveType:PrimitiveMode.TRIANGLE_LIST,positions:y,normals:f,indices:P,minPos:s,maxPos:i}}}exports.default=new ControllerShape;