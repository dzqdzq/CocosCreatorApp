"use strict";var __importDefault=this&&this.__importDefault||function(c){return c&&c.__esModule?c:{default:c}};Object.defineProperty(exports,"__esModule",{value:!0});const{PrimitiveMode:PrimitiveMode}=require("../../../utils/engine"),cc_1=require("cc"),external_1=__importDefault(require("../../../utils/external")),EditorMath=external_1.default.EditorMath,Utils=require("../../../utils"),v3_forward=new cc_1.Vec3(0,0,1),tempVec3=new cc_1.Vec3,tempVec3_a=new cc_1.Vec3,tempVec3_b=new cc_1.Vec3,tempQuat_a=new cc_1.Quat;class ControllerShape{constructor(){this.calcRectanglePoints=function(c,e,t){const n=new cc_1.Vec3(t.x/2,0,0),a=new cc_1.Vec3(0,t.y/2,0);cc_1.Vec3.transformQuat(n,n,e),cc_1.Vec3.transformQuat(a,a,e);const r=[];r[0]=c.clone(),r[0].add(n),r[0].add(a),r[1]=c.clone(),r[1].add(n),r[1].subtract(a),r[2]=c.clone(),r[2].subtract(n),r[2].subtract(a),r[3]=c.clone(),r[3].subtract(n),r[3].add(a);const o=[];for(let c=1;c<4;c++)o.push(c-1,c);return o.push(0,3),{vertices:r,indices:o}},this.calcSphereData=function(c,e=.5,t={}){const n=void 0!==t.segments?t.segments:32,a=[],r=[],o=[],s=[],i=new cc_1.Vec3(-e,-e,-e),l=new cc_1.Vec3(e,e,e),_=e;for(let t=0;t<=n;++t){const i=t*Math.PI/n,l=Math.sin(i),_=-Math.cos(i);for(let i=0;i<=n;++i){const V=2*i*Math.PI/n-Math.PI/2,m=Math.sin(V)*l,u=_,h=Math.cos(V)*l,w=i/n,p=t/n;if(a.push(new cc_1.Vec3(c.x+m*e,c.y+u*e,c.z+h*e)),r.push(new cc_1.Vec3(m,u,h)),o.push(cc.v2(w,p)),t<n&&i<n){const c=n+1,e=c*t+i,a=c*(t+1)+i,r=c*(t+1)+i+1,o=c*t+i+1;s.push(e,o,a),s.push(o,r,a)}}}return{positions:a,indices:s,normals:r,uvs:o,minPos:i,maxPos:l,boundingRadius:_}}}calcCylinderData(c=.5,e=.5,t=2,n={}){const a=.5*t,r=n.radialSegments||16,o=n.heightSegments||1,s=void 0===n.capped||n.capped,i=n.arc||2*Math.PI;let l=0;s||(c>0&&l++,e>0&&l++);let _=(r+1)*(o+1);s&&(_+=(r+1)*l+r*l);let V=r*o*2*3;s&&(V+=r*l*3);const m=new Array(V),u=new Array(_),h=new Array(_),w=new Array(_),p=Math.max(c,e),d=new cc_1.Vec3(-p,-a,-p),f=new cc_1.Vec3(p,a,p);let y=0,P=0;function M(t){const n=t?c:e,o=t?1:-1,s=y;for(let c=1;c<=r;++c)u[y]=new cc_1.Vec3(0,a*o,0),h[y]=new cc_1.Vec3(0,o,0),w[y]=cc.v2(.5,.5),++y;const l=y;for(let c=0;c<=r;++c){const e=c/r*i,t=Math.cos(e),s=Math.sin(e);u[y]=new cc_1.Vec3(n*s,a*o,n*t),h[y]=new cc_1.Vec3(0,o,0),w[y]=cc.v2(.5-.5*s*o,.5+.5*t),++y}for(let c=0;c<r;++c){const e=s+c,n=l+c;t?(m[P]=n+1,m[++P]=e,m[++P]=n,++P):(m[P]=e,m[++P]=n+1,m[++P]=n,++P)}}return function(){const n=[],s=(c-e)/t;for(let l=0;l<=o;l++){const _=[],V=l/o,m=V*(c-e)+e;for(let c=0;c<=r;++c){const e=c/r,n=e*i,o=Math.sin(n),l=Math.cos(n);u[y]=new cc_1.Vec3(m*o,V*t-a,m*l),h[y]=new cc_1.Vec3(o,-s,l),h[y].normalize(),w[y]=cc.v2(2*(1-e)%1,V),_.push(y),++y}n.push(_)}for(let c=0;c<o;++c)for(let e=0;e<r;++e){const t=n[c][e],a=n[c+1][e],r=n[c+1][e+1],o=n[c][e+1];m[P]=t,m[++P]=o,m[++P]=a,m[++P]=o,m[++P]=r,m[++P]=a,++P}}(),s&&(e>0&&M(!1),c>0&&M(!0)),{positions:u,normals:h,uvs:w,indices:m,minPos:d,maxPos:f}}calcConeData(c,e,t={}){return this.calcCylinderData(0,c,e,t)}calcQuadData(c,e,t,n=new cc_1.Vec3(0,0,1),a=!0){const r=e/2,o=t/2,s=[],i=tempQuat_a;cc_1.Quat.rotationTo(i,v3_forward,n),s[0]=c.clone(),s[0].add(cc_1.Vec3.transformQuat(tempVec3,new cc_1.Vec3(-r,o,0),i)),s[1]=c.clone(),s[1].add(cc_1.Vec3.transformQuat(tempVec3,new cc_1.Vec3(-r,-o,0),i)),s[2]=c.clone(),s[2].add(cc_1.Vec3.transformQuat(tempVec3,new cc_1.Vec3(r,-o,0),i)),s[3]=c.clone(),s[3].add(cc_1.Vec3.transformQuat(tempVec3,new cc_1.Vec3(r,o,0),i));let l,_;a&&((l=c.clone()).add(cc_1.Vec3.transformQuat(tempVec3,new cc_1.Vec3(-r,-o,-.01),i)),(_=c.clone()).add(cc_1.Vec3.transformQuat(tempVec3,new cc_1.Vec3(r,o,.01),i)));const V=[cc.v2(0,1),cc.v2(0,0),cc.v2(1,0),cc.v2(1,1)];return{positions:s,normals:Array(4).fill(n),indices:[0,3,1,3,2,1],minPos:l,maxPos:_,uvs:V,doubleSided:!0}}lineWithBoundingBox(c,e=3){return{positions:[new cc_1.Vec3,new cc_1.Vec3(c,0,0)],normals:Array(2).fill(new cc_1.Vec3(0,1,0)),indices:[0,1],minPos:new cc_1.Vec3(0,-e,-e),maxPos:new cc_1.Vec3(c,e,e),primitiveType:PrimitiveMode.LINE_LIST}}calcCubeData(c,e,t,n={}){const a=n.widthSegments?n.widthSegments:1,r=n.heightSegments?n.heightSegments:1,o=n.lengthSegments?n.lengthSegments:1,s=.5*c,i=.5*e,l=.5*t,_=[new cc_1.Vec3(-s,-i,l),new cc_1.Vec3(s,-i,l),new cc_1.Vec3(s,i,l),new cc_1.Vec3(-s,i,l),new cc_1.Vec3(s,-i,-l),new cc_1.Vec3(-s,-i,-l),new cc_1.Vec3(-s,i,-l),new cc_1.Vec3(s,i,-l)],V=[[2,3,1],[4,5,7],[7,6,2],[1,0,4],[1,4,2],[5,0,6]],m=[new cc_1.Vec3(0,0,1),new cc_1.Vec3(0,0,-1),new cc_1.Vec3(0,1,0),new cc_1.Vec3(0,-1,0),new cc_1.Vec3(1,0,0),new cc_1.Vec3(-1,0,0)],u=[],h=[],w=[],p=[],d=new cc_1.Vec3(-s,-i,-l),f=new cc_1.Vec3(s,i,l);function y(c,e,t){let n,a,r,o;const s=u.length,i=V[c],l=m[c],d=new cc_1.Vec3,f=new cc_1.Vec3;for(o=0;o<=t;o++)for(r=0;r<=e;r++){n=r/e,a=o/t,cc_1.Vec3.lerp(d,_[i[0]],_[i[1]],n),cc_1.Vec3.lerp(f,_[i[0]],_[i[2]],a),f.subtract(_[i[0]]);const c=new cc_1.Vec3(d);if(c.add(f),u.push(c),h.push(l.clone()),w.push(cc.v2(n,a)),r<e&&o<t){const c=e+1,t=r+o*c,n=r+(o+1)*c,a=r+1+(o+1)*c,i=r+1+o*c;p.push(s+t,s+i,s+n),p.push(s+n,s+i,s+a)}}}return y(0,a,r),y(4,o,r),y(1,a,r),y(5,o,r),y(3,a,o),y(2,a,o),{positions:u,indices:p,normals:h,minPos:d,maxPos:f}}torus(c,e,t={}){const n=t.radialSegments||30,a=t.tubularSegments||20,r=t.arc||2*Math.PI,o=[],s=[],i=[],l=[],_=new cc_1.Vec3(-c-e,-e,-c-e),V=new cc_1.Vec3(c+e,e,c+e);for(let t=0;t<=n;t++)for(let _=0;_<=a;_++){const V=_/a,m=t/n,u=V*r,h=m*Math.PI*2,w=(c+e*Math.cos(h))*Math.sin(u),p=e*Math.sin(h),d=(c+e*Math.cos(h))*Math.cos(u),f=Math.sin(u)*Math.cos(h),y=Math.sin(h),P=Math.cos(u)*Math.cos(h);if(o.push(new cc_1.Vec3(w,p,d)),s.push(new cc_1.Vec3(f,y,P)),i.push(cc.v2(V,m)),_<a&&t<n){const c=a+1,e=c*t+_,n=c*(t+1)+_,r=c*(t+1)+_+1,o=c*t+_+1;l.push(e,o,n),l.push(o,r,n)}}return{positions:o,indices:l,normals:s,uvs:i,minPos:_,maxPos:V}}calcArcPoints(c,e,t,n,a,r=60){cc_1.Vec3.normalize(tempVec3_a,t),cc_1.Vec3.normalize(tempVec3_b,e);const o=tempQuat_a,s=r;cc_1.Quat.fromAxisAngle(o,tempVec3_b,n/(s-1));const i=tempVec3;cc_1.Vec3.multiplyScalar(i,tempVec3_a,a);const l=[];for(let e=0;e<s;e++)l[e]=c.clone(),l[e].add(i),cc_1.Vec3.transformQuat(i,i,o);return l}getBiNormalByNormal(c){const e=new cc_1.Vec3;return cc_1.Vec3.cross(e,c,new cc_1.Vec3(0,1,0)),cc_1.Vec3.lengthSqr(e)<.001&&cc_1.Vec3.cross(e,c,new cc_1.Vec3(1,0,0)),e}calcCirclePoints(c,e,t,n=60){const a=this.getBiNormalByNormal(e);return this.calcArcPoints(c,e,a,EditorMath.TWO_PI,t,n)}calcDiscPoints(c,e,t,n=60){const a=this.getBiNormalByNormal(e);return this.calcSectorPoints(c,e,a,EditorMath.TWO_PI,t,n)}calcSectorPoints(c,e,t,n,a,r){let o=[];o.push(c);const s=this.calcArcPoints(c,e,t,n,a,r);return o=o.concat(s)}calcSectorData(c,e,t,n,a,r){return{positions:this.calcSectorPoints(c,e,t,n,a,r),normals:Array(r+1).fill(e.clone()),indices:[...Array(r+1).keys()],primitiveType:PrimitiveMode.TRIANGLE_FAN}}arcDirectionLine(c,e,t,n,a,r,o){const s=[],i=[],l=this.calcArcPoints(c,e,t,n,a,o),_=new cc_1.Vec3;cc_1.Vec3.multiplyScalar(_,e,r);for(let c=0;c<l.length;c++){const e=new cc_1.Vec3;cc_1.Vec3.add(e,l[c],_),s.push(l[c],e),i.push(2*c,2*c+1)}for(let c=1;c<l.length;c++)s.push(l[c-1]),i.push(s.length-1),s.push(l[c]),i.push(s.length-1);return{positions:s,normals:Array(s.length).fill(new cc_1.Vec3(0,1,1)),indices:i,primitiveType:PrimitiveMode.LINE_LIST}}calcBoxPoints(c,e){const t=new cc_1.Vec3;cc_1.Vec3.multiplyScalar(t,e,.5);const n=[];return n[0]=new cc_1.Vec3(c),n[0].add(new cc_1.Vec3(-t.x,-t.y,-t.z)),n[1]=new cc_1.Vec3(c),n[1].add(new cc_1.Vec3(-t.x,t.y,-t.z)),n[2]=new cc_1.Vec3(c),n[2].add(new cc_1.Vec3(t.x,t.y,-t.z)),n[3]=new cc_1.Vec3(c),n[3].add(new cc_1.Vec3(t.x,-t.y,-t.z)),n[4]=new cc_1.Vec3(c),n[4].add(new cc_1.Vec3(-t.x,-t.y,t.z)),n[5]=new cc_1.Vec3(c),n[5].add(new cc_1.Vec3(-t.x,t.y,t.z)),n[6]=new cc_1.Vec3(c),n[6].add(new cc_1.Vec3(t.x,t.y,t.z)),n[7]=new cc_1.Vec3(c),n[7].add(new cc_1.Vec3(t.x,-t.y,t.z)),n}wireframeBox(c,e){const t=this.calcBoxPoints(c,e),n=[];for(let c=1;c<4;c++)n.push(c-1,c);n.push(0,3);for(let c=5;c<8;c++)n.push(c-1,c);n.push(4,7);for(let c=0;c<4;c++)n.push(c,c+4);return{positions:t,normals:Array(t.length).fill(new cc_1.Vec3(0,1,0)),indices:n,primitiveType:PrimitiveMode.LINE_LIST}}calcFrustum(c,e,t,n,a,r,o){const s=[],i=[];let l,_,V,m;c?_=m=(l=V=e)*n:o?(_=(l=Math.tan(EditorMath.deg2rad(t/2))*a)*n,m=(V=Math.tan(EditorMath.deg2rad(t/2))*r)*n):(l=(_=Math.tan(EditorMath.deg2rad(t/2))*a)/n,V=(m=Math.tan(EditorMath.deg2rad(t/2))*r)/n),s[0]=new cc_1.Vec3(-_,-l,-a),s[1]=new cc_1.Vec3(-_,l,-a),s[2]=new cc_1.Vec3(_,l,-a),s[3]=new cc_1.Vec3(_,-l,-a),s[4]=new cc_1.Vec3(-m,-V,-r),s[5]=new cc_1.Vec3(-m,V,-r),s[6]=new cc_1.Vec3(m,V,-r),s[7]=new cc_1.Vec3(m,-V,-r);for(let c=1;c<4;c++)i.push(c-1,c);i.push(0,3);for(let c=5;c<8;c++)i.push(c-1,c);i.push(4,7);for(let c=0;c<4;c++)i.push(c,c+4);return{positions:s,indices:i,normals:Array(s.length).fill(new cc_1.Vec3(0,1,0)),primitiveType:PrimitiveMode.LINE_LIST}}calcRectangleData(c,e,t){const n=this.calcRectanglePoints(c,e,t);return{positions:n.vertices,normals:Array(n.vertices.length).fill(new cc_1.Vec3(0,1,0)),indices:n.indices,primitiveType:PrimitiveMode.LINE_LIST}}calcArcData(c,e,t,n,a,r=60){cc_1.Vec3.normalize(tempVec3_a,t),cc_1.Vec3.normalize(tempVec3_b,e);const o=tempQuat_a,s=r;cc_1.Quat.fromAxisAngle(o,tempVec3_b,n/(s-1));const i=new cc_1.Vec3;cc_1.Vec3.multiplyScalar(i,tempVec3_a,a);const l=[];for(let e=0;e<s;e++)l[e]=c.clone(),l[e].add(i),cc_1.Vec3.transformQuat(i,i,o);return{positions:l,normals:Array(r).fill(new cc_1.Vec3(tempVec3_b)),indices:[...Array(r).keys()],primitiveType:PrimitiveMode.LINE_STRIP}}calcCircleData(c,e,t,n=60){const a=this.getBiNormalByNormal(e);return this.calcArcData(c,e,a,EditorMath.TWO_PI,t,n)}calcLinesData(c,e,t=!0){const n={positions:c,normals:Array(c.length).fill(new cc_1.Vec3(0,1,0)),indices:e,primitiveType:PrimitiveMode.LINE_LIST};if(t){const e=new cc_1.Vec3,t=new cc_1.Vec3;if(c.length>0){e.set(c[0]),t.set(c[0]);for(let n=1;n<c.length;n++)cc_1.Vec3.min(e,e,c[n]),cc_1.Vec3.max(t,t,c[n])}n.minPos=e,n.maxPos=t}return n}calcDiscData(c,e,t,n=60){const a=this.getBiNormalByNormal(e),r=new cc_1.Vec3(t,t,0),o=new cc_1.Vec3(-t,-t,0);return cc_1.Quat.rotationTo(tempQuat_a,cc_1.Vec3.UNIT_Z,e),cc_1.Vec3.add(r,r,c),cc_1.Vec3.transformQuat(r,r,tempQuat_a),cc_1.Vec3.add(o,o,c),cc_1.Vec3.transformQuat(o,o,tempQuat_a),{positions:this.calcSectorPoints(c,e,a,EditorMath.TWO_PI,t,n),normals:Array(n+1).fill(e.clone()),indices:[...Array(n+1).keys()],primitiveType:PrimitiveMode.TRIANGLE_FAN,minPos:o,maxPos:r}}calcLineData(c,e){const t=new cc_1.Vec3,n=new cc_1.Vec3;cc_1.Vec3.min(t,c,e),cc_1.Vec3.max(n,c,e),cc_1.Vec3.subtract(tempVec3,n,t);const a=[];return["x","y","z"].forEach(c=>{0===tempVec3[c]&&a.push(c)}),2===a.length&&a.forEach(c=>{t[c]-=.5,n[c]+=.5}),{positions:[new cc_1.Vec3(c.x,c.y,c.z),new cc_1.Vec3(e.x,e.y,e.z)],normals:Array(2).fill(new cc_1.Vec3(0,1,0)),indices:[0,1],minPos:t,maxPos:n,primitiveType:PrimitiveMode.LINE_LIST}}calcPolygonData(c,e){const t=new cc_1.Vec3,n=new cc_1.Vec3;let a;return c.forEach(c=>{cc_1.Vec3.min(t,t,c),cc_1.Vec3.max(n,n,c)}),a=e||[...c.keys()],{positions:c,normals:Array(c.length).fill(new cc_1.Vec3(0,1,0)),indices:a,minPos:t,maxPos:n,primitiveType:PrimitiveMode.TRIANGLE_LIST}}calcOctahedronData(c,e,t,n,a=.2){const r=t/2,o=n/2,s=new cc_1.Vec3,i=new cc_1.Vec3,l=[new cc_1.Vec3(0,0,0),new cc_1.Vec3(0,1,0),new cc_1.Vec3(r,a,o),new cc_1.Vec3(-r,a,o),new cc_1.Vec3(-r,a,-o),new cc_1.Vec3(r,a,-o)],_=cc_1.Vec3.subtract(new cc_1.Vec3,e,c),V=cc_1.Vec3.len(_);cc_1.Vec3.normalize(_,_);const m=cc_1.Quat.rotationTo(new cc_1.Quat,cc_1.Vec3.UNIT_Y,_),u=cc_1.Mat4.fromRTS(new cc_1.Mat4,m,c,new cc_1.Vec3(V,V,V));for(let c=0;c<l.length;++c){const e=l[c];cc_1.Vec3.transformMat4(e,e,u),cc_1.Vec3.min(s,s,e),cc_1.Vec3.max(i,i,e)}const h=[2,3,0,3,4,0,4,5,0,5,2,0,1,3,2,1,4,3,1,5,4,1,2,5],w=h.length,p=new Array(3*w).fill(0);for(let c=0;c<w;++c){const e=h[c];p[3*c]=l[e].x,p[3*c+1]=l[e].y,p[3*c+2]=l[e].z}const d=external_1.default.GeometryUtils.calculateNormals(p,Array.from({length:w},(c,e)=>e),new Array(p.length).fill(0)),f=[];for(let c=0;c<d.length;c+=3)f.push(new cc_1.Vec3(d[c],d[c+1],d[c+2]));const y=h.map(c=>l[c]),P=[...Array(y.length).keys()];return{primitiveType:PrimitiveMode.TRIANGLE_LIST,positions:y,normals:f,indices:P,minPos:s,maxPos:i}}}exports.default=new ControllerShape;