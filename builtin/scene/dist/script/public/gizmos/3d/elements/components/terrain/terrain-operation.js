"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.TerrainWeightUndoRedo=exports.TerrainBlockLayerData=exports.TerrainWeightOperation=exports.TerrainLayerUndoRedo=exports.TerrainLayerOperation=exports.TerrainWeightData=exports.TerrainHeightUndoRedo=exports.TerrainHeightOperation=exports.TerrainHeightData=void 0;const cc_1=require("cc"),undo_1=require("../../../../../../export/undo");class TerrainHeightData{constructor(){this.x=0,this.y=0,this.value=0}}exports.TerrainHeightData=TerrainHeightData;class TerrainHeightOperation extends undo_1.SceneUndoCommand{constructor(e){super(),this.data=new Array,this._terrain=e}set terrain(e){this._terrain=e}get terrain(){return this._terrain}static addChangeList(e,r){for(const t of e)if(t===r)return;e.push(r)}push(e,r,t){for(const t of this.data)if(t.x===e&&t.y===r)return;const a=new TerrainHeightData;a.x=e,a.y=r,a.value=t,this.data.push(a)}apply(){if(!this._terrain||0==this.data.length)return;let e=this.data[0].x,r=this.data[0].x,t=this.data[0].y,a=this.data[0].y;for(const i of this.data)this._terrain.setHeight(i.x,i.y,i.value),e=Math.min(e,i.x),r=Math.max(r,i.x),t=Math.min(t,i.y),a=Math.max(a,i.y);e>0&&(e-=1),r<this._terrain.info.vertexCount[0]-1&&(r+=1),t>0&&(t-=1),this._terrain.info.vertexCount[1];for(let i=t;i<=a;++i)for(let t=e;t<=r;++t){const e=this._terrain._calcNormal(t,i);this._terrain._setNormal(t,i,e)}const i=new Array,n=new cc_1.Rect(e,t,r-e,a-t);for(const e of this._terrain.getBlocks()){e.getRect().intersects(n)&&TerrainHeightOperation.addChangeList(i,e)}for(const e of i)e._updateHeight(),e.update()}}exports.TerrainHeightOperation=TerrainHeightOperation;class TerrainHeightUndoRedo extends TerrainHeightOperation{constructor(){super(...arguments),this.redoOperations=[]}async undo(){this.apply()}async redo(){this.redoOperations.forEach(e=>{e.apply()})}}exports.TerrainHeightUndoRedo=TerrainHeightUndoRedo;class TerrainWeightData{constructor(){this.x=0,this.y=0,this.value=new cc_1.Vec4}}exports.TerrainWeightData=TerrainWeightData;class TerrainLayerOperation{constructor(e){this._layers=[],this._terrain=e}set terrain(e){this._terrain=e}get terrain(){return this._terrain}setLayers(){for(let e=0;e<this.terrain._layers.length;e++)this._layers[e]=this.terrain._layers[e]}apply(){for(let e=0;e<this._layers.length;e++)this.terrain.setLayer(e,this._layers[e])}}exports.TerrainLayerOperation=TerrainLayerOperation;class TerrainLayerUndoRedo extends TerrainLayerOperation{constructor(){super(...arguments),this.redoOperations=[]}undo(){this.apply()}redo(){this.redoOperations.forEach(e=>{e.apply()})}}exports.TerrainLayerUndoRedo=TerrainLayerUndoRedo;class TerrainWeightOperation extends undo_1.SceneUndoCommand{constructor(e){super(),this.data=new Array,this._terrain=e}set terrain(e){this._terrain=e}get terrain(){return this._terrain}static addChangeList(e,r){for(const t of e)if(t===r)return;e.push(r)}push(e,r,t){for(const t of this.data)if(t.x===e&&t.y===r)return;const a=new TerrainWeightData;a.x=e,a.y=r,a.value=t,this.data.push(a)}apply(){if(!this._terrain)return;for(const e of this.data)this._terrain.setWeight(e.x,e.y,e.value);const e=new Array;for(const r of this._terrain.getBlocks()){const t=new cc_1.Rect;t.x=r.getIndex()[0]*this._terrain.info.weightMapSize,t.y=r.getIndex()[1]*this._terrain.info.weightMapSize,t.width=this._terrain.info.weightMapSize,t.height=this._terrain.info.weightMapSize;for(const a of this.data)t.contains(new cc_1.Vec2(a.x,a.y))&&TerrainWeightOperation.addChangeList(e,r)}for(const r of e)r._updateWeightMap(),r.update()}}exports.TerrainWeightOperation=TerrainWeightOperation;class TerrainBlockLayerData{constructor(e,r){this.layers=[-1,-1,-1,-1],this.block=e,this.layers.length=r.length;for(let e=0;e<r.length;++e)this.layers[e]=r[e]}}exports.TerrainBlockLayerData=TerrainBlockLayerData;class TerrainWeightUndoRedo extends TerrainWeightOperation{constructor(){super(...arguments),this.undoBlockLayers=new Array,this.redoBlockLayers=new Array,this.redoOperations=[]}async undo(){this.apply()}async redo(){for(const e of this.redoBlockLayers){const r=e.block,t=e.layers;r.setLayer(0,t[0]),r.setLayer(1,t[1]),r.setLayer(2,t[2]),r.setLayer(3,t[3])}this.redoOperations.forEach(e=>{e.apply()})}pushBlock(e,r,t){for(const r of this.redoBlockLayers)if(r.block===e){r.layers.length=t.length;for(let e=0;e<t.length;++e)r.layers[e]=t[e];return}this.redoBlockLayers.push(new TerrainBlockLayerData(e,t));for(const r of this.undoBlockLayers)if(r.block===e)return;this.undoBlockLayers.push(new TerrainBlockLayerData(e,r))}apply(){if(this._terrain){for(const e of this.undoBlockLayers){const r=e.block,t=e.layers;r.setLayer(0,t[0]),r.setLayer(1,t[1]),r.setLayer(2,t[2]),r.setLayer(3,t[3])}super.apply()}}}exports.TerrainWeightUndoRedo=TerrainWeightUndoRedo;