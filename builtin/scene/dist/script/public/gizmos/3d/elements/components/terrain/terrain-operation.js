"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.TerrainWeightUndoRedo=exports.TerrainBlockLayerData=exports.TerrainWeightOperation=exports.TerrainLayerUndoRedo=exports.TerrainLayerOperation=exports.TerrainWeightData=exports.TerrainHeightUndoRedo=exports.TerrainHeightOperation=exports.TerrainHeightData=void 0;const cc_1=require("cc");class TerrainHeightData{constructor(){this.x=0,this.y=0,this.value=0}}exports.TerrainHeightData=TerrainHeightData;class TerrainHeightOperation{constructor(r){this.data=new Array,this._terrain=r}set terrain(r){this._terrain=r}get terrain(){return this._terrain}static addChangeList(r,e){for(const t of r)if(t===e)return;r.push(e)}push(r,e,t){for(const t of this.data)if(t.x===r&&t.y===e)return;const a=new TerrainHeightData;a.x=r,a.y=e,a.value=t,this.data.push(a)}apply(){if(!this._terrain||0==this.data.length)return;let r=this.data[0].x,e=this.data[0].x,t=this.data[0].y,a=this.data[0].y;for(const i of this.data)this._terrain.setHeight(i.x,i.y,i.value),r=Math.min(r,i.x),e=Math.max(e,i.x),t=Math.min(t,i.y),a=Math.max(a,i.y);r>0&&(r-=1),e<this._terrain.info.vertexCount[0]-1&&(e+=1),t>0&&(t-=1),this._terrain.info.vertexCount[1];for(let i=t;i<=a;++i)for(let t=r;t<=e;++t){const r=this._terrain._calcNormal(t,i);this._terrain._setNormal(t,i,r)}const i=new Array,s=new cc_1.Rect(r,t,e-r,a-t);for(const r of this._terrain.getBlocks()){r.getRect().intersects(s)&&TerrainHeightOperation.addChangeList(i,r)}for(const r of i)r._updateHeight()}}exports.TerrainHeightOperation=TerrainHeightOperation;class TerrainHeightUndoRedo extends TerrainHeightOperation{constructor(){super(...arguments),this.redoOperations=[]}undo(){this.apply()}redo(){this.redoOperations.forEach(r=>{r.apply()})}}exports.TerrainHeightUndoRedo=TerrainHeightUndoRedo;class TerrainWeightData{constructor(){this.x=0,this.y=0,this.value=new cc_1.Vec4}}exports.TerrainWeightData=TerrainWeightData;class TerrainLayerOperation{constructor(r){this._layers=[],this._terrain=r}set terrain(r){this._terrain=r}get terrain(){return this._terrain}setLayers(){for(let r=0;r<this.terrain._layers.length;r++)this._layers[r]=this.terrain._layers[r]}apply(){for(let r=0;r<this._layers.length;r++)this.terrain.setLayer(r,this._layers[r])}}exports.TerrainLayerOperation=TerrainLayerOperation;class TerrainLayerUndoRedo extends TerrainLayerOperation{constructor(){super(...arguments),this.redoOperations=[]}undo(){this.apply()}redo(){this.redoOperations.forEach(r=>{r.apply()})}}exports.TerrainLayerUndoRedo=TerrainLayerUndoRedo;class TerrainWeightOperation{constructor(r){this.data=new Array,this._terrain=r}set terrain(r){this._terrain=r}get terrain(){return this._terrain}static addChangeList(r,e){for(const t of r)if(t===e)return;r.push(e)}push(r,e,t){for(const t of this.data)if(t.x===r&&t.y===e)return;const a=new TerrainWeightData;a.x=r,a.y=e,a.value=t,this.data.push(a)}apply(){if(!this._terrain)return;for(const r of this.data)this._terrain.setWeight(r.x,r.y,r.value);const r=new Array;for(const e of this._terrain.getBlocks()){const t=new cc_1.Rect;t.x=e.getIndex()[0]*this._terrain.info.weightMapSize,t.y=e.getIndex()[1]*this._terrain.info.weightMapSize,t.width=this._terrain.info.weightMapSize,t.height=this._terrain.info.weightMapSize;for(const a of this.data)t.contains(new cc_1.Vec2(a.x,a.y))&&TerrainWeightOperation.addChangeList(r,e)}for(const e of r)e._updateWeightMap(),e.update()}}exports.TerrainWeightOperation=TerrainWeightOperation;class TerrainBlockLayerData{constructor(r,e){this.layers=[-1,-1,-1,-1],this.block=r,this.layers.length=e.length;for(let r=0;r<e.length;++r)this.layers[r]=e[r]}}exports.TerrainBlockLayerData=TerrainBlockLayerData;class TerrainWeightUndoRedo extends TerrainWeightOperation{constructor(){super(...arguments),this.undoBlockLayers=new Array,this.redoBlockLayers=new Array,this.redoOperations=[]}undo(){this.apply()}redo(){for(const r of this.redoBlockLayers){const e=r.block,t=r.layers;e.setLayer(0,t[0]),e.setLayer(1,t[1]),e.setLayer(2,t[2]),e.setLayer(3,t[3])}this.redoOperations.forEach(r=>{r.apply()})}pushBlock(r,e,t){for(const e of this.redoBlockLayers)if(e.block===r){e.layers.length=t.length;for(let r=0;r<t.length;++r)e.layers[r]=t[r];return}this.redoBlockLayers.push(new TerrainBlockLayerData(r,t));for(const e of this.undoBlockLayers)if(e.block===r)return;this.undoBlockLayers.push(new TerrainBlockLayerData(r,e))}apply(){if(this._terrain){for(const r of this.undoBlockLayers){const e=r.block,t=r.layers;e.setLayer(0,t[0]),e.setLayer(1,t[1]),e.setLayer(2,t[2]),e.setLayer(3,t[3])}super.apply()}}}exports.TerrainWeightUndoRedo=TerrainWeightUndoRedo;