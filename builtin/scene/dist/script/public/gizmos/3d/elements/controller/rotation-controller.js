"use strict";var __importDefault=this&&this.__importDefault||function(t){return t&&t.__esModule?t:{default:t}};Object.defineProperty(exports,"__esModule",{value:!0});const controller_base_1=__importDefault(require("./controller-base")),controller_shape_1=__importDefault(require("../utils/controller-shape")),controller_utils_1=__importDefault(require("../utils/controller-utils")),{AttributeName:AttributeName,setNodeOpacity:setNodeOpacity,getModel:getModel,updatePositions:updatePositions,create3DNode:create3DNode,panPlaneLayer:panPlaneLayer,getRaycastResults:getRaycastResults,setMeshColor:setMeshColor}=require("../../../utils/engine"),Utils=require("../../../utils"),external_1=__importDefault(require("../../../utils/external")),cc_1=require("cc"),NodeUtils=external_1.default.NodeUtils,EditorMath=external_1.default.EditorMath,EditorCamera=external_1.default.EditorCamera,tempVec3_a=new cc_1.Vec3,tempVec3_b=new cc_1.Vec3,tempVec3_c=new cc_1.Vec3,tempQuat=new cc_1.Quat,tempMat4=new cc_1.Mat4;class RotationController extends controller_base_1.default{constructor(t){super(t),this._deltaRotation=new cc_1.Quat(0,0,0,1),this._rotFactor=3,this._baseRadius=100,this._tubeRadius=3,this._circleBorderNode=null,this._circleBorderMR=null,this._cutoffNode=null,this._cutoffMR=null,this._indicator={},this._mouseDownRot=new cc_1.Quat,this._mouseDeltaPos=new cc_1.Vec2(0,0),this._indicatorStartDir=new cc_1.Vec3,this._rotateAlignDir=new cc_1.Vec3,this._transformAxisDir=new cc_1.Vec3,this._axisDir={},this._zDeltaAngle=0,this._axisDir.x=new cc_1.Vec3(1,0,0),this._axisDir.y=new cc_1.Vec3(0,1,0),this._axisDir.z=new cc_1.Vec3(0,0,1),this._axisDir.w=new cc_1.Vec3(0,0,1),this.initShape()}createRotationShape(t,e,i,a,o,s){let r=this._baseRadius,c=this._tubeRadius,l=create3DNode(t+"Rotation");l.parent=this.shape;let n=controller_utils_1.default.torus(r,c,{arc:Math.abs(o)},s);n.name=t+"RotationTorus",n.parent=l,setNodeOpacity(n,0),NodeUtils.setEulerAngles(n,e);let h=controller_utils_1.default.arrow(25,10,140,s);h.name=t+"Axis",h.parent=l,NodeUtils.setEulerAngles(h,i);let d=controller_utils_1.default.arc(cc.v3(),this._axisDir[t],a,o,r,s,{noDepthTestForLines:!0});d.parent=l,d.name=t+"RotationArc";let _=controller_utils_1.default.arc(cc.v3(),this._axisDir[t],a,this._twoPI,r,s,{noDepthTestForLines:!0});_.parent=l,_.active=!1,_.name=t+"IndicatorCircle";let u=this.initHandle(l,t);u&&(u.normalTorusNode=d,u.indicatorCircle=_,u.arrowNode=h,u.arrowNode.active=!1,u.normalTorusMR=getModel(u.normalTorusNode))}initShape(){this.createShapeNode("RotationController"),this.registerEvents(),this._baseRadius=100,this._tubeRadius=3,this.createRotationShape("x",cc.v3(0,0,90),cc.v3(-90,-90,0),this._axisDir.z,-this._twoPI,cc.Color.RED),this.createRotationShape("y",cc.v3(0,0,0),cc.v3(0,0,0),this._axisDir.z,this._twoPI,cc.Color.GREEN),this.createRotationShape("z",cc.v3(-90,0,0),cc.v3(90,0,90),this._axisDir.x,this._twoPI,cc.Color.BLUE),this.createRotationShape("w",cc.v3(-90,0,0),cc.v3(0,0,-90),this._axisDir.x,this._twoPI,cc.Color.BLUE);let t=EditorCamera.camera.node.getWorldRotation(tempQuat),e=cc.v3();cc_1.Vec3.transformQuat(e,cc.v3(0,0,1),t);let i=controller_utils_1.default.circle(cc.v3(),e,this._baseRadius,cc.Color.GRAY);i.name="circleBorder",i.parent=this._rootNode,setNodeOpacity(i,200),this._circleBorderNode=i,this._circleBorderMR=getModel(i),this._circleBorderNode.setWorldPosition(this.getPosition());let a=controller_utils_1.default.quad(cc.v3(),2*this._baseRadius,2*this._baseRadius);setNodeOpacity(a,0),a.parent=this._rootNode,a.layer|=panPlaneLayer,this._cutoffNode=a,this._cutoffMR=getModel(a);let o={};o.sectorNode=controller_utils_1.default.sector(cc.v3(),cc.v3(0,1,0),cc.v3(1,0,0),Math.PI,this._baseRadius,controller_utils_1.default.YELLOW,{unlit:!0}),setNodeOpacity(o.sectorNode,200),o.sectorNode.parent=this._rootNode,o.sectorNode.active=!1,o.meshRenderer=getModel(o.sectorNode),this._indicator=o,this.shape.active=!1}isHitOnAxisArrow(t,e){let i=this._handleDataMap[e].arrowNode;for(let e=0;e<i.children.length;e++){if(t===i.children[e])return!0}return!1}isInCutoffBack(t,e,i){let a=this._handleDataMap[t].normalTorusNode,o=getRaycastResults(this._cutoffNode,e,i);if(o.length>0){let t=o[0].distance;if((o=getRaycastResults(a,e,i)).length>0){if(o[0].distance>t)return!0}}return!1}onMouseDown(t){if(!this.is2D&&this.isInCutoffBack(t.handleName,t.x,t.y))return;this._mouseDownRot=cc_1.Quat.clone(this.getRotation()),this._mouseDeltaPos=cc.v2(0,0);let e=t.hitPoint,i=cc_1.Vec3.clone(this._axisDir[t.handleName]),a=cc.v3(),o=cc.v3();this._indicatorStartDir=cc.v3(),this.is2D?(this.isHitOnAxisArrow(t.node,t.handleName)?cc_1.Vec3.transformQuat(a,cc.v3(1,0,0),this.getRotation()):cc_1.Vec3.subtract(a,e,this.getPosition()),cc_1.Vec3.transformQuat(this._indicatorStartDir,cc.v3(1,0,0),this.getRotation()),this._zDeltaAngle=0):(cc_1.Vec3.subtract(a,e,this.getPosition()),this._indicatorStartDir=a),cc_1.Vec3.normalize(a,a),cc_1.Vec3.transformQuat(i,i,this.getRotation()),cc_1.Vec3.cross(o,a,i),cc_1.Vec3.cross(a,i,o),this._rotateAlignDir=o,this._transformAxisDir=i,this.updateRotationIndicator(this._transformAxisDir,this._indicatorStartDir,0),this._indicator.sectorNode.active=!0,this._handleDataMap[t.handleName].indicatorCircle.active=!0,this._circleBorderNode.active=!1,Object.keys(this._handleDataMap).forEach(e=>{e===t.handleName?(this._handleDataMap[e].normalTorusNode.active=!1,this._handleDataMap[e].arrowNode.active=!0):this._handleDataMap[e].topNode.active=!1}),Utils.requestPointerLock(),this.onControllerMouseDown&&this.onControllerMouseDown(t)}onMouseMove(t){if(this._isMouseDown){const e=EditorMath.clamp(t.moveDeltaX,-10,10),i=EditorMath.clamp(t.moveDeltaY,-10,10);this._mouseDeltaPos.x+=e,this._mouseDeltaPos.y+=i,cc_1.Quat.identity(this._deltaRotation);let a=0;if(1===t.handleName.length){const e=this.getAlignAxisMoveDistance(this._rotateAlignDir,this._mouseDeltaPos);a=-e/this._rotFactor*this._degreeToRadianFactor,cc_1.Quat.fromAxisAngle(this._deltaRotation,this._axisDir[t.handleName],a),this.is2D&&(this._zDeltaAngle=-e/this._rotFactor)}this.updateRotationIndicator(this._transformAxisDir,this._indicatorStartDir,a);const o=this.getRotation();cc_1.Quat.multiply(o,this._mouseDownRot,this._deltaRotation),this.setRotation(o),this.onControllerMouseMove&&this.onControllerMouseMove(t),this.updateController()}}onMouseUp(t){Utils.exitPointerLock(),this._indicator.sectorNode.active=!1,cc_1.Quat.identity(this._deltaRotation),this.is2D?(this._handleDataMap.w.indicatorCircle.active=!1,this._handleDataMap.w.normalTorusNode.active=!0,this._handleDataMap.w.topNode.active=!0):(this._circleBorderNode.active=!0,Object.keys(this._handleDataMap).forEach(t=>{"w"!==t&&(this._handleDataMap[t].normalTorusNode.active=!0,this._handleDataMap[t].topNode.active=!0,this._handleDataMap[t].indicatorCircle.active=!1,this._handleDataMap[t].arrowNode.active=!1)})),this.onControllerMouseUp&&this.onControllerMouseUp(t)}onMouseLeave(t){this.onMouseUp(t)}onHoverIn(t){!this.is2D&&this.isInCutoffBack(t.handleName,t.x,t.y)||(this.setHandleColor(t.handleName,controller_utils_1.default.YELLOW),Object.keys(this._handleDataMap).forEach(e=>{e!==t.handleName&&this.setNodesOpacity(this._handleDataMap[e].rendererNodes,50)}))}onHoverOut(){this.resetHandleColor(),Object.keys(this._handleDataMap).forEach(t=>{this.setNodesOpacity(this._handleDataMap[t].rendererNodes,255)})}setNodesOpacity(t,e){t.forEach(t=>{setNodeOpacity(t,e)})}getDeltaRotation(){return this._deltaRotation}getZDeltaAngle(){return this._zDeltaAngle}onShow(){this.registerEvents(),this.is2D?(this._handleDataMap.x.topNode.active=!1,this._handleDataMap.y.topNode.active=!1,this._handleDataMap.z.topNode.active=!1,this._handleDataMap.w.topNode.active=!0,this._handleDataMap.w.arrowNode.active=!0,this._circleBorderNode.active=!1,this._cutoffNode.active=!1,this.updateController()):(this._handleDataMap.x.topNode.active=!0,this._handleDataMap.y.topNode.active=!0,this._handleDataMap.z.topNode.active=!0,this._handleDataMap.w.topNode.active=!1,this._handleDataMap.w.arrowNode.active=!1,this._circleBorderNode.active=!0,this._cutoffNode.active=!0)}onHide(){this.unregisterEvents(),this._circleBorderNode.active=!1,this._cutoffNode.active=!1}updateRotationIndicator(t,e,i){let a=controller_shape_1.default.calcSectorPoints(this.getPosition(),t,e,i,this._baseRadius*this.getDistScalar(),60);updatePositions(this._indicator.meshRenderer,a)}adjustControllerSize(){const t=this.getDistScalar(),e=this.getScale(),i=tempVec3_a;cc_1.Vec3.copy(i,e),i.multiplyScalar(t),this.shape.setScale(i),this._circleBorderNode.setScale(i),this._circleBorderNode.setWorldPosition(this.getPosition());let a=EditorCamera.camera.node.getWorldRotation(tempQuat),o=tempVec3_b;cc_1.Vec3.transformQuat(o,cc_1.Vec3.UNIT_Z,a);let s=controller_shape_1.default.calcCirclePoints(cc_1.Vec3.ZERO,o,this._baseRadius);updatePositions(this._circleBorderMR,s),this._cutoffNode.setScale(i),this._cutoffNode.setWorldPosition(this.getPosition()),this._cutoffNode.setWorldRotation(a);let r=tempVec3_b,c=tempMat4;this.shape.getWorldMatrix(c),cc.Mat4.invert(c,c),cc_1.Vec3.transformMat4Normal(r,o,c),this.is2D||Object.keys(this._handleDataMap).forEach(t=>{if("w"!==t){let e=tempVec3_c,i=this._axisDir[t];cc_1.Vec3.cross(e,i,r),cc_1.Vec3.normalize(e,e),s=controller_shape_1.default.calcArcPoints(cc_1.Vec3.ZERO,i,e,-Math.PI,this._baseRadius);let a=this._handleDataMap[t];updatePositions(a.normalTorusMR,s)}})}}exports.default=RotationController;