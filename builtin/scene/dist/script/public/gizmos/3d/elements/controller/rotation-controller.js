"use strict";var __importDefault=this&&this.__importDefault||function(t){return t&&t.__esModule?t:{default:t}};Object.defineProperty(exports,"__esModule",{value:!0});const controller_base_1=__importDefault(require("./controller-base")),controller_shape_1=__importDefault(require("../utils/controller-shape")),controller_utils_1=__importDefault(require("../utils/controller-utils")),{AttributeName:AttributeName,setNodeOpacity:setNodeOpacity,getModel:getModel,updateIB:updateIB,updatePositions:updatePositions,create3DNode:create3DNode,panPlaneLayer:panPlaneLayer,getRaycastResults:getRaycastResults,setMeshColor:setMeshColor}=require("../../../utils/engine/index"),Utils=require("../../../utils"),external_1=__importDefault(require("../../../utils/external")),cc_1=require("cc"),NodeUtils=external_1.default.NodeUtils,EditorMath=external_1.default.EditorMath,EditorCamera=external_1.default.EditorCamera,tempVec3_a=new cc_1.Vec3,tempVec3_b=new cc_1.Vec3,tempVec3_c=new cc_1.Vec3,tempVec3_d=new cc_1.Vec3,tempQuat=new cc_1.Quat,tempMat4=new cc_1.Mat4;class RotationController extends controller_base_1.default{constructor(t){super(t),this._deltaRotation=new cc_1.Quat(0,0,0,1),this._rotFactor=3,this._baseRadius=100,this._tubeRadius=3,this._circleBorderNode=null,this._circleBorderMR=null,this._cutoffNode=null,this._cutoffMR=null,this._indicator={},this._mouseDownRot=new cc_1.Quat,this._mouseDeltaPos=new cc_1.Vec2(0,0),this._indicatorStartDir=new cc_1.Vec3,this._rotateAlignDir=new cc_1.Vec3,this._transformAxisDir=new cc_1.Vec3,this._axisDir={},this._deltaAngle=0,this._handleAxisDir=new cc_1.Vec3,this._graduationNode=null,this._graduationMR=null,this._axisDir.x=new cc_1.Vec3(1,0,0),this._axisDir.y=new cc_1.Vec3(0,1,0),this._axisDir.z=new cc_1.Vec3(0,0,1),this._axisDir.w=new cc_1.Vec3(0,0,1),this.initShape()}get transformAxisDir(){return this._transformAxisDir}get indicatorStartDir(){return this._indicatorStartDir}createRotationShape(t,e,i,a,o,s){const c=this._baseRadius,r=this._tubeRadius,n=create3DNode(t+"Rotation");n.parent=this.shape;const l=controller_utils_1.default.torus(c,r,{arc:Math.abs(o)},s);l.name=t+"RotationTorus",l.parent=n,setNodeOpacity(l,0),NodeUtils.setEulerAngles(l,e);const h=controller_utils_1.default.arrow(25,10,140,s);h.name=t+"Axis",h.parent=n,NodeUtils.setEulerAngles(h,i);const d=controller_utils_1.default.arc(cc.v3(),this._axisDir[t],a,o,c,s,{noDepthTestForLines:!0});d.parent=n,d.name=t+"RotationArc";const _=controller_utils_1.default.arc(cc.v3(),this._axisDir[t],a,this._twoPI,c,s,{noDepthTestForLines:!0});_.parent=n,_.active=!1,_.name=t+"IndicatorCircle";const u=this.initHandle(n,t);u&&(u.normalTorusNode=d,u.indicatorCircle=_,u.arrowNode=h,u.arrowNode.active=!1,u.normalTorusMR=getModel(u.normalTorusNode))}createGraduationShape(t,e){this._graduationNode=controller_utils_1.default.lines([new cc_1.Vec3(0,0,0),new cc_1.Vec3(0,0,0)],[0,1],e,{noDepthTestForLines:!0}),this._graduationNode.parent=t,this._graduationMR=getModel(this._graduationNode)}updateGraduation(t,e,i){cc_1.Vec3.normalize(tempVec3_a,e),cc_1.Vec3.normalize(tempVec3_b,t);const a=Math.round(360/i),o=tempQuat;cc_1.Quat.fromAxisAngle(o,tempVec3_b,EditorMath.deg2rad(i));const s=tempVec3_c,c=this.getPosition();cc_1.Vec3.multiplyScalar(s,tempVec3_a,this._baseRadius*this.getDistScalar());const r=tempVec3_d;cc_1.Vec3.multiplyScalar(r,tempVec3_a,(this._baseRadius-15)*this.getDistScalar());const n=[],l=[];for(let t=0;t<a;t++)n[t]=c.clone(),l[t]=c.clone(),n[t].add(s),l[t].add(r),cc_1.Vec3.transformQuat(s,s,o),cc_1.Vec3.transformQuat(r,r,o);const h=[],d=[];for(let t=0;t<a;t++)h.push(n[t]),h.push(l[t]),d.push(2*t,2*t+1);const _=controller_shape_1.default.calcLinesData(h,d);updatePositions(this._graduationMR,_.positions),updateIB(this._graduationMR,_.indices)}setGraduation(t){this.updateGraduation(this._transformAxisDir,this._indicatorStartDir,t)}showGraduation(){this._graduationNode&&(this._graduationNode.active=!0)}hideGraduation(){this._graduationNode&&(this._graduationNode.active=!1)}initShape(){this.createShapeNode("RotationController"),this.registerEvents(),this._baseRadius=100,this._tubeRadius=5,this.createRotationShape("x",cc.v3(0,0,90),cc.v3(-90,-90,0),this._axisDir.z,-this._twoPI,cc.Color.RED),this.createRotationShape("y",cc.v3(0,0,0),cc.v3(0,0,0),this._axisDir.z,this._twoPI,cc.Color.GREEN),this.createRotationShape("z",cc.v3(-90,0,0),cc.v3(90,0,90),this._axisDir.x,this._twoPI,cc.Color.BLUE),this.createRotationShape("w",cc.v3(-90,0,0),cc.v3(0,0,-90),this._axisDir.x,this._twoPI,cc.Color.BLUE);const t=EditorCamera.camera.node.getWorldRotation(tempQuat),e=cc.v3();cc_1.Vec3.transformQuat(e,cc.v3(0,0,1),t);const i=controller_utils_1.default.circle(cc.v3(),e,this._baseRadius,cc.Color.GRAY);i.name="circleBorder",i.parent=this._rootNode,setNodeOpacity(i,200),this._circleBorderNode=i,this._circleBorderMR=getModel(i),this._circleBorderNode.setWorldPosition(this.getPosition());const a=controller_utils_1.default.disc(cc.v3(),cc_1.Vec3.UNIT_Z,this._baseRadius,cc_1.Color.RED);setNodeOpacity(a,0),a.name="cutoff",a.parent=this._rootNode,a.layer=panPlaneLayer,this._cutoffNode=a,this._cutoffMR=getModel(a);const o={};o.sectorNode=controller_utils_1.default.sector(cc.v3(),cc.v3(0,1,0),cc.v3(1,0,0),Math.PI,this._baseRadius,cc_1.Color.YELLOW,{unlit:!0}),setNodeOpacity(o.sectorNode,200),o.sectorNode.parent=this._rootNode,o.sectorNode.active=!1,o.meshRenderer=getModel(o.sectorNode),this._indicator=o,this.createGraduationShape(this._rootNode,cc_1.Color.YELLOW),this.hideGraduation(),this.shape.active=!1}isHitOnAxisArrow(t,e){const i=this._handleDataMap[e].arrowNode;for(let e=0;e<i.children.length;e++){if(t===i.children[e])return!0}return!1}isInCutoffBack(t,e,i){const a=this._handleDataMap[t].normalTorusNode;let o=getRaycastResults(this._cutoffNode,e,i);if(o.length>0){const t=o[0].distance;if((o=getRaycastResults(a,e,i)).length>0){if(o[0].distance>t)return!0}}return!1}onMouseDown(t){if(!this.is2D&&this.isInCutoffBack(t.handleName,t.x,t.y))return void(this._isMouseDown=!1);this._mouseDownRot=cc_1.Quat.clone(this.getRotation()),this._mouseDeltaPos=cc.v2(0,0);const e=t.hitPoint;cc_1.Vec3.copy(this._handleAxisDir,this._axisDir[t.handleName]);const i=cc_1.Vec3.clone(this._handleAxisDir),a=cc.v3(),o=cc.v3();this._indicatorStartDir=cc.v3(),this._deltaAngle=0,this.is2D?(this.isHitOnAxisArrow(t.node,t.handleName)?cc_1.Vec3.transformQuat(a,cc.v3(1,0,0),this.getRotation()):cc_1.Vec3.subtract(a,e,this.getPosition()),cc_1.Vec3.transformQuat(this._indicatorStartDir,cc.v3(1,0,0),this.getRotation())):(cc_1.Vec3.subtract(a,e,this.getPosition()),this._indicatorStartDir=a),cc_1.Vec3.normalize(a,a),cc_1.Vec3.transformQuat(i,i,this.getRotation()),cc_1.Vec3.cross(o,a,i),cc_1.Vec3.cross(a,i,o),this._rotateAlignDir=o,this._transformAxisDir=i,this.updateRotationIndicator(this._transformAxisDir,this._indicatorStartDir,0),this._indicator.sectorNode.active=!0,this._handleDataMap[t.handleName].indicatorCircle.active=!0,this._circleBorderNode.active=!1,Object.keys(this._handleDataMap).forEach(e=>{e===t.handleName?(this._handleDataMap[e].normalTorusNode.active=!1,this._handleDataMap[e].arrowNode.active=!0):this._handleDataMap[e].topNode.active=!1}),Utils.requestPointerLock(),this.onControllerMouseDown&&this.onControllerMouseDown(t)}onMouseMove(t){if(this._isMouseDown){const e=EditorMath.clamp(t.moveDeltaX,-10,10),i=EditorMath.clamp(t.moveDeltaY,-10,10);this._mouseDeltaPos.x+=e,this._mouseDeltaPos.y+=i,cc_1.Quat.identity(this._deltaRotation);let a=0;if(1===t.handleName.length){const e=this.getAlignAxisMoveDistance(this._rotateAlignDir,this._mouseDeltaPos);this._deltaAngle=-e/this._rotFactor,a=this._deltaAngle*this._degreeToRadianFactor,cc_1.Vec3.copy(this._handleAxisDir,this._axisDir[t.handleName]),cc_1.Quat.fromAxisAngle(this._deltaRotation,this._handleAxisDir,a)}this.updateRotationIndicator(this._transformAxisDir,this._indicatorStartDir,a);const o=this.getRotation();cc_1.Quat.multiply(o,this._mouseDownRot,this._deltaRotation),this.setRotation(o),this.onControllerMouseMove&&this.onControllerMouseMove(t),this.updateController()}}onMouseUp(t){Utils.exitPointerLock(),this._indicator.sectorNode.active=!1,cc_1.Quat.identity(this._deltaRotation),this.is2D?(this._handleDataMap.w.indicatorCircle.active=!1,this._handleDataMap.w.normalTorusNode.active=!0,this._handleDataMap.w.topNode.active=!0):(this._circleBorderNode.active=!0,Object.keys(this._handleDataMap).forEach(t=>{"w"!==t&&(this._handleDataMap[t].normalTorusNode.active=!0,this._handleDataMap[t].topNode.active=!0,this._handleDataMap[t].indicatorCircle.active=!1,this._handleDataMap[t].arrowNode.active=!1)})),this.onControllerMouseUp&&this.onControllerMouseUp(t),this._handleAxisDir.set(0,0,0)}onMouseLeave(t){this.onMouseUp(t)}onHoverIn(t){!this.is2D&&this.isInCutoffBack(t.handleName,t.x,t.y)||(this.setHandleColor(t.handleName,cc_1.Color.YELLOW),Object.keys(this._handleDataMap).forEach(e=>{e!==t.handleName&&this.setNodesOpacity(this._handleDataMap[e].rendererNodes,50)}))}onHoverOut(){this.resetHandleColor(),Object.keys(this._handleDataMap).forEach(t=>{this.setNodesOpacity(this._handleDataMap[t].rendererNodes,255)})}setNodesOpacity(t,e){t.forEach(t=>{setNodeOpacity(t,e)})}getDeltaRotation(){return this._deltaRotation}getDeltaAngle(){return this._deltaAngle}getHandleAxisDir(){return this._handleAxisDir}onShow(){this.registerEvents(),this.is2D?(this._handleDataMap.x.topNode.active=!1,this._handleDataMap.y.topNode.active=!1,this._handleDataMap.z.topNode.active=!1,this._handleDataMap.w.topNode.active=!0,this._handleDataMap.w.arrowNode.active=!0,this._circleBorderNode.active=!1,this._cutoffNode.active=!1,this.updateController()):(this._handleDataMap.x.topNode.active=!0,this._handleDataMap.y.topNode.active=!0,this._handleDataMap.z.topNode.active=!0,this._handleDataMap.w.topNode.active=!1,this._handleDataMap.w.arrowNode.active=!1,this._circleBorderNode.active=!0,this._cutoffNode.active=!0)}onHide(){this.unregisterEvents(),this._circleBorderNode.active=!1,this._cutoffNode.active=!1}updateRotationIndicator(t,e,i){const a=controller_shape_1.default.calcSectorPoints(this.getPosition(),t,e,i,this._baseRadius*this.getDistScalar(),60);updatePositions(this._indicator.meshRenderer,a)}adjustControllerSize(){const t=this.getDistScalar(),e=this.getScale(),i=tempVec3_a;cc_1.Vec3.copy(i,e),i.multiplyScalar(t),this.shape.setScale(i),this._circleBorderNode.setScale(i),this._circleBorderNode.setWorldPosition(this.getPosition());const a=EditorCamera.camera.node.getWorldRotation(tempQuat),o=tempVec3_b;cc_1.Vec3.transformQuat(o,cc_1.Vec3.UNIT_Z,a);let s=controller_shape_1.default.calcCirclePoints(cc_1.Vec3.ZERO,o,this._baseRadius);updatePositions(this._circleBorderMR,s),this._cutoffNode.setScale(i),this._cutoffNode.setWorldPosition(this.getPosition()),this._cutoffNode.setWorldRotation(a);const c=tempVec3_b,r=tempMat4;this.shape.getWorldMatrix(r),cc.Mat4.invert(r,r),cc_1.Vec3.transformMat4Normal(c,o,r),this.is2D||Object.keys(this._handleDataMap).forEach(t=>{if("w"!==t){const e=tempVec3_c,i=this._axisDir[t];cc_1.Vec3.cross(e,i,c),cc_1.Vec3.normalize(e,e),s=controller_shape_1.default.calcArcPoints(cc_1.Vec3.ZERO,i,e,-Math.PI,this._baseRadius);const a=this._handleDataMap[t];updatePositions(a.normalTorusMR,s)}})}}exports.default=RotationController;