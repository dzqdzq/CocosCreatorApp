"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.assetWatcherManager=void 0;const cc_1=require("cc"),editor_1=require("editor"),callbacks_invoker_1=require("../../../../utils/callbacks-invoker");let ASSET_PROPS="A$$ETprops",DELIMETER=cc_1.CCClass.Attr.DELIMETER,ASSET_PROPS_KEY=ASSET_PROPS+DELIMETER+ASSET_PROPS;const assetListener=cc_1.assetManager.assetListener=new callbacks_invoker_1.CallbacksInvoker;function removeCaches(e){cc_1.assetManager.releaseAsset(cc_1.assetManager.assets.get(e))}function getPropertyDescriptorAndOwner(e,t){for(;e;){const s=Object.getOwnPropertyDescriptor(e,t);if(s)return{owner:e,pd:s};e=Object.getPrototypeOf(e)}return null}function forceSetterNotify(e,t){const s=getPropertyDescriptorAndOwner(e.prototype,t);if(!s)return void console.warn("Failed to get property descriptor of %s.%s",cc_1.js.getClassName(e),t);if(s.owner._modifiedSetters&&s.owner._modifiedSetters.includes(t))return;const r=s.pd;if(!1===r.configurable)return void console.warn("Failed to register notifier for %s.%s",cc_1.js.getClassName(e),t);if("value"in r)return void console.warn("Cannot watch instance variable of %s.%s",cc_1.js.getClassName(e),t);const n=r.set;r.set=function(e,s){if(n.call(this,e,s),this._watcherHandle){const e=getUuidsOfPropValue(this[t]);this._watcherHandle.changeWatchAsset(t,e)}},Object.defineProperty(s.owner,t,r),s.owner._modifiedSetters?s.owner._modifiedSetters.push(t):s.owner._modifiedSetters=[t]}function invokeAssetSetter(e,t,s){const r=cc_1.js.getPropertyDescriptor(e,t);let n=s;if(r&&r.get){const t=r.get.call(e);if(Array.isArray(t)){for(let e=0;e<t.length;e++)t[e]&&s&&t[e]._uuid===s._uuid&&(t[e]=s);n=t}if(r.set){const a=!0;try{Array.isArray(t)&&r.set.call(e,new Array(n.length).fill(null),a)}catch(e){console.error(e)}r.set.call(e,n,a),s._uuid&&cce.Asset.emit("asset-refresh",s._uuid)}}}function getUuidsOfPropValue(e){const t=[];if(Array.isArray(e))for(const s of e)s instanceof cc_1.Asset&&s._uuid&&t.push(s._uuid);else e instanceof cc_1.Asset&&e._uuid&&t.push(e._uuid);return t}class AssetWatcher{constructor(e){this.owner=null,this.watchingInfos=Object.create(null),this.owner=e}start(){let e=this.owner,t=e.constructor;const s=cc_1.CCClass.Attr.getClassAttrs(t)[ASSET_PROPS_KEY];for(const r of s.assetProps){const s=r[0];forceSetterNotify(t,s);const n=getUuidsOfPropValue(e[s]);this.registerListener(n,e,s)}}stop(){for(const e in this.watchingInfos){if(!(e in this.watchingInfos))continue;const t=this.watchingInfos[e];if(t)for(const e of t.uuids)assetListener.off(e,t.callback)}this.watchingInfos=Object.create(null)}changeWatchAsset(e,t){this.unRegisterListener(e),t.length>0&&this.registerListener(t,this.owner,e)}registerListener(e,t,s){const r=invokeAssetSetter.bind(null,t,s);for(const t of e)assetListener.on(t,r);this.watchingInfos[s]={uuids:e,callback:r}}unRegisterListener(e){const t=this.watchingInfos[e];if(t){for(const e of t.uuids)assetListener.off(e,t.callback);this.watchingInfos[e]=void 0}}}function parseAssetProps(e,t,s){let r=null,n=cc_1.js.getClassName(e);if(s.includes(n))return null;if(!e.__props__)return null;const a=cc_1.CCClass.Attr.getClassAttrs(e);s=s.concat(n);for(let n=0,c=e.__props__;n<c.length;n++){let e=c[n];const o=e+DELIMETER;if(a[o+"hasSetter"]&&a[o+"hasGetter"]){const n=a[o+"ctor"],c=cc_1.js.isChildClassOf(n,cc_1.Asset);let i=t.concat(e);if(c)r?r.push(i):r=[i];else if(cc_1.CCClass._isCCClass(n)){let e=parseAssetProps(n,i,s);e&&(r=r?r.concat(e):e)}}}return r}function getAssetPropsData(e){let t=cc_1.CCClass.Attr.getClassAttrs(e.constructor)[ASSET_PROPS_KEY];if(void 0===t){let s=parseAssetProps(e.constructor,[],[]);if(t={},s)for(const e of s)e.length>1?t.nestedAssetProps?t.nestedAssetProps.push(e):t.nestedAssetProps=[e]:1===e.length&&(t.assetProps?t.assetProps.push(e):t.assetProps=[e]);cc_1.CCClass.Attr.setClassAttr(e.constructor,ASSET_PROPS,ASSET_PROPS,t)}return t}function getPropObj(e,t){let s=e;for(let e=0;e<t.length;e++){let r=t[e];if(s&&(s=s[r]),!s)return null}return s}function walkNestedAssetProp(e,t){let s=getAssetPropsData(e);if(s&&s.nestedAssetProps)for(const r of s.nestedAssetProps){const s=r.concat();s.pop();let n=e;s.length>0&&(n=getPropObj(n,s))&&t(n)}}function updateAsset(e,t,s=[]){if(cc_1.assetManager.references.has(e)){const r=cc_1.assetManager.references.get(e);for(let e=0,n=r.length;e<n;e++){const n=r[e],a=n[0],c=n[1],o=n[2];s.includes(a)||cc_1.isValid(a,!0)&&(a instanceof cc_1.Material&&(t instanceof cc_1.Texture2D||t instanceof cc_1.TextureCube)?a.setProperty(o,t):(c[o]=t,a.onLoaded&&a.onLoaded()),assetListener.emit(a._uuid,a),s.push(a),updateAsset(a._uuid,a,s))}}}class AssetWatcherManager{initHandle(e){let t=getAssetPropsData(e);e._watcherHandle=t&&t.assetProps?new AssetWatcher(e):void 0,walkNestedAssetProp(e,e=>{this.initHandle(e)})}startWatch(e){e._watcherHandle||this.initHandle(e),e._watcherHandle&&e._watcherHandle.start(),walkNestedAssetProp(e,e=>{this.startWatch(e)})}stopWatch(e){e._watcherHandle&&e._watcherHandle.stop(),walkNestedAssetProp(e,e=>{this.stopWatch(e)})}async onAssetChanged(e){if(!await editor_1.Message.request("asset-db","query-asset-info",e))return;if(e.endsWith("@6c48a")){let t=e.indexOf("@"),s=e.substring(0,t);cc_1.assetManager.releaseAsset(cc_1.assetManager.assets.get(s))}if(!assetListener.hasEventListener(e)&&!cc_1.assetManager.references.has(e))return removeCaches(e);const t=cc_1.assetManager.assets.remove(e);cc_1.assetManager.loadAny(e,(s,r)=>{s?console.error(s):(t&&r&&t.constructor.name!==r.constructor.name?(assetListener.emit(e,null),assetListener.off(e),console.warn("The asset type has been modified, and emptied the original reference in the scene.")):assetListener.emit(e,r),updateAsset(e,r),t instanceof cc_1.Asset&&t.destroy())})}onAssetDeleted(e,t){const s=cc_1.assetManager.assets.get(e);if(s){const t=new s.constructor;t.initDefault(e),assetListener.emit(e,t)}removeCaches(e)}}const assetWatcherManager=new AssetWatcherManager;exports.assetWatcherManager=assetWatcherManager;