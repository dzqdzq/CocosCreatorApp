"use strict";var __importDefault=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(exports,"__esModule",{value:!0});const cc_1=require("cc"),{EventEmitter:EventEmitter}=require("events"),material_1=__importDefault(require("./material")),physics_material_1=__importDefault(require("./physics-material")),animation_mask_1=__importDefault(require("./animation-mask")),render_pipeline_1=__importDefault(require("./render-pipeline")),node_1=__importDefault(require("../node")),gizmos_1=__importDefault(require("./../gizmos")),selection_1=__importDefault(require("../selection")),node_2=__importDefault(require("../../../utils/node")),dump_1=__importDefault(require("../../utils/dump")),camera_1=__importDefault(require("../camera")),asset_watcher_1=require("./asset-watcher"),plugin_1=__importDefault(require("../plugin")),scripts_1=__importDefault(require("../scripts")),operation_1=__importDefault(require("../../../public/operation")),asset_1=require("../../../utils/asset"),creatableAssetTypes=node_1.default.creatableAssetTypes;let lastHighlightNode;const ray=cc_1.geometry.Ray.create();let lastHighlightMC=null;class AssetManager extends EventEmitter{init(){scripts_1.default.on(scripts_1.default.EXECUTION_FINISHED,this.onScriptExecutedEnd),operation_1.default.on("onDragOver",this.onDragOver.bind(this)),operation_1.default.on("onDrop",this.onDrop.bind(this))}onScriptExecutedEnd(){cc_1.assetManager.assets.forEach((e,t)=>{e instanceof cc_1.Prefab&&cc_1.assetManager.releaseAsset(e)})}removeAllAssetListeners(){const e=cc_1.assetManager.assetListener;e&&e._callbackTable&&Object.keys(e._callbackTable).forEach(t=>{e.removeAll(t)})}onSceneOpened(){this.removeAllAssetListeners(),node_1.default.queryUuids().forEach(e=>{const t=node_1.default.query(e);t instanceof cc_1.Scene?asset_watcher_1.assetWatcherManager.startWatch(t.globals):node_2.default.isEditorNode(t)||t.components.forEach(e=>{asset_watcher_1.assetWatcherManager.startWatch(e)})})}onNodeChanged(e){e.components.forEach(e=>{asset_watcher_1.assetWatcherManager.stopWatch(e),asset_watcher_1.assetWatcherManager.startWatch(e)})}onComponentAdded(e){asset_watcher_1.assetWatcherManager.startWatch(e)}onComponentRemoved(e){asset_watcher_1.assetWatcherManager.stopWatch(e)}queryAllEffects(){return material_1.default.queryAllEffects()}queryEffect(e){return material_1.default.queryEffect(e)}async queryMaterial(e){return material_1.default.queryMaterial(e)}async applyMaterial(e,t){const a=await material_1.default.decodeMaterial(t);await cce.Ipc.send("save-asset",e,a)}async previewMaterial(e,t,a){return material_1.default.previewMaterial(e,t,a)}async queryPhysicsMaterial(e){let t;try{t=await(0,asset_1.loadAssetUncached)(e)}catch(e){console.error(e)}return t?(physics_material_1.default.cacheComponent(t),physics_material_1.default.encodeComponent(t)):null}async queryAnimationMask(e){let t;try{t=await(0,asset_1.loadAssetUncached)(e)}catch(e){console.error(e)}return t?(animation_mask_1.default.cacheComponent(t),animation_mask_1.default.encodeComponent(t)):null}async changePhysicsMaterial(e){return physics_material_1.default.updateComponent(e)}async applyPhysicsMaterial(e){const t=physics_material_1.default.getComponent(),a=cce.Utils.serialize(t);await cce.Ipc.send("save-asset",e,a)}async changeAnimationMask(e){return"import-skeleton"===e.method?await animation_mask_1.default.importSkeleton(e.uuid):"change-dump"===e.method?await animation_mask_1.default.updateComponent(e.dump):"clear-nodes"===e.method?animation_mask_1.default.clearNodes():void 0}async applyAnimationMask(e){const t=animation_mask_1.default.getComponent(),a=cce.Utils.serialize(t);await cce.Ipc.send("save-asset",e,a)}async applyRenderTexture(e,t){let a;try{a=await(0,asset_1.loadAssetUncached)(e)}catch(e){console.error(e)}if(!a||!t)return;a.resize(t.width||1,t.height||1);const s=cce.Utils.serialize(a);cce.Ipc.send("save-asset",e,s)}onAssetChanged(e){asset_watcher_1.assetWatcherManager.onAssetChanged(e),this.emit("asset-change",e)}onAssetDeleted(e,t){asset_watcher_1.assetWatcherManager.onAssetDeleted(e,t.url),this.emit("asset-delete",e)}getAllReferenceAssets(e,t=[]){var a;let s=[];const n=null===(a=cc_1.assetManager.references)||void 0===a?void 0:a.get(e);if(n)for(let e=0,a=n.length;e<a;e++){const a=n[e][0].deref();a&&(t.includes(a)||(0,cc_1.isValid)(a,!0)&&(t.push(a),s.push(a),s=s.concat(this.getAllReferenceAssets(a._uuid,t))))}return s}releaseAsset(e){const t=cc_1.assetManager.assets.get(e);t&&(t instanceof cc_1.Prefab?(cc_1.assetManager.assets.forEach((t,a)=>{cc_1.assetManager.dependUtil.getDepsRecursively(a).includes(e)&&cc_1.assetManager.releaseAsset(t)}),cc_1.assetManager.releaseAsset(t)):cc_1.assetManager.releaseAsset(t))}canDrop(e){return creatableAssetTypes.includes(e)}onDragOver(e){if(!e)return;const t=node_2.default.getRaycastResultNodes(camera_1.default.getCamera(),e.x,e.y,cc_1.Layers.makeMaskExclude([cc_1.Layers.BitMask.GIZMOS,cc_1.Layers.Enum.SCENE_GIZMO])),a=t.length>0?t[0]:null;if(!a)return lastHighlightMC&&!selection_1.default.isSelect(lastHighlightMC.node.uuid)&&gizmos_1.default.hideComponentGizmo(lastHighlightMC),void(lastHighlightNode=null);if(lastHighlightNode!==a&&e.values.some(e=>"cc.Material"===e.type)){const e=a.components.find(e=>e instanceof cc_1.MeshRenderer);if(!e)return;lastHighlightNode=a,lastHighlightMC&&!selection_1.default.isSelect(lastHighlightMC.node.uuid)&&gizmos_1.default.hideComponentGizmo(lastHighlightMC),lastHighlightMC=e,gizmos_1.default.showComponentGizmo(lastHighlightMC)}}async onDrop(e){if(!e)return;const t=node_2.default.getRaycastResultNodes(camera_1.default.getCamera(),e.x,e.y,cc_1.Layers.makeMaskExclude([cc_1.Layers.BitMask.GIZMOS,cc_1.Layers.Enum.SCENE_GIZMO])),a=t.length>0?t[0]:null;let s=cc.geometry.plane.create(0,1,0,0);const n=e.x,r=cc.game.canvas.height-e.y;camera_1.default.is2D&&(s=cc.geometry.plane.create(0,0,1,0)),camera_1.default.getCamera().screenPointToRay(ray,n,r);const i=cc.geometry.intersect.rayPlane(ray,s);let c=new cc.Vec3;cc.Vec3.scaleAndAdd(c,ray.o,ray.d,i),c=node_2.default.makeVec3InPrecision(c,0);let l=0;const o={},u=[],d=[];e.values.forEach(e=>{if(this.canDrop(e.type)){const[t,a]=e.value.split("@");if(d.includes(t))return;d.push(t),u.push(e)}});for(const e of u)switch(e.type){case"cc.Material":if(a){const t={type:e.type,value:""},s=`__comps__.${a.components.findIndex(e=>e instanceof cc_1.MeshRenderer)}.sharedMaterials.${l}`;t.value={uuid:e.value},await node_1.default.setProperty(a.uuid,s,t),l++}break;default:if(plugin_1.default.getDropHandle(e.type)){o[e.type]=o[e.type]||[],o[e.type].push(e);continue}const t=await node_1.default.createNodeFromAsset(a?a.uuid:cc.director._scene.uuid,e.value,{name:e.name,type:e.type,canvasRequired:e.canvasRequired,unlinkPrefab:e.unlinkPrefab,position:c}),s=node_1.default.query(t);gizmos_1.default.showNodeGizmoOfNode(s)}for(const e in o){const a=plugin_1.default.getDropHandle(e);a&&Editor.Message.send(a.name,a.item.message,t.map(dump_1.default.dumpNode),{x:c.x,y:c.y,z:c.z},o[e])}lastHighlightMC&&!selection_1.default.isSelect(lastHighlightMC.node.uuid)&&(gizmos_1.default.hideComponentGizmo(lastHighlightMC),lastHighlightMC=null),lastHighlightNode=null}async queryRenderPipeline(e){let t;try{t=await(0,asset_1.loadAssetUncached)(e)}catch(e){console.error(e)}return t?(render_pipeline_1.default.cacheComponent(t),render_pipeline_1.default.encodeComponent(t)):null}async changeRenderPipeline(e){return await render_pipeline_1.default.updateComponent(e)}async applyRenderPipeline(e){const t=render_pipeline_1.default.getComponent(),a=cce.Utils.serialize(t);await cce.Ipc.send("save-asset",e,a),render_pipeline_1.default.preview()}}exports.default=new AssetManager;