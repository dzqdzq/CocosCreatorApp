"use strict";var __importDefault=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(exports,"__esModule",{value:!0}),exports.AssetManager=void 0;const cc_1=require("cc"),events_1=require("events"),material_1=__importDefault(require("./material")),physics_material_1=__importDefault(require("./physics-material")),animation_graph_variant_1=__importDefault(require("./animation-graph-variant")),animation_mask_1=__importDefault(require("./animation-mask")),render_pipeline_1=__importDefault(require("./render-pipeline")),node_1=__importDefault(require("../node")),gizmos_1=__importDefault(require("./../gizmos")),selection_1=__importDefault(require("../selection")),node_2=__importDefault(require("../../../utils/node")),dump_1=__importDefault(require("../../utils/dump")),camera_1=__importDefault(require("../camera")),asset_watcher_1=require("./asset-watcher"),plugin_1=__importDefault(require("../plugin")),scripts_1=__importDefault(require("../scripts")),operation_1=__importDefault(require("../../../public/operation")),asset_1=require("../../../utils/asset"),droppableAssetTypes=["cc.Material",...node_1.default.creatableAssetTypes];let lastHighlightNode;const ray=cc_1.geometry.Ray.create();let lastHighlightMC=null;class AssetManager extends events_1.EventEmitter{init(){scripts_1.default.on(scripts_1.default.EXECUTION_FINISHED,this.onScriptExecutedEnd),operation_1.default.on("onDragOver",this.onDragOver.bind(this)),operation_1.default.on("onDrop",this.onDrop.bind(this))}onScriptExecutedEnd(){cc_1.assetManager.assets.forEach((e,a)=>{e instanceof cc_1.Prefab&&cc_1.assetManager.releaseAsset(e)})}removeAllAssetListeners(){const e=cc_1.assetManager.assetListener;e&&e._callbackTable&&Object.keys(e._callbackTable).forEach(a=>{e.removeAll(a)})}onSceneOpened(){this.removeAllAssetListeners(),node_1.default.queryUuids().forEach(e=>{const a=node_1.default.query(e);a instanceof cc_1.Scene?asset_watcher_1.assetWatcherManager.startWatch(a.globals):a&&!node_2.default.isEditorNode(a)&&a.components.forEach(e=>{asset_watcher_1.assetWatcherManager.startWatch(e)})})}onNodeChanged(e){e.components.forEach(e=>{asset_watcher_1.assetWatcherManager.stopWatch(e),asset_watcher_1.assetWatcherManager.startWatch(e)})}onComponentAdded(e){asset_watcher_1.assetWatcherManager.startWatch(e)}onComponentRemoved(e){asset_watcher_1.assetWatcherManager.stopWatch(e)}queryAllEffects(){return material_1.default.queryAllEffects()}queryEffect(e){return material_1.default.queryEffect(e)}async queryMaterial(e){return material_1.default.queryMaterial(e)}async applyMaterial(e,a){const t=await material_1.default.decodeMaterial(a);await cce.Ipc.send("save-asset",e,t)}async previewMaterial(e,a,t){return material_1.default.previewMaterial(e,a,t)}async queryPhysicsMaterial(e){let a;try{a=await(0,asset_1.loadAssetUncached)(e)}catch(e){console.error(e)}return a?(physics_material_1.default.cacheComponent(a),physics_material_1.default.encodeComponent(a)):null}async queryAnimationGraphVariant(e){let a;try{a=await(0,asset_1.loadAssetUncached)(e)}catch(e){console.error(e)}return a?(animation_graph_variant_1.default.cacheComponent(a),animation_graph_variant_1.default.encodeComponent()):null}async queryAnimationMask(e){let a;try{a=await(0,asset_1.loadAssetUncached)(e)}catch(e){console.error(e)}return a?(animation_mask_1.default.cacheComponent(a),animation_mask_1.default.encodeComponent(a)):null}async changePhysicsMaterial(e){return await physics_material_1.default.updateComponent(e)}async applyPhysicsMaterial(e){const a=physics_material_1.default.getComponent(),t=cce.Utils.serialize(a);await cce.Ipc.send("save-asset",e,t)}async changeAnimationGraphVariant(e){return await animation_graph_variant_1.default.updateComponent(e)}async applyAnimationGraphVariant(e){const a=await animation_graph_variant_1.default.applyComponent();if(!a)return;const t=cce.Utils.serialize(a);await cce.Ipc.send("save-asset",e,t)}async changeAnimationMask(e){return"import-skeleton"===e.method?await animation_mask_1.default.importSkeleton(e.uuid):"change-dump"===e.method?await animation_mask_1.default.updateComponent(e.dump):"clear-nodes"===e.method?animation_mask_1.default.clearNodes():void 0}async applyAnimationMask(e){const a=animation_mask_1.default.getComponent(),t=cce.Utils.serialize(a);await cce.Ipc.send("save-asset",e,t)}async applyRenderTexture(e,a){let t;try{t=await(0,asset_1.loadAssetUncached)(e)}catch(e){console.error(e)}if(!t||!a)return;t.resize(a.width||1,a.height||1);const s=cce.Utils.serialize(t);cce.Ipc.send("save-asset",e,s)}onAssetChanged(e){asset_watcher_1.assetWatcherManager.onAssetChanged(e),this.emit("asset-change",e)}onAssetDeleted(e,a){asset_watcher_1.assetWatcherManager.onAssetDeleted(e,a.url),this.emit("asset-delete",e)}getAllReferenceAssets(e,a=[]){var t;let s=[];const n=null===(t=cc_1.assetManager.references)||void 0===t?void 0:t.get(e);if(n)for(let e=0,t=n.length;e<t;e++){const t=n[e][0].deref();t&&(a.includes(t)||(0,cc_1.isValid)(t,!0)&&(a.push(t),s.push(t),s=s.concat(this.getAllReferenceAssets(t._uuid,a))))}return s}releaseAsset(e){const a=cc_1.assetManager.assets.get(e);a&&(a instanceof cc_1.Prefab?(cc_1.assetManager.assets.forEach((a,t)=>{cc_1.assetManager.dependUtil.getDepsRecursively(t).includes(e)&&cc_1.assetManager.releaseAsset(a)}),cc_1.assetManager.releaseAsset(a)):cc_1.assetManager.releaseAsset(a))}canDrop(e){return droppableAssetTypes.includes(e)}onDragOver(e){if(!e)return;const a=node_2.default.getRaycastResultNodes(camera_1.default.getCamera(),e.x,e.y,cc_1.Layers.makeMaskExclude([cc_1.Layers.BitMask.GIZMOS,cc_1.Layers.Enum.SCENE_GIZMO])),t=a.length>0?a[0]:null;if(!t)return lastHighlightMC&&!selection_1.default.isSelect(lastHighlightMC.node.uuid)&&gizmos_1.default.hideComponentGizmo(lastHighlightMC),void(lastHighlightNode=null);if(lastHighlightNode!==t&&e.values.some(e=>"cc.Material"===e.type)){const e=t.components.find(e=>e instanceof cc_1.MeshRenderer);if(!e)return;lastHighlightNode=t,lastHighlightMC&&!selection_1.default.isSelect(lastHighlightMC.node.uuid)&&gizmos_1.default.hideComponentGizmo(lastHighlightMC),lastHighlightMC=e,gizmos_1.default.showComponentGizmo(lastHighlightMC)}}async onDrop(e){var a;if(!e)return;const t=node_2.default.getRaycastResultNodes(camera_1.default.getCamera(),e.x,e.y,cc_1.Layers.makeMaskExclude([cc_1.Layers.BitMask.GIZMOS,cc_1.Layers.Enum.SCENE_GIZMO])),s=t.length>0?t[0]:null;let n=cc.geometry.plane.create(0,1,0,0);const r=e.x,i=cc.game.canvas.height-e.y;camera_1.default.is2D&&(n=cc.geometry.plane.create(0,0,1,0)),camera_1.default.getCamera().screenPointToRay(ray,r,i);const c=cc.geometry.intersect.rayPlane(ray,n);let l=new cc.Vec3;cc.Vec3.scaleAndAdd(l,ray.o,ray.d,c),l=node_2.default.makeVec3InPrecision(l,0);let o=0;const u={},d=[],_=[];e.values.forEach(e=>{if(this.canDrop(e.type)){const[a,t]=e.value.split("@");if(_.includes(a))return;_.push(a),d.push(e)}});for(const e of d)switch(e.type){case"cc.Material":if(s){const a={type:e.type,value:""},t=`__comps__.${s.components.findIndex(e=>e instanceof cc_1.MeshRenderer)}.sharedMaterials.${o}`;a.value={uuid:e.value},await node_1.default.setProperty(s.uuid,t,a),o++}break;default:if(plugin_1.default.getDropHandle(e.type)){u[e.type]=u[e.type]||[],u[e.type].push(e);continue}const t=null!==(a=null===s||void 0===s?void 0:s.uuid)&&void 0!==a?a:cc.director._scene.uuid,n=await cce.SceneFacadeManager.createNode({parent:t,assetUuid:e.value,name:e.name,type:e.type,canvasRequired:e.canvasRequired,unlinkPrefab:e.unlinkPrefab,position:l}),r=node_1.default.query(n);r&&gizmos_1.default.showNodeGizmoOfNode(r)}for(const e in u){const a=plugin_1.default.getDropHandle(e);a&&Editor.Message.send(a.name,a.item.message,t.map(dump_1.default.dumpNode),{x:l.x,y:l.y,z:l.z},u[e])}lastHighlightMC&&!selection_1.default.isSelect(lastHighlightMC.node.uuid)&&(gizmos_1.default.hideComponentGizmo(lastHighlightMC),lastHighlightMC=null),lastHighlightNode=null}async queryRenderPipeline(e){let a;try{a=await(0,asset_1.loadAssetUncached)(e)}catch(e){console.error(e)}return a?(render_pipeline_1.default.cacheComponent(a),render_pipeline_1.default.encodeComponent(a)):null}async changeRenderPipeline(e){return await render_pipeline_1.default.updateComponent(e)}async applyRenderPipeline(e){const a=render_pipeline_1.default.getComponent(),t=cce.Utils.serialize(a);await cce.Ipc.send("save-asset",e,t),render_pipeline_1.default.preview()}}exports.AssetManager=AssetManager,exports.default=new AssetManager;