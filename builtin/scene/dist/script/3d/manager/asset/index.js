"use strict";var __importDefault=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(exports,"__esModule",{value:!0}),exports.AssetManager=void 0;const cc_1=require("cc"),events_1=require("events"),material_1=__importDefault(require("./material")),physics_material_1=__importDefault(require("./physics-material")),animation_graph_variant_1=__importDefault(require("./animation-graph-variant")),animation_mask_1=__importDefault(require("./animation-mask")),render_pipeline_1=__importDefault(require("./render-pipeline")),node_1=__importDefault(require("../node")),gizmos_1=__importDefault(require("./../gizmos")),selection_1=__importDefault(require("../selection")),node_2=__importDefault(require("../../../utils/node")),dump_1=__importDefault(require("../../../export/dump")),camera_1=__importDefault(require("../camera")),asset_watcher_1=require("./asset-watcher"),plugin_1=__importDefault(require("../plugin")),operation_1=__importDefault(require("../../../public/operation")),asset_1=require("../../../utils/asset"),window_1=require("../../../utils/window"),droppableAssetTypes=["cc.Material",...node_1.default.creatableAssetTypes];let lastHighlightNode;const ray=cc_1.geometry.Ray.create();let lastHighlightMC=null;class AssetManager extends events_1.EventEmitter{init(){cce.Script.on(cce.Script.EXECUTION_FINISHED,this.onScriptExecutedEnd),operation_1.default.on("onDragOver",this.onDragOver.bind(this)),operation_1.default.on("onDrop",this.onDrop.bind(this))}onScriptExecutedEnd(){cc_1.assetManager.assets.forEach((e,a)=>{e instanceof cc_1.Prefab&&cc_1.assetManager.releaseAsset(e)})}removeAllAssetListeners(){cc_1.assetManager.assetListener.removeAllListeners()}onSceneOpened(){this.removeAllAssetListeners(),node_1.default.queryUuids().forEach(e=>{const a=node_1.default.query(e);a instanceof cc_1.Scene?asset_watcher_1.assetWatcherManager.startWatch(a.globals):a&&!node_2.default.isEditorNode(a)&&a.components.forEach(e=>{asset_watcher_1.assetWatcherManager.startWatch(e)})})}onNodeChanged(e){e.components.forEach(e=>{asset_watcher_1.assetWatcherManager.stopWatch(e),asset_watcher_1.assetWatcherManager.startWatch(e)})}onComponentAdded(e){asset_watcher_1.assetWatcherManager.startWatch(e)}onComponentRemoved(e){asset_watcher_1.assetWatcherManager.stopWatch(e)}queryAllEffects(){return material_1.default.queryAllEffects()}queryEffect(e){return material_1.default.queryEffect(e)}async queryMaterial(e){return material_1.default.queryMaterial(e)}async applyMaterial(e,a){const t=await material_1.default.decodeMaterial(a);await cce.Ipc.send("save-asset",e,t)}async previewMaterial(e,a,t){return material_1.default.previewMaterial(e,a,t)}async queryPhysicsMaterial(e){let a;try{a=await(0,asset_1.loadAssetUncached)(e)}catch(e){console.error(e)}return a?(physics_material_1.default.cacheComponent(a),physics_material_1.default.encodeComponent(a)):null}async queryAnimationGraphVariant(e){let a;try{a=await(0,asset_1.loadAssetUncached)(e)}catch(e){console.error(e)}return a?(animation_graph_variant_1.default.cacheComponent(a),animation_graph_variant_1.default.encodeComponent()):null}async queryAnimationMask(e){let a;try{a=await(0,asset_1.loadAssetUncached)(e)}catch(e){console.error(e)}return a?(animation_mask_1.default.cacheComponent(a),animation_mask_1.default.encodeComponent(a)):null}async changePhysicsMaterial(e){return await physics_material_1.default.updateComponent(e)}async applyPhysicsMaterial(e){const a=physics_material_1.default.getComponent(),t=cce.Utils.serialize(a);await cce.Ipc.send("save-asset",e,t)}async changeAnimationGraphVariant(e){return await animation_graph_variant_1.default.updateComponent(e)}async applyAnimationGraphVariant(e){const a=await animation_graph_variant_1.default.applyComponent();if(!a)return;const t=cce.Utils.serialize(a);await cce.Ipc.send("save-asset",e,t)}async changeAnimationMask(e){return"import-skeleton"===e.method?await animation_mask_1.default.importSkeleton(e.uuid):"change-dump"===e.method?await animation_mask_1.default.updateComponent(e.dump):"clear-nodes"===e.method?animation_mask_1.default.clearNodes():void 0}async applyAnimationMask(e){const a=animation_mask_1.default.getComponent(),t=cce.Utils.serialize(a);await cce.Ipc.send("save-asset",e,t)}async applyRenderTexture(e,a){let t;try{t=await(0,asset_1.loadAssetUncached)(e)}catch(e){console.error(e)}if(!t||!a)return;t.resize(a.width||1,a.height||1);const s=cce.Utils.serialize(t);cce.Ipc.send("save-asset",e,s)}onAssetChanged(e,a,t){asset_watcher_1.assetWatcherManager.onAssetChanged(e),this.emit("asset-change",e,a,t)}onAssetDeleted(e,a){asset_watcher_1.assetWatcherManager.onAssetDeleted(e,a.url),this.emit("asset-delete",e)}getAllReferenceAssets(e,a=[]){var t;let s=[];const n=null===(t=cc_1.assetManager.references)||void 0===t?void 0:t.get(e);if(n)for(let e=0,t=n.length;e<t;e++){const t=n[e][0].deref();t&&(a.includes(t)||(0,cc_1.isValid)(t,!0)&&(a.push(t),s.push(t),s=s.concat(this.getAllReferenceAssets(t._uuid,a))))}return s}releaseAsset(e){const a=cc_1.assetManager.assets.get(e);if(a){if(a instanceof cc_1.Prefab){const e=[];cc_1.assetManager.assets.forEach((t,s)=>{const n=cc_1.assetManager.dependUtil.getDepsRecursively(s);a&&n.includes(a.uuid)&&e.push(t)}),e.forEach(e=>{cc_1.assetManager.releaseAsset(e)})}cc_1.assetManager.releaseAsset(a)}}canDrop(e){return droppableAssetTypes.includes(e)}onDragOver(e){if(!e)return;const a=node_2.default.getRaycastResultNodes(camera_1.default.getCamera(),e.x,e.y,cc_1.Layers.makeMaskExclude([cc_1.Layers.BitMask.GIZMOS,cc_1.Layers.Enum.SCENE_GIZMO])),t=a.length>0?a[0]:null;if(!t)return lastHighlightMC&&!selection_1.default.isSelect(lastHighlightMC.node.uuid)&&gizmos_1.default.hideComponentGizmo(lastHighlightMC),void(lastHighlightNode=null);if(lastHighlightNode!==t&&e.values.some(e=>"cc.Material"===e.type)){const e=t.components.find(e=>e instanceof cc_1.MeshRenderer);if(!e)return;lastHighlightNode=t,lastHighlightMC&&!selection_1.default.isSelect(lastHighlightMC.node.uuid)&&gizmos_1.default.hideComponentGizmo(lastHighlightMC),lastHighlightMC=e,gizmos_1.default.showComponentGizmo(lastHighlightMC)}}async onDrop(e){var a,t;if(!e)return;const s=(0,window_1.getMainWindowSize)(),n=node_2.default.getRaycastResultNodes(camera_1.default.getCamera(),e.x,e.y,cc_1.Layers.makeMaskExclude([cc_1.Layers.BitMask.GIZMOS,cc_1.Layers.Enum.SCENE_GIZMO])),r=n.length>0?n[0]:null;let i=cc.geometry.plane.create(0,1,0,0);const c=e.x,o=s.height-e.y;camera_1.default.is2D&&(i=cc.geometry.plane.create(0,0,1,0)),camera_1.default.getCamera().screenPointToRay(ray,c,o);const l=cc.geometry.intersect.rayPlane(ray,i);let d=new cc.Vec3;cc.Vec3.scaleAndAdd(d,ray.o,ray.d,l),d=node_2.default.makeVec3InPrecision(d,0);let u=0;const _={},p=[],h={},m=["cc.Prefab","cc.LabelAtlas"];e.values.forEach(e=>{if(this.canDrop(e.type)){const[a,t]=e.value.split("@");if(m.includes(e.type))h[a]=!0;else if(h[a])return;p.push(e)}});for(const e of p)switch(e.type){case"cc.Material":if(r){const a={type:e.type,value:""},t=`__comps__.${r.components.findIndex(e=>e instanceof cc_1.MeshRenderer)}.sharedMaterials.${u}`;a.value={uuid:e.value},await node_1.default.setProperty(r.uuid,t,a),u++}break;default:{if(plugin_1.default.getDropHandle(e.type)){_[e.type]=_[e.type]||[],_[e.type].push(e);continue}const s=null!==(a=null===r||void 0===r?void 0:r.uuid)&&void 0!==a?a:null===(t=cc_1.director.getScene())||void 0===t?void 0:t.uuid;cce.SceneFacadeManager.snapshot();const n=await cce.SceneFacadeManager.createNode({parent:s,assetUuid:e.value,name:e.name,type:e.type,canvasRequired:e.canvasRequired,unlinkPrefab:e.unlinkPrefab,position:d});cce.SceneFacadeManager.snapshot();const i=node_1.default.query(n);i&&gizmos_1.default.showNodeGizmoOfNode(i);break}}for(const e in _){const a=plugin_1.default.getDropHandle(e);a&&Editor.Message.send(a.name,a.item.message,n.map(dump_1.default.dumpNode),{x:d.x,y:d.y,z:d.z},_[e])}lastHighlightMC&&!selection_1.default.isSelect(lastHighlightMC.node.uuid)&&(gizmos_1.default.hideComponentGizmo(lastHighlightMC),lastHighlightMC=null),lastHighlightNode=null}async queryRenderPipeline(e){let a;try{a=await(0,asset_1.loadAssetUncached)(e)}catch(e){console.error(e)}return a?(render_pipeline_1.default.cacheComponent(a),render_pipeline_1.default.encodeComponent(a)):null}async changeRenderPipeline(e){return await render_pipeline_1.default.updateComponent(e)}async applyRenderPipeline(e){const a=render_pipeline_1.default.getComponent(),t=cce.Utils.serialize(a);await cce.Ipc.send("save-asset",e,t),e===await Editor.Profile.getProject("project","general.renderPipeline")&&render_pipeline_1.default.preview()}}exports.AssetManager=AssetManager,exports.default=new AssetManager;