"use strict";var __importDefault=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(exports,"__esModule",{value:!0}),exports.CameraUtils=exports.CameraMoveMode=exports.$info=void 0;const cc_1=require("cc"),editor_camera_components_1=__importDefault(require("./editor-camera-components")),node_1=__importDefault(require("../node")),$info=document.createElement("div");exports.$info=$info,$info.hidden=!0,$info.id="camera_info",$info.innerHTML='\n<style>\n    #camera_info { position: absolute; bottom: 10px; left: 10px; font-size: 12px; text-align: center; color: #fff; }\n    #camera_info div { padding: 2px 0; }\n    #camera_info span { border: 1px solid #fff; border-radius: 2px; width: 18px; display: inline-block; }\n    #camera_info .opacity { opacity: 0.4; }\n</style>\n<div>\n    <span class="opacity">q</span>\n    <span>w</span>\n    <span class="opacity">e</span>\n</div>\n<div>\n    <span>a</span>\n    <span>s</span>\n    <span>d</span>\n</div>\n',document.body.appendChild($info);const _maxTicks=100;class Utils{updateVBAttr(e,t,n){const s=e&&e.model&&e.model.subModels[0];if(!s||!s.inputAssembler||!s.subMesh)return;const{inputAssembler:o,subMesh:r}=s,a=r.vbuffer;let c=0,i=cc_1.gfx.Format.UNKNOWN;for(const e of o.attributes){if(e.name===t){i=e.format;break}c+=cc_1.gfx.FormatInfos[e.format].size}const u=o.vertexBuffers[0];i&&u&&(cc_1.utils.writeBuffer(new DataView(a),n,i,c,u.stride),u.update(a,u.stride*u.count),r.geometricInfo&&r.geometricInfo.positions.set(n))}updateIB(e,t){const n=e&&e.model&&e.model.subModels[0];if(!n||!n.inputAssembler||!n.subMesh)return;const{inputAssembler:s,subMesh:o}=n,r=o.ibuffer,a=s.indexCount,c=s.indexBuffer;if(!a||!c)return;const i=cc_1.gfx.Format[`R${8*c.stride}UI`];cc_1.utils.writeBuffer(new DataView(r),t,i),c.update(r,c.stride*c.count),s.indexCount=t.length}grid(e,t,n,s){const o=[],r=[],a=[],c=.5*e,i=.5*t,u=e/n,d=t/s,f=cc.v3(-c,-.1,-i),p=cc.v3(c,.1,i);function l(e,t,n,s){const c=o.length/3;e===n?(o.push(e+.01,0,t),r.push(1,0),o.push(e-.01,0,t),r.push(0,0),o.push(e+.01,0,s),r.push(1,0),o.push(e-.01,0,s),r.push(0,0)):(o.push(e,0,t-.01),r.push(0,1),o.push(e,0,t+.01),r.push(1,1),o.push(n,0,t-.01),r.push(0,1),o.push(n,0,t+.01),r.push(1,1)),a.push(c,c+1,c+2,c+2,c+1,c+3)}for(let e=-c;e<=c;e+=u)l(e,-i,e,i);for(let e=-i;e<=i;e+=d)l(-c,e,c,e);return{positions:o,uvs:r,indices:a,minPos:f,maxPos:p}}createStrokeGrid(e,t){const n=new cc.Node("Editor Grid");n.layer=cc.Layers.Enum.EDITOR|cc.Layers.Enum.IGNORE_RAYCAST,n.parent=cce.backgroundNode;const s=n.addComponent(cc_1.MeshRenderer);s.mesh=cc.utils.createMesh(this.grid(e,t,e,t));const o=s.onEnable.bind(s);s.onEnable=(()=>{o()});const r=new cc.Material;return r.initialize({effectName:"editor/grid-stroke"}),s.material=r,s}createGrid(e){const t=new cc.Node(e);t.layer=cc.Layers.Enum.EDITOR|cc.Layers.Enum.IGNORE_RAYCAST,t.parent=cce.backgroundNode,t.setWorldPosition(cc.v3(0,0,0));const n=t.addComponent(cc_1.MeshRenderer),s=n.onEnable.bind(n);n.onEnable=(()=>{s()});const o=[],r=[],a=[];for(let e=0;e<_maxTicks*_maxTicks;e++)o.push(0,0),r.push(1,1,1,1);for(let e=0;e<o.length;e+=2)a.push(e/2);const c=cc_1.gfx.PrimitiveMode.LINE_LIST,i=[{name:cc_1.gfx.AttributeName.ATTR_POSITION,format:cc_1.gfx.Format.RG32F}],u=cc.utils.createMesh({positions:o,indices:a,colors:r,primitiveMode:c,attributes:i}),d=u.renderingSubMeshes[0],f=u.struct.vertexBundles[0].view;d.vbuffer=u.data.buffer.slice(f.offset,f.offset+f.length);const p=u.struct.primitives[0].indexView;d.ibuffer=u.data.buffer.slice(p.offset,p.offset+p.length),n.mesh=u;const l=new cc.Material;return l.initialize({effectName:e,states:{primitive:c}}),n.material=l,n}createCamera(e){const t=new cc.Node("Editor Camera");t.layer=cc.Layers.Enum.EDITOR,t.parent=cce.backgroundNode;const n=t.addComponent(editor_camera_components_1.default);return n.clearFlags=cc_1.Camera.ClearFlag.SKYBOX|cc_1.gfx.ClearFlagBit.COLOR,n.clearColor=e,n.visibility=cc_1.Layers.makeMaskExclude([cc_1.Layers.BitMask.PROFILER,cc_1.Layers.Enum.GIZMOS,cc_1.Layers.Enum.SCENE_GIZMO]),n.far=1e5,n.near=.1,n}queryLightNodes(e){const t=[];return node_1.default.queryUuids().forEach(n=>{const s=node_1.default.query(n);s&&!e.includes(s)&&s.getComponent(cc_1.Light)&&t.push(s)}),t}isSceneHasActiveLight(e){let t=!1;const n=[];return e.forEach(e=>{if(e.active){const s=e.getComponent(cc_1.Light);s?!0===s.enabled&&(t=!0):n.push(e)}}),n.forEach(t=>{const n=e.indexOf(t);e.splice(n,1)}),t}queryComponent(e){const t=[];return node_1.default.queryUuids().forEach(n=>{const s=node_1.default.query(n).getComponent(e);s&&t.push(s)}),t}}var CameraMoveMode;!function(e){e[e.IDLE=0]="IDLE",e[e.ORBIT=1]="ORBIT",e[e.PAN=2]="PAN",e[e.ZOOM=3]="ZOOM",e[e.WANDER=4]="WANDER"}(CameraMoveMode||(CameraMoveMode={})),exports.CameraMoveMode=CameraMoveMode;const CameraUtils=new Utils;exports.CameraUtils=CameraUtils;