"use strict";var __importDefault=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(exports,"__esModule",{value:!0});const scene_1=__importDefault(require("../scene")),event_emitter_1=require("../../../utils/event-emitter"),cc_1=require("cc");class PreviewBuffer extends event_emitter_1.EventEmitter{_name;device=cc.director.root.device;width=Math.floor(cc.director.root.mainWindow.width);height=Math.floor(cc.director.root.mainWindow.height);data=new Uint8Array(this.width*this.height*4);renderScene=null;scene=null;windows={};window=null;regions=[new cc_1.gfx.BufferTextureCopy];renderData;queue;lock=!1;_registerName;constructor(e,t,i=null){super(),this.renderData={width:this.width,height:this.height,buffer:this.data},this._name=t,this._registerName=e,i?this.onLoadScene(i):(scene_1.default.on("open",this.onLoadScene.bind(this)),scene_1.default.on("reload",this.onLoadScene.bind(this))),this.regions[0].texExtent.width=this.width,this.regions[0].texExtent.height=this.height,this.createWindow(),this.queue=[]}resize(e,t,i=null){(i=i||this.window)&&(e=Math.floor(e),t=Math.floor(t),this.renderData.width=this.width=e,this.renderData.height=this.height=t,this.regions[0].texExtent.width=e,this.regions[0].texExtent.height=t,i.resize(e,t),this.renderData.buffer=this.data=new Uint8Array(this.width*this.height*4))}clear(){isSceneNative||this.resize(0,0,this.window),this.resize(this.width,this.height,this.window)}createWindow(e=null){var t,i;e&&this.windows[e]?this.window=this.windows[e]:(i=cc.director.root,(t=new cc_1.gfx.RenderPassInfo([new cc_1.gfx.ColorAttachment(i.mainWindow.swapchain.colorTexture.format)],new cc_1.gfx.DepthStencilAttachment(i.mainWindow.swapchain.depthStencilTexture.format))).colorAttachments[0].barrier=i.device.getGeneralBarrier(new cc_1.gfx.GeneralBarrierInfo(0,cc_1.gfx.AccessFlagBit.FRAGMENT_SHADER_READ_TEXTURE)),i=i.createWindow({title:this._name,width:this.width,height:this.height,renderPassInfo:t,isOffscreen:!0}),this.window=i,e&&(this.windows[e]=i))}removeWindow(e){e&&this.windows[e]&&(cc.director.root.destroyWindow(this.windows[e]),this.windows[e]===this.window&&(this.window=null),delete this.windows[e])}onLoadScene(e){var t,i,r=cc.director.root;for([t,i]of Object.entries(this.windows))r.destroyWindow(i);this.windows={},this.scene=e,this.renderScene=e.renderScene,this.emit("loadScene",e)}switchCameras(e,t){t&&(e.isWindowSize=!1,e.isEnable=!0,e.changeTargetWindow(t),cc.director.root.tempWindow=t)}needInvertGFXApi=[cc_1.gfx.API.GLES2,cc_1.gfx.API.GLES3,cc_1.gfx.API.WEBGL,cc_1.gfx.API.WEBGL2];copyFrameBuffer(e=null){return(e=e||this.window)&&e.framebuffer&&(this.device.copyTextureToBuffers(e.framebuffer.colorTextures[0],[new Uint8Array(this.renderData.buffer.buffer)],this.regions),this.formatBuffer(this.renderData.buffer,!this.needInvertGFXApi.includes(this.device.gfxAPI),this.device.gfxAPI===cc_1.gfx.API.METAL),this.emit("getData",this,this.data)),this.renderData}static indexOfRGBA=[0,1,2,3];static indexOfBGRA=[2,1,0,3];formatBuffer(i,e,t){if(e){var r,h,n={r:0,g:0,b:0,a:0},s=t?PreviewBuffer.indexOfBGRA:PreviewBuffer.indexOfRGBA;for(let t=0;t<this.renderData.width;t++)for(let e=0;e<=this.renderData.height/2;e++)r=4*(e*this.renderData.width+t),h=4*((this.renderData.height-e)*this.renderData.width+t),n.r=i[r+s[0]],n.g=i[r+s[1]],n.b=i[r+s[2]],n.a=i[r+s[3]],i[0+r]=i[h+s[0]],i[1+r]=i[h+s[1]],i[2+r]=i[h+s[2]],i[3+r]=i[h+s[3]],i[0+h]=n.r,i[1+h]=n.g,i[2+h]=n.b,i[3+h]=n.a}return i}getImageDataInQueue(e,t,i){e={width:Math.floor(e),height:Math.floor(t)};this.queue.push({params:e,event:i}),this.step()}async step(){var e,t;this.lock||(this.lock=!0,(t=this.queue.shift())?({params:t,event:e}=t,t=await this.getImageData(t.width,t.height),e.reply(null,t),this.lock=!1,this.step()):this.lock=!1)}async getImageData(t,i){if(!this.renderScene)return this.renderData;cce.Engine.repaintInEditMode();var e=this.renderScene.root,r=this.window;if(!r)return this.renderData;let h=[];if(e)for(const s of e.windows)0<s.cameras.length&&s===r&&(h=s.cameras);if(!h.length)return this.renderData;t&&i&&(t!==this.width||i!==this.height)&&this.resize(t,i,r);for(let e=0;e<h.length;e++){var n=h[e];n.width===this.width&&n.height===this.height||n.resize(t,i),n.update(!0)}return new Promise(e=>{cc.director.once(cc.Director.EVENT_AFTER_DRAW,()=>{e(this.copyFrameBuffer(this.window))})})}}exports.default=PreviewBuffer;