"use strict";var __importDefault=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(exports,"__esModule",{value:!0});const scene_1=__importDefault(require("../scene")),event_emitter_1=require("../../../utils/event-emitter"),cc_1=require("cc"),component_1=__importDefault(require("../component"));module.paths.push(AppModulePath);class PreviewBuffer extends event_emitter_1.EventEmitter{constructor(e,t,i=null){super(),this.device=cc.director.root.device,this.width=Math.floor(cc.director.root.mainWindow.width),this.height=Math.floor(cc.director.root.mainWindow.height),this.data=new Uint8Array(this.width*this.height*4),this.renderScene=null,this.scene=null,this.windows={},this.window=null,this.windowList=[],this.regions=[new cc_1.gfx.BufferTextureCopy],this.lock=!1,this._curActiveCameraComp=null,this.needInvertGFXApi=[cc_1.gfx.API.GLES2,cc_1.gfx.API.GLES3,cc_1.gfx.API.WEBGL,cc_1.gfx.API.WEBGL2],this.uint8ArrayPool=[],this.renderData={width:this.width,height:this.height,buffer:this.data},this._name=t,this._registerName=e,i?this.onLoadScene(i):(scene_1.default.on("open",this.onLoadScene.bind(this)),scene_1.default.on("reload",this.onLoadScene.bind(this))),this.regions[0].texExtent.width=this.width,this.regions[0].texExtent.height=this.height,this.createWindow(),this.queue=[]}resize(e,t,i=null){i||(i=this.window),i&&(e=Math.floor(e),t=Math.floor(t),this.renderData.width=this.width=e,this.renderData.height=this.height=t,this.regions[0].texExtent.width=e,this.regions[0].texExtent.height=t,i.resize(e,t),this.renderData.buffer=this.data=new Uint8Array(this.width*this.height*4))}clear(){isSceneNative||this.resize(0,0,this.window),this.resize(this.width,this.height,this.window)}queryWindowList(){const e=this.windows,t=[];if(!this.renderScene)return t;const i=this.renderScene.root.windows;this.windowList=[];for(let r=0;r<i.length;r++)for(const[n,s]of Object.entries(e)){const e=i[r];if(e===s){let s=e._title;const h=component_1.default.query(n);h&&h.node&&(s=h.node.name),t.push({index:r,uuid:n,name:s}),this.windowList.push({index:r,uuid:n,window:i[r],name:s})}}return t}createWindow(e=null){if(e&&this.windows[e])return void(this.window=this.windows[e]);const t=cc.director.root,i=new cc_1.gfx.RenderPassInfo([new cc_1.gfx.ColorAttachment(t.mainWindow.swapchain.colorTexture.format)],new cc_1.gfx.DepthStencilAttachment(t.mainWindow.swapchain.depthStencilTexture.format));i.colorAttachments[0].barrier=t.device.getGeneralBarrier(new cc_1.gfx.GeneralBarrierInfo(0,cc_1.gfx.AccessFlagBit.FRAGMENT_SHADER_READ_TEXTURE));const r=t.createWindow({title:this._name,width:this.width,height:this.height,renderPassInfo:i,isOffscreen:!0});this.window=r,e&&(this.windows[e]=r)}removeWindow(e){e&&this.windows[e]&&(cc.director.root.destroyWindow(this.windows[e]),delete this.windows[e])}onLoadScene(e){const t=cc.director.root;for(const[e,i]of Object.entries(this.windows))t.destroyWindow(i);this.windows={},this.scene=e,this.renderScene=e.renderScene,this.emit("loadScene",e)}switchCameras(e,t){e.isWindowSize=!1,e.isEnable=!0,e.changeTargetWindow(t),cc.director.root.tempWindow=t}changeCamera(e){let t=null,i=null;for(const r of this.windowList)if(r.index===e){t=r.uuid,i=r.window;break}if(!t||!i||i&&i===this.window&&i.cameras.length>0)return;const r=cce.Component.query(t);r?(r.camera.isWindowSize=!1,r.camera.changeTargetWindow(i),this.window=i,cc.director.root.tempWindow=i,this._curActiveCameraComp=r):console.error(`Component with UUID ${t} does not exist!`)}copyFrameBuffer(e=null){e||(e=this.window),this.device.copyTextureToBuffers(e.framebuffer.colorTextures[0],[new Uint8Array(this.renderData.buffer.buffer)],this.regions);const t=!this.needInvertGFXApi.includes(this.device.gfxAPI);if(t){const e=this.device.gfxAPI===cc_1.gfx.API.METAL,i={r:0,g:0,b:0,a:0};let r=this.uint8ArrayPool.find(e=>e.length===this.renderData.buffer.length);r||(r=new Uint8Array(this.renderData.buffer.length),this.uint8ArrayPool.unshift(r),this.uint8ArrayPool.length=3);for(let n=0;n<=this.renderData.width;n++)for(let s=0;s<=this.renderData.height;s++){const h=4*(s*this.renderData.width+n),o=4*((this.renderData.height-s)*this.renderData.width+n);i.r=this.renderData.buffer[e?h+2:h],i.g=this.renderData.buffer[h+1],i.b=this.renderData.buffer[e?h:h+2],i.a=this.renderData.buffer[h+3],r[t?o:h]=i.r,r[(t?o:h)+1]=i.g,r[(t?o:h)+2]=i.b,r[(t?o:h)+3]=i.a}this.renderData.buffer=r}return this.emit("getData",this,this.data),this.renderData}getImageDataInQueue(e,t,i,r){const n={index:e,width:Math.floor(t),height:Math.floor(i)};this.queue.push({params:n,event:r}),this.step()}async step(){if(this.lock)return;this.lock=!0;const e=this.queue.shift();if(!e)return void(this.lock=!1);const{params:t,event:i}=e,r=await this.getImageData(t.index,t.width,t.height);i.reply(null,r),this.lock=!1,this.step()}async getImageData(e,t,i){if(!this.renderScene)return this.renderData;cce.Engine.repaintInEditMode(),e=parseInt(e);const r=this.renderScene.root;let n=this.window;if(!isNaN(e)){if(!r.windows[e]||!n)return this.renderData}if(this.beforeDataHandle&&!this.beforeDataHandle(this,e))return this.renderData;let s=null;if(r)for(const e of r.windows)e.cameras.length>0&&e===n&&(s=e.cameras[0]);if(!s&&this._curActiveCameraComp){const e=this.windows[this._curActiveCameraComp.uuid];e&&(s=this._curActiveCameraComp.camera,this.switchCameras(s,e),this.window=n=e)}if(!s)return this.renderData;return t&&i&&(t!==this.width||i!==this.height)&&this.resize(t,i,n),s.width===this.width&&s.height===this.height||s.resize(t,i),s.update(!0),await new Promise(e=>{cc.director.once(cc.Director.EVENT_AFTER_DRAW,()=>{e(this.copyFrameBuffer(this.window))})})}}exports.default=PreviewBuffer;