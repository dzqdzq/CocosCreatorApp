"use strict";var __importDefault=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(exports,"__esModule",{value:!0});const scene_1=__importDefault(require("../scene")),event_emitter_1=require("../../../utils/event-emitter"),cc_1=require("cc");class PreviewBuffer extends event_emitter_1.EventEmitter{constructor(e,t,i=null){super(),this.device=cc.director.root.device,this.width=Math.floor(cc.director.root.mainWindow.width),this.height=Math.floor(cc.director.root.mainWindow.height),this.data=new Uint8Array(this.width*this.height*4),this.renderScene=null,this.scene=null,this.windows={},this.window=null,this.regions=[new cc_1.gfx.BufferTextureCopy],this.lock=!1,this.needInvertGFXApi=[cc_1.gfx.API.GLES2,cc_1.gfx.API.GLES3,cc_1.gfx.API.WEBGL,cc_1.gfx.API.WEBGL2],this.renderData={width:this.width,height:this.height,buffer:this.data},this._name=t,this._registerName=e,i?this.onLoadScene(i):(scene_1.default.on("open",this.onLoadScene.bind(this)),scene_1.default.on("reload",this.onLoadScene.bind(this))),this.regions[0].texExtent.width=this.width,this.regions[0].texExtent.height=this.height,this.createWindow(),this.queue=[]}resize(e,t,i=null){i||(i=this.window),i&&(e=Math.floor(e),t=Math.floor(t),this.renderData.width=this.width=e,this.renderData.height=this.height=t,this.regions[0].texExtent.width=e,this.regions[0].texExtent.height=t,i.resize(e,t),this.renderData.buffer=this.data=new Uint8Array(this.width*this.height*4))}clear(){isSceneNative||this.resize(0,0,this.window),this.resize(this.width,this.height,this.window)}createWindow(e=null){if(e&&this.windows[e])return void(this.window=this.windows[e]);const t=cc.director.root,i=new cc_1.gfx.RenderPassInfo([new cc_1.gfx.ColorAttachment(t.mainWindow.swapchain.colorTexture.format)],new cc_1.gfx.DepthStencilAttachment(t.mainWindow.swapchain.depthStencilTexture.format));i.colorAttachments[0].barrier=t.device.getGeneralBarrier(new cc_1.gfx.GeneralBarrierInfo(0,cc_1.gfx.AccessFlagBit.FRAGMENT_SHADER_READ_TEXTURE));const r=t.createWindow({title:this._name,width:this.width,height:this.height,renderPassInfo:i,isOffscreen:!0});this.window=r,e&&(this.windows[e]=r)}removeWindow(e){e&&this.windows[e]&&(cc.director.root.destroyWindow(this.windows[e]),this.windows[e]===this.window&&(this.window=null),delete this.windows[e])}onLoadScene(e){const t=cc.director.root;for(const[e,i]of Object.entries(this.windows))t.destroyWindow(i);this.windows={},this.scene=e,this.renderScene=e.renderScene,this.emit("loadScene",e)}switchCameras(e,t){t&&(e.isWindowSize=!1,e.isEnable=!0,e.changeTargetWindow(t),cc.director.root.tempWindow=t)}copyFrameBuffer(e=null){return e||(e=this.window),e&&e.framebuffer?(this.device.copyTextureToBuffers(e.framebuffer.colorTextures[0],[new Uint8Array(this.renderData.buffer.buffer)],this.regions),this.formatBuffer(this.renderData.buffer,!this.needInvertGFXApi.includes(this.device.gfxAPI),this.device.gfxAPI===cc_1.gfx.API.METAL),this.emit("getData",this,this.data),this.renderData):this.renderData}formatBuffer(e,t,i){if(!t)return e;let r,s;const h={r:0,g:0,b:0,a:0},n=i?PreviewBuffer.indexOfBGRA:PreviewBuffer.indexOfRGBA;for(let t=0;t<this.renderData.width;t++)for(let i=0;i<=this.renderData.height/2;i++)r=4*(i*this.renderData.width+t),s=4*((this.renderData.height-i)*this.renderData.width+t),h.r=e[r+n[0]],h.g=e[r+n[1]],h.b=e[r+n[2]],h.a=e[r+n[3]],e[r+0]=e[s+n[0]],e[r+1]=e[s+n[1]],e[r+2]=e[s+n[2]],e[r+3]=e[s+n[3]],e[s+0]=h.r,e[s+1]=h.g,e[s+2]=h.b,e[s+3]=h.a;return e}getImageDataInQueue(e,t,i){const r={width:Math.floor(e),height:Math.floor(t)};this.queue.push({params:r,event:i}),this.step()}async step(){if(this.lock)return;this.lock=!0;const e=this.queue.shift();if(!e)return void(this.lock=!1);const{params:t,event:i}=e,r=await this.getImageData(t.width,t.height);i.reply(null,r),this.lock=!1,this.step()}async getImageData(e,t){if(!this.renderScene)return this.renderData;cce.Engine.repaintInEditMode();const i=this.renderScene.root,r=this.window;if(!r)return this.renderData;let s=[];if(i)for(const e of i.windows)e.cameras.length>0&&e===r&&(s=e.cameras);if(!s.length)return this.renderData;e&&t&&(e!==this.width||t!==this.height)&&this.resize(e,t,r);for(let i=0;i<s.length;i++){const r=s[i];r.width===this.width&&r.height===this.height||r.resize(e,t),r.update(!0)}return await new Promise(e=>{cc.director.once(cc.Director.EVENT_AFTER_DRAW,()=>{e(this.copyFrameBuffer(this.window))})})}}PreviewBuffer.indexOfRGBA=[0,1,2,3],PreviewBuffer.indexOfBGRA=[2,1,0,3],exports.default=PreviewBuffer;