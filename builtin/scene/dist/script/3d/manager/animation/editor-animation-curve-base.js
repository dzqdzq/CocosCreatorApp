"use strict";var __createBinding=this&&this.__createBinding||(Object.create?function(e,t,r,a){void 0===a&&(a=r),Object.defineProperty(e,a,{enumerable:!0,get:function(){return t[r]}})}:function(e,t,r,a){void 0===a&&(a=r),e[a]=t[r]}),__setModuleDefault=this&&this.__setModuleDefault||(Object.create?function(e,t){Object.defineProperty(e,"default",{enumerable:!0,value:t})}:function(e,t){e.default=t}),__importStar=this&&this.__importStar||function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)"default"!==r&&Object.prototype.hasOwnProperty.call(e,r)&&__createBinding(t,e,r);return __setModuleDefault(t,e),t};Object.defineProperty(exports,"__esModule",{value:!0});const cc_1=require("cc"),dumpEncode=__importStar(require("../../../../utils/dump/encode")),utils_1=require("./utils"),uniform_handler_1=require("./uniform-handler");class EditorAnimationCurveBase{constructor(){this._keyframeData=[],this._isDirty=!1}set node(e){this._node=e}get dirty(){return this._isDirty}set dirty(e){this._isDirty=e}get curveInfo(){return this._curveInfo}set curveInfo(e){this._curveInfo=e}get keyframeData(){return this._keyframeData}set keyframeData(e){this._keyframeData=e}get nodePath(){return this._curveInfo.nodePath}get propKey(){return this._curveInfo.propKey}get propData(){return{combinedType:this._curveInfo.combinedType,type:this._curveInfo.type,targetPaths:this._curveInfo.targetPaths,valueAdapter:this._curveInfo.valueAdapter,commonTarget:this._curveInfo.commonTarget}}getClipSample(){return this._clipData.sharedData.sample}getClipDuration(){return this._clipData.sharedData.duration}initFromCurve(e,t){var r;this._keyframeData=[];const a=utils_1.utils.getCurveInfo(this._node,e,t);if(this.curveInfo=a,t.data.keys<0)return;const i=e.keysPool[t.data.keys],n=t.data;if(!n)return;let u=n.values;uniform_handler_1.uniformHandler.isUniformPartCurve(a.valueAdapter)&&"cc.Color"===(null===(r=a.combinedType)||void 0===r?void 0:r.value)&&(u=uniform_handler_1.uniformHandler.colorFloatToInt(u));for(let t=0;t<i.length;t++){const r=i[t],a={frame:Math.round(r*e.sharedData.sample),value:u[t]};n.easingMethods&&n.easingMethods[t]&&(a.easingMethod=n.easingMethods[t]),this._keyframeData.push(a)}}async getPropValueAtFrame(e){var t,r;let a=null;const i=this.propData;if(0===this._keyframeData.length){let e=await utils_1.utils.getValueFrom(this._node,i);null!==e&&void 0!==e||(e=utils_1.utils.getDefaultValue(null===(t=i.type)||void 0===t?void 0:t.value)),null!==e&&void 0!==e&&(a=dumpEncode.encodeObject(e,{default:null}))}else{const t=this.getClipSample(),n=this.getClipDuration(),u=[],o=[];this._keyframeData.forEach(e=>{o.push(e.frame),u.push(e.value)});const s=new cc_1.AnimCurve({values:u},n),l=o.map(e=>e/t/n),d=new cc_1.RatioSampler(l);let c=e/t/n;c<0&&(c=0),c>1&&(c=1);let _=cc_1.sampleAnimationCurve(s,d,c);null!==_&&void 0!==_||(_=utils_1.utils.getDefaultValue(null===(r=i.type)||void 0===r?void 0:r.value)),null!==_&&void 0!==_&&(a=dumpEncode.encodeObject(_,{default:null}))}return a}async decodeDump(e){this._curveInfo.nodePath=e.nodePath,this._curveInfo.propKey=e.key,this._curveInfo.type=e.type,this._keyframeData=await utils_1.utils.getKeyframeDataFromDump(e.keyframes)}}exports.default=EditorAnimationCurveBase;