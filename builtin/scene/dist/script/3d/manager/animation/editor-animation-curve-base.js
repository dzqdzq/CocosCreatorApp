"use strict";Object.defineProperty(exports,"__esModule",{value:!0});const cc_1=require("cc"),type_defines_1=require("./type-defines"),utils_1=require("./utils");class EditorAnimationCurveBase{constructor(){this._keyframeData=[],this._isDirty=!1,this._preExtrap=cc_1.ExtrapolationMode.CLAMP,this._postExtrap=cc_1.ExtrapolationMode.CLAMP}set node(e){this._node=e}get dirty(){return this._isDirty}set dirty(e){this._isDirty=e}get curveInfo(){return this._curveInfo}set curveInfo(e){this._curveInfo=e}get keyframeData(){return this._keyframeData}set keyframeData(e){this._keyframeData=e}get nodePath(){return this._curveInfo.nodePath}get propKey(){return this._curveInfo.propKey}get propData(){return{combinedType:this._curveInfo.combinedType,type:this._curveInfo.type,targetPaths:this._curveInfo.targetPaths,valueAdapter:this._curveInfo.valueAdapter,commonTarget:this._curveInfo.commonTarget}}get preExtrap(){return this._preExtrap}set preExtrap(e){this._preExtrap=e}get postExtrap(){return this._postExtrap}set postExtrap(e){this._postExtrap=e}getClipSample(){return this._clipData.sharedData.sample}getClipDuration(){return this._clipData.sharedData.duration}initFromCurve(e,t){if(this._keyframeData=[],this.curveInfo=e,!t)return;const a=[...t.times()];if(a.length<=0)return;const r=[...t.values()];for(let e=0;e<a.length;e++){const n=a[e],i={frame:Math.round(n*this._clipData.sharedData.sample),value:0};if(t instanceof cc_1.RealCurve){const t=r[e];i.value=t.value,i.interpMode=t.interpolationMode,i.inTangent=t.leftTangent,i.inTangentWeight=t.leftTangentWeight,i.outTangent=t.rightTangent,i.outTangentWeight=t.rightTangentWeight,i.tangentWeightMode=t.tangentWeightMode,i.easingMethod=t.easingMethod,t[cc_1.editorExtrasTag]&&(i.broken=t[cc_1.editorExtrasTag].broken,i.tangentMode=t[cc_1.editorExtrasTag].tangentMode)}else if(t instanceof cc_1.QuatCurve){const t=r[e];i.value=t.value}else{const t=r[e];i.value=t}this._keyframeData.push(i)}(t instanceof cc_1.RealCurve||t instanceof cc_1.QuatCurve)&&(this.preExtrap=t.preExtrapolation,this.postExtrap=t.postExtrapolation)}async decodeDump(e){this._curveInfo.nodePath=e.nodePath,this._curveInfo.propKey=e.key,this._curveInfo.type=e.type,this._keyframeData=await utils_1.utils.getKeyframeDataFromDump(e.keyframes)}autoSetTangents(){var e;if("Number"===(null===(e=this._curveInfo.type)||void 0===e?void 0:e.value))for(let e=0;e<this._keyframeData.length;e++){const t=this._keyframeData[e];let a=t.inTangent,r=t.outTangent,n=t,i=t,o=t,s=!1;if(0===e?e<this._keyframeData.length-1&&t.tangentMode===type_defines_1.TangentMode.AUTO&&(r=0,t.interpMode===cc_1.RealInterpolationMode.CUBIC&&(i=o=this._keyframeData[e+1],s=!0)):e<this._keyframeData.length-1?(n=this._keyframeData[e-1],t.interpMode===cc_1.RealInterpolationMode.CUBIC&&t.tangentMode===type_defines_1.TangentMode.AUTO?(o=this._keyframeData[e+1],s=!0):n.interpMode!==cc_1.RealInterpolationMode.CONSTANT&&t.interpMode!==cc_1.RealInterpolationMode.CONSTANT||(r=0,n.interpMode!==cc_1.RealInterpolationMode.CUBIC&&(a=0))):t.interpMode===cc_1.RealInterpolationMode.CUBIC&&t.tangentMode===type_defines_1.TangentMode.AUTO&&(a=0,this._keyframeData.length>1&&(n=this._keyframeData[e-1],s=!0)),s){const e=this.getClipSample(),t=this.calculateCurveTangent(n.frame/e,n.value,i.frame/e,i.value,o.frame/e,o.value);r=a=null!==t&&void 0!==t?t:a}}}calculateCurveTangent(e,t,a,r,n,i){let o;if(utils_1.utils.isNumber(r)){o=r-t+(i-r),o/=n-e}return o}}exports.default=EditorAnimationCurveBase;