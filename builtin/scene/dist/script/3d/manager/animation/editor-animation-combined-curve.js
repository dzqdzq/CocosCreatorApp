"use strict";var __createBinding=this&&this.__createBinding||(Object.create?function(t,e,a,r){void 0===r&&(r=a);var i=Object.getOwnPropertyDescriptor(e,a);i&&("get"in i?e.__esModule:!i.writable&&!i.configurable)||(i={enumerable:!0,get:function(){return e[a]}}),Object.defineProperty(t,r,i)}:function(t,e,a,r){void 0===r&&(r=a),t[r]=e[a]}),__setModuleDefault=this&&this.__setModuleDefault||(Object.create?function(t,e){Object.defineProperty(t,"default",{enumerable:!0,value:e})}:function(t,e){t.default=e}),__importStar=this&&this.__importStar||function(t){if(t&&t.__esModule)return t;var e={};if(null!=t)for(var a in t)"default"!==a&&Object.prototype.hasOwnProperty.call(t,a)&&__createBinding(e,t,a);return __setModuleDefault(e,t),e},__importDefault=this&&this.__importDefault||function(t){return t&&t.__esModule?t:{default:t}};Object.defineProperty(exports,"__esModule",{value:!0});const cc_1=require("cc"),editor_animation_curve_1=__importDefault(require("./editor-animation-curve")),editor_animation_curve_base_1=__importDefault(require("./editor-animation-curve-base")),utils_1=require("./utils"),uniform_handler_1=require("./uniform-handler"),dumpEncode=__importStar(require("../../../../utils/dump/encode"));class EditorAnimationCombinedCurve extends editor_animation_curve_base_1.default{constructor(t,e){super(),this.canMerge=!0,this._partEditorAnimCurves=[],this._maxPartNumber=0,this._node=t,this._clipData=e}get maxPartNumber(){return this._maxPartNumber}set maxPartNumber(t){this._maxPartNumber=t}get curveInfo(){return this._curveInfo}set curveInfo(t){super.curveInfo=t}updateType(t){t&&(this._curveInfo.type=t,this._partEditorAnimCurves.forEach(e=>{e.curveInfo.combinedType=t}))}async getDumpData(){var t;await this.updateCurveData();const e=utils_1.utils.dumpKeyframeData(this._keyframeData);let a=!1;if(this._partEditorAnimCurves&&this._partEditorAnimCurves.length>0){const e=null===(t=this._partEditorAnimCurves[0].curveInfo.type)||void 0===t?void 0:t.value;a=utils_1.utils.isTypeSupportCurve(e)}return{nodePath:this._curveInfo.nodePath,keyframes:e,displayName:this._curveInfo.displayName,key:this._curveInfo.propKey,type:this._curveInfo.type,isCurveSupport:a}}getClipSample(){return this._clipData.sharedData.sample}getClipDuration(){return this._clipData.sharedData.duration}changeNodePath(t){const e=this._curveInfo.targetPaths;if(e.length>0)if(e.isHierarchyAt(0))if("/"===t)this._curveInfo.targetPaths=this._curveInfo.targetPaths.slice(1);else{const e=t.substr(1);this._curveInfo.targetPaths=(new cc_1.animation.TrackPath).toHierarchy(e).append(this._curveInfo.targetPaths.slice(1))}else if("/"!==t){const e=t.substr(1);this._curveInfo.targetPaths=(new cc_1.animation.TrackPath).toHierarchy(e).append(this._curveInfo.targetPaths)}this._curveInfo.nodePath=utils_1.utils.getNodePath(this._curveInfo.targetPaths)}initFromTrack(t,e){var a;this._curveInfo=t,this._partEditorAnimCurves=[];const r=null===(a=this._curveInfo.type)||void 0===a?void 0:a.value,i=utils_1.utils.getPartsOfType(r);if(!i)return;let n=null;const s=uniform_handler_1.uniformHandler.isUniformCurve(this._curveInfo.valueAdapter);s&&(n=uniform_handler_1.uniformHandler.getValueToArrayIndexMapByType(r)),this.maxPartNumber=i.length,i.forEach(t=>{const e=this.curveInfo.targetPaths.slice().toProperty(t),a={nodePath:this._curveInfo.nodePath,propKey:this._curveInfo.propKey+"."+t,combinedType:this._curveInfo.type,type:{value:"Number"},targetPaths:e,partName:t,displayName:this._curveInfo.displayName+"."+t,propName:this._curveInfo.propName,compName:this._curveInfo.compName};if(s){a.targetPaths=this._curveInfo.targetPaths;const e=utils_1.utils.cloneCCClass(this._curveInfo.valueAdapter);if(n){const a=n[t];e.channelIndex=a}a.valueAdapter=e}const r=new editor_animation_curve_1.default(this._node,this._clipData);r.curveInfo=a,r.parentCurve=this,this._partEditorAnimCurves.push(r)});const o=e.channels();for(let t=0;t<this._partEditorAnimCurves.length;t++)if(t<o.length){const e=this._partEditorAnimCurves[t],a=o[t].curve;if(e.partName&&a){const t=[];for(const[e,r]of a.keyframes())t.push({frame:Math.round(e*this._clipData.sharedData.sample),value:r.value,inTangent:r.leftTangent,inTangentWeight:r.leftTangentWeight,outTangent:r.rightTangent,outTangentWeight:r.rightTangentWeight,interpMode:r.interpolationMode,tangentWeightMode:r.tangentWeightMode,easingMethod:r.easingMethod});e.keyframeData=t}}this.updateCurveData()}async updateCurveData(){let t=new Map;await this.iteratorPartAnimCurves(async(e,a)=>{const r=e.keyframeData;if(r)for(let e=0;e<r.length;e++){const i=r[e];if(!t.has(i.frame)){let e=await utils_1.utils.getValueFrom(this._node,this.propData);void 0===e&&this.propData.type&&(e=utils_1.utils.getDefaultValue(this.propData.type.value));const a={value:e,keyNumber:0,isEasingMethodSame:!0};t.set(i.frame,a)}const n=t.get(i.frame);n&&(n.keyNumber++,void 0!==n.value&&null!==n.value&&(n.value[a]=i.value))}}),t=new Map([...t.entries()].sort((t,e)=>t[0]-e[0])),this._keyframeData=[],t.forEach((t,e)=>{const a={frame:e,value:t.value};this._keyframeData.push(a)}),this.canMerge=!0;const e=Array.from(t.values());for(let t=0;t<e.length;t++){const a=e[t];if(a.keyNumber!==this.maxPartNumber||!a.isEasingMethodSame){this.canMerge=!1;break}}this._partEditorAnimCurves.forEach(t=>{t.isActive=!this.canMerge})}separateDataIntoParts(){var t;this._partEditorAnimCurves=[];const e=null===(t=this._curveInfo.type)||void 0===t?void 0:t.value,a=utils_1.utils.getPartsOfType(e);if(!a)return;let r=null;const i=uniform_handler_1.uniformHandler.isUniformCurve(this._curveInfo.valueAdapter);i&&(r=uniform_handler_1.uniformHandler.getValueToArrayIndexMapByType(e)),this.maxPartNumber=a.length,a.forEach(t=>{const e=this.curveInfo.targetPaths.slice().toProperty(t),a={nodePath:this._curveInfo.nodePath,propKey:this._curveInfo.propKey+"."+t,combinedType:this._curveInfo.type,type:{value:"Number"},targetPaths:e,partName:t,displayName:this._curveInfo.displayName+"."+t,propName:this._curveInfo.propName,compName:this._curveInfo.compName};if(i){a.targetPaths=this._curveInfo.targetPaths;const e=utils_1.utils.cloneCCClass(this._curveInfo.valueAdapter);if(r){const a=r[t];e.channelIndex=a}a.valueAdapter=e}const n=new editor_animation_curve_1.default(this._node,this._clipData);n.curveInfo=a,n.parentCurve=this,this._partEditorAnimCurves.push(n)});for(let t=0;t<this._partEditorAnimCurves.length;t++){const e=this._partEditorAnimCurves[t],a=e.partName;if(a){const t=[];for(let e=0;e<this._keyframeData.length;e++){const r=this._keyframeData[e],i=r.value;let n=0;void 0!==i&&(n=i[a]),t.push({frame:r.frame,value:n})}e.keyframeData=t}}}addPartEditorAnimCurve(t){this._partEditorAnimCurves.push(t),this.maxPartNumber<this._partEditorAnimCurves.length&&(this.maxPartNumber=this._partEditorAnimCurves.length)}getPartEditorAnimCurves(){return this._partEditorAnimCurves}async iteratorPartAnimCurves(t){for(let e=0;e<this._partEditorAnimCurves.length;e++){const a=this._partEditorAnimCurves[e],r=a.partName;r&&await t(a,r)}}hasKey(t){let e=!1;return this._partEditorAnimCurves.forEach(a=>{a.hasKey(t)&&(e=!0)}),e}async createKey(t=0,e){let a=!0;return await this.iteratorPartAnimCurves(async(r,i)=>{let n;e&&e.newValue&&(n={newValue:e.newValue[i]}),await r.createKey(t,n)||(a=!1)}),this._isDirty=!0,a}async moveKeys(t,e){let a=!0;return this._partEditorAnimCurves.forEach(r=>{const i=r.getValidKeys(t),n=[];i&&i.length>0&&(i.forEach(a=>{const r=t.indexOf(a);n.push(e[r])}),r.moveKeys(i,n)||(a=!1))}),this._isDirty=!0,a}async removeKey(t){let e=!0;return this._partEditorAnimCurves.forEach(a=>{const r=a.getValidKeys(t);r&&r.length>0&&(a.removeKey(r)||(e=!1))}),this._isDirty=!0,e}async updateKey(t){let e=!0;return await this.iteratorPartAnimCurves(async a=>{const r=a.getValidKeys(t);r&&r.length>0&&(await a.updateKey(r)||(e=!1))}),this._isDirty=!0,e}async copyKeysTo(t,e){let a=!0;return await this.iteratorPartAnimCurves(async r=>{const i=r.getValidKeys(t);i&&i.length>0&&(await r.copyKeysTo(i,e)||(a=!1))}),this._isDirty=!0,a}async spacingKeys(t,e){let a=!0;return this._partEditorAnimCurves.forEach(r=>{const i=r.getValidKeys(t);i&&i.length>0&&(r.spacingKeys(i,e)||(a=!1))}),this._isDirty=!0,a}async clearKeys(){let t=!0;return this._partEditorAnimCurves.forEach(e=>{e.clearKeys()||(t=!1)}),this._isDirty=!0,t}async modifyCurveOfKey(t,e){let a=!0;return this._partEditorAnimCurves.forEach(r=>{r.hasKey(t)&&(r.modifyCurveOfKey(t,e)||(a=!1))}),this._isDirty=!0,a}async getPropValueAtFrame(t){var e,a,r;let i=null;const n=this.propData;if(0===this._keyframeData.length){let t=await utils_1.utils.getValueFrom(this._node,n);null!==t&&void 0!==t||(t=utils_1.utils.getDefaultValue(null===(e=n.type)||void 0===e?void 0:e.value)),null!==t&&void 0!==t&&(i=dumpEncode.encodeObject(t,{default:void 0}))}else{const e=this.getClipSample();let s=await utils_1.utils.getValueFrom(this._node,n);null!==s&&void 0!==s||(s=utils_1.utils.getDefaultValue(null===(a=n.type)||void 0===a?void 0:a.value)),await this.iteratorPartAnimCurves(async(a,r)=>{const i=a.keyframeData,n=new cc_1.RealCurve;n.assignSorted(i.map(t=>[t.frame/e,{value:t.value,interpolationMode:t.interpMode,leftTangent:t.inTangent,rightTangent:t.outTangent,leftTangentWeight:t.inTangentWeight,rightTangentWeight:t.outTangentWeight,tangentWeightMode:t.tangentWeightMode}])),s[r]=n.evaluate(t/e)}),null!==s&&void 0!==s||(s=utils_1.utils.getDefaultValue(null===(r=n.type)||void 0===r?void 0:r.value)),null!==s&&void 0!==s&&(i=dumpEncode.encodeObject(s,{default:void 0}))}return i}}exports.default=EditorAnimationCombinedCurve;