"use strict";var __importDefault=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(exports,"__esModule",{value:!0});const cc_1=require("cc"),editor_animation_curve_base_1=__importDefault(require("./editor-animation-curve-base")),utils_1=require("./utils");class EditorAnimationCurve extends editor_animation_curve_base_1.default{constructor(e,t){super(),this._parentCurve=null,this.isActive=!0,this._node=e,this._clipData=t}get parentCurve(){return this._parentCurve}set parentCurve(e){this._parentCurve=e}get isPartCurve(){return this._parentCurve}get partName(){return this._curveInfo.partName}get targetPaths(){return this._curveInfo.targetPaths}get combinedPropKey(){const e=this._curveInfo.propKey.lastIndexOf(".");return this._curveInfo.propKey.substring(0,e)}get combinedCurveKeyData(){return null}get combinedDisplayName(){const e=this._curveInfo.displayName.lastIndexOf(".");return this._curveInfo.displayName.substring(0,e)}get displayName(){let e=this._curveInfo.displayName;if(this.isPartCurve){let t=this._curveInfo.displayName.lastIndexOf(".");const a=this._curveInfo.displayName.substring(0,t),r=this._curveInfo.displayName.substring(t+1);let s="";(t=a.lastIndexOf("."))>=0&&(s=a.substring(t+1)+"."),e=s+r}return e}async getDumpData(){const e=utils_1.utils.dumpKeyframeData(this._keyframeData);return{nodePath:this._curveInfo.nodePath,keyframes:e,displayName:this.displayName,key:this._curveInfo.propKey,type:this._curveInfo.type,preExtrap:this.preExtrap,postExtrap:this.postExtrap}}getCompName(){return this._curveInfo.compName}getPropName(){return this._curveInfo.propName}changeNodePath(e){let t=null;if((t=this._curveInfo.targetPaths)&&t.length>0)if(t.isHierarchyAt(0))if("/"===e)this._curveInfo.targetPaths=t.slice(1);else{const a=e.substr(1);this._curveInfo.targetPaths=(new cc_1.animation.TrackPath).toHierarchy(a).append(t.slice(1))}else if("/"!==e){const a=e.substr(1);this._curveInfo.targetPaths=(new cc_1.animation.TrackPath).toHierarchy(a).append(t)}this._curveInfo.nodePath=utils_1.utils.getNodePath(this._curveInfo.targetPaths)}queryKeyIndex(e){if(!this._keyframeData)return-1;for(let t=0;t<this._keyframeData.length;t++){if(this._keyframeData[t].frame===e)return t}return-1}queryKeyframe(e){if(!this._keyframeData)return null;for(let t=0;t<this._keyframeData.length;t++){const a=this._keyframeData[t];if(a.frame===e)return a}return null}getValidKeys(e){if(!this._keyframeData)return null;const t=[];for(let a=0;a<this._keyframeData.length;a++){const r=this._keyframeData[a].frame;e.includes(r)&&t.push(r)}return t}hasKey(e){return null!==this.queryKeyframe(e)}async createKey(e=0,t){const a=this.propData,r=await utils_1.utils.getValueFrom(this._node,a,t),s=this.queryKeyframe(e);if(s)return s.value=r,t&&utils_1.utils.copyCurveData(t,s),!0;let i=0;for(i=0;i<this._keyframeData.length&&!(this._keyframeData[i].frame>e);i++);const n={frame:e,value:r,inTangent:0,inTangentWeight:1,outTangent:0,outTangentWeight:1,interpMode:cc_1.RealInterpolationMode.LINEAR,tangentWeightMode:cc_1.TangentWeightMode.NONE,tangentMode:0};return t&&utils_1.utils.copyCurveData(t,n),this._keyframeData.splice(i,0,n),this._isDirty=!0,!0}async moveKeys(e,t){if(!this._keyframeData)return!1;const a=[];for(let t=0;t<e.length;t++){const r=e[t],s=this.queryKeyIndex(r);if(s<0)return!1;a.push(this._keyframeData[s]),this._keyframeData.splice(s,1)}for(let e=0;e<a.length;e++){const r=a[e];let s=r.frame+t[e];s<0&&(s=0);let i=0,n=!1,u=!1;if(this._keyframeData.length>0){for(let e=0;e<this._keyframeData.length;e++){const t=this._keyframeData[e].frame;if(t>=s){i=e,n=!0,t===s&&(u=!0);break}}n||(s<=this._keyframeData[0].frame?i=0:s>this._keyframeData[this._keyframeData.length-1].frame&&(i=this._keyframeData.length))}const h=u?1:0,o={frame:s,value:r.value};utils_1.utils.copyCurveData(r,o),this._keyframeData.splice(i,h,o)}return this._isDirty=!0,!0}async removeKey(e){return e.forEach(e=>{const t=this.queryKeyIndex(e);t<0||this._keyframeData.splice(t,1)}),this._isDirty=!0,!0}async updateKey(e){const t=this.propData;for(let a=0;a<e.length;a++){const r=e[a],s=this.queryKeyframe(r);if(!s)return!1;const i=await utils_1.utils.getValueFrom(this._node,t,null);s.value=i}return this._isDirty=!0,!0}async copyKeysTo(e,t){for(let a=0;a<e.length;a++){const r=e[a],s=this.queryKeyframe(r);if(s){const a={newValue:s.value};utils_1.utils.copyCurveData(s,a),await this.createKey(t+r-e[0],a)}}return this._isDirty=!0,!0}async spacingKeys(e,t){if(e.sort((e,t)=>e-t),e.length>1){const a=e[0],r=[],s=[];for(let i=1;i<e.length;i++)r.push(e[i]),s.push(a+i*t-e[i]);return this.moveKeys(r,s),this._isDirty=!0,!0}return!1}async clearKeys(){return this._keyframeData=[],!0}async modifyCurveOfKey(e,t){const a=this.queryKeyframe(e);return!!a&&(utils_1.utils.copyCurveData(t,a),this._isDirty=!0,!0)}getCurveDuration(){let e=0;if(this._keyframeData&&this._keyframeData.length>0){const t=this._keyframeData[this._keyframeData.length-1].frame,a=this.getCompName(),r=this.getPropName(),s=this.getClipSample();e=a===cc_1.js.getClassName(cc_1.Sprite)&&"spriteFrame"===r?(t+1)/s:t/s}return e}}exports.default=EditorAnimationCurve;