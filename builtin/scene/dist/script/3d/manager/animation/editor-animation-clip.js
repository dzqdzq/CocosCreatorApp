"use strict";var __importDefault=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(exports,"__esModule",{value:!0});const cc_1=require("cc"),editor_animation_curve_1=require("./editor-animation-curve"),editor_animation_combined_curve_1=__importDefault(require("./editor-animation-combined-curve")),editor_animation_aux_curve_1=require("./editor-animation-aux-curve"),utils_1=require("./utils"),uniform_handler_1=require("./uniform-handler"),embedded_player_1=require("cc/editor/embedded-player"),asset_1=require("../../../utils/asset"),CombinedType=["cc.Vec2","cc.Vec3","cc.Vec4","cc.Color","cc.Size"];class EditorAnimationClip{constructor(e,t,a){this._initPropDataMap=new Map,this._createdCurveMap=new Map,this._editorCurves=[],this._editEmbeddedPlayerMap={},this._createdAuxCurveMap=new Map,this._auxCurves=new Set,this._rootNode=e,this._clipUuid=t,this._animComp=e.getComponent(cc_1.Animation),this._animState=a,this.init()}refreshData(e,t){this._rootNode=e,this._clipUuid=t,this._animComp=e.getComponent(cc_1.Animation);for(let t=0;t<this._editorCurves.length;t++)this._editorCurves[t].node=e;for(const t of this._auxCurves)t.node=e}init(){const e=this._getAnimState();if(!e)return;const t=e.clip;if(this._editorSharedClipData={sample:t.sample,duration:t.duration},t.upgradeUntypedTracks((e,t)=>{let a=null;if(t){if(t instanceof cc_1.animation.UniformProxyFactory){const r=e.trace(this._rootNode);a=uniform_handler_1.uniformHandler.getUniformDumpData(r,t).type}}else{const t=e.trace(this._rootNode,0,e.length-1),r=e.length-1,i=e.isPropertyAt(r)?e.parsePropertyAt(r):e.isElementAt(r)?e.parseElementAt(r):null;if(null===i||"number"==typeof i)return null;if(cc_1.CCClass._isCCClass(t.constructor)){const e=cc_1.CCClass.attr(t.constructor,i);a=t instanceof cc_1.Node&&("position"===i||"eulerAngles"===i||"scale"===i)?"cc.Vec3":e.type}else a=typeof t[i]}return utils_1.utils.getTrackTypeBy(a)}),t[cc_1.editorExtrasTag]&&t[cc_1.editorExtrasTag].embeddedPlayerGroups||(t[cc_1.editorExtrasTag]={embeddedPlayerGroups:[]}),!t.tracks)return void console.warn("tracks is null");const a=this.generateClipData(t);for(const e of t.tracks){const t=utils_1.utils.getCurveInfoByTrack(this._rootNode,e);if(e instanceof cc_1.animation.RealTrack||e instanceof cc_1.animation.QuatTrack||e instanceof cc_1.animation.ObjectTrack){const r=e.channel.curve,i=new editor_animation_curve_1.EditorAnimationCurve(this._rootNode,a);i.initFromCurve(t,r),this.addEditorCurve(i)}else e instanceof cc_1.animation.VectorTrack||e instanceof cc_1.animation.ColorTrack||e instanceof cc_1.animation.SizeTrack?this.createCombinedAndPartsAnimCurve(a,t,e):console.warn("unknown track:",e)}const r=t[embedded_player_1.getEmbeddedPlayersTag]();this._editEmbeddedPlayerMap={};for(const e of r){const a={begin:Math.round(e.begin*t.sample),end:Math.round(e.end*t.sample),reconciledSpeed:e.reconciledSpeed,group:e[cc_1.editorExtrasTag]&&e[cc_1.editorExtrasTag].group,displayName:e[cc_1.editorExtrasTag]&&e[cc_1.editorExtrasTag].displayName,playable:utils_1.utils.getPlayableInfo(e.playable)||void 0},r=utils_1.utils.calcEmbeddedPlayerKey(a);this._editEmbeddedPlayerMap[r]=a}this._initAuxCurves(!0)}get rootNode(){return this._rootNode}get clipUUID(){return this._clipUuid}generateClipData(e){return{sharedData:this._editorSharedClipData}}createCombinedAndPartsAnimCurve(e,t,a){const r=new editor_animation_combined_curve_1.default(this._rootNode,e);r.initFromTrack(t,a),this.addEditorCurve(r),r.getPartEditorAnimCurves().forEach(e=>{this.addEditorCurve(e)})}addInitPropDataMap(e,t){const a=new Map;t.forEach(e=>{a.set(e.key,e)}),this._initPropDataMap.set(e,a)}getInitPropData(e,t){if(!this._initPropDataMap.has(e)){let t=this._rootNode;"/"!==e&&(t=t.getChildByPath(e.substr(1)));const a=utils_1.utils.getAnimableProperties(t,t!==this._rootNode);a&&this.addInitPropDataMap(e,a)}const a=this._initPropDataMap.get(e);return a?a.get(t):null}getCreatedCurve(e,t){let a=null;const r=this._createdCurveMap.get(e);return r&&(a=r.get(t)),a}getCreatedAuxCurve(e,t){const a=this._createdAuxCurveMap.get(e);if(!0===t&&void 0===a)throw new Error(`Cannot find auxiliary curve named "${e}"`);return a}addEditorCurve(e){this._editorCurves.includes(e)||(this._editorCurves.push(e),this.addToCreatedCurveMap(e))}addAuxCurve(e){if(!this._auxCurves.has(e)){this._auxCurves.add(e);const t=e.curveInfo.displayName,a=this._createdAuxCurveMap.get(t);void 0!==a&&this._auxCurves.delete(a),this.addToAuxCurveMap(e)}}addToCreatedCurveMap(e){let t=this._createdCurveMap.get(e.nodePath);t||(t=new Map),t.set(e.propKey,e),this._createdCurveMap.set(e.nodePath,t)}addToAuxCurveMap(e){const t=e.curveInfo.displayName;Editor.App.dev&&this._createdAuxCurveMap.has(t)&&console.warn(`aux curve "${t}" already exists and will be overwritten.`),this._createdAuxCurveMap.set(t,e)}rebuildCreatedCurveMap(){this._createdCurveMap.clear(),this._editorCurves.forEach(e=>{this.addToCreatedCurveMap(e)}),this._createdAuxCurveMap.clear();for(const e of this._auxCurves)this.addToAuxCurveMap(e)}async getDumpData(){const e=this._getAnimState();if(!e)return null;const t=e.clip,a=[];for(let e=0;e<this._editorCurves.length;e++){const t=this._editorCurves[e],r=await t.getDumpData();t instanceof editor_animation_combined_curve_1.default?(a.push(r),await t.iteratorPartAnimCurves(async(e,t)=>{const i=await e.getDumpData();i.parentPropKey=r.key,r.partKeys?r.partKeys.push(i.key):r.partKeys=[i.key],a.push(i)})):t instanceof editor_animation_curve_1.EditorAnimationCurve&&(t.isPartCurve||a.push(r))}const r=await this.getAuxiliaryCurves();let i=!1;return this._animComp instanceof cc_1.SkeletalAnimation&&(i=this._animComp.useBakedAnimation),{name:t.name,duration:t.duration,sample:t.sample,speed:t.speed,wrapMode:t.wrapMode,curves:a,events:t.events.map(e=>({frame:Math.round(e.frame*t.sample),func:e.func,params:e.params})),embeddedPlayers:Array.from(t[embedded_player_1.getEmbeddedPlayersTag]()).map(e=>({begin:Math.round(e.begin*t.sample),end:Math.round(e.end*t.sample),reconciledSpeed:e.reconciledSpeed,group:e[cc_1.editorExtrasTag]&&e[cc_1.editorExtrasTag].group,displayName:e[cc_1.editorExtrasTag]&&e[cc_1.editorExtrasTag].displayName,playable:utils_1.utils.getPlayableInfo(e.playable)||void 0})),embeddedPlayerGroups:t[cc_1.editorExtrasTag].embeddedPlayerGroups,time:e.time||0,isLock:!1,auxiliaryCurves:r,isSkeleton:(0,utils_1.isSkeletonClip)(this.clipUUID),useBakedAnimation:i}}recalculateDuration(){if(!this._getAnimState()||this._animComp instanceof cc_1.SkeletalAnimation)return;let e=0;this._editorCurves.forEach(t=>{t instanceof editor_animation_curve_1.EditorAnimationCurve&&(e=Math.max(t.getCurveDuration(),e))}),this._editorSharedClipData.duration=e}async applyEditorCurvesToClip(){const e=this._getAnimState();if(!e)return;const t=e.clip;t.sample=this._editorSharedClipData.sample,t.duration=this._editorSharedClipData.duration;const a=[];try{for(let e=0;e<this._editorCurves.length;e++){const r=this._editorCurves[e];if(r instanceof editor_animation_curve_1.EditorAnimationCurve){if(!r.isPartCurve){const e=this.createTrack(r,t.sample);e&&a.push(e)}}else if(r instanceof editor_animation_combined_curve_1.default){await r.updateCurveData();const e=this.createTrack(r,t.sample);e&&a.push(e)}}}catch(e){return void console.error(e)}t.clearTracks(),a.forEach(e=>{t.addTrack(e)})}applyAuxCurvesToClip(){const e=this._getAnimState();if(!e)return;const t=e.clip;for(const e of this._auxCurves){const a=t.getAuxiliaryCurve_experimental(e.curveInfo.displayName);null!=a&&(0,editor_animation_aux_curve_1.syncToRealCurve)(e,a)}}async applyEditorEmbeddedPlayersToClip(){const e=this._getAnimState();if(!e)return;const t=Object.values(this._editEmbeddedPlayerMap);e.clip[embedded_player_1.clearEmbeddedPlayersTag]();for(const a of t){const t=new embedded_player_1.EmbeddedPlayer;if(t.begin=a.begin/e.clip.sample,t.end=a.end/e.clip.sample,t.reconciledSpeed=a.reconciledSpeed,t[cc_1.editorExtrasTag]={group:a.group,displayName:a.displayName},a.playable){if("animation-clip"===a.playable.type){const e=new embedded_player_1.EmbeddedAnimationClipPlayable;a.playable.clip&&(e.clip=await(0,asset_1.loadAssetUncached)(a.playable.clip,cc_1.AnimationClip)),a.playable.path&&(e.path=a.playable.path),t.playable=e}if("particle-system"===a.playable.type){const e=new embedded_player_1.EmbeddedParticleSystemPlayable;a.playable.path&&(e.path=a.playable.path),t.playable=e}}e.clip[embedded_player_1.addEmbeddedPlayerTag](t)}}updateEditorEmbeddedPlayers(){const e=this._getAnimState();e&&(e.clip.duration=this._editorSharedClipData.duration,utils_1.utils.initAninState(e,this._rootNode))}_ensureEditorExtras(e){e[cc_1.editorExtrasTag]||(e[cc_1.editorExtrasTag]={})}_getRealKeyframeData(e){const t={value:e.value,interpolationMode:e.interpMode,rightTangent:e.outTangent,rightTangentWeight:e.outTangentWeight,leftTangent:e.inTangent,leftTangentWeight:e.inTangentWeight,tangentWeightMode:e.tangentWeightMode,easingMethod:e.easingMethod};return void 0!==e.tangentMode&&(this._ensureEditorExtras(t),t[cc_1.editorExtrasTag].tangentMode=e.tangentMode),void 0!==e.broken&&(this._ensureEditorExtras(t),t[cc_1.editorExtrasTag].broken=e.broken),t}createTrack(e,t){let a=null;const r=e.curveInfo,i=r.type.value;if(e instanceof editor_animation_combined_curve_1.default){switch(i){case"cc.Vec2":case"cc.Vec3":case"cc.Vec4":a=new cc_1.animation.VectorTrack,"cc.Vec2"===i?a.componentsCount=2:"cc.Vec3"===i?a.componentsCount=3:"cc.Vec4"===i&&(a.componentsCount=4);break;case"cc.Color":a=new cc_1.animation.ColorTrack;break;case"cc.Size":a=new cc_1.animation.SizeTrack;break;default:console.error("unknown track type:",i)}if(a){const r=e.getPartEditorAnimCurves(),i=a.channels();r.forEach((e,a)=>{const r=i[a];e.keyframeData.forEach(a=>{const i=this._getRealKeyframeData(a);r.curve.addKeyFrame(a.frame/t,i),e.partName&&(r.name=e.partName)}),r.curve.preExtrapolation=e.preExtrap,r.curve.postExtrapolation=e.postExtrap})}}else if(e instanceof editor_animation_curve_1.EditorAnimationCurve){switch(i){case"cc.Quat":a=new cc_1.animation.QuatTrack;break;case"cc.Number":case"Number":case"Integer":case"Float":a=new cc_1.animation.RealTrack;break;default:a=new cc_1.animation.ObjectTrack}if(a){const r=a.channel.curve;e.keyframeData.forEach(e=>{if(r instanceof cc_1.RealCurve){const a=this._getRealKeyframeData(e);r.addKeyFrame(e.frame/t,a)}else r instanceof cc_1.QuatCurve?r.addKeyFrame(e.frame/t,{value:e.value}):r.addKeyFrame(e.frame/t,e.value)}),(r instanceof cc_1.QuatCurve||r instanceof cc_1.RealCurve)&&(r.preExtrapolation=e.preExtrap,r.postExtrapolation=e.postExtrap)}}return a&&(a.path=e.curveInfo.targetPaths,r.valueAdapter&&(a.proxy=r.valueAdapter)),a}async updateCurveData(){const e=this._getAnimState();e&&(await this.applyEditorCurvesToClip(),utils_1.utils.initAninState(e,this._rootNode))}updateEventData(){const e=this._getAnimState();e&&(e.clip.updateEventDatas(),e.clip.duration=this._editorSharedClipData.duration,utils_1.utils.initAninState(e,this._rootNode))}async changeSample(e){const t=this._getAnimState();if(!t)return!1;e=Math.round(e),(isNaN(e)||e<1)&&(e=1);const a=t.clip,r=a.events;return r&&r.forEach(t=>{const r=Math.round(t.frame*a.sample);t.frame=r/e}),this._editorSharedClipData.sample=e,this.recalculateDuration(),await this.updateCurveData(),this.applyAuxCurvesToClip(),!0}async changeSpeed(e){const t=this._getAnimState();return!!t&&(t.clip.speed=e,await this.updateCurveData(),this.applyAuxCurvesToClip(),!0)}async changeWrapMode(e){const t=this._getAnimState();return!!t&&(void 0===cc.AnimationClip.WrapMode[e]&&(e=0),e=Number(e),t.clip.wrapMode=e,await this.updateCurveData(),this.applyAuxCurvesToClip(),!0)}async removeNode(e){if(!this._getAnimState())return!1;for(let t=this._editorCurves.length-1;t>=0;t--){this._editorCurves[t].nodePath===e&&this._editorCurves.splice(t,1)}return this.rebuildCreatedCurveMap(),this.recalculateDuration(),await this.updateCurveData(),!0}async changeNodeDataPath(e,t){if(e===t)return!1;if(!this._getAnimState())return!1;if(void 0===e||void 0===t)return!1;let a=-1;const r=[];let i=null;for(let n=0;n<this._editorCurves.length;n++){const s=this._editorCurves[n];s.nodePath===e?(a=n,this._editorCurves[a].changeNodePath(t),this._editorCurves[a]instanceof editor_animation_combined_curve_1.default&&(i=this._editorCurves[a])):s.nodePath===t&&r.push(n)}if(r.length>0)for(let e=r.length-1;e>=0;e--)this._editorCurves.splice(r[e],1);if(a>=0){if(i){const e=this.getInitPropData(i.nodePath,i.propKey);i.updateType(null===e||void 0===e?void 0:e.type)}return this.rebuildCreatedCurveMap(),await this.updateCurveData(),!0}return!1}async copyNode(e,t){const a=t.nodePath,r=e.curvesDump;if(r.length<=0)return console.warn("source of copyNode is empty"),!1;for(let e=0;e<r.length;e++){const t=r[e],i=t.key;let n;await this.createProp(a,i)&&(n=this.getCreatedCurve(a,i));const s=this.getCreatedCurve(t.nodePath,i);if(!(CombinedType.includes(t.type&&t.type.value||"")||s instanceof editor_animation_combined_curve_1.default)&&n){const e=await utils_1.utils.getKeyframeDataFromDump(t.keyframes);for(let t=0;t<e.length;t++){const a=e[t],r={newValue:a.value};utils_1.utils.copyCurveData(a,r),await n.createKey(a.frame,r)}}}return this.recalculateDuration(),await this.updateCurveData(),!0}async copyProp(e,t){var a,r,i,n;const s=t.nodePath,o=e.curvesDump;if(!t.propKeys)return console.warn("need a propKeys for target"),!1;if(t.propKeys&&t.propKeys.length!==o.length)return console.warn("src curves number doesn't equal to dst propKeys"),!1;if(o.length<=0)return console.warn("source of copyProp is empty"),!1;for(let e=0;e<o.length;e++){const u=o[e],d=(u.key,t.propKeys[e]),c=this.getCreatedCurve(s,d);if((null===(a=u.type)||void 0===a?void 0:a.value)!==(null===(r=null===c||void 0===c?void 0:c.curveInfo.type)||void 0===r?void 0:r.value))return console.warn(`type of source ${null===(i=u.type)||void 0===i?void 0:i.value} doesn't equal to type of target ${null===(n=null===c||void 0===c?void 0:c.curveInfo.type)||void 0===n?void 0:n.value}`),!1;if(c){const e=await utils_1.utils.getKeyframeDataFromDump(u.keyframes);for(let t=0;t<e.length;t++){const a=e[t],r={newValue:a.value};utils_1.utils.copyCurveData(a,r),await c.createKey(a.frame,r)}}}return this.recalculateDuration(),await this.updateCurveData(),!0}async copyKey(e,t){var a,r,i,n;const s=t.nodePath,o=e.curvesDump;if(!t.propKeys)return console.warn("need a propKeys for target"),!1;if(t.propKeys&&t.propKeys.length!==o.length)return console.warn("src curves number doesn't equal to dst propKeys"),!1;if(o.length<=0)return console.warn("source of copyKey is empty"),!1;for(let e=0;e<o.length;e++){const u=o[e],d=t.propKeys[e],c=this.getCreatedCurve(u.nodePath,d);if(c instanceof editor_animation_curve_1.EditorAnimationCurve&&c.parentCurve&&await this.createProp(s,c.parentCurve.propKey),!await this.createProp(s,d)){console.warn(`fail to create prop: ${s} ${d}`);continue}const l=this.getCreatedCurve(s,d);if((null===(a=u.type)||void 0===a?void 0:a.value)!==(null===(r=null===l||void 0===l?void 0:l.curveInfo.type)||void 0===r?void 0:r.value))return console.warn(`type of source ${null===(i=u.type)||void 0===i?void 0:i.value} doesn't equal to type of target ${null===(n=null===l||void 0===l?void 0:l.curveInfo.type)||void 0===n?void 0:n.value}`),!1;if(l){const e=await utils_1.utils.getKeyframeDataFromDump(u.keyframes),a=e[0].frame;for(let r=0;r<e.length;r++){const i=e[r],n={newValue:i.value};utils_1.utils.copyCurveData(i,n),await l.createKey(i.frame+t.startFrame-a,n)}}}return this.recalculateDuration(),await this.updateCurveData(),!0}copyEvent(e,t){const a=e.eventsDump;if(a.length<=0)return console.warn("source of copyEvent is empty"),!1;const r=a[0].frame,i=[];for(let e=0;e<a.length;e++){const n=a[e],s=t.startFrame+n.frame-r;i.push(s),this._deleteEvent([s])}for(let e=0;e<a.length;e++){const t=a[e],r=i[e];this.addEvent(r,t.func,t.params)}return!0}async copyPropTo(e,t,a,r){if(e===a&&t===r)return!1;if(!this._getAnimState())return!1;if(!(e&&t&&a&&r))return!1;const i=this.getCreatedCurve(e,t);if(!i)return console.log(`can't find src prop Curve: nodePath:${e} propKey:${t}`),!1;const n=this.getCreatedCurve(a,r);if(!n)return console.log(`can't find dst prop Curve: nodePath:${a} propKey:${r}`),!1;const s=i.curveInfo,o=n.curveInfo;if(!s.type||!o.type)return!1;if(s.type.value!==o.type.value)return!1;const u=i.keyframeData;if(!u)return!1;for(let e=0;e<u.length;e++){const t=u[e];await n.createKey(t.frame,{newValue:t.value})}return this.recalculateDuration(),await this.updateCurveData(),!0}async createProp(e,t){const a=this._getAnimState();if(!a)return!1;if(this.getCreatedCurve(e,t))return!0;const r=this.getInitPropData(e,t);if(!r)return!1;const i=new cc_1.animation.TrackPath,n=utils_1.utils.generateHierarchyPath(e);n&&i.append(n);const s=r.propData.valueAdapter,o=r.propData.targetPaths;i.append(o);const u=a.clip,d=r.type.value,c=this.generateClipData(u),l={nodePath:e,propKey:t,type:r.type,targetPaths:i,valueAdapter:s,displayName:r.displayName,propName:r.name,compName:r.comp};if(utils_1.utils.getPartsOfType(d)){const e=new editor_animation_combined_curve_1.default(this._rootNode,c);e.curveInfo=l,e.separateDataIntoParts(),this.addEditorCurve(e),e.getPartEditorAnimCurves().forEach(e=>{this.addEditorCurve(e)})}else{const e=new editor_animation_curve_1.EditorAnimationCurve(this._rootNode,c);e.curveInfo=l,this.addEditorCurve(e)}return await this.updateCurveData(),!0}async removeProp(e,t){if(!this._getAnimState())return!1;const a=this.getCreatedCurve(e,t);if(!a)return!1;let r=null;if(a instanceof editor_animation_combined_curve_1.default)r=a.getPartEditorAnimCurves();else if(a instanceof editor_animation_curve_1.EditorAnimationCurve&&a.isPartCurve)return console.warn("can't remove part prop directly"),!1;for(let e=this._editorCurves.length-1;e>=0;e--){const t=this._editorCurves[e];t!==a?t instanceof editor_animation_curve_1.EditorAnimationCurve&&r&&r.includes(t)&&this._editorCurves.splice(e,1):this._editorCurves.splice(e,1)}return this.rebuildCreatedCurveMap(),this.recalculateDuration(),await this.updateCurveData(),!0}async createKey(e,t,a=0,r){if(a<0)return!1;if(!this._getAnimState())return!1;const i=this.getCreatedCurve(e,t);return!!i&&(!!await i.createKey(a,r)&&(this.recalculateDuration(),await this.updateCurveData(),(0,utils_1.multiplyTrackWithTimer)("hippoAnimator",{A100001:1,project_id:Editor.Project.uuid,clip_id:this._clipUuid,version:Editor.App.version}),!0))}async moveKeys(e,t,a,r){if(a.length<=0)return!1;for(let e=0;e<a.length;e++)if(a[e]<0)return!1;let i=[];if(Array.isArray(r)?i=r:a.forEach(e=>{i.push(r)}),0===i.length)return!1;if(a.length!==i.length)return!1;if(!this._getAnimState())return!1;const n=this.getCreatedCurve(e,t);return!!n&&(!!n.moveKeys(a,i)&&(this.recalculateDuration(),await this.updateCurveData(),!0))}async removeKey(e,t,a){if(!this._getAnimState())return!1;if(null===a||void 0===a)return!1;Array.isArray(a)||(a=[a]);const r=this.getCreatedCurve(e,t);return!!r&&(!!r.removeKey(a)&&(this.recalculateDuration(),await this.updateCurveData(),!0))}async updateKey(e,t,a){if(null===a||void 0===a)return!1;if(!this._getAnimState())return!1;Array.isArray(a)||(a=[a]);const r=this.getCreatedCurve(e,t);return!!r&&(!!await r.updateKey(a)&&(await this.updateCurveData(),!0))}async copyKeysTo(e,t,a,r){if(!this._getAnimState())return!1;a.sort((e,t)=>e-t);const i=this.getCreatedCurve(e,t);return!!i&&(!!await i.copyKeysTo(a,r)&&(this.recalculateDuration(),await this.updateCurveData(),!0))}async spacingKeys(e,t,a,r){if(!this._getAnimState())return!1;const i=this.getCreatedCurve(e,t);return!!i&&(await i.spacingKeys(a,r),this.recalculateDuration(),await this.updateCurveData(),!0)}async clearKeys(e,t){if(!this._getAnimState())return!1;const a=this.getCreatedCurve(e,t);return!!a&&(!!a.clearKeys()&&(this.recalculateDuration(),await this.updateCurveData(),!0))}addEvent(e,t,a){if(e<0)return!1;const r=this._getAnimState();if(!r)return!1;const i=r.clip;if(!i)return console.log("Clip doesn't exist"),null;const n={frame:e/i.sample,func:t||"",params:a||[]};return i.events=i.events||[],i.events.push(n),i.events.sort((e,t)=>e.frame-t.frame),!!n&&(this.updateEventData(),!0)}_getEditClip(){const e=this._getAnimState();if(!e)return null;const t=e.clip;return t||(console.log("Clip doesn't exist"),null)}addEmbeddedPlayerGroup(e){const t=this._getEditClip();if(!t||!e.key||!e.type)return!1;if(t[cc_1.editorExtrasTag]&&t[cc_1.editorExtrasTag].embeddedPlayerGroups){if(t[cc_1.editorExtrasTag].embeddedPlayerGroups.find(t=>t.key===e.key))return!1}else t[cc_1.editorExtrasTag]={embeddedPlayerGroups:[]};return t[cc_1.editorExtrasTag].embeddedPlayerGroups.push({key:e.key,name:e.name,type:e.type}),!0}async removeEmbeddedPlayerGroup(e){const t=this._getEditClip();return!!t&&(t[cc_1.editorExtrasTag].embeddedPlayerGroups=t[cc_1.editorExtrasTag].embeddedPlayerGroups.filter(t=>t.key!==e),this._clearEmbeddedPlayerGroup(e),await this.applyEditorEmbeddedPlayersToClip(),this.updateEditorEmbeddedPlayers(),!0)}_clearEmbeddedPlayerGroup(e){return Object.keys(this._editEmbeddedPlayerMap).forEach(t=>{this._editEmbeddedPlayerMap[t].group===e&&delete this._editEmbeddedPlayerMap[t]}),!0}async clearEmbeddedPlayerGroup(e){return this._clearEmbeddedPlayerGroup(e),await this.applyEditorEmbeddedPlayersToClip(),this.updateEditorEmbeddedPlayers(),!0}async addEmbeddedPlayer(e){if(e.end<e.begin||e.begin<0)return!1;return!!this._addEmbeddedPlayer(e)&&(await this.applyEditorEmbeddedPlayersToClip(),this.updateEditorEmbeddedPlayers(),!0)}_addEmbeddedPlayer(e){const t=utils_1.utils.calcEmbeddedPlayerKey(e);return this._editEmbeddedPlayerMap||(this._editEmbeddedPlayerMap={}),this._editEmbeddedPlayerMap[t],this._editEmbeddedPlayerMap[t]=e,!0}async deleteEmbeddedPlayer(e){return!!this._deleteEmbeddedPlayer(e)&&(await this.applyEditorEmbeddedPlayersToClip(),this.updateEditorEmbeddedPlayers(),!0)}async clearEmbeddedPlayer(e){delete this._editEmbeddedPlayerMap[e],await this.applyEditorEmbeddedPlayersToClip(),this.updateEditorEmbeddedPlayers()}_deleteEmbeddedPlayer(e){const t=utils_1.utils.calcEmbeddedPlayerKey(e);return!!this._editEmbeddedPlayerMap[t]&&(delete this._editEmbeddedPlayerMap[t],!0)}async updateEmbeddedPlayer(e,t){if(!this._getEditClip())return!1;const a=utils_1.utils.calcEmbeddedPlayerKey(e);if(!this._editEmbeddedPlayerMap[a])return!1;delete this._editEmbeddedPlayerMap[a];const r=utils_1.utils.calcEmbeddedPlayerKey(t);return this._editEmbeddedPlayerMap[r]=t,await this.applyEditorEmbeddedPlayersToClip(),this.updateEditorEmbeddedPlayers(),!0}_deleteEvent(e){const t=this._getAnimState();if(!t)return!1;if(null===e||void 0===e)return!1;Array.isArray(e)||(e=[e]);const a=t.clip;if(!a)return console.log("Clip doesn't exist"),!1;const r=a.events;if(!r)return!1;const i=a.sample,n=[];return e.forEach(e=>{for(let t=r.length-1;t>=0;t--){const a=r[t];Math.round(a.frame*i)===e&&(r.splice(t,1),n.push(a))}}),!0}deleteEvent(e){const t=this._deleteEvent(e);return this.updateEventData(),t}updateEvent(e,t){return!!this._getAnimState()&&(null!==e&&void 0!==e&&(Array.isArray(e)||(e=[e]),e.forEach(e=>{if(!this.deleteEvent([e]))return!1;t&&t.forEach(t=>{this.addEvent(e,t.func,t.params)})}),this.updateEventData(),!0))}moveEvents(e,t){const a=this._getAnimState();if(!a)return!1;if(null===e||void 0===e)return!1;const r=utils_1.utils.queryEvents(a.clip);if(!r)return!1;const i=a.clip.sample;for(let a=0;a<r.length;a++){const n=r[a],s=Math.round(n.frame*i);if(e.indexOf(s)>=0){let e=s+t;e<0&&(e=0),n.frame=e/i}}return this.updateEventData(),!0}copyEventsTo(e,t){if(!e||e.length<=0)return!1;const a=this._getAnimState();if(!a)return!1;const r=utils_1.utils.queryEvents(a.clip);if(!r)return!1;e.sort((e,t)=>e-t);const i=a.clip.sample,n=e[0],s=[];for(let a=0;a<r.length;a++){const o=r[a],u=Math.round(o.frame*i);if(e.indexOf(u)>=0){let e=u-n+t;e<0&&(e=0),s.push({frame:e,func:o.func,params:o.params})}}return s.forEach(e=>{this.addEvent(e.frame,e.func,e.params)}),this.updateEventData(),!0}async modifyCurveOfKey(e,t,a,r){var i;if(!this._getAnimState())return!1;const n=this.getCreatedCurve(e,t);if(!n)return!1;const s=null===(i=n.curveInfo.type)||void 0===i?void 0:i.value;return!(!s||!utils_1.allowModifyCurveType.includes(s))&&(!!n.modifyCurveOfKey(a,r)&&(await this.updateCurveData(),!0))}async getPropValueAtFrame(e,t,a){const r=this.getCreatedCurve(e,t);if(r){const e=await r.getPropValueAtFrame(a);return"2d"===cce.SceneFacadeManager._projectType&&e&&("position"===t&&(e.lock={z:{default:0,message:"i18n:scene.is3DValueWarn"}}),"rotation"===t&&(e.lock={x:{default:0,message:"i18n:scene.is3DValueWarn"},y:{default:0,message:"i18n:scene.is3DValueWarn"}}),"eulerAngles"===t&&(e.lock={x:{default:0,message:"i18n:scene.is3DValueWarn"},y:{default:0,message:"i18n:scene.is3DValueWarn"}}),"scale"===t&&(e.lock={z:{default:1,message:"i18n:scene.is3DValueWarn"}})),e}return null}_getRawAuxiliaryCurves(e){const t=[],a=e.getAuxiliaryCurveNames_experimental();for(const r of a){const a=e.getAuxiliaryCurve_experimental(r);null!=a&&t.push({name:r,curve:a})}return t}_initAuxCurves(e){const t=this._getAnimState(),a=this._rootNode,r=this._getRawAuxiliaryCurves(t.clip),i=this._createdAuxCurveMap,n=this.generateClipData(t.clip);for(const e of r){i.has(e.name)&&Editor.App.dev&&console.warn(`auxiliary curve named "${e.name}" already exists`);const t=(0,editor_animation_aux_curve_1.createEditorCurve)(e.name,e.curve,a,n);this.addAuxCurve(t)}}async getAuxiliaryCurves(){const e=this._getAnimState().clip.getAuxiliaryCurveNames_experimental(),t={};for(const a of e){const e=this._createdAuxCurveMap.get(a);if(void 0!==e){const r=await e.getDumpData();t[a]=r}}return t}addAuxiliaryCurve(e){const t=this._animState.clip,a=t.addAuxiliaryCurve_experimental(e),r=this.generateClipData(t),i=(0,editor_animation_aux_curve_1.createEditorCurve)(e,a,this._rootNode,r);return this.addAuxCurve(i),null!==a}renameAuxiliaryCurve(e,t){const a=this._createdAuxCurveMap.get(e);null!=a&&(this._auxCurves.delete(a),this._createdAuxCurveMap.delete(a.curveInfo.displayName));const r=this._animState.clip,i=this.generateClipData(r);r.renameAuxiliaryCurve_experimental(e,t);const n=r.getAuxiliaryCurve_experimental(t),s=(0,editor_animation_aux_curve_1.createEditorCurve)(t,n,this._rootNode,i);return this.addAuxCurve(s),!0}removeAuxiliaryCurve(e){const t=this._createdAuxCurveMap.get(e);return t?(this._animState.clip.removeAuxiliaryCurve_experimental(e),this._createdAuxCurveMap.delete(e),this._auxCurves.delete(t),!0):(Editor.App.dev&&console.warn(`auxiliary curve "${e}" has already been removed`),!0)}async createAuxKey(e,t,a){if(!Number.isFinite(t)||t<0)return!1;if(!this._getAnimState())return!1;const r=this.getCreatedAuxCurve(e);return!!r&&(!!await r.createKey(t,a)&&(this.updateCurveData(),this.applyAuxCurvesToClip(),!0))}async removeAuxKey(e,t){if(!Number.isFinite(t)||t<0)return!1;const a=this.getCreatedAuxCurve(e,!0);return await a.removeKey([t]),await this.updateCurveData(),this.applyAuxCurvesToClip(),!0}async moveAuxKeys(e,t,a){const r=this.getCreatedAuxCurve(e);if(!r)return!1;const i=await r.moveKeys(t,Array.isArray(a)?a:[a]);return!0===i&&(await this.updateCurveData(),this.applyAuxCurvesToClip()),i}async copyAuxKey(e,t){return this.getCreatedAuxCurve(t.name,!0).createKey(t.frame,e.data).then(e=>(this.applyAuxCurvesToClip(),e))}async modifyAuxCurveOfKey(e,t,a){var r;const i=this.getCreatedAuxCurve(e,!0),n=null===(r=i.curveInfo.type)||void 0===r?void 0:r.value;if("string"!=typeof n||!utils_1.allowModifyCurveType.includes(n))return!1;const s=await i.modifyCurveOfKey(t,a);return s&&this.applyAuxCurvesToClip(),s}async getAuxCurveValueAtFrame(e,t){const a=this.getCreatedAuxCurve(e);return a?await a.getPropValueAtFrame(t):null}_getAnimState(){return this._animState}}exports.default=EditorAnimationClip;