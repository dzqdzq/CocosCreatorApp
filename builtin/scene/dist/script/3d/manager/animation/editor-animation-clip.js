"use strict";var __importDefault=this&&this.__importDefault||function(t){return t&&t.__esModule?t:{default:t}};Object.defineProperty(exports,"__esModule",{value:!0});const cc_1=require("cc"),editor_animation_curve_1=__importDefault(require("./editor-animation-curve")),editor_animation_combined_curve_1=__importDefault(require("./editor-animation-combined-curve")),utils_1=require("./utils"),uniform_handler_1=require("./uniform-handler");class EditorAnimationClip{constructor(t,e,a){this._initPropDataMap=new Map,this._createdCurveMap=new Map,this._editorCurves=[],this._rootNode=t,this._clipUuid=e,this._animComp=t.getComponent(cc_1.Animation),this._animState=a,this.init()}refreshData(t,e){this._rootNode=t,this._clipUuid=e,this._animComp=t.getComponent(cc_1.Animation);for(let e=0;e<this._editorCurves.length;e++)this._editorCurves[e].node=t}init(){const t=this._getAnimState();if(!t)return;const e=t.clip;if(this._editorSharedClipData={sample:e.sample,duration:e.duration},e.upgradeUntypedTracks((t,e)=>{let a=null;if(e){if(e instanceof cc_1.animation.UniformProxyFactory){const r=t.trace(this._rootNode);a=uniform_handler_1.uniformHandler.getUniformDumpData(r,e).type}}else{const e=t.trace(this._rootNode,0,t.length-1),r=t.length-1,i=t.isPropertyAt(r)?t.parsePropertyAt(r):t.isElementAt(r)?t.parseElementAt(r):null;if(null===i||"number"==typeof i)return null;if(cc_1.CCClass._isCCClass(e.constructor)){const t=cc_1.CCClass.attr(e.constructor,i);a=e instanceof cc_1.Node&&("position"===i||"eulerAngles"===i||"scale"===i)?"cc.Vec3":t.type}else a=typeof e[i]}return utils_1.utils.getTrackTypeBy(a)}),!e.tracks)return void console.warn("tracks is null");const a=this.generateClipData(e);for(const t of e.tracks){const e=utils_1.utils.getCurveInfoByTrack(this._rootNode,t);if(t instanceof cc_1.animation.RealTrack||t instanceof cc_1.animation.QuatTrack||t instanceof cc_1.animation.ObjectTrack){const r=t.channel.curve,i=new editor_animation_curve_1.default(this._rootNode,a);i.initFromCurve(e,r),this.addEditorCurve(i)}else t instanceof cc_1.animation.VectorTrack||t instanceof cc_1.animation.ColorTrack||t instanceof cc_1.animation.SizeTrack?this.createCombinedAndPartsAnimCurve(a,e,t):console.warn("unknown track:",t)}}get rootNode(){return this._rootNode}generateClipData(t){return{sharedData:this._editorSharedClipData}}createCombinedAndPartsAnimCurve(t,e,a){const r=new editor_animation_combined_curve_1.default(this._rootNode,t);r.initFromTrack(e,a),this.addEditorCurve(r),r.getPartEditorAnimCurves().forEach(t=>{this.addEditorCurve(t)})}addInitPropDataMap(t,e){const a=new Map;e.forEach(t=>{a.set(t.key,t)}),this._initPropDataMap.set(t,a)}getInitPropData(t,e){if(!this._initPropDataMap.has(t)){let e=this._rootNode;"/"!==t&&(e=e.getChildByPath(t.substr(1)));const a=utils_1.utils.getAnimableProperties(e,e!==this._rootNode);a&&this.addInitPropDataMap(t,a)}const a=this._initPropDataMap.get(t);return a?a.get(e):null}getCreatedCurve(t,e){let a=null;const r=this._createdCurveMap.get(t);return r&&(a=r.get(e)),a}addEditorCurve(t){this._editorCurves.includes(t)||(this._editorCurves.push(t),this.addToCreatedCurveMap(t))}addToCreatedCurveMap(t){let e=this._createdCurveMap.get(t.nodePath);e||(e=new Map),e.set(t.propKey,t),this._createdCurveMap.set(t.nodePath,e)}rebuildCreatedCurveMap(){this._createdCurveMap.clear(),this._editorCurves.forEach(t=>{this.addToCreatedCurveMap(t)})}async getDumpData(){const t=[];for(let e=0;e<this._editorCurves.length;e++){const a=this._editorCurves[e],r=await a.getDumpData();a instanceof editor_animation_combined_curve_1.default?(t.push(r),await a.iteratorPartAnimCurves(async(e,a)=>{const i=await e.getDumpData();i.parentPropKey=r.key,r.partKeys?r.partKeys.push(i.key):r.partKeys=[i.key],t.push(i)})):a instanceof editor_animation_curve_1.default&&(a.isPartCurve||t.push(r))}const e=this._getAnimState();if(!e)return null;const a=e.clip;return{name:a.name,duration:a.duration,sample:a.sample,speed:a.speed,wrapMode:a.wrapMode,curves:t,events:a.events.map(t=>({frame:Math.round(t.frame*a.sample),func:t.func,params:t.params})),time:e.time||0,isLock:!1}}recalculateDuration(){let t=0;this._editorCurves.forEach(e=>{e instanceof editor_animation_curve_1.default&&(t=Math.max(e.getCurveDuration(),t))});const e=this._getAnimState();if(!e)return;const a=e.clip.events;if(a){const e=a[a.length-1];e&&(t=Math.max(e.frame,t))}this._editorSharedClipData.duration=t}async applyEditorCurvesToClip(){const t=this._getAnimState();if(!t)return;const e=t.clip;e.sample=this._editorSharedClipData.sample,e.duration=this._editorSharedClipData.duration,e.clearTracks();const a=[];for(let t=0;t<this._editorCurves.length;t++){const r=this._editorCurves[t];if(r instanceof editor_animation_curve_1.default){if(!r.isPartCurve){const t=this.createTrack(r,e.sample);t&&a.push(t)}}else if(r instanceof editor_animation_combined_curve_1.default){await r.updateCurveData();const t=this.createTrack(r,e.sample);t&&a.push(t)}}a.forEach(t=>{e.addTrack(t)})}_getRealKeyframeData(t){const e={value:t.value,interpolationMode:t.interpMode,rightTangent:t.outTangent,rightTangentWeight:t.outTangentWeight,leftTangent:t.inTangent,leftTangentWeight:t.inTangentWeight,tangentWeightMode:t.tangentWeightMode,easingMethod:t.easingMethod};return e[cc_1.editorExtrasTag]||(e[cc_1.editorExtrasTag]={}),e[cc_1.editorExtrasTag].tangentMode=t.tangentMode,e}createTrack(t,e){let a=null;const r=t.curveInfo,i=r.type.value;if(t instanceof editor_animation_combined_curve_1.default){switch(i){case"cc.Vec2":case"cc.Vec3":case"cc.Vec4":a=new cc_1.animation.VectorTrack,"cc.Vec2"===i?a.componentsCount=2:"cc.Vec3"===i?a.componentsCount=3:"cc.Vec4"===i&&(a.componentsCount=4);break;case"cc.Color":a=new cc_1.animation.ColorTrack;break;case"cc.Size":a=new cc_1.animation.SizeTrack;break;default:console.error("unknown track type:",i)}if(a){const r=t.getPartEditorAnimCurves(),i=a.channels();r.forEach((t,a)=>{const r=i[a];t.keyframeData.forEach(a=>{const i=this._getRealKeyframeData(a);r.curve.addKeyFrame(a.frame/e,i),t.partName&&(r.name=t.partName)}),r.curve.preExtrapolation=t.preExtrap,r.curve.postExtrapolation=t.postExtrap})}}else if(t instanceof editor_animation_curve_1.default){switch(i){case"cc.Quat":a=new cc_1.animation.QuatTrack;break;case"cc.Number":case"Number":case"Integer":case"Float":a=new cc_1.animation.RealTrack;break;default:a=new cc_1.animation.ObjectTrack}if(a){const r=a.channel.curve;t.keyframeData.forEach(t=>{r.addKeyFrame(t.frame/e,t.value)}),(r instanceof cc_1.QuatCurve||r instanceof cc_1.RealCurve)&&(r.preExtrapolation=t.preExtrap,r.postExtrapolation=t.postExtrap)}}return a&&(a.path=t.curveInfo.targetPaths,r.valueAdapter&&(a.proxy=r.valueAdapter)),a}async updateCurveData(){await this.applyEditorCurvesToClip();const t=this._getAnimState();t&&(t._curveLoaded=!1,t.initialize(this._rootNode))}updateEventData(){const t=this._getAnimState();t&&(t.clip.updateEventDatas(),t._curveLoaded=!1,t.initialize(this._rootNode))}async changeSample(t){const e=this._getAnimState();if(!e)return!1;t=Math.round(t),(isNaN(t)||t<1)&&(t=1);const a=e.clip,r=a.events;return r&&r.forEach(e=>{const r=Math.round(e.frame*a.sample);e.frame=r/t}),this._editorSharedClipData.sample=t,this.recalculateDuration(),await this.updateCurveData(),!0}async changeSpeed(t){const e=this._getAnimState();return!!e&&(e.clip.speed=t,await this.updateCurveData(),!0)}async changeWrapMode(t){const e=this._getAnimState();return!!e&&(void 0===cc.AnimationClip.WrapMode[t]&&(t=0),t=Number(t),e.clip.wrapMode=t,await this.updateCurveData(),!0)}async removeNode(t){if(!this._getAnimState())return!1;for(let e=this._editorCurves.length-1;e>=0;e--){this._editorCurves[e].nodePath===t&&this._editorCurves.splice(e,1)}return this.rebuildCreatedCurveMap(),this.recalculateDuration(),await this.updateCurveData(),!0}async changeNodeDataPath(t,e){if(t===e)return!1;if(!this._getAnimState())return!1;if(void 0===t||void 0===e)return!1;let a=-1;const r=[];let i=null;for(let n=0;n<this._editorCurves.length;n++){const o=this._editorCurves[n];o.nodePath===t?(a=n,this._editorCurves[a].changeNodePath(e),this._editorCurves[a]instanceof editor_animation_combined_curve_1.default&&(i=this._editorCurves[a])):o.nodePath===e&&r.push(n)}if(r.length>0)for(let t=r.length-1;t>=0;t--)this._editorCurves.splice(r[t],1);if(a>=0){if(i){const t=this.getInitPropData(i.nodePath,i.propKey);i.updateType(null===t||void 0===t?void 0:t.type)}return this.rebuildCreatedCurveMap(),await this.updateCurveData(),!0}return!1}async copyNode(t,e){const a=e.nodePath,r=t.curvesDump;if(r.length<=0)return console.warn("source of copyNode is empty"),!1;for(let t=0;t<r.length;t++){const e=r[t],i=e.key;let n;if(await this.createProp(a,i)&&(n=this.getCreatedCurve(a,i)),n){const t=await utils_1.utils.getKeyframeDataFromDump(e.keyframes);for(let e=0;e<t.length;e++){const a=t[e],r={newValue:a.value};utils_1.utils.copyCurveData(a,r),await n.createKey(a.frame,r)}}}return this.recalculateDuration(),await this.updateCurveData(),!0}async copyProp(t,e){var a,r,i,n;const o=e.nodePath,s=t.curvesDump;if(!e.propKeys)return console.warn("need a propKeys for target"),!1;if(e.propKeys&&e.propKeys.length!==s.length)return console.warn("src curves number doesn't equal to dst propKeys"),!1;if(s.length<=0)return console.warn("source of copyProp is empty"),!1;for(let t=0;t<s.length;t++){const u=s[t],c=(u.key,e.propKeys[t]),l=this.getCreatedCurve(o,c);if((null===(a=u.type)||void 0===a?void 0:a.value)!==(null===(r=null===l||void 0===l?void 0:l.curveInfo.type)||void 0===r?void 0:r.value))return console.warn(`type of source ${null===(i=u.type)||void 0===i?void 0:i.value} doesn't equal to type of target ${null===(n=null===l||void 0===l?void 0:l.curveInfo.type)||void 0===n?void 0:n.value}`),!1;if(l){const t=await utils_1.utils.getKeyframeDataFromDump(u.keyframes);for(let e=0;e<t.length;e++){const a=t[e],r={newValue:a.value};utils_1.utils.copyCurveData(a,r),await l.createKey(a.frame,r)}}}return this.recalculateDuration(),await this.updateCurveData(),!0}async copyKey(t,e){var a,r,i,n;const o=e.nodePath,s=t.curvesDump;if(!e.propKeys)return console.warn("need a propKeys for target"),!1;if(e.propKeys&&e.propKeys.length!==s.length)return console.warn("src curves number doesn't equal to dst propKeys"),!1;if(s.length<=0)return console.warn("source of copyKey is empty"),!1;for(let t=0;t<s.length;t++){const u=s[t],c=e.propKeys[t],l=this.getCreatedCurve(o,c);if((null===(a=u.type)||void 0===a?void 0:a.value)!==(null===(r=null===l||void 0===l?void 0:l.curveInfo.type)||void 0===r?void 0:r.value))return console.warn(`type of source ${null===(i=u.type)||void 0===i?void 0:i.value} doesn't equal to type of target ${null===(n=null===l||void 0===l?void 0:l.curveInfo.type)||void 0===n?void 0:n.value}`),!1;if(l){const t=await utils_1.utils.getKeyframeDataFromDump(u.keyframes),a=t[0].frame;for(let r=0;r<t.length;r++){const i=t[r],n={newValue:i.value};utils_1.utils.copyCurveData(i,n),await l.createKey(i.frame+e.startFrame-a,n)}}}return this.recalculateDuration(),await this.updateCurveData(),!0}async copyEvent(t,e){const a=t.eventsDump;if(a.length<=0)return console.warn("source of copyEvent is empty"),!1;const r=a[0].frame,i=[];for(let t=0;t<a.length;t++){const n=a[t],o=e.startFrame+n.frame-r;i.push(o),this._deleteEvent([o])}for(let t=0;t<a.length;t++){const e=a[t],r=i[t];this.addEvent(r,e.func,e.params)}return!0}async copyPropTo(t,e,a,r){if(t===a&&e===r)return!1;if(!this._getAnimState())return!1;if(!(t&&e&&a&&r))return!1;const i=this.getCreatedCurve(t,e);if(!i)return console.log(`can't find src prop Curve: nodePath:${t} propKey:${e}`),!1;const n=this.getCreatedCurve(a,r);if(!n)return console.log(`can't find dst prop Curve: nodePath:${a} propKey:${r}`),!1;const o=i.curveInfo,s=n.curveInfo;if(!o.type||!s.type)return!1;if(o.type.value!==s.type.value)return!1;const u=i.keyframeData;if(!u)return!1;for(let t=0;t<u.length;t++){const e=u[t];await n.createKey(e.frame,{newValue:e.value})}return this.recalculateDuration(),await this.updateCurveData(),!0}async createProp(t,e){const a=this._getAnimState();if(!a)return!1;if(this.getCreatedCurve(t,e))return!0;const r=this.getInitPropData(t,e);if(!r)return!1;const i=new cc_1.animation.TrackPath,n=utils_1.utils.generateHierarchyPath(t);n&&i.append(n);const o=r.propData.valueAdapter,s=r.propData.targetPaths;i.append(s);const u=a.clip,c=r.type.value,l=this.generateClipData(u),d={nodePath:t,propKey:e,type:r.type,targetPaths:i,valueAdapter:o,displayName:r.displayName,propName:r.name,compName:r.comp};if(utils_1.utils.getPartsOfType(c)){const t=new editor_animation_combined_curve_1.default(this._rootNode,l);t.curveInfo=d,t.separateDataIntoParts(),this.addEditorCurve(t),t.getPartEditorAnimCurves().forEach(t=>{this.addEditorCurve(t)})}else{const t=new editor_animation_curve_1.default(this._rootNode,l);t.curveInfo=d,this.addEditorCurve(t)}return await this.updateCurveData(),!0}async removeProp(t,e){if(!this._getAnimState())return!1;const a=this.getCreatedCurve(t,e);if(!a)return!1;let r=null;if(a instanceof editor_animation_combined_curve_1.default)r=a.getPartEditorAnimCurves();else if(a instanceof editor_animation_curve_1.default&&a.isPartCurve)return console.warn("can't remove part prop directly"),!1;for(let t=this._editorCurves.length-1;t>=0;t--){const e=this._editorCurves[t];e!==a?e instanceof editor_animation_curve_1.default&&r&&r.includes(e)&&this._editorCurves.splice(t,1):this._editorCurves.splice(t,1)}return this.rebuildCreatedCurveMap(),this.recalculateDuration(),await this.updateCurveData(),!0}async createKey(t,e,a=0,r){if(a<0)return!1;if(!this._getAnimState())return!1;const i=this.getCreatedCurve(t,e);return!!i&&(!!await i.createKey(a,r)&&(this.recalculateDuration(),await this.updateCurveData(),!0))}async moveKeys(t,e,a,r){if(a.length<=0)return!1;for(let t=0;t<a.length;t++)if(a[t]<0)return!1;let i=[];if(Array.isArray(r)?i=r:a.forEach(t=>{i.push(r)}),0===i.length)return!1;if(a.length!==i.length)return!1;if(!this._getAnimState())return!1;const n=this.getCreatedCurve(t,e);return!!n&&(!!n.moveKeys(a,i)&&(this.recalculateDuration(),await this.updateCurveData(),!0))}async removeKey(t,e,a){if(!this._getAnimState())return!1;if(null===a||void 0===a)return!1;Array.isArray(a)||(a=[a]);const r=this.getCreatedCurve(t,e);return!!r&&(!!r.removeKey(a)&&(this.recalculateDuration(),await this.updateCurveData(),!0))}async updateKey(t,e,a){if(null===a||void 0===a)return!1;if(!this._getAnimState())return!1;Array.isArray(a)||(a=[a]);const r=this.getCreatedCurve(t,e);return!!r&&(!!await r.updateKey(a)&&(await this.updateCurveData(),!0))}async copyKeysTo(t,e,a,r){if(!this._getAnimState())return!1;a.sort((t,e)=>t-e);const i=this.getCreatedCurve(t,e);return!!i&&(!!await i.copyKeysTo(a,r)&&(this.recalculateDuration(),await this.updateCurveData(),!0))}async spacingKeys(t,e,a,r){if(!this._getAnimState())return!1;const i=this.getCreatedCurve(t,e);return!!i&&(await i.spacingKeys(a,r),this.recalculateDuration(),await this.updateCurveData(),!0)}async clearKeys(t,e){if(!this._getAnimState())return!1;const a=this.getCreatedCurve(t,e);return!!a&&(!!a.clearKeys()&&(this.recalculateDuration(),await this.updateCurveData(),!0))}addEvent(t,e,a){if(t<0)return!1;const r=this._getAnimState();if(!r)return!1;const i=r.clip;if(!i)return console.log("Clip doesn't exist"),null;const n={frame:t/i.sample,func:e||"",params:a||[]};return i.events=i.events||[],i.events.push(n),i.events.sort((t,e)=>t.frame-e.frame),!!n&&(this.recalculateDuration(),this.updateEventData(),!0)}_deleteEvent(t){const e=this._getAnimState();if(!e)return!1;if(null===t||void 0===t)return!1;Array.isArray(t)||(t=[t]);const a=e.clip;if(!a)return console.log("Clip doesn't exist"),!1;const r=a.events;if(!r)return!1;const i=a.sample,n=[];return t.forEach(t=>{for(let e=r.length-1;e>=0;e--){const a=r[e];Math.round(a.frame*i)===t&&(r.splice(e,1),n.push(a))}}),!0}deleteEvent(t){const e=this._deleteEvent(t);return this.recalculateDuration(),this.updateEventData(),e}updateEvent(t,e){return!!this._getAnimState()&&(null!==t&&void 0!==t&&(Array.isArray(t)||(t=[t]),t.forEach(t=>{if(!this.deleteEvent([t]))return!1;e&&e.forEach(e=>{this.addEvent(t,e.func,e.params)})}),this.updateEventData(),!0))}moveEvents(t,e){const a=this._getAnimState();if(!a)return!1;if(null===t||void 0===t)return!1;const r=utils_1.utils.queryEvents(a.clip);if(!r)return!1;const i=a.clip.sample;for(let a=0;a<r.length;a++){const n=r[a],o=Math.round(n.frame*i);if(t.indexOf(o)>=0){let t=o+e;t<0&&(t=0),n.frame=t/i}}return this.recalculateDuration(),this.updateEventData(),!0}copyEventsTo(t,e){if(!t||t.length<=0)return!1;const a=this._getAnimState();if(!a)return!1;const r=utils_1.utils.queryEvents(a.clip);if(!r)return!1;t.sort((t,e)=>t-e);const i=a.clip.sample,n=t[0],o=[];for(let a=0;a<r.length;a++){const s=r[a],u=Math.round(s.frame*i);if(t.indexOf(u)>=0){let t=u-n+e;t<0&&(t=0),o.push({frame:t,func:s.func,params:s.params})}}return o.forEach(t=>{this.addEvent(t.frame,t.func,t.params)}),this.recalculateDuration(),this.updateEventData(),!0}async modifyCurveOfKey(t,e,a,r){if(!this._getAnimState())return!1;const i=this.getCreatedCurve(t,e);return!!i&&(!!i.modifyCurveOfKey(a,r)&&(await this.updateCurveData(),!0))}async getPropValueAtFrame(t,e,a){const r=this.getCreatedCurve(t,e);return r?await r.getPropValueAtFrame(a):null}_getAnimState(){return this._animState}}exports.default=EditorAnimationClip;