"use strict";var __importDefault=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(exports,"__esModule",{value:!0});const cc_1=require("cc"),editor_animation_curve_1=__importDefault(require("./editor-animation-curve")),editor_animation_combined_curve_1=__importDefault(require("./editor-animation-combined-curve")),uniform_handler_1=require("./uniform-handler"),utils_1=require("./utils");class EditorAnimationClip{constructor(e,t){this._initPropDataMap=new Map,this._createdCurveMap=new Map,this._editorCurves=[],this._rootNode=e,this._clipUuid=t,this._animComp=e.getComponent(cc_1.Animation),this.init()}refreshData(e,t){this._rootNode=e,this._clipUuid=t,this._animComp=e.getComponent(cc_1.Animation);for(let t=0;t<this._editorCurves.length;t++)this._editorCurves[t].node=e}init(){const e=this._getAnimState();if(!e)return;const t=e.clip;this._editorSharedClipData={sample:t.sample,duration:t.duration},t.curves?t.curves.forEach(e=>{var r;const a=this.generateClipData(t),i=utils_1.utils.getCurveInfo(this._rootNode,a,e);if(utils_1.utils.getPartsOfType(null===(r=i.type)||void 0===r?void 0:r.value))this.createCombinedAndPartsAnimCurve(t,e);else{const t=new editor_animation_curve_1.default(this._rootNode,a);if(t.initFromCurve(a,e),t.isPartCurve){let e=this.getCreatedCurve(t.nodePath,t.combinedPropKey);if(!e){let r;const i=this.getInitPropData(t.nodePath,t.combinedPropKey);i?r=i.type:console.warn(`can't find prop: nodePath:${t.nodePath} propKey:${t.combinedPropKey}`);const n=t.curveInfo;n.combinedType=r;const o={nodePath:t.nodePath,propKey:t.combinedPropKey,type:r,targetPaths:n.targetPaths,valueAdapter:n.valueAdapter,displayName:t.combinedDisplayName,propName:n.propName,compName:n.compName};if(uniform_handler_1.uniformHandler.isUniformPartCurve(n.valueAdapter)){const e=utils_1.utils.cloneCCClass(n.valueAdapter);e.channelIndex=void 0,o.valueAdapter=e}else n.commonTarget&&(o.targetPaths=n.commonTarget.modifiers,o.valueAdapter=n.commonTarget.valueAdapter);(e=new editor_animation_combined_curve_1.default(this._rootNode,a)).curveInfo=o,this.addEditorCurve(e)}e.addPartEditorAnimCurve(t)}this.addEditorCurve(t)}}):console.warn("curves is null")}get rootNode(){return this._rootNode}generateClipData(e){return{keysPool:e.keys,commonTargetsPool:e.commonTargets,sharedData:this._editorSharedClipData}}createCombinedAndPartsAnimCurve(e,t){const r=this.generateClipData(e),a=new editor_animation_combined_curve_1.default(this._rootNode,r);a.initFromCurve(r,t),a.separateDataIntoParts(),this.addEditorCurve(a),a.getPartEditorAnimCurves().forEach(e=>{this.addEditorCurve(e)})}addInitPropDataMap(e,t){const r=new Map;t.forEach(e=>{r.set(e.key,e)}),this._initPropDataMap.set(e,r)}getInitPropData(e,t){if(!this._initPropDataMap.has(e)){let t=this._rootNode;"/"!==e&&(t=t.getChildByPath(e.substr(1)));const r=utils_1.utils.getAnimableProperties(t,t!==this._rootNode);r&&this.addInitPropDataMap(e,r)}const r=this._initPropDataMap.get(e);return r?r.get(t):null}getCreatedCurve(e,t){let r=null;const a=this._createdCurveMap.get(e);return a&&(r=a.get(t)),r}addEditorCurve(e){this._editorCurves.includes(e)||(this._editorCurves.push(e),this.addToCreatedCurveMap(e))}addToCreatedCurveMap(e){let t=this._createdCurveMap.get(e.nodePath);t||(t=new Map),t.set(e.propKey,e),this._createdCurveMap.set(e.nodePath,t)}rebuildCreatedCurveMap(){this._createdCurveMap.clear(),this._editorCurves.forEach(e=>{this.addToCreatedCurveMap(e)})}async getDumpData(){const e=[];for(let t=0;t<this._editorCurves.length;t++){const r=this._editorCurves[t],a=await r.getDumpData();r instanceof editor_animation_combined_curve_1.default?(e.push(a),await r.iteratorPartAnimCurves(async(t,r)=>{const i=await t.getDumpData();i.parentPropKey=a.key,a.partKeys?a.partKeys.push(i.key):a.partKeys=[i.key],e.push(i)})):r instanceof editor_animation_curve_1.default&&(r.isPartCurve||e.push(a))}const t=this._getAnimState();if(!t)return null;const r=t.clip;return{name:r.name,duration:r.duration,sample:r.sample,speed:r.speed,wrapMode:r.wrapMode,curves:e,events:r.events.map(e=>({frame:Math.round(e.frame*r.sample),func:e.func,params:e.params})),time:t.time||0,isLock:!1}}recalculateDuration(){let e=0;this._editorCurves.forEach(t=>{t instanceof editor_animation_curve_1.default&&(e=Math.max(t.getCurveDuration(),e))});const t=this._getAnimState();if(!t)return;const r=t.clip.events;if(r){const t=r[r.length-1];t&&(e=Math.max(t.frame,e))}this._editorSharedClipData.duration=e}async applyEditorCurvesToClip(){const e=this._getAnimState();if(!e)return;const t=e.clip;function r(e){for(let r=0;r<t.commonTargets.length;r++){const a=t.commonTargets[r];if(a===e||JSON.stringify(a)===JSON.stringify(e))return r}return t.commonTargets.push(e)-1}t.keys=[],t.commonTargets=[],t.sample=this._editorSharedClipData.sample,t.duration=this._editorSharedClipData.duration;const a=[];for(let e=0;e<this._editorCurves.length;e++){const i=this._editorCurves[e],n=i.curveInfo;if(i instanceof editor_animation_curve_1.default){if(i.isActive){const e=utils_1.utils.createPropertyCurve(n,t.keys,t.sample,i.keyframeData);i.isPartCurve&&n.commonTarget&&(e.commonTarget=r(n.commonTarget)),uniform_handler_1.uniformHandler.checkToProcessColorOfUniformCurve(n,e),a.push(e)}}else if(i instanceof editor_animation_combined_curve_1.default&&(await i.updateCurveData(),i.canMerge)){const e=utils_1.utils.createPropertyCurve(n,t.keys,t.sample,i.keyframeData);a.push(e)}}e.clip.curves=a}async updateCurveData(){await this.applyEditorCurvesToClip();const e=this._getAnimState();e&&(e.clip.curves=e.clip.curves,e._curveLoaded=!1,e.initialize(this._rootNode))}updateEventData(){const e=this._getAnimState();e&&(e.clip.updateEventDatas(),e._curveLoaded=!1,e.initialize(this._rootNode))}async changeSample(e){const t=this._getAnimState();if(!t)return!1;e=Math.round(e),(isNaN(e)||e<1)&&(e=1);const r=t.clip,a=r.events;return a&&a.forEach(t=>{const a=Math.round(t.frame*r.sample);t.frame=a/e}),this._editorSharedClipData.sample=e,this.recalculateDuration(),await this.updateCurveData(),!0}async changeSpeed(e){const t=this._getAnimState();return!!t&&(t.clip.speed=e,await this.updateCurveData(),!0)}async changeWrapMode(e){const t=this._getAnimState();return!!t&&(void 0===cc.AnimationClip.WrapMode[e]&&(e=0),e=Number(e),t.clip.wrapMode=e,await this.updateCurveData(),!0)}async removeNode(e){if(!this._getAnimState())return!1;for(let t=this._editorCurves.length-1;t>=0;t--){this._editorCurves[t].nodePath===e&&this._editorCurves.splice(t,1)}return this.rebuildCreatedCurveMap(),this.recalculateDuration(),await this.updateCurveData(),!0}async changeNodeDataPath(e,t){if(e===t)return!1;if(!this._getAnimState())return!1;if(void 0===e||void 0===t)return!1;let r=-1,a=[],i=null;if(this._editorCurves.forEach((n,o)=>{n.nodePath===e?(r=o,this._editorCurves[r].changeNodePath(t),this._editorCurves[r]instanceof editor_animation_combined_curve_1.default&&(i=this._editorCurves[r])):n.nodePath===t&&a.push(o)}),a.length>0)for(let e=a.length-1;e>=0;e--)this._editorCurves.splice(a[e],1);if(r>=0){if(i){const e=this.getInitPropData(i.nodePath,i.propKey);i.updateType(null===e||void 0===e?void 0:e.type)}return this.rebuildCreatedCurveMap(),await this.updateCurveData(),!0}return!1}async copyNode(e,t){const r=t.nodePath,a=e.curvesDump;if(a.length<=0)return console.warn("source of copyNode is empty"),!1;for(let e=0;e<a.length;e++){const t=a[e],i=t.key;let n;if(this.createProp(r,i)&&(n=this.getCreatedCurve(r,i)),n){const e=await utils_1.utils.getKeyframeDataFromDump(t.keyframes);for(let t=0;t<e.length;t++){const r=e[t];await n.createKey(r.frame,{newValue:r.value,easingMethod:r.easingMethod})}}}return await this.updateCurveData(),!0}async copyProp(e,t){var r,a,i,n;const o=t.nodePath,s=e.curvesDump;if(!t.propKeys)return console.warn("need a propKeys for target"),!1;if(t.propKeys&&t.propKeys.length!==s.length)return console.warn("src curves number doesn't equal to dst propKeys"),!1;if(s.length<=0)return console.warn("source of copyProp is empty"),!1;for(let e=0;e<s.length;e++){const u=s[e],c=u.key,d=t.propKeys[e];if(u.nodePath===o&&c===d)return!1;let l=this.getCreatedCurve(o,d);if((null===(r=u.type)||void 0===r?void 0:r.value)!==(null===(a=null===l||void 0===l?void 0:l.curveInfo.type)||void 0===a?void 0:a.value))return console.warn(`type of source ${null===(i=u.type)||void 0===i?void 0:i.value} doesn't equal to type of target ${null===(n=null===l||void 0===l?void 0:l.curveInfo.type)||void 0===n?void 0:n.value}`),!1;if(l){const e=await utils_1.utils.getKeyframeDataFromDump(u.keyframes);for(let t=0;t<e.length;t++){const r=e[t];await l.createKey(r.frame,{newValue:r.value,easingMethod:r.easingMethod})}}}return await this.updateCurveData(),!0}async copyKey(e,t){var r,a,i,n;const o=t.nodePath,s=e.curvesDump;if(!t.propKeys)return console.warn("need a propKeys for target"),!1;if(t.propKeys&&t.propKeys.length!==s.length)return console.warn("src curves number doesn't equal to dst propKeys"),!1;if(s.length<=0)return console.warn("source of copyKey is empty"),!1;for(let e=0;e<s.length;e++){const u=s[e],c=t.propKeys[e];let d=this.getCreatedCurve(o,c);if((null===(r=u.type)||void 0===r?void 0:r.value)!==(null===(a=null===d||void 0===d?void 0:d.curveInfo.type)||void 0===a?void 0:a.value))return console.warn(`type of source ${null===(i=u.type)||void 0===i?void 0:i.value} doesn't equal to type of target ${null===(n=null===d||void 0===d?void 0:d.curveInfo.type)||void 0===n?void 0:n.value}`),!1;if(d){const e=await utils_1.utils.getKeyframeDataFromDump(u.keyframes),r=e[0].frame;for(let a=0;a<e.length;a++){const i=e[a];await d.createKey(i.frame+t.startFrame-r,{newValue:i.value,easingMethod:i.easingMethod})}}}return this.recalculateDuration(),await this.updateCurveData(),!0}async copyEvent(e,t){const r=e.eventsDump;if(r.length<=0)return console.warn("source of copyEvent is empty"),!1;const a=r[0].frame;let i=[];for(let e=0;e<r.length;e++){const n=r[e];let o=t.startFrame+n.frame-a;i.push(o),this._deleteEvent([o])}for(let e=0;e<r.length;e++){const t=r[e];let a=i[e];this.addEvent(a,t.func,t.params)}return!0}async copyPropTo(e,t,r,a){if(e===r&&t===a)return!1;if(!this._getAnimState())return!1;if(!(e&&t&&r&&a))return!1;const i=this.getCreatedCurve(e,t);if(!i)return console.log(`can't find src prop Curve: nodePath:${e} propKey:${t}`),!1;const n=this.getCreatedCurve(r,a);if(!n)return console.log(`can't find dst prop Curve: nodePath:${r} propKey:${a}`),!1;const o=i.curveInfo,s=n.curveInfo;if(!o.type||!s.type)return!1;if(o.type.value!==s.type.value)return!1;const u=i.keyframeData;if(!u)return!1;for(let e=0;e<u.length;e++){const t=u[e];await n.createKey(t.frame,{newValue:t.value,easingMethod:t.easingMethod})}return await this.updateCurveData(),!0}async createProp(e,t){const r=this._getAnimState();if(!r)return!1;if(this.getCreatedCurve(e,t))return!0;const a=this.getInitPropData(e,t);if(!a)return!1;let i=[];const n=utils_1.utils.generateHierarchyPath(e);n&&i.push(n);const o=a.propData.valueAdapter,s=a.propData.targetPaths;i=i.concat(s);const u=r.clip,c=a.type.value,d=this.generateClipData(u),l={nodePath:e,propKey:t,type:a.type,targetPaths:i,valueAdapter:o,displayName:a.displayName,propName:a.name,compName:a.comp};if(utils_1.utils.getPartsOfType(c)){const e=new editor_animation_combined_curve_1.default(this._rootNode,d);e.curveInfo=l,e.separateDataIntoParts(),this.addEditorCurve(e),e.getPartEditorAnimCurves().forEach(e=>{this.addEditorCurve(e)})}else{const e=new editor_animation_curve_1.default(this._rootNode,d);e.curveInfo=l,this.addEditorCurve(e)}return await this.updateCurveData(),!0}async removeProp(e,t){if(!this._getAnimState())return!1;const r=this.getCreatedCurve(e,t);if(!r)return!1;let a=null;if(r instanceof editor_animation_combined_curve_1.default)a=r.getPartEditorAnimCurves();else if(r instanceof editor_animation_curve_1.default&&r.isPartCurve)return console.warn("can't remove part prop directly"),!1;for(let e=this._editorCurves.length-1;e>=0;e--){const t=this._editorCurves[e];t!==r?t instanceof editor_animation_curve_1.default&&a&&a.includes(t)&&this._editorCurves.splice(e,1):this._editorCurves.splice(e,1)}return this.rebuildCreatedCurveMap(),this.recalculateDuration(),await this.updateCurveData(),!0}async createKey(e,t,r=0,a){if(r<0)return!1;if(!this._getAnimState())return!1;const i=this.getCreatedCurve(e,t);return!!i&&(!!await i.createKey(r,a)&&(this.recalculateDuration(),await this.updateCurveData(),!0))}async moveKeys(e,t,r,a){if(r.length<=0)return!1;for(let e=0;e<r.length;e++)if(r[e]<0)return!1;let i=[];if(Array.isArray(a)?i=a:r.forEach(e=>{i.push(a)}),0===i.length)return!1;if(r.length!==i.length)return!1;if(!this._getAnimState())return!1;const n=this.getCreatedCurve(e,t);return!!n&&(!!n.moveKeys(r,i)&&(this.recalculateDuration(),await this.updateCurveData(),!0))}async removeKey(e,t,r){if(!this._getAnimState())return!1;if(null===r||void 0===r)return!1;Array.isArray(r)||(r=[r]);const a=this.getCreatedCurve(e,t);return!!a&&(!!a.removeKey(r)&&(this.recalculateDuration(),await this.updateCurveData(),!0))}async updateKey(e,t,r){if(null===r||void 0===r)return!1;if(!this._getAnimState())return!1;Array.isArray(r)||(r=[r]);const a=this.getCreatedCurve(e,t);return!!a&&(!!await a.updateKey(r)&&(await this.updateCurveData(),!0))}async copyKeysTo(e,t,r,a){if(!this._getAnimState())return!1;r.sort((e,t)=>e-t);const i=this.getCreatedCurve(e,t);return!!i&&(!!await i.copyKeysTo(r,a)&&(this.recalculateDuration(),await this.updateCurveData(),!0))}async spacingKeys(e,t,r,a){if(!this._getAnimState())return!1;const i=this.getCreatedCurve(e,t);return!!i&&(await i.spacingKeys(r,a),this.recalculateDuration(),await this.updateCurveData(),!0)}async clearKeys(e,t){if(!this._getAnimState())return!1;const r=this.getCreatedCurve(e,t);return!!r&&(!!r.clearKeys()&&(this.recalculateDuration(),await this.updateCurveData(),!0))}addEvent(e,t,r){if(e<0)return!1;const a=this._getAnimState();if(!a)return!1;const i=a.clip;if(!i)return console.log("Clip doesn't exist"),null;const n={frame:e/i.sample,func:t||"",params:r||[]};return i.events=i.events||[],i.events.push(n),i.events.sort((e,t)=>e.frame-t.frame),!!n&&(this.recalculateDuration(),this.updateEventData(),!0)}_deleteEvent(e){const t=this._getAnimState();if(!t)return!1;if(null===e||void 0===e)return!1;Array.isArray(e)||(e=[e]);const r=t.clip;if(!r)return console.log("Clip doesn't exist"),!1;const a=r.events;if(!a)return!1;const i=r.sample,n=[];return e.forEach(e=>{for(let t=a.length-1;t>=0;t--){const r=a[t];Math.round(r.frame*i)===e&&(a.splice(t,1),n.push(r))}}),!0}deleteEvent(e){let t=this._deleteEvent(e);return this.recalculateDuration(),this.updateEventData(),t}updateEvent(e,t){return!!this._getAnimState()&&(null!==e&&void 0!==e&&(Array.isArray(e)||(e=[e]),e.forEach(e=>{if(!this.deleteEvent([e]))return!1;t&&t.forEach(t=>{this.addEvent(e,t.func,t.params)})}),this.updateEventData(),!0))}moveEvents(e,t){const r=this._getAnimState();if(!r)return!1;if(null===e||void 0===e)return!1;const a=utils_1.utils.queryEvents(r.clip);if(!a)return!1;const i=r.clip.sample;for(let r=0;r<a.length;r++){const n=a[r],o=Math.round(n.frame*i);if(e.indexOf(o)>=0){let e=o+t;e<0&&(e=0),n.frame=e/i}}return this.recalculateDuration(),this.updateEventData(),!0}copyEventsTo(e,t){if(!e||e.length<=0)return!1;const r=this._getAnimState();if(!r)return!1;const a=utils_1.utils.queryEvents(r.clip);if(!a)return!1;e.sort((e,t)=>e-t);const i=r.clip.sample,n=e[0],o=[];for(let r=0;r<a.length;r++){const s=a[r],u=Math.round(s.frame*i);if(e.indexOf(u)>=0){let e=u-n+t;e<0&&(e=0),o.push({frame:e,func:s.func,params:s.params})}}return o.forEach(e=>{this.addEvent(e.frame,e.func,e.params)}),this.recalculateDuration(),this.updateEventData(),!0}async modifyCurveOfKey(e,t,r,a){if(!this._getAnimState())return!1;const i=this.getCreatedCurve(e,t);return!!i&&(!!i.modifyCurveOfKey(r,a)&&(await this.updateCurveData(),!0))}async getPropValueAtFrame(e,t,r){const a=this.getCreatedCurve(e,t);return a?await a.getPropValueAtFrame(r):null}_getAnimState(){if(!this._animComp)return console.debug(`can't find Animation of Node:${this._rootNode.uuid}`),null;const e=utils_1.utils.getClipName(this._clipUuid,this._animComp);return e?""===e?(console.debug(`clipName is empty in Node(${this._rootNode.uuid}) Clip(${this._clipUuid})`),null):this._animComp.getState(e):(console.debug(`can't find clip in Node:${this._rootNode.uuid}`),null)}}exports.default=EditorAnimationClip;