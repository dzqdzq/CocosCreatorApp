"use strict";var __importDefault=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(exports,"__esModule",{value:!0});const cc_1=require("cc"),editor_animation_curve_1=__importDefault(require("./editor-animation-curve")),editor_animation_combined_curve_1=__importDefault(require("./editor-animation-combined-curve")),utils_1=require("./utils"),uniform_handler_1=require("./uniform-handler"),embedded_player_1=require("cc/editor/embedded-player"),asset_1=require("../../../utils/asset");class EditorAnimationClip{constructor(e,t,a){this._initPropDataMap=new Map,this._createdCurveMap=new Map,this._editorCurves=[],this._editEmbeddedPlayerMap={},this._rootNode=e,this._clipUuid=t,this._animComp=e.getComponent(cc_1.Animation),this._animState=a,this.init()}refreshData(e,t){this._rootNode=e,this._clipUuid=t,this._animComp=e.getComponent(cc_1.Animation);for(let t=0;t<this._editorCurves.length;t++)this._editorCurves[t].node=e}init(){const e=this._getAnimState();if(!e)return;const t=e.clip;if(this._editorSharedClipData={sample:t.sample,duration:t.duration},t.upgradeUntypedTracks((e,t)=>{let a=null;if(t){if(t instanceof cc_1.animation.UniformProxyFactory){const r=e.trace(this._rootNode);a=uniform_handler_1.uniformHandler.getUniformDumpData(r,t).type}}else{const t=e.trace(this._rootNode,0,e.length-1),r=e.length-1,i=e.isPropertyAt(r)?e.parsePropertyAt(r):e.isElementAt(r)?e.parseElementAt(r):null;if(null===i||"number"==typeof i)return null;if(cc_1.CCClass._isCCClass(t.constructor)){const e=cc_1.CCClass.attr(t.constructor,i);a=t instanceof cc_1.Node&&("position"===i||"eulerAngles"===i||"scale"===i)?"cc.Vec3":e.type}else a=typeof t[i]}return utils_1.utils.getTrackTypeBy(a)}),t[cc_1.editorExtrasTag]&&t[cc_1.editorExtrasTag].embeddedPlayerGroups||(t[cc_1.editorExtrasTag]={embeddedPlayerGroups:[]}),!t.tracks)return void console.warn("tracks is null");const a=this.generateClipData(t);for(const e of t.tracks){const t=utils_1.utils.getCurveInfoByTrack(this._rootNode,e);if(e instanceof cc_1.animation.RealTrack||e instanceof cc_1.animation.QuatTrack||e instanceof cc_1.animation.ObjectTrack){const r=e.channel.curve,i=new editor_animation_curve_1.default(this._rootNode,a);i.initFromCurve(t,r),this.addEditorCurve(i)}else e instanceof cc_1.animation.VectorTrack||e instanceof cc_1.animation.ColorTrack||e instanceof cc_1.animation.SizeTrack?this.createCombinedAndPartsAnimCurve(a,t,e):console.warn("unknown track:",e)}const r=t[embedded_player_1.getEmbeddedPlayersTag]();this._editEmbeddedPlayerMap={};for(const e of r){const a={begin:Math.round(e.begin*t.sample),end:Math.round(e.end*t.sample),reconciledSpeed:e.reconciledSpeed,group:e[cc_1.editorExtrasTag]&&e[cc_1.editorExtrasTag].group,playable:utils_1.utils.getPlayableInfo(e.playable)||void 0},r=utils_1.utils.calcEmbeddedPlayerKey(a);this._editEmbeddedPlayerMap[r]=a}}get rootNode(){return this._rootNode}generateClipData(e){return{sharedData:this._editorSharedClipData}}createCombinedAndPartsAnimCurve(e,t,a){const r=new editor_animation_combined_curve_1.default(this._rootNode,e);r.initFromTrack(t,a),this.addEditorCurve(r),r.getPartEditorAnimCurves().forEach(e=>{this.addEditorCurve(e)})}addInitPropDataMap(e,t){const a=new Map;t.forEach(e=>{a.set(e.key,e)}),this._initPropDataMap.set(e,a)}getInitPropData(e,t){if(!this._initPropDataMap.has(e)){let t=this._rootNode;"/"!==e&&(t=t.getChildByPath(e.substr(1)));const a=utils_1.utils.getAnimableProperties(t,t!==this._rootNode);a&&this.addInitPropDataMap(e,a)}const a=this._initPropDataMap.get(e);return a?a.get(t):null}getCreatedCurve(e,t){let a=null;const r=this._createdCurveMap.get(e);return r&&(a=r.get(t)),a}addEditorCurve(e){this._editorCurves.includes(e)||(this._editorCurves.push(e),this.addToCreatedCurveMap(e))}addToCreatedCurveMap(e){let t=this._createdCurveMap.get(e.nodePath);t||(t=new Map),t.set(e.propKey,e),this._createdCurveMap.set(e.nodePath,t)}rebuildCreatedCurveMap(){this._createdCurveMap.clear(),this._editorCurves.forEach(e=>{this.addToCreatedCurveMap(e)})}async getDumpData(){const e=[];for(let t=0;t<this._editorCurves.length;t++){const a=this._editorCurves[t],r=await a.getDumpData();a instanceof editor_animation_combined_curve_1.default?(e.push(r),await a.iteratorPartAnimCurves(async(t,a)=>{const i=await t.getDumpData();i.parentPropKey=r.key,r.partKeys?r.partKeys.push(i.key):r.partKeys=[i.key],e.push(i)})):a instanceof editor_animation_curve_1.default&&(a.isPartCurve||e.push(r))}const t=this._getAnimState();if(!t)return null;const a=t.clip;return{name:a.name,duration:a.duration,sample:a.sample,speed:a.speed,wrapMode:a.wrapMode,curves:e,events:a.events.map(e=>({frame:Math.round(e.frame*a.sample),func:e.func,params:e.params})),embeddedPlayers:Array.from(a[embedded_player_1.getEmbeddedPlayersTag]()).map(e=>({begin:Math.round(e.begin*a.sample),end:Math.round(e.end*a.sample),reconciledSpeed:e.reconciledSpeed,group:e[cc_1.editorExtrasTag]&&e[cc_1.editorExtrasTag].group,playable:utils_1.utils.getPlayableInfo(e.playable)||void 0})),embeddedPlayerGroups:a[cc_1.editorExtrasTag].embeddedPlayerGroups,time:t.time||0,isLock:!1}}recalculateDuration(){if(!this._getAnimState()||this._animComp instanceof cc_1.SkeletalAnimation)return;let e=0;this._editorCurves.forEach(t=>{t instanceof editor_animation_curve_1.default&&(e=Math.max(t.getCurveDuration(),e))}),this._editorSharedClipData.duration=e}async applyEditorCurvesToClip(){const e=this._getAnimState();if(!e)return;const t=e.clip;t.sample=this._editorSharedClipData.sample,t.duration=this._editorSharedClipData.duration;const a=[];try{for(let e=0;e<this._editorCurves.length;e++){const r=this._editorCurves[e];if(r instanceof editor_animation_curve_1.default){if(!r.isPartCurve){const e=this.createTrack(r,t.sample);e&&a.push(e)}}else if(r instanceof editor_animation_combined_curve_1.default){await r.updateCurveData();const e=this.createTrack(r,t.sample);e&&a.push(e)}}}catch(e){return void console.error(e)}t.clearTracks(),a.forEach(e=>{t.addTrack(e)})}async applyEditorEmbeddedPlayersToClip(){const e=this._getAnimState();if(!e)return;const t=Object.values(this._editEmbeddedPlayerMap);e.clip[embedded_player_1.clearEmbeddedPlayersTag]();for(const a of t){const t=new embedded_player_1.EmbeddedPlayer;if(t.begin=a.begin/e.clip.sample,t.end=a.end/e.clip.sample,t.reconciledSpeed=a.reconciledSpeed,t[cc_1.editorExtrasTag]={group:a.group},a.playable){if("animation-clip"===a.playable.type){const e=new embedded_player_1.EmbeddedAnimationClipPlayable;a.playable.clip&&(e.clip=await(0,asset_1.loadAssetUncached)(a.playable.clip,cc_1.AnimationClip)),a.playable.path&&(e.path=a.playable.path),t.playable=e}if("particle-system"===a.playable.type){const e=new embedded_player_1.EmbeddedParticleSystemPlayable;a.playable.path&&(e.path=a.playable.path),t.playable=e}}e.clip[embedded_player_1.addEmbeddedPlayerTag](t)}}updateEditorEmbeddedPlayers(){const e=this._getAnimState();e&&(e.clip.duration=this._editorSharedClipData.duration,utils_1.utils.initAninState(e,this._rootNode))}_ensureEditorExtras(e){e[cc_1.editorExtrasTag]||(e[cc_1.editorExtrasTag]={})}_getRealKeyframeData(e){const t={value:e.value,interpolationMode:e.interpMode,rightTangent:e.outTangent,rightTangentWeight:e.outTangentWeight,leftTangent:e.inTangent,leftTangentWeight:e.inTangentWeight,tangentWeightMode:e.tangentWeightMode,easingMethod:e.easingMethod};return void 0!==e.tangentMode&&(this._ensureEditorExtras(t),t[cc_1.editorExtrasTag].tangentMode=e.tangentMode),void 0!==e.broken&&(this._ensureEditorExtras(t),t[cc_1.editorExtrasTag].broken=e.broken),t}createTrack(e,t){let a=null;const r=e.curveInfo,i=r.type.value;if(e instanceof editor_animation_combined_curve_1.default){switch(i){case"cc.Vec2":case"cc.Vec3":case"cc.Vec4":a=new cc_1.animation.VectorTrack,"cc.Vec2"===i?a.componentsCount=2:"cc.Vec3"===i?a.componentsCount=3:"cc.Vec4"===i&&(a.componentsCount=4);break;case"cc.Color":a=new cc_1.animation.ColorTrack;break;case"cc.Size":a=new cc_1.animation.SizeTrack;break;default:console.error("unknown track type:",i)}if(a){const r=e.getPartEditorAnimCurves(),i=a.channels();r.forEach((e,a)=>{const r=i[a];e.keyframeData.forEach(a=>{const i=this._getRealKeyframeData(a);r.curve.addKeyFrame(a.frame/t,i),e.partName&&(r.name=e.partName)}),r.curve.preExtrapolation=e.preExtrap,r.curve.postExtrapolation=e.postExtrap})}}else if(e instanceof editor_animation_curve_1.default){switch(i){case"cc.Quat":a=new cc_1.animation.QuatTrack;break;case"cc.Number":case"Number":case"Integer":case"Float":a=new cc_1.animation.RealTrack;break;default:a=new cc_1.animation.ObjectTrack}if(a){const r=a.channel.curve;e.keyframeData.forEach(e=>{if(r instanceof cc_1.RealCurve){const a=this._getRealKeyframeData(e);r.addKeyFrame(e.frame/t,a)}else r instanceof cc_1.QuatCurve?r.addKeyFrame(e.frame/t,{value:e.value}):r.addKeyFrame(e.frame/t,e.value)}),(r instanceof cc_1.QuatCurve||r instanceof cc_1.RealCurve)&&(r.preExtrapolation=e.preExtrap,r.postExtrapolation=e.postExtrap)}}return a&&(a.path=e.curveInfo.targetPaths,r.valueAdapter&&(a.proxy=r.valueAdapter)),a}async updateCurveData(){await this.applyEditorCurvesToClip();const e=this._getAnimState();e&&utils_1.utils.initAninState(e,this._rootNode)}updateEventData(){const e=this._getAnimState();e&&(e.clip.updateEventDatas(),e.clip.duration=this._editorSharedClipData.duration,utils_1.utils.initAninState(e,this._rootNode))}async changeSample(e){const t=this._getAnimState();if(!t)return!1;e=Math.round(e),(isNaN(e)||e<1)&&(e=1);const a=t.clip,r=a.events;return r&&r.forEach(t=>{const r=Math.round(t.frame*a.sample);t.frame=r/e}),this._editorSharedClipData.sample=e,this.recalculateDuration(),await this.updateCurveData(),!0}async changeSpeed(e){const t=this._getAnimState();return!!t&&(t.clip.speed=e,await this.updateCurveData(),!0)}async changeWrapMode(e){const t=this._getAnimState();return!!t&&(void 0===cc.AnimationClip.WrapMode[e]&&(e=0),e=Number(e),t.clip.wrapMode=e,await this.updateCurveData(),!0)}async removeNode(e){if(!this._getAnimState())return!1;for(let t=this._editorCurves.length-1;t>=0;t--){this._editorCurves[t].nodePath===e&&this._editorCurves.splice(t,1)}return this.rebuildCreatedCurveMap(),this.recalculateDuration(),await this.updateCurveData(),!0}async changeNodeDataPath(e,t){if(e===t)return!1;if(!this._getAnimState())return!1;if(void 0===e||void 0===t)return!1;let a=-1;const r=[];let i=null;for(let n=0;n<this._editorCurves.length;n++){const o=this._editorCurves[n];o.nodePath===e?(a=n,this._editorCurves[a].changeNodePath(t),this._editorCurves[a]instanceof editor_animation_combined_curve_1.default&&(i=this._editorCurves[a])):o.nodePath===t&&r.push(n)}if(r.length>0)for(let e=r.length-1;e>=0;e--)this._editorCurves.splice(r[e],1);if(a>=0){if(i){const e=this.getInitPropData(i.nodePath,i.propKey);i.updateType(null===e||void 0===e?void 0:e.type)}return this.rebuildCreatedCurveMap(),await this.updateCurveData(),!0}return!1}async copyNode(e,t){const a=t.nodePath,r=e.curvesDump;if(r.length<=0)return console.warn("source of copyNode is empty"),!1;for(let e=0;e<r.length;e++){const t=r[e],i=t.key;let n;if(await this.createProp(a,i)&&(n=this.getCreatedCurve(a,i)),!(this.getCreatedCurve(t.nodePath,i)instanceof editor_animation_combined_curve_1.default)&&n){const e=await utils_1.utils.getKeyframeDataFromDump(t.keyframes);for(let t=0;t<e.length;t++){const a=e[t],r={newValue:a.value};utils_1.utils.copyCurveData(a,r),await n.createKey(a.frame,r)}}}return this.recalculateDuration(),await this.updateCurveData(),!0}async copyProp(e,t){var a,r,i,n;const o=t.nodePath,s=e.curvesDump;if(!t.propKeys)return console.warn("need a propKeys for target"),!1;if(t.propKeys&&t.propKeys.length!==s.length)return console.warn("src curves number doesn't equal to dst propKeys"),!1;if(s.length<=0)return console.warn("source of copyProp is empty"),!1;for(let e=0;e<s.length;e++){const d=s[e],u=(d.key,t.propKeys[e]),c=this.getCreatedCurve(o,u);if((null===(a=d.type)||void 0===a?void 0:a.value)!==(null===(r=null===c||void 0===c?void 0:c.curveInfo.type)||void 0===r?void 0:r.value))return console.warn(`type of source ${null===(i=d.type)||void 0===i?void 0:i.value} doesn't equal to type of target ${null===(n=null===c||void 0===c?void 0:c.curveInfo.type)||void 0===n?void 0:n.value}`),!1;if(c){const e=await utils_1.utils.getKeyframeDataFromDump(d.keyframes);for(let t=0;t<e.length;t++){const a=e[t],r={newValue:a.value};utils_1.utils.copyCurveData(a,r),await c.createKey(a.frame,r)}}}return this.recalculateDuration(),await this.updateCurveData(),!0}async copyKey(e,t){var a,r,i,n;const o=t.nodePath,s=e.curvesDump;if(!t.propKeys)return console.warn("need a propKeys for target"),!1;if(t.propKeys&&t.propKeys.length!==s.length)return console.warn("src curves number doesn't equal to dst propKeys"),!1;if(s.length<=0)return console.warn("source of copyKey is empty"),!1;for(let e=0;e<s.length;e++){const d=s[e],u=t.propKeys[e],c=this.getCreatedCurve(d.nodePath,u);if(c instanceof editor_animation_curve_1.default&&c.parentCurve&&await this.createProp(o,c.parentCurve.propKey),!await this.createProp(o,u)){console.warn(`fail to create prop: ${o} ${u}`);continue}const l=this.getCreatedCurve(o,u);if((null===(a=d.type)||void 0===a?void 0:a.value)!==(null===(r=null===l||void 0===l?void 0:l.curveInfo.type)||void 0===r?void 0:r.value))return console.warn(`type of source ${null===(i=d.type)||void 0===i?void 0:i.value} doesn't equal to type of target ${null===(n=null===l||void 0===l?void 0:l.curveInfo.type)||void 0===n?void 0:n.value}`),!1;if(l){const e=await utils_1.utils.getKeyframeDataFromDump(d.keyframes),a=e[0].frame;for(let r=0;r<e.length;r++){const i=e[r],n={newValue:i.value};utils_1.utils.copyCurveData(i,n),await l.createKey(i.frame+t.startFrame-a,n)}}}return this.recalculateDuration(),await this.updateCurveData(),!0}copyEvent(e,t){const a=e.eventsDump;if(a.length<=0)return console.warn("source of copyEvent is empty"),!1;const r=a[0].frame,i=[];for(let e=0;e<a.length;e++){const n=a[e],o=t.startFrame+n.frame-r;i.push(o),this._deleteEvent([o])}for(let e=0;e<a.length;e++){const t=a[e],r=i[e];this.addEvent(r,t.func,t.params)}return!0}async copyPropTo(e,t,a,r){if(e===a&&t===r)return!1;if(!this._getAnimState())return!1;if(!(e&&t&&a&&r))return!1;const i=this.getCreatedCurve(e,t);if(!i)return console.log(`can't find src prop Curve: nodePath:${e} propKey:${t}`),!1;const n=this.getCreatedCurve(a,r);if(!n)return console.log(`can't find dst prop Curve: nodePath:${a} propKey:${r}`),!1;const o=i.curveInfo,s=n.curveInfo;if(!o.type||!s.type)return!1;if(o.type.value!==s.type.value)return!1;const d=i.keyframeData;if(!d)return!1;for(let e=0;e<d.length;e++){const t=d[e];await n.createKey(t.frame,{newValue:t.value})}return this.recalculateDuration(),await this.updateCurveData(),!0}async createProp(e,t){const a=this._getAnimState();if(!a)return!1;if(this.getCreatedCurve(e,t))return!0;const r=this.getInitPropData(e,t);if(!r)return!1;const i=new cc_1.animation.TrackPath,n=utils_1.utils.generateHierarchyPath(e);n&&i.append(n);const o=r.propData.valueAdapter,s=r.propData.targetPaths;i.append(s);const d=a.clip,u=r.type.value,c=this.generateClipData(d),l={nodePath:e,propKey:t,type:r.type,targetPaths:i,valueAdapter:o,displayName:r.displayName,propName:r.name,compName:r.comp};if(utils_1.utils.getPartsOfType(u)){const e=new editor_animation_combined_curve_1.default(this._rootNode,c);e.curveInfo=l,e.separateDataIntoParts(),this.addEditorCurve(e),e.getPartEditorAnimCurves().forEach(e=>{this.addEditorCurve(e)})}else{const e=new editor_animation_curve_1.default(this._rootNode,c);e.curveInfo=l,this.addEditorCurve(e)}return await this.updateCurveData(),!0}async removeProp(e,t){if(!this._getAnimState())return!1;const a=this.getCreatedCurve(e,t);if(!a)return!1;let r=null;if(a instanceof editor_animation_combined_curve_1.default)r=a.getPartEditorAnimCurves();else if(a instanceof editor_animation_curve_1.default&&a.isPartCurve)return console.warn("can't remove part prop directly"),!1;for(let e=this._editorCurves.length-1;e>=0;e--){const t=this._editorCurves[e];t!==a?t instanceof editor_animation_curve_1.default&&r&&r.includes(t)&&this._editorCurves.splice(e,1):this._editorCurves.splice(e,1)}return this.rebuildCreatedCurveMap(),this.recalculateDuration(),await this.updateCurveData(),!0}async createKey(e,t,a=0,r){if(a<0)return!1;if(!this._getAnimState())return!1;const i=this.getCreatedCurve(e,t);return!!i&&(!!await i.createKey(a,r)&&(this.recalculateDuration(),await this.updateCurveData(),!0))}async moveKeys(e,t,a,r){if(a.length<=0)return!1;for(let e=0;e<a.length;e++)if(a[e]<0)return!1;let i=[];if(Array.isArray(r)?i=r:a.forEach(e=>{i.push(r)}),0===i.length)return!1;if(a.length!==i.length)return!1;if(!this._getAnimState())return!1;const n=this.getCreatedCurve(e,t);return!!n&&(!!n.moveKeys(a,i)&&(this.recalculateDuration(),await this.updateCurveData(),!0))}async removeKey(e,t,a){if(!this._getAnimState())return!1;if(null===a||void 0===a)return!1;Array.isArray(a)||(a=[a]);const r=this.getCreatedCurve(e,t);return!!r&&(!!r.removeKey(a)&&(this.recalculateDuration(),await this.updateCurveData(),!0))}async updateKey(e,t,a){if(null===a||void 0===a)return!1;if(!this._getAnimState())return!1;Array.isArray(a)||(a=[a]);const r=this.getCreatedCurve(e,t);return!!r&&(!!await r.updateKey(a)&&(await this.updateCurveData(),!0))}async copyKeysTo(e,t,a,r){if(!this._getAnimState())return!1;a.sort((e,t)=>e-t);const i=this.getCreatedCurve(e,t);return!!i&&(!!await i.copyKeysTo(a,r)&&(this.recalculateDuration(),await this.updateCurveData(),!0))}async spacingKeys(e,t,a,r){if(!this._getAnimState())return!1;const i=this.getCreatedCurve(e,t);return!!i&&(await i.spacingKeys(a,r),this.recalculateDuration(),await this.updateCurveData(),!0)}async clearKeys(e,t){if(!this._getAnimState())return!1;const a=this.getCreatedCurve(e,t);return!!a&&(!!a.clearKeys()&&(this.recalculateDuration(),await this.updateCurveData(),!0))}addEvent(e,t,a){if(e<0)return!1;const r=this._getAnimState();if(!r)return!1;const i=r.clip;if(!i)return console.log("Clip doesn't exist"),null;const n={frame:e/i.sample,func:t||"",params:a||[]};return i.events=i.events||[],i.events.push(n),i.events.sort((e,t)=>e.frame-t.frame),!!n&&(this.updateEventData(),!0)}_getEditClip(){const e=this._getAnimState();if(!e)return null;const t=e.clip;return t||(console.log("Clip doesn't exist"),null)}addEmbeddedPlayerGroup(e){const t=this._getEditClip();if(!t||!e.key||!e.type)return!1;if(t[cc_1.editorExtrasTag]&&t[cc_1.editorExtrasTag].embeddedPlayerGroups){if(t[cc_1.editorExtrasTag].embeddedPlayerGroups.find(t=>t.key===e.key))return!1}else t[cc_1.editorExtrasTag]={embeddedPlayerGroups:[]};return t[cc_1.editorExtrasTag].embeddedPlayerGroups.push({key:e.key,name:e.name,type:e.type}),!0}async removeEmbeddedPlayerGroup(e){const t=this._getEditClip();return!!t&&(t[cc_1.editorExtrasTag].embeddedPlayerGroups=t[cc_1.editorExtrasTag].embeddedPlayerGroups.filter(t=>t.key!==e),this._clearEmbeddedPlayerGroup(e),await this.applyEditorEmbeddedPlayersToClip(),this.updateEditorEmbeddedPlayers(),!0)}_clearEmbeddedPlayerGroup(e){return Object.keys(this._editEmbeddedPlayerMap).forEach(t=>{this._editEmbeddedPlayerMap[t].group===e&&delete this._editEmbeddedPlayerMap[t]}),!0}async clearEmbeddedPlayerGroup(e){return this._clearEmbeddedPlayerGroup(e),await this.applyEditorEmbeddedPlayersToClip(),this.updateEditorEmbeddedPlayers(),!0}async addEmbeddedPlayer(e){if(e.end<e.begin||e.begin<0)return!1;return!!this._addEmbeddedPlayer(e)&&(await this.applyEditorEmbeddedPlayersToClip(),this.updateEditorEmbeddedPlayers(),!0)}_addEmbeddedPlayer(e){const t=utils_1.utils.calcEmbeddedPlayerKey(e);return this._editEmbeddedPlayerMap||(this._editEmbeddedPlayerMap={}),this._editEmbeddedPlayerMap[t],this._editEmbeddedPlayerMap[t]=e,!0}async deleteEmbeddedPlayer(e){return!!this._deleteEmbeddedPlayer(e)&&(await this.applyEditorEmbeddedPlayersToClip(),this.updateEditorEmbeddedPlayers(),!0)}async clearEmbeddedPlayer(e){delete this._editEmbeddedPlayerMap[e],await this.applyEditorEmbeddedPlayersToClip(),this.updateEditorEmbeddedPlayers()}_deleteEmbeddedPlayer(e){const t=utils_1.utils.calcEmbeddedPlayerKey(e);return!!this._editEmbeddedPlayerMap[t]&&(delete this._editEmbeddedPlayerMap[t],!0)}async updateEmbeddedPlayer(e,t){if(!this._getEditClip())return!1;const a=utils_1.utils.calcEmbeddedPlayerKey(e);if(!this._editEmbeddedPlayerMap[a])return!1;delete this._editEmbeddedPlayerMap[a];const r=utils_1.utils.calcEmbeddedPlayerKey(t);return this._editEmbeddedPlayerMap[r]=t,await this.applyEditorEmbeddedPlayersToClip(),this.updateEditorEmbeddedPlayers(),!0}_deleteEvent(e){const t=this._getAnimState();if(!t)return!1;if(null===e||void 0===e)return!1;Array.isArray(e)||(e=[e]);const a=t.clip;if(!a)return console.log("Clip doesn't exist"),!1;const r=a.events;if(!r)return!1;const i=a.sample,n=[];return e.forEach(e=>{for(let t=r.length-1;t>=0;t--){const a=r[t];Math.round(a.frame*i)===e&&(r.splice(t,1),n.push(a))}}),!0}deleteEvent(e){const t=this._deleteEvent(e);return this.updateEventData(),t}updateEvent(e,t){return!!this._getAnimState()&&(null!==e&&void 0!==e&&(Array.isArray(e)||(e=[e]),e.forEach(e=>{if(!this.deleteEvent([e]))return!1;t&&t.forEach(t=>{this.addEvent(e,t.func,t.params)})}),this.updateEventData(),!0))}moveEvents(e,t){const a=this._getAnimState();if(!a)return!1;if(null===e||void 0===e)return!1;const r=utils_1.utils.queryEvents(a.clip);if(!r)return!1;const i=a.clip.sample;for(let a=0;a<r.length;a++){const n=r[a],o=Math.round(n.frame*i);if(e.indexOf(o)>=0){let e=o+t;e<0&&(e=0),n.frame=e/i}}return this.updateEventData(),!0}copyEventsTo(e,t){if(!e||e.length<=0)return!1;const a=this._getAnimState();if(!a)return!1;const r=utils_1.utils.queryEvents(a.clip);if(!r)return!1;e.sort((e,t)=>e-t);const i=a.clip.sample,n=e[0],o=[];for(let a=0;a<r.length;a++){const s=r[a],d=Math.round(s.frame*i);if(e.indexOf(d)>=0){let e=d-n+t;e<0&&(e=0),o.push({frame:e,func:s.func,params:s.params})}}return o.forEach(e=>{this.addEvent(e.frame,e.func,e.params)}),this.updateEventData(),!0}async modifyCurveOfKey(e,t,a,r){var i;if(!this._getAnimState())return!1;const n=this.getCreatedCurve(e,t);if(!n)return!1;const o=null===(i=n.curveInfo.type)||void 0===i?void 0:i.value;return!(!o||!utils_1.allowModifyCurveType.includes(o))&&(!!n.modifyCurveOfKey(a,r)&&(await this.updateCurveData(),!0))}async getPropValueAtFrame(e,t,a){const r=this.getCreatedCurve(e,t);return r?await r.getPropValueAtFrame(a):null}_getAnimState(){return this._animState}}exports.default=EditorAnimationClip;