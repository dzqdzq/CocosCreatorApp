"use strict";var __importDefault=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(exports,"__esModule",{value:!0}),exports.EditorAnimationAuxCurve=exports.createEditorCurve=exports.syncToRealCurve=void 0;const cc_1=require("cc"),editor_animation_curve_base_1=__importDefault(require("./editor-animation-curve-base")),utils_1=require("./utils"),dump_1=__importDefault(require("../../../export/dump"));function syncToRealCurve(e,t){const a=e.getClipSample(),r=e.keyframeData.map(e=>[e.frame/a,{value:e.value,interpolationMode:e.interpMode,leftTangent:e.inTangent,rightTangent:e.outTangent,leftTangentWeight:e.inTangentWeight,rightTangentWeight:e.outTangentWeight,tangentWeightMode:e.tangentWeightMode}]);return t.assignSorted(r),t.preExtrapolation=e.preExtrap,t.postExtrapolation=e.postExtrap,t}function createEditorCurve(e,t,a,r){return EditorAnimationAuxCurve.create(e,t,a,r)}exports.syncToRealCurve=syncToRealCurve,exports.createEditorCurve=createEditorCurve;class EditorAnimationAuxCurve extends editor_animation_curve_base_1.default{constructor(e,t){super(),this._node=e,this._clipData=t}static create(e,t,a,r){const i=new EditorAnimationAuxCurve(a,r);return i.initFromCurve({displayName:e,nodePath:"",propKey:"",propName:e,targetPaths:new cc_1.animation.TrackPath,type:{value:"Float"}},t),i}get targetPaths(){return this._curveInfo.targetPaths}get displayName(){return this._curveInfo.displayName}async getDumpData(){var e;const t=utils_1.utils.dumpKeyframeData(this._keyframeData),a=null===(e=this._curveInfo.type)||void 0===e?void 0:e.value,r=utils_1.utils.isTypeSupportCurve(a);return{nodePath:"",keyframes:t,displayName:this.displayName,key:this.displayName,type:this._curveInfo.type,preExtrap:this.preExtrap,postExtrap:this.postExtrap,isCurveSupport:r}}getCompName(){return this._curveInfo.compName}getPropName(){return this._curveInfo.propName}changeNodePath(e){throw new Error("Method not supported.")}queryKeyIndex(e){if(!this._keyframeData)return-1;for(let t=0;t<this._keyframeData.length;t++){if(this._keyframeData[t].frame===e)return t}return-1}queryKeyframe(e){if(!this._keyframeData)return null;for(let t=0;t<this._keyframeData.length;t++){const a=this._keyframeData[t];if(a.frame===e)return a}return null}getValidKeys(e){if(!this._keyframeData)return null;const t=[];for(let a=0;a<this._keyframeData.length;a++){const r=this._keyframeData[a].frame;e.includes(r)&&t.push(r)}return t}hasKey(e){return null!==this.queryKeyframe(e)}async createKey(e=0,t){var a;const r=this.propData;let i;if(void 0!==(null===t||void 0===t?void 0:t.newValue))i=null===t||void 0===t?void 0:t.newValue;else{const{curve:t,sample:a}=this._getMockCurve();i=t.evaluate(e/a)}const n=this.queryKeyframe(e);if(n)return n.value=i,t&&utils_1.utils.copyCurveData(t,n),!0;let s=0;for(s=0;s<this._keyframeData.length&&!(this._keyframeData[s].frame>e);s++);const u={frame:e,value:i,interpMode:cc_1.RealInterpolationMode.LINEAR};return utils_1.utils.isTypeSupportCurve(null===(a=r.type)||void 0===a?void 0:a.value)&&(u.inTangent=0,u.inTangentWeight=1,u.outTangent=0,u.outTangentWeight=1,u.tangentWeightMode=cc_1.TangentWeightMode.NONE,u.tangentMode=0),t&&utils_1.utils.copyCurveData(t,u),this._keyframeData.splice(s,0,u),this._isDirty=!0,!0}async moveKeys(e,t){if(!this._keyframeData)return!1;const a=[];for(let t=0;t<e.length;t++){const r=e[t],i=this.queryKeyIndex(r);if(i<0)return!1;a.push(this._keyframeData[i]),this._keyframeData.splice(i,1)}for(let e=0;e<a.length;e++){const r=a[e];let i=r.frame+t[e];i<0&&(i=0);let n=0,s=!1,u=!1;if(this._keyframeData.length>0){for(let e=0;e<this._keyframeData.length;e++){const t=this._keyframeData[e].frame;if(t>=i){n=e,s=!0,t===i&&(u=!0);break}}s||(i<=this._keyframeData[0].frame?n=0:i>this._keyframeData[this._keyframeData.length-1].frame&&(n=this._keyframeData.length))}const o=u?1:0,l={frame:i,value:r.value};utils_1.utils.copyCurveData(r,l),this._keyframeData.splice(n,o,l)}return this._isDirty=!0,!0}async removeKey(e){return e.forEach(e=>{const t=this.queryKeyIndex(e);t<0||this._keyframeData.splice(t,1)}),this._isDirty=!0,!0}async updateKey(e){for(let t=0;t<e.length;t++){const a=e[t];if(!this.queryKeyframe(a))return!1}return this._isDirty=!0,!0}async copyKeysTo(e,t){for(let a=0;a<e.length;a++){const r=e[a],i=this.queryKeyframe(r);if(i){const a={newValue:i.value};utils_1.utils.copyCurveData(i,a),await this.createKey(t+r-e[0],a)}}return this._isDirty=!0,!0}async spacingKeys(e,t){if(e.length>1){e.sort((e,t)=>e-t);const a=e[0],r=[],i=[];for(let n=1;n<e.length;n++)r.push(e[n]),i.push(a+n*t-e[n]);return this.moveKeys(r,i),this._isDirty=!0,!0}return!1}async clearKeys(){return this._keyframeData=[],!0}async modifyCurveOfKey(e,t){const a=this.queryKeyframe(e);return!!a&&(utils_1.utils.copyCurveData(t,a),this._isDirty=!0,!0)}getCurveDuration(){let e=0;if(this._keyframeData&&this._keyframeData.length>0){const t=this._keyframeData[this._keyframeData.length-1].frame,a=this.getCompName(),r=this.getPropName(),i=this.getClipSample();e=a===cc_1.js.getClassName(cc_1.Sprite)&&"spriteFrame"===r?(t+1)/i:t/i}return e}async getPropValueAtFrame(e){var t,a;let r=null;const i=this.propData;if(0===this._keyframeData.length){const e=utils_1.utils.getDefaultValue(null===(t=i.type)||void 0===t?void 0:t.value);null!==e&&void 0!==e&&(r=dump_1.default.encodeObject(e,{default:void 0}))}else{const{sample:t,curve:n}=this._getMockCurve();let s=n.evaluate(e/t);null!==s&&void 0!==s||(s=utils_1.utils.getDefaultValue(null===(a=i.type)||void 0===a?void 0:a.value)),null!==s&&void 0!==s&&(r=dump_1.default.encodeObject(s,{default:void 0}))}return r}_getMockCurve(){const e=this.getClipSample(),t=new cc_1.RealCurve;return t.assignSorted(this._keyframeData.map(t=>[t.frame/e,{value:t.value,interpolationMode:t.interpMode,leftTangent:t.inTangent,rightTangent:t.outTangent,leftTangentWeight:t.inTangentWeight,rightTangentWeight:t.outTangentWeight,tangentWeightMode:t.tangentWeightMode}])),t.preExtrapolation=this.preExtrap,t.postExtrapolation=this.postExtrap,{sample:e,curve:t}}}exports.EditorAnimationAuxCurve=EditorAnimationAuxCurve;