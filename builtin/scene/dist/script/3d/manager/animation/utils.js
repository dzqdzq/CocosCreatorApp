"use strict";var __createBinding=this&&this.__createBinding||(Object.create?function(e,t,n,a){void 0===a&&(a=n);var r=Object.getOwnPropertyDescriptor(t,n);r&&("get"in r?t.__esModule:!r.writable&&!r.configurable)||(r={enumerable:!0,get:function(){return t[n]}}),Object.defineProperty(e,a,r)}:function(e,t,n,a){void 0===a&&(a=n),e[a]=t[n]}),__setModuleDefault=this&&this.__setModuleDefault||(Object.create?function(e,t){Object.defineProperty(e,"default",{enumerable:!0,value:t})}:function(e,t){e.default=t}),__importStar=this&&this.__importStar||function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var n in e)"default"!==n&&Object.prototype.hasOwnProperty.call(e,n)&&__createBinding(t,e,n);return __setModuleDefault(t,e),t};Object.defineProperty(exports,"__esModule",{value:!0}),exports.multiplyTrackWithTimer=exports.allowModifyCurveType=exports.isHierarchyPath=exports.utils=exports.copyAuxiliaryCurves=exports.uniqAnimationClips=exports.getSerializedAuxCurves=exports.isSkeletonClip=void 0;const cc_1=require("cc"),uniform_handler_1=require("./uniform-handler"),dumpEncode=__importStar(require("../../../export/dump/encode")),dumpDecode=__importStar(require("../../../export/dump/decode")),dumpUtil=__importStar(require("../../../export/dump/utils")),embedded_player_1=require("cc/editor/embedded-player"),util_1=require("util"),new_gen_anim_1=require("cc/editor/new-gen-anim"),allowModifyCurveType=["cc.Number","Number","Integer","Float"];exports.allowModifyCurveType=allowModifyCurveType;const propToDisplayNameMap={eulerAngles:"rotation(eulerAngles)",rotation:"rotation(quaternion)"};function generateAnimablePropData(e,t){let n=e;return propToDisplayNameMap[e]&&(n=propToDisplayNameMap[e]),{name:e,key:e,displayName:n,type:{value:t},menuName:n,propData:{targetPaths:(new cc_1.animation.TrackPath).toProperty(e),type:{value:t}}}}const defaultProperties=[generateAnimablePropData("position","cc.Vec3"),generateAnimablePropData("eulerAngles","cc.Vec3"),generateAnimablePropData("rotation","cc.Quat"),generateAnimablePropData("scale","cc.Vec3")],activeProperty=generateAnimablePropData("active","cc.Boolean"),excludeComponentAnimProps={"*":["type","__scriptAsset"],"cc.ParticleSystem":["materials"]},excludeCCClass=["cc.Mesh","cc.ColorOvertimeModule","cc.CurveRange","cc.ForceOvertimeModule","cc.GradientRange","cc.LimitVelocityOvertimeModule","cc.RotationOvertimeModule","cc.SizeOvertimeModule","cc.TextureAnimationModule","cc.VelocityOvertimeModule","cc.ShapeModule","cc.TrailModule","cc.Terrain","cc.TerrainAsset","cc.Material"],valueTypePartMap={"cc.Vec2":["x","y"],"cc.Vec3":["x","y","z"],"cc.Vec4":["x","y","z","w"],"cc.Color":["r","g","b","a"],"cc.Size":["width","height"]},valueTypeParts=Object.keys(valueTypePartMap);function isSkeletonClip(e){return e.indexOf("@")>-1}function isHierarchyPath(e){return cc_1.animation.isCustomPath(e,cc_1.animation.HierarchyPath)}function isComponentPath(e){return e instanceof cc_1.animation.ComponentPath}function isPropPath(e){return"string"==typeof e}function isElementPath(e){return"number"==typeof e}function getExcludeAnimProps(e){const t=[];return Object.keys(excludeComponentAnimProps).forEach(n=>{if("*"===n)t.concat(excludeComponentAnimProps[n]);else{const a=cc_1.js.getClassByName(n);a&&cc_1.js.isChildClassOf(e,a)&&t.concat(excludeComponentAnimProps[n])}}),t}function getSerializedAuxCurves(e){const t={},n=e.getAuxiliaryCurveNames_experimental();for(const a of n){const n=e.getAuxiliaryCurve_experimental(a);t[a]={curve:cce.Utils.serialize(n,{stringify:!1})}}return t}function uniqAnimationClips(e){const t={},n=[];for(const a of e){if(null==a)continue;const e=t[a.uuid];void 0===e?(t[a.uuid]=a,n.push(a)):e!==a&&console.warn(`Animation clip conflict(has same uuid but fails in equality comparisons): "${a.uuid}"`)}return n}function copyAuxiliaryCurves(e,t){if(t.auxiliaryCurveCount_experimental>0){const e=t.getAuxiliaryCurveNames_experimental();for(const n of e)t.removeAuxiliaryCurve_experimental(n)}const n=e.getAuxiliaryCurveNames_experimental();for(const a of n){const n=e.getAuxiliaryCurve_experimental(a),r=t.addAuxiliaryCurve_experimental(a);r.assignSorted(n.keyframes()),r.preExtrapolation=n.preExtrapolation,r.postExtrapolation=n.postExtrapolation}}exports.isSkeletonClip=isSkeletonClip,exports.isHierarchyPath=isHierarchyPath,exports.getSerializedAuxCurves=getSerializedAuxCurves,exports.uniqAnimationClips=uniqAnimationClips,exports.copyAuxiliaryCurves=copyAuxiliaryCurves;class AnimationUtil{cloneCCClass(e){let t=null;return e&&(t=(0,cc_1.deserialize)(cce.Utils.serialize(e))),t}getNodePathFromAnimRoot(e,t){let n=null,a=!1;if(e===t)n="/",a=!0;else{n="/"+t.name;let r=t.parent;for(;r;){if(r===e){a=!0;break}n="/"+r.name+n,r=r.parent}}return a?n:null}getCustomModifierData(e){const t={};return e instanceof cc_1.animation.HierarchyPath?t.path=e.path:e instanceof cc_1.animation.ComponentPath?t.component=e.component:console.log(`Unknown modifier ${e.constructor.name}`),t}decodeClipsMenu(e){const t=[];return e.forEach(e=>{if(e){if(!e.name)return;const n={name:e.name,uuid:e._uuid};t.push(n)}}),t}getPropDumpData(e,t,n,a){const r={displayName:"",propData:{}};let o;if(a){if(a instanceof cc_1.animation.UniformProxyFactory){const e=uniform_handler_1.uniformHandler.getUniformDumpData(t,a);r.displayName=e.displayName,r.key=e.key,o=e.type}r.propData.valueAdapter=a}else{let a=null;e&&cc_1.CCClass._isCCClass(e.constructor)&&(a=cc_1.CCClass.attr(e.constructor,n));const r=dumpUtil.getConstructor(t,a);o={value:""},a&&!a.ctor&&a.type?a.type instanceof cc_1.CCClass.Attr.PrimitiveType?o.value=a.type.name:o.value=a.type:o.value=dumpUtil.getTypeName(r),r&&(o.extends=dumpUtil.getTypeInheritanceChain(r))}return r.type=o,r}dumpKeyframeData(e){const t=[];return e.forEach((e,n)=>{const a=e.value,r={frame:e.frame,dump:dumpEncode.encodeObject(a,{default:void 0}),inTangent:e.inTangent,inTangentWeight:e.inTangentWeight,outTangent:e.outTangent,outTangentWeight:e.outTangentWeight,interpMode:e.interpMode,tangentWeightMode:e.tangentWeightMode,easingMethod:e.easingMethod};t.push(r)}),t}async getKeyframeDataFromDump(e){const t=[],n=[];for(let a=0;a<e.length;a++){const r=e[a];null===r.dump.value||void 0===r.dump.value?n[a]=r.dump.value:await dumpDecode.decodePatch(""+a,r.dump,n);const o={frame:r.frame,value:n[a],inTangent:r.inTangent,inTangentWeight:r.inTangentWeight,outTangent:r.outTangent,outTangentWeight:r.outTangentWeight,interpMode:r.interpMode,tangentWeightMode:r.tangentWeightMode};t.push(o)}return t}getPartsOfType(e){return e&&valueTypeParts.includes(e)?valueTypePartMap[e]:null}createPropertyCurve(e,t,n,a){const r=[],o=[];a.forEach((e,t)=>{r.push(e.frame/n),o.push(e.value)});const i={keys:t.push(r)-1,values:o,easingMethods:{}};return{modifiers:e.targetPaths,valueAdapter:e.valueAdapter,data:i}}getNodePath(e,t){let n="/",a=e.slice();if(a&&(t&&(a=t.modifiers.concat(a)),a.length>0&&a.isHierarchyAt(0))){const e=a.parseHierarchyAt(0);"/"!==e.substr(0,1)&&(n+=e)}return n}generateHierarchyPath(e){if(e&&"/"!==e){const t=e.substr(1);return(new cc_1.animation.TrackPath).toHierarchy(t)}return null}getPropInfo(e,t){let n,a="",r="",o="",i="/",c=null,l=t,s="",u=t;for(let t=0;t<e.length;t++){let s="";if(e.isPropertyAt(t)||e.isElementAt(t)){const n=e.isPropertyAt(t)?e.parsePropertyAt(t):e.parseElementAt(t);e.isPropertyAt(t)&&(a=e.parsePropertyAt(t)),s=e.isElementAt(t)?`[${n}]`:`.${n}`,r+=`.${n}`,l&&(u=l,l=l[n])}else if(e.isHierarchyAt(t)){const n=e.parseHierarchyAt(t);if("/"!==n&&("/"===n.substr(0,1)?i=n:i+=n,l))try{u=l=l.getChildByPath(n)}catch(e){}}else if(e.isComponentAt(t)){const a=e.parseComponentAt(t);s=a,n=a,l&&(l=c=l.getComponent(n),u=c),r+=a}o+=s}return"."===o.charAt(0)&&(o=o.substr(1)),"."===r.charAt(0)&&(r=r.substr(1)),s=o,propToDisplayNameMap[o]&&(s=propToDisplayNameMap[o]),{nodePath:i,propPath:o,propKey:r,compName:n,propName:a,displayName:s,propObject:l,propOwnerObject:u}}getCurveInfoByTrack(e,t){const n=t.path,a=t.proxy,r=this.getPropInfo(n,e),o=this.getPropDumpData(r.propOwnerObject,r.propObject,r.propName,a),i=o.key?(null===r||void 0===r?void 0:r.propKey)+"."+o.key:null===r||void 0===r?void 0:r.propKey,c=o.displayName?(null===r||void 0===r?void 0:r.displayName)+"."+o.displayName:null===r||void 0===r?void 0:r.displayName;return o.type&&"Unknown"!==o.type.value||(o.type=this.getTypeByTrack(t)),o.type&&"Unknown"!==o.type.value||console.warn(`Can't find type of ${c}`),{nodePath:null===r||void 0===r?void 0:r.nodePath,propKey:i,combinedType:void 0,type:o.type,targetPaths:n,valueAdapter:a,displayName:c,propName:null===r||void 0===r?void 0:r.propName,compName:null===r||void 0===r?void 0:r.compName,partName:void 0}}getTypeByTrack(e){let t,n="";if(e instanceof cc_1.animation.VectorTrack)switch(e.componentsCount){case 2:n="cc.Vec2";break;case 3:n="cc.Vec3";break;case 4:n="cc.Vec4"}else if(e instanceof cc_1.animation.RealTrack)n="Number";else if(e instanceof cc_1.animation.QuatTrack)n="cc.Quat";else if(e instanceof cc_1.animation.ColorTrack)n="cc.Color";else if(e instanceof cc_1.animation.ObjectTrack){const a=e.channel.curve.keyframes();for(const[e,r]of a)if(void 0!==r&&null!==r){const e=dumpEncode.encodeObject(r,{default:void 0});n=e.type,t=e.extends;break}}return{value:n||"",extends:t}}copyClip(e,t){e.name=t.name,e.duration=t.duration,e.sample=t.sample,e.speed=t.speed,e.wrapMode=t.wrapMode,e.clearTracks();for(const n of t.tracks)e.addTrack(n);e.events=t.events,e[cc_1.editorExtrasTag].embeddedPlayerGroups=t[cc_1.editorExtrasTag].embeddedPlayerGroups,e[embedded_player_1.clearEmbeddedPlayersTag]();const n=t[embedded_player_1.getEmbeddedPlayersTag]();for(const t of n)e[embedded_player_1.addEmbeddedPlayerTag](t);copyAuxiliaryCurves(t,e)}queryEvents(e){return e?e.events:(console.warn("Clip is not valid"),null)}isObject(e){return"object"==typeof e}isExcludeType(e){const t=cc_1.js.getClassByName(e);return excludeCCClass.includes(e)||t&&cc_1.js.isChildClassOf(t,cc_1.Component)||cc_1.js.isChildClassOf(t,cc_1.Node)}handleAnimableProp(e,t,n,a,r,o){let i=[];if(this.isExcludeType(n))return i;if(Array.isArray(a)){const c=this.handleArrayProp(e,t,n,a,r,o);c&&(i=c)}else if(this.isObject(a)){const c=this.handlePrimitiveProp(e,t,n,r),l=this.handleObjectProp(e,t,n,a,r,o);l&&(i=i.concat(l)),!c||l&&l.length||(i=i.concat(c))}else{const a=this.handlePrimitiveProp(e,t,n,r);a&&(i=[a])}return i}generatePropDumpData(e,t,n){const a={propData:{}},r=(new cc_1.animation.TrackPath).toComponent(e);if(a.category=e,n){r.append(n);for(let e=0;e<n.length;++e){let t="";switch(!0){default:t="UnknownPath";break;case n.isPropertyAt(e):t=n.parsePropertyAt(e);break;case n.isElementAt(e):t=`${n.parseElementAt(e)}`;break;case n.isHierarchyAt(e):t=n.parseHierarchyAt(e);break;case n.isComponentAt(e):t=n.parseComponentAt(e)}a.category+=`/${t}`}}r.toProperty(t);const o=this.getPropInfo(r);return a.key=o.propKey,a.displayName=o.displayName,a.name=o.propName,o.displayName.endsWith(o.propName)||"number"!=typeof t?a.menuName=o.propName:a.menuName=o.propName+`[${t}]`,a.propData.targetPaths=r,a}handlePrimitiveProp(e,t,n,a){const r=this.generatePropDumpData(e,t,a);r.comp=e;const o={value:n},i=cc_1.js.getClassByName(n);return i&&(o.extends=dumpUtil.getTypeInheritanceChain(i)),r.type=o,r.propData.type=r.type,r}handleObjectProp(e,t,n,a,r,o){if(!a)return null;if(this.isExcludeType(n))return null;if(o.includes(n))return null;let i=[];if(n===cc_1.js.getClassName(cc_1.renderer.MaterialInstance)){const n=uniform_handler_1.uniformHandler.getAnimablePropsFromMaterial(a);n&&n.length>0&&n.forEach(n=>{const a=this.generatePropDumpData(e,t,r);a.type=n.type,a.comp=e,a.name=n.name,a.category+=`/${t}/${n.name}`;const o=uniform_handler_1.uniformHandler.getUniformNameData(n.passIndex,n.name);a.key+="."+o.key,a.displayName+="."+o.displayName,a.menuName=o.displayName,n.uniformAdapter&&(a.propData.valueAdapter=n.uniformAdapter),i.push(a)})}else{let c=!1,l=[];cc_1.js.getClassByName(n)?(c=!0,a.constructor&&a.constructor.__props__&&(l=a.constructor.__props__)):l=Object.keys(a);const s=(null!==r&&void 0!==r?r:new cc_1.animation.TrackPath).toProperty(t);l.forEach(t=>{const r=a[t];let l=null;c?l=this.getCCClassAnimablePropType(a,t):r&&(l=typeof r),l&&(o.includes(n)||o.push(n),i=i.concat(this.handleAnimableProp(e,t,l,r,s,o)))})}return i}handleArrayProp(e,t,n,a,r,o){let i=[];const c=r.slice().toProperty(t);return a.forEach((t,a)=>{i=i.concat(this.handleAnimableProp(e,a,n,t,c,o))}),i}getCCClassAnimablePropType(e,t){if(!this.isObject(e))return null;const n=e.constructor,a=cc_1.CCClass.attr(n,t);if(!a)return null;let r=!0;if(!(r=a.type!==cc_1.js.getClassName(cc_1.Node)&&(void 0!==a.animatable?a.animatable:void 0===a.visible||a.visible)))return null;const o=e[t],i=dumpUtil.getConstructor(o,a);let c=null;if(!a.ctor&&a.type)c=a.type;else if(Array.isArray(o)){const e=o[0];e&&e.constructor&&(c=dumpUtil.getTypeName(e.constructor))}else c=dumpUtil.getTypeName(i);return"Unknown"===c&&(c=null),c}getAnimablePropsFromProperty(e,t){cc_1.js.isChildClassOf(e.constructor,cc_1.Renderer)&&"sharedMaterials"===t&&(t="materials");const n=this.getCCClassAnimablePropType(e,t);if(!n)return null;let a="";a=n instanceof cc_1.CCClass.Attr.PrimitiveType?n.name:n;const r=e[t],o=dumpUtil.getTypeName(e.constructor);return this.handleAnimableProp(o,t,a,r,new cc_1.animation.TrackPath,[o])}getAnimablePropsFromComponent(e){let t=[];const n=e.constructor;if(n){const a=n.__props__,r=getExcludeAnimProps(a);a.map(n=>{if(r.includes(n))return;const a=this.getAnimablePropsFromProperty(e,n);null!==a&&(t=t.concat(a))})}return t}getAnimableProperties(e,t){if(!e)return null;const n=[];return t&&n.push(activeProperty),defaultProperties.forEach(e=>{n.push(e)}),e.components.forEach(e=>{if(!(e instanceof cc_1.Animation))try{if(excludeCCClass.includes(cc_1.js.getClassName(e)))return;for(let t=0;t<n.length;++t)if(n[t].name.startsWith(cc_1.js.getClassName(e)))return;this.getAnimablePropsFromComponent(e).forEach(e=>{n.push(e)})}catch(e){console.warn(e)}}),n}getClipName(e,t){if(!e)return null;let n=null;return t.forEach(t=>{t&&t._uuid===e&&(n=t.name)}),n}queryNodeAnimationData(e,t){const n={defaultClip:null};if(!e)return console.debug(`Node(${e}) doesn't exist`),n;let a=null;if(!(a="string"==typeof e?cce.Node.query(e):e))return console.debug(`Node(${e}) doesn't exist`),n;n.node=a;let r=[];const o=a.getComponent(cc_1.animation.AnimationController);if(o)r=[...(0,new_gen_anim_1.visitAnimationClipsInController)(o)],n.animComp=o;else{const t=a.getComponent(cc_1.Animation);if(!t)return console.debug(`Node(${e}) lacks Animation`),n;r=t.clips,n.animComp=t,n.defaultClip=t.defaultClip}if(!t)return n;let i=null;return r.forEach(e=>{e&&e._uuid===t&&(i=e)}),n.clips=r,n.defaultClip=n.defaultClip||r[0],!i||(n.animComp,cc_1.animation.AnimationController),n}getDefaultValue(e){let t=null;const n=cc_1.js.getClassByName(e);if(n)t=new n;else switch(e){case"Boolean":t=!1;break;case"Number":case"Integer":case"Float":t=0;break;case"String":t=""}return t}async getValueFrom(e,t,n=null){var a,r;if(!t)return;let o;if(n&&void 0!==n.newValue){const e=t.type.value;if(o=n.newValue,cc_1.js.getClassByName(e))if(t.type.extends&&t.type.extends.includes("cc.Asset")){const e=(null===(a=n.newValue)||void 0===a?void 0:a.uuid)||(null===(r=n.newValue)||void 0===r?void 0:r._uuid);o=e&&""!==e?await(0,util_1.promisify)(cc_1.assetManager.loadAny)(e):null}else{const t={};t.__type__=e,Object.assign(t,n.newValue),o=(0,cc_1.deserialize)(t)}else o=n.newValue}else{let n=e;const a=t.targetPaths,r=t.valueAdapter;n=a.trace(n),r?r instanceof cc_1.animation.UniformProxyFactory&&(o=await uniform_handler_1.uniformHandler.getCurrentValue(n,r,t)):(void 0!==n&&(o=n),o&&o.constructor&&cc_1.js.isChildClassOf(o.constructor,cc_1.ValueType)&&(o=o.clone()))}return o}loadJsonWithUuid(e,t,n){cc_1.assetManager.assets.remove(e),cc_1.assetManager.loadWithJson(t,{assetId:e},(e,t)=>{n&&n(e,t)})}copyCurveData(e,t){var n,a,r,o,i,c,l,s,u;t.inTangent=null!==(n=e.inTangent)&&void 0!==n?n:t.inTangent,t.inTangentWeight=null!==(a=e.inTangentWeight)&&void 0!==a?a:t.inTangentWeight,t.outTangent=null!==(r=e.outTangent)&&void 0!==r?r:t.outTangent,t.outTangentWeight=null!==(o=e.outTangentWeight)&&void 0!==o?o:t.outTangentWeight,t.interpMode=null!==(i=e.interpMode)&&void 0!==i?i:t.interpMode,t.tangentWeightMode=null!==(c=e.tangentWeightMode)&&void 0!==c?c:t.tangentWeightMode,t.tangentMode=null!==(l=e.tangentMode)&&void 0!==l?l:t.tangentMode,t.broken=null!==(s=e.broken)&&void 0!==s?s:t.broken,t.easingMethod=null!==(u=e.easingMethod)&&void 0!==u?u:t.easingMethod}isNumber(e){return"number"==typeof e&&!isNaN(e)}getTrackTypeBy(e){let t=null;switch(e){case"cc.Vec2":t="vec2";break;case"cc.Vec3":t="vec3";break;case"cc.Vec4":t="vec4";break;case"cc.Color":t="color";break;case"cc.Size":t="size"}return t}isTypeSupportCurve(e){return!(!e||!allowModifyCurveType.includes(e))}calcEmbeddedPlayerKey(e){var t;return`begin:${e.begin},end:${e.end},player:${null===(t=e.playable)||void 0===t?void 0:t.type},group:${e.group}},displayName:${e.displayName}}`}initAninState(e,t){e._curveLoaded=!1;try{e.initialize(t)}catch(e){console.error(e)}}getPlayableInfo(e){var t;return e instanceof embedded_player_1.EmbeddedParticleSystemPlayable?{path:e.path,type:"particle-system"}:e instanceof embedded_player_1.EmbeddedAnimationClipPlayable?{path:e.path,clip:(null===(t=e.clip)||void 0===t?void 0:t._uuid)||"",type:"animation-clip"}:null}}const utils=new AnimationUtil;function multiplyTrackWithTimer(e,t){for(const n in t)Editor.Metrics._trackEventWithTimer({category:e,id:n,value:t[n]})}exports.utils=utils,exports.multiplyTrackWithTimer=multiplyTrackWithTimer;