"use strict";var __createBinding=this&&this.__createBinding||(Object.create?function(e,t,a,n){void 0===n&&(n=a),Object.defineProperty(e,n,{enumerable:!0,get:function(){return t[a]}})}:function(e,t,a,n){void 0===n&&(n=a),e[n]=t[a]}),__setModuleDefault=this&&this.__setModuleDefault||(Object.create?function(e,t){Object.defineProperty(e,"default",{enumerable:!0,value:t})}:function(e,t){e.default=t}),__importStar=this&&this.__importStar||function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var a in e)"default"!==a&&Object.prototype.hasOwnProperty.call(e,a)&&__createBinding(t,e,a);return __setModuleDefault(t,e),t},__importDefault=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(exports,"__esModule",{value:!0}),exports.isHierarchyPath=exports.utils=void 0;const cc_1=require("cc"),uniform_handler_1=require("./uniform-handler"),dumpEncode=__importStar(require("../../../../utils/dump/encode")),dumpUtil=__importStar(require("../../../../utils/dump/utils")),dumpDecode=__importStar(require("../../../../utils/dump/decode")),node_1=__importDefault(require("../node")),pathUtil=require("path"),{promisify:promisify}=require("util"),propToDisplayNameMap={eulerAngles:"rotation(eulerAngles)",rotation:"rotation(quaternion)"};function generateAnimablePropData(e,t){let a=e;return propToDisplayNameMap[e]&&(a=propToDisplayNameMap[e]),{name:e,key:e,displayName:a,type:{value:t},menuName:a,propData:{targetPaths:[e],type:{value:t}}}}const defaultProperties=[generateAnimablePropData("position","cc.Vec3"),generateAnimablePropData("eulerAngles","cc.Vec3"),generateAnimablePropData("rotation","cc.Quat"),generateAnimablePropData("scale","cc.Vec3")],activeProperty=generateAnimablePropData("active","cc.Boolean"),excludeComponentAnimProps={"*":["type","__scriptAsset"],"cc.ParticleSystem":["materials"]},excludeCCClass=["cc.Mesh","cc.ColorOvertimeModule","cc.CurveRange","cc.ForceOvertimeModule","cc.GradientRange","cc.LimitVelocityOvertimeModule","cc.RotationOvertimeModule","cc.SizeOvertimeModule","cc.TextureAnimationModule","cc.VelocityOvertimeModule","cc.ShapeModule","cc.TrailModule","cc.Terrain","cc.TerrainAsset"],valueTypePartMap={"cc.Vec2":["x","y"],"cc.Vec3":["x","y","z"],"cc.Vec4":["x","y","z","w"],"cc.Color":["r","g","b","a"],"cc.Size":["width","height"]},valueTypeParts=Object.keys(valueTypePartMap);function isHierarchyPath(e){return cc_1.animation.isCustomPath(e,cc_1.animation.HierarchyPath)}function isComponentPath(e){return e instanceof cc_1.animation.ComponentPath}function isPropPath(e){return"string"==typeof e}function isElementPath(e){return"number"==typeof e}function getExcludeAnimProps(e){const t=[];return Object.keys(excludeComponentAnimProps).forEach(a=>{if("*"===a)t.concat(excludeComponentAnimProps[a]);else{const n=cc_1.js.getClassByName(a);n&&cc_1.js.isChildClassOf(e,n)&&t.concat(excludeComponentAnimProps[a])}}),t}exports.isHierarchyPath=isHierarchyPath;class AnimationUtil{cloneCCClass(e){let t=null;return e&&(t=cc_1.deserialize(cce.Utils.serialize(e),null,null)),t}getNodePathFromAnimRoot(e,t){let a=null,n=!1;if(e===t)a="/",n=!0;else{a="/"+t.name;let r=t.parent;for(;r;){if(r===e){n=!0;break}a="/"+r.name+a,r=r.parent}}return n?a:null}getCustomModifierData(e){const t={};return e instanceof cc_1.animation.HierarchyPath?t.path=e.path:e instanceof cc_1.animation.ComponentPath?t.component=e.component:console.log(`Unknown modifier ${e.constructor.name}`),t}getPropDumpData(e,t,a,n){const r={displayName:"",propData:{}};let o;if(n){if(n instanceof cc_1.animation.UniformProxyFactory){const e=uniform_handler_1.uniformHandler.getUniformDumpData(t,n);r.displayName=e.displayName,r.key=e.key,o=e.type}r.propData.valueAdapter=n}else{let n=null;e&&cc_1.CCClass._isCCClass(e.constructor)&&(n=cc_1.CCClass.attr(e.constructor,a));const r=dumpUtil.getConstructor(t,n);o={value:""},n&&!n.ctor&&n.type?o.value=n.type:o.value=dumpUtil.getTypeName(r),r&&(o.extends=dumpUtil.getTypeInheritanceChain(r))}return r.type=o,r}dumpKeyframeData(e){const t=[];return e.forEach((e,a)=>{const n=e.value,r=e.easingMethod,o={frame:e.frame,dump:dumpEncode.encodeObject(n,{default:null}),curve:r};t.push(o)}),t}async getKeyframeDataFromDump(e){const t=[],a=[];for(let n=0;n<e.length;n++){const r=e[n];null===r.dump.value||void 0===r.dump.value?a[n]=r.dump.value:await dumpDecode.decodePatch(""+n,r.dump,a);const o={frame:r.frame,value:a[n],easingMethod:r.curve};t.push(o)}return t}handleKeys(e,t,a){if(a&&a.keys>=0){const n=e[a.keys],r=a.values||[],o=a.easingMethods||[],i=[];if(n)return n.forEach((e,a)=>{const n=r[a],c={frame:Math.round(e*t),dump:dumpEncode.encodeObject(n,{default:null}),curve:o[a]};i.push(c)}),i}return null}getPartsOfType(e){return e&&valueTypeParts.includes(e)?valueTypePartMap[e]:null}createPropertyCurve(e,t,a,n){const r=[],o=[],i={};n.forEach((e,t)=>{r.push(e.frame/a),o.push(e.value),e.easingMethod&&(i[t]=e.easingMethod)});const c={keys:t.push(r)-1,values:o,easingMethods:i};return{modifiers:e.targetPaths,valueAdapter:e.valueAdapter,data:c}}getNodePath(e,t){let a="/",n=e.concat();if(n&&(t&&(n=t.modifiers.concat(n)),n.length>0)){const e=n[0];if(isHierarchyPath(e)){const t=e;"/"!==t.path.substr(0,1)&&(a+=t.path)}}return a}generateHierarchyPath(e){if(e&&"/"!==e){const t=e.substr(1);return new cc_1.animation.HierarchyPath(t)}return null}getPropInfo(e,t){let a,n="",r="",o="",i="/",c=null,l=t,s="",u=t;for(let t=0;t<e.length;t++){const s=e[t];let p="";if(cc_1.animation.isPropertyPath(s))isPropPath(s)&&(n=s),p=isElementPath(s)?`[${s}]`:`.${s}`,r+=`.${s}`,l&&(u=l,l=l[s]);else if(isHierarchyPath(s)){if("/"!==s.path&&("/"===s.path.substr(0,1)?i=s.path:i+=s.path,l))try{u=l=s.get(l)}catch(e){}}else isComponentPath(s)&&(p=s.component,a=s.component,l&&(l=c=l.getComponent(a),u=c),r+=s.component);o+=p}return"."===o.charAt(0)&&(o=o.substr(1)),"."===r.charAt(0)&&(r=r.substr(1)),s=o,propToDisplayNameMap[o]&&(s=propToDisplayNameMap[o]),{nodePath:i,propPath:o,propKey:r,compName:a,propName:n,displayName:s,propObject:l,propOwnerObject:u}}getCurveInfo(e,t,a){let n,r=a.modifiers.concat(),o=null;void 0!==a.commonTarget&&a.commonTarget>=0&&(n=t.commonTargetsPool[a.commonTarget])&&(r=n.modifiers.concat()),r&&(o=this.getPropInfo(r,e));let i=a.valueAdapter;n&&(i=n.valueAdapter);const c=this.getPropDumpData(null===o||void 0===o?void 0:o.propOwnerObject,null===o||void 0===o?void 0:o.propObject,null===o||void 0===o?void 0:o.propName,i);let l,s,u=c.key?(null===o||void 0===o?void 0:o.propKey)+"."+c.key:null===o||void 0===o?void 0:o.propKey,p=c.displayName?(null===o||void 0===o?void 0:o.displayName)+"."+c.displayName:null===o||void 0===o?void 0:o.displayName;if(n&&a.modifiers&&a.modifiers.length>0)l=c.type,c.type={value:"Number"},u+="."+(s=a.modifiers[0]),p+="."+s;else if(uniform_handler_1.uniformHandler.isUniformPartCurve(i)){l=c.type,c.type={value:"Number"};const e=i,t=uniform_handler_1.uniformHandler.getArrayIndexToValuePartMapByType(null===l||void 0===l?void 0:l.value);void 0!==e.channelIndex?(u+="."+(s=t?t[e.channelIndex]:e.channelIndex.toString()),p+="."+s):console.warn(`can't find parts of ${p}`)}if(!c.type){const e=t.keysPool[a.data.keys];for(let t=0;t<e.length;t++){const e=a.data.values[t];if(void 0!==e&&null!==e){const t=dumpEncode.encodeObject(e,{default:null}),a={value:t.type||"",extends:t.extends};c.type=a;break}}}return c.type||console.warn(`Can't find type of ${p}`),{nodePath:null===o||void 0===o?void 0:o.nodePath,propKey:u,combinedType:l,type:c.type,targetPaths:a.modifiers,valueAdapter:a.valueAdapter,displayName:p,propName:null===o||void 0===o?void 0:o.propName,compName:null===o||void 0===o?void 0:o.compName,partName:s,commonTarget:n}}copyClip(e,t){e.name=t.name,e.duration=t.duration,e.sample=t.sample,e.speed=t.speed,e.wrapMode=t.wrapMode,e.keys=t.keys,e.commonTargets=t.commonTargets,e.curves=t.curves,e.events=t.events}queryEvents(e){return e?e.events:(console.warn("Clip is not valid"),null)}isObject(e){return"object"==typeof e}handleAnimableProp(e,t,a,n,r,o){let i=[];if(excludeCCClass.includes(a))return i;if(Array.isArray(n)){const c=this.handleArrayProp(e,t,a,n,r,o);c&&(i=c)}else if(this.isObject(n)){const c=this.handlePrimitiveProp(e,t,a,r);c&&(i=i.concat(c));const l=this.handleObjectProp(e,t,a,n,r,o);l&&(i=i.concat(l))}else{const n=this.handlePrimitiveProp(e,t,a,r);n&&(i=[n])}return i}generatePropDumpData(e,t,a){const n={propData:{}};let r=[];r.push(new cc_1.animation.ComponentPath(e)),n.category=e,a&&(r=r.concat(a),a.forEach(e=>{n.category+=`/${e}`})),r.push(t);const o=this.getPropInfo(r);return n.key=o.propKey,n.displayName=o.displayName,n.name=o.propName,n.menuName=o.propName,n.propData.targetPaths=r,n}handlePrimitiveProp(e,t,a,n){const r=this.generatePropDumpData(e,t,n);r.comp=e;const o={value:a},i=cc_1.js.getClassByName(a);return i&&(o.extends=dumpUtil.getTypeInheritanceChain(i)),r.type=o,r.propData.type=r.type,r}handleObjectProp(e,t,a,n,r,o){if(!n)return null;if(excludeCCClass.includes(a))return null;if(o.includes(a))return null;let i=[];if(a===cc_1.js.getClassName(cc_1.Material)){const a=uniform_handler_1.uniformHandler.getAnimablePropsFromMaterial(n);a&&a.length>0&&a.forEach(a=>{const n=this.generatePropDumpData(e,t,r);n.type=a.type,n.comp=e,n.name=a.name,n.category+=`/${t}`;const o=uniform_handler_1.uniformHandler.getUniformNameData(a.passIndex,a.name);n.key+="."+o.key,n.displayName+="."+o.displayName,n.menuName=o.displayName,a.uniformAdapter&&(n.propData.valueAdapter=a.uniformAdapter),i.push(n)})}else{let c=!1,l=[];cc_1.js.getClassByName(a)?(c=!0,n.constructor&&n.constructor.__props__&&(l=n.constructor.__props__)):l=Object.keys(n);let s=[t];r&&(s=r.concat(s)),l.forEach(t=>{const r=n[t];let l=null;c?l=this.getCCClassAnimablePropType(n,t):r&&(l=typeof r),l&&(o.includes(a)||o.push(a),i=i.concat(this.handleAnimableProp(e,t,l,r,s,o)))})}return i}handleArrayProp(e,t,a,n,r,o){let i=[];const c=r.concat(t);return n.forEach((t,n)=>{i=i.concat(this.handleAnimableProp(e,n,a,t,c,o))}),i}getCCClassAnimablePropType(e,t){if(!this.isObject(e))return null;const a=e.constructor,n=cc_1.CCClass.attr(a,t);if(!n)return null;let r=!0;if(!(r=n.type!==cc_1.js.getClassName(cc_1.Node)&&(void 0!==n.animatable?n.animatable:void 0===n.visible||n.visible)))return null;const o=e[t],i=dumpUtil.getConstructor(o,n);let c=null;if(!n.ctor&&n.type)c=n.type;else if(Array.isArray(o)){const e=o[0];e&&e.constructor&&(c=dumpUtil.getTypeName(e.constructor))}else c=dumpUtil.getTypeName(i);return"Unknown"===c&&(c=null),c}getAnimablePropsFromProperty(e,t){const a=this.getCCClassAnimablePropType(e,t);if(!a)return null;const n=e[t],r=dumpUtil.getTypeName(e.constructor);return cc_1.js.isChildClassOf(e.constructor,cc_1.RenderableComponent)&&"sharedMaterials"===t&&(t="materials"),this.handleAnimableProp(r,t,a,n,[],[r])}getAnimablePropsFromComponent(e){let t=[];const a=e.constructor;if(a){const n=a.__props__,r=getExcludeAnimProps(n);n.map(a=>{if(r.includes(a))return;const n=this.getAnimablePropsFromProperty(e,a);null!==n&&(t=t.concat(n))})}return t}getAnimableProperties(e,t){if(!e)return null;const a=[];return t&&a.push(activeProperty),defaultProperties.forEach(e=>{a.push(e)}),e.components.forEach(e=>{if(e instanceof cc_1.Animation)return;if(excludeCCClass.includes(cc_1.js.getClassName(e)))return;for(let t=0;t<a.length;++t)if(a[t].name.startsWith(cc_1.js.getClassName(e)))return;this.getAnimablePropsFromComponent(e).forEach(e=>{a.push(e)})}),a}getClipName(e,t){if(!e)return null;let a=null;return t.clips.forEach(t=>{t&&t._uuid===e&&(a=t.name)}),a}queryNodeAnimationData(e,t){const a={},n=node_1.default.query(e);if(!n)return console.log(`Node(${e}) doesn't exist`),a;a.node=n;const r=n.getComponent(cc_1.Animation);if(!r)return console.debug(`Node(${e}) lacks Animation`),a;if(a.animComp=r,!t)return a;const o=this.getClipName(t,r);if(!o)return console.debug(`Node(${e})doesn't contain clip(${t})`),a;if(""===o)return console.debug(`ClipName is empty Node(${e}) Clip(${t})`),a;const i=r.getState(o);return i?(a.animState=i,a):(console.debug(`Can't find AnimationState Node(${e}) Clip(${t})`),a)}getDefaultValue(e){let t=null;const a=cc_1.js.getClassByName(e);if(a)t=new a;else switch(e){case"Boolean":t=!1;break;case"Number":t=0;break;case"String":t=""}return t}async getValueFrom(e,t,a=null){var n,r;if(!t)return;let o;if(a&&void 0!==a.newValue){const e=t.type.value;if(o=a.newValue,cc_1.js.getClassByName(e))if(t.type.extends&&t.type.extends.includes("cc.Asset")){const e=(null===(n=a.newValue)||void 0===n?void 0:n.uuid)||(null===(r=a.newValue)||void 0===r?void 0:r._uuid);o=e&&""!==e?await promisify(cc_1.assetManager.loadAny)(e):null}else{const t={};t.__type__=e,Object.assign(t,a.newValue),o=cc_1.deserialize(t,null,null)}else o=a.newValue}else{let a=e,n=t.targetPaths,r=t.valueAdapter;if(t.commonTarget){const e=t.commonTarget;e.modifiers&&(n=e.modifiers),r=e.valueAdapter}for(let e=0;e<n.length;e++){const t=n[e];if(cc_1.animation.isPropertyPath(t)&&a)a=a[t];else try{a=t.get(a)}catch(e){a=void 0}}if(r?r instanceof cc_1.animation.UniformProxyFactory&&(o=await uniform_handler_1.uniformHandler.getCurrentValue(a,r,t)):(o=a)&&o.constructor&&cc_1.js.isChildClassOf(o.constructor,cc_1.ValueType)&&(o=o.clone()),t.commonTarget&&t.targetPaths&&t.targetPaths.length>0){const e=t.targetPaths[0];o&&(o=o[e])}}return o}loadJsonWithUuid(e,t,a){cc_1.assetManager.assets.remove(e),cc_1.assetManager.loadWithJson(t,{assetId:e},(e,t)=>{a&&a(e,t)})}}const utils=new AnimationUtil;exports.utils=utils;