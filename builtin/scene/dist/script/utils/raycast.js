"use strict";var __importDefault=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(exports,"__esModule",{value:!0});const cc_1=require("cc"),intersect_1=__importDefault(require("./geom-utils/intersect")),recycle_pool_1=require("./memop/recycle-pool"),ray=cc_1.geometry.Ray,AABB=cc_1.geometry.AABB,triangle=cc_1.geometry.Triangle,testHitPoint=new cc_1.Vec3,hitPoint=new cc_1.Vec3,worldM4=new cc_1.Mat4,inverseM4=new cc_1.Mat4;class Raycast{get rayResultCanvas(){return resultCanvas}get rayResultModels(){return resultModels}get rayResultAll(){return resultAll}get rayResultSingleModel(){return resultSingleModel}get raycastColliderResults(){return raycastColliderResults}raycastAll(e,t,r=cc_1.Layers.Enum.DEFAULT|cc_1.Layers.Enum.UI_2D|cc_1.Layers.Enum.IGNORE_RAYCAST,o=1/0){const s=this.raycastAllModels(e,t,r,o),c=this.raycastAllCanvas(t,r,o),n=s||c;return resultAll.length=0,n&&(Array.prototype.push.apply(resultAll,resultModels),Array.prototype.push.apply(resultAll,resultCanvas)),n}raycastAllForSnap(e,t,r=cc_1.Layers.Enum.DEFAULT|cc_1.Layers.Enum.UI_2D|cc_1.Layers.Enum.IGNORE_RAYCAST,o=1/0){const s=this.raycastAllModelsForSnap(e,t,r,o),c=this.raycastAllCanvas(t,r,o),n=s||c;return resultAll.length=0,n&&(Array.prototype.push.apply(resultAll,resultModels),Array.prototype.push.apply(resultAll,resultCanvas)),n}raycastAllModels(e,t,r=cc_1.Layers.Enum.DEFAULT,o=1/0){pool.reset();const s=[];for(const c of e.models){if(!(c.transform&&c.enabled&&c.node.layer&r&&c.worldBounds))continue;const e=intersect_1.default.ray_aabb(t,c.worldBounds);e<=0||e>=o||s.push([c,e])}s.sort((e,t)=>e[1]-t[1]);let c=Number.MAX_VALUE;return s.every((e,r)=>{const s=e[0];let n=e[1];if(c<=n)return!1;const l=s.transform;if(s.type===cc_1.renderer.scene.ModelType.DEFAULT){l.getWorldMatrix(worldM4),cc_1.Mat4.invert(m4,l.getWorldMatrix(m4)),cc_1.Vec3.transformMat4(modelRay.o,t.o,m4),cc_1.Vec3.normalize(modelRay.d,cc_1.Vec3.transformMat4Normal(modelRay.d,t.d,m4)),n=1/0;for(let e=0;e<s.subModels.length;++e){const r=s.subModels[e].subMesh;if(r&&r.geometricInfo){const{positions:e,indices:s,doubleSided:c}=r.geometricInfo;if(narrowphase(e,s,r.primitiveMode,c,o,testHitPoint),narrowDis<n){cc_1.Vec3.transformMat4(testHitPoint,testHitPoint,worldM4);const e=cc_1.Vec3.distance(t.o,testHitPoint);e<n&&(n=e,hitPoint.set(testHitPoint))}}}}if(n<o){const e=pool.add();e.node=s.node,e.distance=n,e.hitPoint=new cc_1.Vec3(hitPoint),resultModels[pool.length-1]=e,c=n}return!0}),resultModels.length=pool.length,resultModels.length>0}raycastAllModelsForSnap(e,t,r=cc_1.Layers.Enum.DEFAULT,o=1/0){pool.reset();const s=[];for(const c of e.models){if(!(c.transform&&c.enabled&&c.node.layer&r&&c.worldBounds))continue;const e=intersect_1.default.ray_aabb(t,c.worldBounds);e<=0||e>=o||s.push([c,e])}s.sort((e,t)=>e[1]-t[1]);let c=Number.MAX_VALUE;return s.every((e,r)=>{const s=e[0];let n=e[1];if(c<=n)return!1;const l=s.transform;if(s.type===cc_1.renderer.scene.ModelType.DEFAULT){l.getWorldMatrix(worldM4),cc_1.Mat4.invert(m4,l.getWorldMatrix(m4)),cc_1.Vec3.transformMat4(modelRay.o,t.o,m4),cc_1.Vec3.normalize(modelRay.d,cc_1.Vec3.transformMat4Normal(modelRay.d,t.d,m4)),n=1/0;for(let e=0;e<s.subModels.length;++e){const r=s.subModels[e].subMesh;if(r&&r.geometricInfo){const{positions:e,indices:s,doubleSided:c}=r.geometricInfo;if(narrowphaseForSnap(e,s,r.primitiveMode,c,o,testHitPoint),narrowDis<n){cc_1.Vec3.transformMat4(testHitPoint,testHitPoint,worldM4);const e=cc_1.Vec3.distance(t.o,testHitPoint);e<n&&(n=e,hitPoint.set(testHitPoint))}}}}if(n<o){const e=pool.add();e.node=s.node,e.distance=n,e.hitPoint=new cc_1.Vec3(hitPoint),resultModels[pool.length-1]=e,c=n}return!0}),resultModels.length=pool.length,resultModels.length>0}raycastSingleModel(e,t,r=cc_1.Layers.Enum.DEFAULT,o=1/0){pool.reset();const s=t,c=s.transform;if(!(c&&s.enabled&&s.node.layer&r&&s.worldBounds))return!1;let n=intersect_1.default.ray_aabb(e,s.worldBounds);if(n<=0||n>=o)return!1;if(s.type===cc_1.renderer.scene.ModelType.DEFAULT){c.getWorldMatrix(worldM4),cc_1.Mat4.invert(inverseM4,c.getWorldMatrix(inverseM4)),cc_1.Vec3.transformMat4(modelRay.o,e.o,inverseM4),cc_1.Vec3.normalize(modelRay.d,cc_1.Vec3.transformMat4Normal(modelRay.d,e.d,m4)),n=1/0;for(let t=0;t<s.subModels.length;++t){const r=s.subModels[t].subMesh;if(r&&r.geometricInfo){const{positions:t,indices:s,doubleSided:c}=r.geometricInfo;if(narrowphase(t,s,r.primitiveMode,c,o,testHitPoint),narrowDis<n){cc_1.Vec3.transformMat4(testHitPoint,testHitPoint,worldM4);const t=cc_1.Vec3.distance(e.o,testHitPoint);t<n&&(n=t,hitPoint.set(testHitPoint))}}}}if(n<o){const e=pool.add();e.node=s.node,e.distance=n,e.hitPoint=new cc_1.Vec3(hitPoint),resultSingleModel[pool.length-1]=e}return resultSingleModel.length=pool.length,resultSingleModel.length>0}raycastAllCanvas(e,t=cc_1.Layers.Enum.UI_2D,r=1/0){poolUI.reset();const o=cc.director.getScene().getComponentsInChildren(cc.Canvas);if(o&&o.length>0)for(let s=o.length-1;s>=0;s--){const c=o[s].node;c&&c.active&&this._raycastUI2DNodeRecursiveChildren(e,c,t,r)}return resultCanvas.length=poolUI.length,resultCanvas.length>0}raycastAllColliders(e,t=cc_1.Layers.Enum.DEFAULT){return!!cc_1.PhysicsSystem.instance.raycast(e,void 0,void 0,!1)&&(raycastColliderResults=cc_1.PhysicsSystem.instance.raycastResults,!0)}_raycastUI2DNode(e,t,r=cc_1.Layers.Enum.UI_2D,o=1/0){const s=t._uiProps.uiTransformComp;if(!(s&&t.layer&r))return null;s.getComputeAABB(aabbUI);const c=intersect_1.default.ray_aabb(e,aabbUI);if(c<=0)return null;if(c<o){const e=poolUI.add();return e.node=t,e.distance=c,e}return null}_raycastUI2DNodeRecursiveChildren(e,t,r=cc_1.Layers.Enum.UI_2D,o=1/0){for(let s=t.children.length-1;s>=0;s--){const c=t.children[s];c&&c.active&&this._raycastUI2DNodeRecursiveChildren(e,c,r,o)}const s=this._raycastUI2DNode(e,t,r,o);s&&(resultCanvas[poolUI.length-1]=s)}}const modelRay=ray.create(),v3=new cc_1.Vec3,m4=new cc_1.Mat4;let narrowDis=1/0;const tri=triangle.create(),tempVec3_a=new cc_1.Vec3,tempVec3_b=new cc_1.Vec3,pool=new recycle_pool_1.RecyclePool(()=>({node:null,distance:1/0,hitPoint:new cc_1.Vec3}),8),resultModels=[],aabbUI=new AABB,poolUI=new recycle_pool_1.RecyclePool(()=>({node:null,distance:1/0,hitPoint:new cc_1.Vec3}),8),resultCanvas=[],resultAll=[],resultSingleModel=[];let raycastColliderResults=[];const narrowphase=(e,t,r,o,s=1/0,c)=>{if(narrowDis=s,!t){const r=e.length/3;t=new Uint32Array([...Array(r).keys()])}if(r===cc_1.gfx.PrimitiveMode.TRIANGLE_LIST){const r=t.length;for(let s=0;s<r;s+=3){const r=3*t[s],n=3*t[s+1],l=3*t[s+2];cc_1.Vec3.set(tri.a,e[r],e[r+1],e[r+2]),cc_1.Vec3.set(tri.b,e[n],e[n+1],e[n+2]),cc_1.Vec3.set(tri.c,e[l],e[l+1],e[l+2]);const a=intersect_1.default.ray_triangle(modelRay,tri,o,c);a<=0||a>=narrowDis||(narrowDis=a)}}else if(r===cc_1.gfx.PrimitiveMode.TRIANGLE_STRIP){const r=t.length-2;let s=0;for(let n=0;n<r;n+=1){const r=3*t[n-s],l=3*t[n+s+1],a=3*t[n+2];cc_1.Vec3.set(tri.a,e[r],e[r+1],e[r+2]),cc_1.Vec3.set(tri.b,e[l],e[l+1],e[l+2]),cc_1.Vec3.set(tri.c,e[a],e[a+1],e[a+2]),s=~s;const i=intersect_1.default.ray_triangle(modelRay,tri,o,c);i<=0||i>=narrowDis||(narrowDis=i)}}else if(r===cc_1.gfx.PrimitiveMode.TRIANGLE_FAN){const r=t.length-1,s=3*t[0];cc_1.Vec3.set(tri.a,e[s],e[s+1],e[s+2]);for(let s=1;s<r;s+=1){const r=3*t[s],n=3*t[s+1];cc_1.Vec3.set(tri.b,e[r],e[r+1],e[r+2]),cc_1.Vec3.set(tri.c,e[n],e[n+1],e[n+2]);const l=intersect_1.default.ray_triangle(modelRay,tri,o,c);l<=0||l>=narrowDis||(narrowDis=l)}}else if(r===cc_1.gfx.PrimitiveMode.LINE_LIST){const r=t.length;for(let o=0;o<r;o+=2){const r=3*t[o],s=3*t[o+1];cc_1.Vec3.set(tempVec3_a,e[r],e[r+1],e[r+2]),cc_1.Vec3.set(tempVec3_b,e[s],e[s+1],e[s+2]);const n=intersect_1.default.ray_segment(modelRay,tempVec3_a,tempVec3_b,2,c);n<=0||n>=narrowDis||(narrowDis=n)}}},narrowphaseForSnap=(e,t,r,o,s=1/0,c)=>{if(narrowDis=s,!t){const r=e.length/3;t=new Uint32Array([...Array(r).keys()])}let n,l,a;const i=tri.a,d=tri.b,_=tri.c;let u;const y=cc_1.Vec3.fromArray;if(r===cc_1.gfx.PrimitiveMode.TRIANGLE_LIST){const r=t.length,s=t.length>3e6?3*Math.floor(t.length/3e6):3;for(let m=0;m<r;m+=s)n=3*t[m],l=3*t[m+1],a=3*t[m+2],y(i,e,n),y(d,e,l),y(_,e,a),(u=intersect_1.default.ray_triangle(modelRay,tri,o,c))<=0||u>=narrowDis||(narrowDis=u)}else if(r===cc_1.gfx.PrimitiveMode.TRIANGLE_STRIP){const r=t.length-2;let s=0;for(let i=0;i<r;i+=1)n=3*t[i-s],l=3*t[i+s+1],a=3*t[i+2],y(tri.a,e,n),y(tri.b,e,l),y(tri.c,e,a),s=~s,(u=intersect_1.default.ray_triangle(modelRay,tri,o,c))<=0||u>=narrowDis||(narrowDis=u)}else if(r===cc_1.gfx.PrimitiveMode.TRIANGLE_FAN){const r=t.length-1;n=3*t[0],cc_1.Vec3.set(tri.a,e[n],e[n+1],e[n+2]);for(let s=1;s<r;s+=1)l=3*t[s],a=3*t[s+1],y(d,e,l),y(_,e,a),(u=intersect_1.default.ray_triangle(modelRay,tri,o,c))<=0||u>=narrowDis||(narrowDis=u)}else if(r===cc_1.gfx.PrimitiveMode.LINE_LIST){const r=t.length;for(let o=0;o<r;o+=2)n=3*t[o],l=3*t[o+1],y(tempVec3_a,e,n),y(tempVec3_b,e,l),(u=intersect_1.default.ray_segment(modelRay,tempVec3_a,tempVec3_b,2,c))<=0||u>=narrowDis||(narrowDis=u)}};exports.default=new Raycast;