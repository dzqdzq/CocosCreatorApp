"use strict";var __importDefault=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(exports,"__esModule",{value:!0});const cc_1=require("cc"),aabb_1=__importDefault(require("./aabb")),intersect_1=__importDefault(require("./geom-utils/intersect")),ray_1=__importDefault(require("./geom-utils/ray")),triangle_1=__importDefault(require("./geom-utils/triangle")),recycle_pool_1=require("./memop/recycle-pool"),testHitPoint=new cc_1.Vec3,hitPoint=new cc_1.Vec3,worldM4=new cc_1.Mat4,inverseM4=new cc_1.Mat4;class Raycast{get rayResultCanvas(){return resultCanvas}get rayResultModels(){return resultModels}get rayResultAll(){return resultAll}get rayResultSingleModel(){return resultSingleModel}raycastAll(e,t,r=cc_1.Layers.Enum.DEFAULT|cc_1.Layers.Enum.UI_2D|cc_1.Layers.Enum.IGNORE_RAYCAST,o=1/0){const c=this.raycastAllModels(e,t,r,o),n=this.raycastAllCanvas(t,r,o),l=c||n;return resultAll.length=0,l&&(Array.prototype.push.apply(resultAll,resultModels),Array.prototype.push.apply(resultAll,resultCanvas)),l}raycastAllModels(e,t,r=cc_1.Layers.Enum.DEFAULT,o=1/0){pool.reset();for(const c of e.models){const e=c.transform;if(!(e&&c.enabled&&c.node.layer&r&&c.worldBounds))continue;let n=intersect_1.default.ray_aabb(t,c.worldBounds);if(!(n<=0||n>=o)){if(c.type===cc_1.renderer.scene.ModelType.DEFAULT){e.getWorldMatrix(worldM4),cc_1.Mat4.invert(m4,e.getWorldMatrix(m4)),cc_1.Vec3.transformMat4(modelRay.o,t.o,m4),cc_1.Vec3.normalize(modelRay.d,cc_1.Vec3.transformMat4Normal(modelRay.d,t.d,m4)),n=1/0;for(let e=0;e<c.subModels.length;++e){const r=c.subModels[e].subMesh;if(r&&r.geometricInfo){const{positions:e,indices:c,doubleSided:l}=r.geometricInfo;if(narrowphase(e,c,r.primitiveMode,l,o,testHitPoint),narrowDis<n){cc_1.Vec3.transformMat4(testHitPoint,testHitPoint,worldM4);let e=cc_1.Vec3.distance(t.o,testHitPoint);e<n&&(n=e,hitPoint.set(testHitPoint))}}}}if(n<o){const e=pool.add();e.node=c.node,e.distance=n,e.hitPoint=hitPoint,resultModels[pool.length-1]=e}}}return resultModels.length=pool.length,resultModels.length>0}raycastSingleModel(e,t,r=cc_1.Layers.Enum.DEFAULT,o=1/0){pool.reset();const c=t,n=c.transform;if(!(n&&c.enabled&&c.node.layer&r&&c.worldBounds))return!1;let l=intersect_1.default.ray_aabb(e,c.worldBounds);if(l<=0||l>=o)return!1;if(c.type===cc_1.renderer.scene.ModelType.DEFAULT){n.getWorldMatrix(worldM4),cc_1.Mat4.invert(inverseM4,n.getWorldMatrix(inverseM4)),cc_1.Vec3.transformMat4(modelRay.o,e.o,inverseM4),cc_1.Vec3.normalize(modelRay.d,cc_1.Vec3.transformMat4Normal(modelRay.d,e.d,m4)),l=1/0;for(let t=0;t<c.subModels.length;++t){const r=c.subModels[t].subMesh;if(r&&r.geometricInfo){const{positions:t,indices:c,doubleSided:n}=r.geometricInfo;if(narrowphase(t,c,r.primitiveMode,n,o,testHitPoint),narrowDis<l){cc_1.Vec3.transformMat4(testHitPoint,testHitPoint,worldM4);let t=cc_1.Vec3.distance(e.o,testHitPoint);t<l&&(l=t,hitPoint.set(testHitPoint))}}}}if(l<o){const e=pool.add();e.node=c.node,e.distance=l,e.hitPoint=hitPoint,resultSingleModel[pool.length-1]=e}return resultSingleModel.length=pool.length,resultSingleModel.length>0}raycastAllCanvas(e,t=cc_1.Layers.Enum.UI_2D,r=1/0){poolUI.reset();const o=cc.director.getScene().getComponentsInChildren(cc.Canvas);if(o&&o.length>0)for(let c=o.length-1;c>=0;c--){const n=o[c].node;n&&n.active&&this._raycastUI2DNodeRecursiveChildren(e,n,t,r)}return resultCanvas.length=poolUI.length,resultCanvas.length>0}_raycastUI2DNode(e,t,r=cc_1.Layers.Enum.UI_2D,o=1/0){const c=t._uiProps.uiTransformComp;if(!(c&&t.layer&r))return null;c.getComputeAABB(aabbUI);const n=intersect_1.default.ray_aabb(e,aabbUI);if(n<=0)return null;if(n<o){const e=poolUI.add();return e.node=t,e.distance=n,e}return null}_raycastUI2DNodeRecursiveChildren(e,t,r=cc_1.Layers.Enum.UI_2D,o=1/0){for(let c=t.children.length-1;c>=0;c--){const n=t.children[c];n&&n.active&&this._raycastUI2DNodeRecursiveChildren(e,n,r,o)}const c=this._raycastUI2DNode(e,t,r,o);c&&(resultCanvas[poolUI.length-1]=c)}}const modelRay=ray_1.default.create(),v3=new cc_1.Vec3,m4=new cc_1.Mat4;let narrowDis=1/0;const tri=triangle_1.default.create(),tempVec3_a=new cc_1.Vec3,tempVec3_b=new cc_1.Vec3,pool=new recycle_pool_1.RecyclePool(()=>({node:null,distance:1/0,hitPoint:new cc_1.Vec3}),8),resultModels=[],aabbUI=new aabb_1.default,poolUI=new recycle_pool_1.RecyclePool(()=>({node:null,distance:1/0,hitPoint:new cc_1.Vec3}),8),resultCanvas=[],resultAll=[],resultSingleModel=[],narrowphase=(e,t,r,o,c=1/0,n)=>{if(narrowDis=c,r===cc_1.gfx.PrimitiveMode.TRIANGLE_LIST){const r=t.length;for(let c=0;c<r;c+=3){const r=3*t[c],l=3*t[c+1],s=3*t[c+2];cc_1.Vec3.set(tri.a,e[r],e[r+1],e[r+2]),cc_1.Vec3.set(tri.b,e[l],e[l+1],e[l+2]),cc_1.Vec3.set(tri.c,e[s],e[s+1],e[s+2]);const a=intersect_1.default.ray_triangle(modelRay,tri,o,n);a<=0||a>=narrowDis||(narrowDis=a)}}else if(r===cc_1.gfx.PrimitiveMode.TRIANGLE_STRIP){const r=t.length-2;let c=0;for(let l=0;l<r;l+=1){const r=3*t[l-c],s=3*t[l+c+1],a=3*t[l+2];cc_1.Vec3.set(tri.a,e[r],e[r+1],e[r+2]),cc_1.Vec3.set(tri.b,e[s],e[s+1],e[s+2]),cc_1.Vec3.set(tri.c,e[a],e[a+1],e[a+2]),c=~c;const i=intersect_1.default.ray_triangle(modelRay,tri,o,n);i<=0||i>=narrowDis||(narrowDis=i)}}else if(r===cc_1.gfx.PrimitiveMode.TRIANGLE_FAN){const r=t.length-1,c=3*t[0];cc_1.Vec3.set(tri.a,e[c],e[c+1],e[c+2]);for(let c=1;c<r;c+=1){const r=3*t[c],l=3*t[c+1];cc_1.Vec3.set(tri.b,e[r],e[r+1],e[r+2]),cc_1.Vec3.set(tri.c,e[l],e[l+1],e[l+2]);const s=intersect_1.default.ray_triangle(modelRay,tri,o,n);s<=0||s>=narrowDis||(narrowDis=s)}}else if(r===cc_1.gfx.PrimitiveMode.LINE_LIST){const r=t.length;for(let o=0;o<r;o+=2){const r=3*t[o],c=3*t[o+1];cc_1.Vec3.set(tempVec3_a,e[r],e[r+1],e[r+2]),cc_1.Vec3.set(tempVec3_b,e[c],e[c+1],e[c+2]);const l=intersect_1.default.ray_segment(modelRay,tempVec3_a,tempVec3_b,2,n);l<=0||l>=narrowDis||(narrowDis=l)}}};exports.default=new Raycast;