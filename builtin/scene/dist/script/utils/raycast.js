"use strict";var __importDefault=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(exports,"__esModule",{value:!0}),exports.Raycast=void 0;const cc_1=require("cc"),intersect_1=__importDefault(require("./geom-utils/intersect")),recycle_pool_1=require("./memop/recycle-pool"),ray=cc_1.geometry.Ray,AABB=cc_1.geometry.AABB,triangle=cc_1.geometry.Triangle,testHitPoint=new cc_1.Vec3,hitPoint=new cc_1.Vec3,worldM4=new cc_1.Mat4,inverseM4=new cc_1.Mat4;class Raycast{get rayResultCanvas(){return resultCanvas}get rayResultModels(){return resultModels}get rayResultAll(){return resultAll}get rayResultSingleModel(){return resultSingleModel}get raycastColliderResults(){return raycastColliderResults}raycastAll(e,t,r=cc_1.Layers.Enum.DEFAULT|cc_1.Layers.Enum.UI_2D|cc_1.Layers.Enum.IGNORE_RAYCAST,c=1/0,o=!1,n){const s=this.raycastAllModels(e,t,r,c,o,n),l=this.raycastAllCanvas(t,r,c,n),a=s||l;return resultAll.length=0,a&&(Array.prototype.push.apply(resultAll,resultModels),Array.prototype.push.apply(resultAll,resultCanvas)),a}narrowPhaseStep(e,t,r,c,o=!1){const{transform:n}=e,s=o?narrowphaseForSnap:narrowphase;if(e.type===cc_1.renderer.scene.ModelType.DEFAULT){n.getWorldMatrix(worldM4),cc_1.Mat4.invert(m4,n.getWorldMatrix(m4)),cc_1.Vec3.transformMat4(modelRay.o,t.o,m4),cc_1.Vec3.normalize(modelRay.d,cc_1.Vec3.transformMat4Normal(modelRay.d,t.d,m4)),c=1/0;for(let o=0;o<e.subModels.length;++o){const n=e.subModels[o].subMesh;if(n&&n.geometricInfo){const{positions:e,indices:o,doubleSided:l}=n.geometricInfo;if(s(e,o,n.primitiveMode,!!l,r,testHitPoint),narrowDis<c){cc_1.Vec3.transformMat4(testHitPoint,testHitPoint,worldM4);const e=cc_1.Vec3.distance(t.o,testHitPoint);e<c&&(c=e,hitPoint.set(testHitPoint))}}}}return c}raycastAllModels(e,t,r=cc_1.Layers.Enum.DEFAULT,c=1/0,o,n){pool.reset();const s=[];for(const o of e.models){const l=o.transform;if(e.isCulledByLod(cce.Camera.camera.camera,o))continue;if(n&&o.node.layer&n)continue;if(!(l&&o.enabled&&o.node.layer&r&&o.worldBounds))continue;const a=intersect_1.default.ray_aabb(t,o.worldBounds);a<=0||a>=c||s.push([o,a])}s.sort((e,t)=>e[1]-t[1]);let l=Number.MAX_VALUE,a=0;return s.every((e,r)=>{const n=e[0];let s=e[1];if(o&&l<=s&&a>1)return!1;if((s=this.narrowPhaseStep(n,t,c,s,!0))<c){const e=pool.add();e.node=n.node,e.distance=s,e.hitPoint=new cc_1.Vec3(hitPoint),resultModels[pool.length-1]=e,l=s,a+=1}return!0}),resultModels.length=pool.length,resultModels.length>0}raycastSingleModel(e,t,r=cc_1.Layers.Enum.DEFAULT,c=1/0,o,n){pool.reset();const s=t;if(!s.transform||!s.enabled||!(s.node.layer&r)||!s.worldBounds||n&&n&s.node.layer)return!1;let l=intersect_1.default.ray_aabb(e,s.worldBounds);if(l<=0||l>=c)return!1;if((l=this.narrowPhaseStep(s,e,c,l,o))<c){const e=pool.add();e.node=s.node,e.distance=l,e.hitPoint=new cc_1.Vec3(hitPoint),resultSingleModel[pool.length-1]=e}return resultSingleModel.length=pool.length,resultSingleModel.length>0}raycastAllCanvas(e,t=cc_1.Layers.Enum.UI_2D,r=1/0,c){poolUI.reset();const o=cc.director.getScene().getComponentsInChildren(cc.Canvas);if(o&&o.length>0)for(let n=o.length-1;n>=0;n--){const s=o[n].node;s&&s.active&&this._raycastUI2DNodeRecursiveChildren(e,s,t,r,c)}return resultCanvas.length=poolUI.length,resultCanvas.length>0}raycastAllColliders(e,t=cc_1.Layers.Enum.DEFAULT){return!!cc_1.PhysicsSystem.instance.raycast(e,void 0,void 0,!1)&&(raycastColliderResults=cc_1.PhysicsSystem.instance.raycastResults,!0)}_raycastUI2DNode(e,t,r=cc_1.Layers.Enum.UI_2D,c=1/0,o){const n=t._uiProps.uiTransformComp;if(!n||!(t.layer&r)||o&&t.layer&o)return null;n.getComputeAABB(aabbUI);const s=intersect_1.default.ray_aabb(e,aabbUI);if(s<=0)return null;if(s<c){const e=poolUI.add();return e.node=t,e.distance=s,e}return null}_raycastUI2DNodeRecursiveChildren(e,t,r=cc_1.Layers.Enum.UI_2D,c=1/0,o){for(let n=t.children.length-1;n>=0;n--){const s=t.children[n];s&&s.active&&this._raycastUI2DNodeRecursiveChildren(e,s,r,c,o)}const n=this._raycastUI2DNode(e,t,r,c,o);n&&(resultCanvas[poolUI.length-1]=n)}}exports.Raycast=Raycast;const modelRay=ray.create(),v3=new cc_1.Vec3,m4=new cc_1.Mat4;let narrowDis=1/0;const tri=triangle.create(),tempVec3_a=new cc_1.Vec3,tempVec3_b=new cc_1.Vec3,defaultNode=new cc_1.Node,pool=new recycle_pool_1.RecyclePool(()=>({node:defaultNode,distance:1/0,hitPoint:new cc_1.Vec3}),8),resultModels=[],aabbUI=new AABB,poolUI=new recycle_pool_1.RecyclePool(()=>({node:defaultNode,distance:1/0,hitPoint:new cc_1.Vec3}),8),resultCanvas=[],resultAll=[],resultSingleModel=[];let raycastColliderResults=[];const narrowphase=(e,t,r,c,o=1/0,n)=>{if(narrowDis=o,!t){const r=e.length/3;t=new Uint32Array([...Array(r).keys()])}if(r===cc_1.gfx.PrimitiveMode.TRIANGLE_LIST){const r=t.length;for(let o=0;o<r;o+=3){const r=3*t[o],s=3*t[o+1],l=3*t[o+2];cc_1.Vec3.set(tri.a,e[r],e[r+1],e[r+2]),cc_1.Vec3.set(tri.b,e[s],e[s+1],e[s+2]),cc_1.Vec3.set(tri.c,e[l],e[l+1],e[l+2]);const a=intersect_1.default.ray_triangle(modelRay,tri,c,n);a<=0||a>=narrowDis||(narrowDis=a)}}else if(r===cc_1.gfx.PrimitiveMode.TRIANGLE_STRIP){const r=t.length-2;let o=0;for(let s=0;s<r;s+=1){const r=3*t[s-o],l=3*t[s+o+1],a=3*t[s+2];cc_1.Vec3.set(tri.a,e[r],e[r+1],e[r+2]),cc_1.Vec3.set(tri.b,e[l],e[l+1],e[l+2]),cc_1.Vec3.set(tri.c,e[a],e[a+1],e[a+2]),o=~o;const i=intersect_1.default.ray_triangle(modelRay,tri,c,n);i<=0||i>=narrowDis||(narrowDis=i)}}else if(r===cc_1.gfx.PrimitiveMode.TRIANGLE_FAN){const r=t.length-1,o=3*t[0];cc_1.Vec3.set(tri.a,e[o],e[o+1],e[o+2]);for(let o=1;o<r;o+=1){const r=3*t[o],s=3*t[o+1];cc_1.Vec3.set(tri.b,e[r],e[r+1],e[r+2]),cc_1.Vec3.set(tri.c,e[s],e[s+1],e[s+2]);const l=intersect_1.default.ray_triangle(modelRay,tri,c,n);l<=0||l>=narrowDis||(narrowDis=l)}}else if(r===cc_1.gfx.PrimitiveMode.LINE_LIST){const r=t.length;for(let c=0;c<r;c+=2){const r=3*t[c],o=3*t[c+1];cc_1.Vec3.set(tempVec3_a,e[r],e[r+1],e[r+2]),cc_1.Vec3.set(tempVec3_b,e[o],e[o+1],e[o+2]);const s=intersect_1.default.ray_segment(modelRay,tempVec3_a,tempVec3_b,2,n);s<=0||s>=narrowDis||(narrowDis=s)}}},narrowphaseForSnap=(e,t,r,c,o=1/0,n)=>{if(narrowDis=o,!t){const r=e.length/3;t=new Uint32Array([...Array(r).keys()])}let s,l,a;const i=tri.a,d=tri.b,_=tri.c;let u;const y=cc_1.Vec3.fromArray;if(r===cc_1.gfx.PrimitiveMode.TRIANGLE_LIST){const r=t.length,o=t.length>3e6?3*Math.floor(t.length/3e6):3;for(let f=0;f<r;f+=o)s=3*t[f],l=3*t[f+1],a=3*t[f+2],y(i,e,s),y(d,e,l),y(_,e,a),(u=intersect_1.default.ray_triangle(modelRay,tri,c,n))<=0||u>=narrowDis||(narrowDis=u)}else if(r===cc_1.gfx.PrimitiveMode.TRIANGLE_STRIP){const r=t.length-2;let o=0;for(let i=0;i<r;i+=1)s=3*t[i-o],l=3*t[i+o+1],a=3*t[i+2],y(tri.a,e,s),y(tri.b,e,l),y(tri.c,e,a),o=~o,(u=intersect_1.default.ray_triangle(modelRay,tri,c,n))<=0||u>=narrowDis||(narrowDis=u)}else if(r===cc_1.gfx.PrimitiveMode.TRIANGLE_FAN){const r=t.length-1;s=3*t[0],cc_1.Vec3.set(tri.a,e[s],e[s+1],e[s+2]);for(let o=1;o<r;o+=1)l=3*t[o],a=3*t[o+1],y(d,e,l),y(_,e,a),(u=intersect_1.default.ray_triangle(modelRay,tri,c,n))<=0||u>=narrowDis||(narrowDis=u)}else if(r===cc_1.gfx.PrimitiveMode.LINE_LIST){const r=t.length;for(let c=0;c<r;c+=2)s=3*t[c],l=3*t[c+1],y(tempVec3_a,e,s),y(tempVec3_b,e,l),(u=intersect_1.default.ray_segment(modelRay,tempVec3_a,tempVec3_b,2,n))<=0||u>=narrowDis||(narrowDis=u)}};exports.default=new Raycast;