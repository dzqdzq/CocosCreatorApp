"use strict";var __importDefault=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(exports,"__esModule",{value:!0}),exports.Raycast=void 0;const cc_1=require("cc"),camera_1=__importDefault(require("../3d/manager/camera")),intersect_1=__importDefault(require("./geom-utils/intersect")),recycle_pool_1=require("./memop/recycle-pool"),ray=cc_1.geometry.Ray,AABB=cc_1.geometry.AABB,triangle=cc_1.geometry.Triangle,testHitPoint=new cc_1.Vec3,hitPoint=new cc_1.Vec3,worldM4=new cc_1.Mat4,inverseM4=new cc_1.Mat4;class Raycast{get rayResultCanvas(){return resultCanvas}get rayResultModels(){return resultModels}get rayResultAll(){return resultAll}get rayResultSingleModel(){return resultSingleModel}get raycastColliderResults(){return raycastColliderResults}raycastAll(e,t,r=cc_1.Layers.Enum.DEFAULT|cc_1.Layers.Enum.UI_2D|cc_1.Layers.Enum.IGNORE_RAYCAST,c=1/0,n=!1,o){const s=this.raycastAllModels(e,t,r,c,n,o),l=this.raycastAllCanvas(t,r,c,o),a=s||l;return resultAll.length=0,a&&(Array.prototype.push.apply(resultAll,resultModels),Array.prototype.push.apply(resultAll,resultCanvas)),a}narrowPhaseStep(e,t,r,c,n=!1){const{transform:o}=e,s=n?narrowphaseForSnap:narrowphase;if(e.type===cc_1.renderer.scene.ModelType.DEFAULT){o.getWorldMatrix(worldM4),cc_1.Mat4.invert(m4,o.getWorldMatrix(m4)),cc_1.Vec3.transformMat4(modelRay.o,t.o,m4),cc_1.Vec3.normalize(modelRay.d,cc_1.Vec3.transformMat4Normal(modelRay.d,t.d,m4)),c=1/0;for(let n=0;n<e.subModels.length;++n){const o=e.subModels[n].subMesh;if(o&&o.geometricInfo){const{positions:e,indices:n,doubleSided:l}=o.geometricInfo;if(s(e,n,o.primitiveMode,l,r,testHitPoint),narrowDis<c){cc_1.Vec3.transformMat4(testHitPoint,testHitPoint,worldM4);const e=cc_1.Vec3.distance(t.o,testHitPoint);e<c&&(c=e,hitPoint.set(testHitPoint))}}}}return c}raycastAllModels(e,t,r=cc_1.Layers.Enum.DEFAULT,c=1/0,n,o){pool.reset();const s=[];for(const n of e.models){const l=n.transform;if(e.isCulledByLod(camera_1.default.camera.camera,n))continue;if(o&&n.node.layer&o)continue;if(!(l&&n.enabled&&n.node.layer&r&&n.worldBounds))continue;const a=intersect_1.default.ray_aabb(t,n.worldBounds);a<=0||a>=c||s.push([n,a])}s.sort((e,t)=>e[1]-t[1]);let l=Number.MAX_VALUE,a=0;return s.every((e,r)=>{const o=e[0];let s=e[1];if(n&&l<=s&&a>1)return!1;if((s=this.narrowPhaseStep(o,t,c,s,!0))<c){const e=pool.add();e.node=o.node,e.distance=s,e.hitPoint=new cc_1.Vec3(hitPoint),resultModels[pool.length-1]=e,l=s,a+=1}return!0}),resultModels.length=pool.length,resultModels.length>0}raycastSingleModel(e,t,r=cc_1.Layers.Enum.DEFAULT,c=1/0,n,o){pool.reset();const s=t;if(!s.transform||!s.enabled||!(s.node.layer&r)||!s.worldBounds||o&&o&s.node.layer)return!1;let l=intersect_1.default.ray_aabb(e,s.worldBounds);if(l<=0||l>=c)return!1;if((l=this.narrowPhaseStep(s,e,c,l,n))<c){const e=pool.add();e.node=s.node,e.distance=l,e.hitPoint=new cc_1.Vec3(hitPoint),resultSingleModel[pool.length-1]=e}return resultSingleModel.length=pool.length,resultSingleModel.length>0}raycastAllCanvas(e,t=cc_1.Layers.Enum.UI_2D,r=1/0,c){poolUI.reset();const n=cc.director.getScene().getComponentsInChildren(cc.Canvas);if(n&&n.length>0)for(let o=n.length-1;o>=0;o--){const s=n[o].node;s&&s.active&&this._raycastUI2DNodeRecursiveChildren(e,s,t,r,c)}return resultCanvas.length=poolUI.length,resultCanvas.length>0}raycastAllColliders(e,t=cc_1.Layers.Enum.DEFAULT){return!!cc_1.PhysicsSystem.instance.raycast(e,void 0,void 0,!1)&&(raycastColliderResults=cc_1.PhysicsSystem.instance.raycastResults,!0)}_raycastUI2DNode(e,t,r=cc_1.Layers.Enum.UI_2D,c=1/0,n){const o=t._uiProps.uiTransformComp;if(!o||!(t.layer&r)||n&&t.layer&n)return null;o.getComputeAABB(aabbUI);const s=intersect_1.default.ray_aabb(e,aabbUI);if(s<=0)return null;if(s<c){const e=poolUI.add();return e.node=t,e.distance=s,e}return null}_raycastUI2DNodeRecursiveChildren(e,t,r=cc_1.Layers.Enum.UI_2D,c=1/0,n){for(let o=t.children.length-1;o>=0;o--){const s=t.children[o];s&&s.active&&this._raycastUI2DNodeRecursiveChildren(e,s,r,c,n)}const o=this._raycastUI2DNode(e,t,r,c,n);o&&(resultCanvas[poolUI.length-1]=o)}}exports.Raycast=Raycast;const modelRay=ray.create(),v3=new cc_1.Vec3,m4=new cc_1.Mat4;let narrowDis=1/0;const tri=triangle.create(),tempVec3_a=new cc_1.Vec3,tempVec3_b=new cc_1.Vec3,pool=new recycle_pool_1.RecyclePool(()=>({node:null,distance:1/0,hitPoint:new cc_1.Vec3}),8),resultModels=[],aabbUI=new AABB,poolUI=new recycle_pool_1.RecyclePool(()=>({node:null,distance:1/0,hitPoint:new cc_1.Vec3}),8),resultCanvas=[],resultAll=[],resultSingleModel=[];let raycastColliderResults=[];const narrowphase=(e,t,r,c,n=1/0,o)=>{if(narrowDis=n,!t){const r=e.length/3;t=new Uint32Array([...Array(r).keys()])}if(r===cc_1.gfx.PrimitiveMode.TRIANGLE_LIST){const r=t.length;for(let n=0;n<r;n+=3){const r=3*t[n],s=3*t[n+1],l=3*t[n+2];cc_1.Vec3.set(tri.a,e[r],e[r+1],e[r+2]),cc_1.Vec3.set(tri.b,e[s],e[s+1],e[s+2]),cc_1.Vec3.set(tri.c,e[l],e[l+1],e[l+2]);const a=intersect_1.default.ray_triangle(modelRay,tri,c,o);a<=0||a>=narrowDis||(narrowDis=a)}}else if(r===cc_1.gfx.PrimitiveMode.TRIANGLE_STRIP){const r=t.length-2;let n=0;for(let s=0;s<r;s+=1){const r=3*t[s-n],l=3*t[s+n+1],a=3*t[s+2];cc_1.Vec3.set(tri.a,e[r],e[r+1],e[r+2]),cc_1.Vec3.set(tri.b,e[l],e[l+1],e[l+2]),cc_1.Vec3.set(tri.c,e[a],e[a+1],e[a+2]),n=~n;const i=intersect_1.default.ray_triangle(modelRay,tri,c,o);i<=0||i>=narrowDis||(narrowDis=i)}}else if(r===cc_1.gfx.PrimitiveMode.TRIANGLE_FAN){const r=t.length-1,n=3*t[0];cc_1.Vec3.set(tri.a,e[n],e[n+1],e[n+2]);for(let n=1;n<r;n+=1){const r=3*t[n],s=3*t[n+1];cc_1.Vec3.set(tri.b,e[r],e[r+1],e[r+2]),cc_1.Vec3.set(tri.c,e[s],e[s+1],e[s+2]);const l=intersect_1.default.ray_triangle(modelRay,tri,c,o);l<=0||l>=narrowDis||(narrowDis=l)}}else if(r===cc_1.gfx.PrimitiveMode.LINE_LIST){const r=t.length;for(let c=0;c<r;c+=2){const r=3*t[c],n=3*t[c+1];cc_1.Vec3.set(tempVec3_a,e[r],e[r+1],e[r+2]),cc_1.Vec3.set(tempVec3_b,e[n],e[n+1],e[n+2]);const s=intersect_1.default.ray_segment(modelRay,tempVec3_a,tempVec3_b,2,o);s<=0||s>=narrowDis||(narrowDis=s)}}},narrowphaseForSnap=(e,t,r,c,n=1/0,o)=>{if(narrowDis=n,!t){const r=e.length/3;t=new Uint32Array([...Array(r).keys()])}let s,l,a;const i=tri.a,d=tri.b,_=tri.c;let u;const y=cc_1.Vec3.fromArray;if(r===cc_1.gfx.PrimitiveMode.TRIANGLE_LIST){const r=t.length,n=t.length>3e6?3*Math.floor(t.length/3e6):3;for(let m=0;m<r;m+=n)s=3*t[m],l=3*t[m+1],a=3*t[m+2],y(i,e,s),y(d,e,l),y(_,e,a),(u=intersect_1.default.ray_triangle(modelRay,tri,c,o))<=0||u>=narrowDis||(narrowDis=u)}else if(r===cc_1.gfx.PrimitiveMode.TRIANGLE_STRIP){const r=t.length-2;let n=0;for(let i=0;i<r;i+=1)s=3*t[i-n],l=3*t[i+n+1],a=3*t[i+2],y(tri.a,e,s),y(tri.b,e,l),y(tri.c,e,a),n=~n,(u=intersect_1.default.ray_triangle(modelRay,tri,c,o))<=0||u>=narrowDis||(narrowDis=u)}else if(r===cc_1.gfx.PrimitiveMode.TRIANGLE_FAN){const r=t.length-1;s=3*t[0],cc_1.Vec3.set(tri.a,e[s],e[s+1],e[s+2]);for(let n=1;n<r;n+=1)l=3*t[n],a=3*t[n+1],y(d,e,l),y(_,e,a),(u=intersect_1.default.ray_triangle(modelRay,tri,c,o))<=0||u>=narrowDis||(narrowDis=u)}else if(r===cc_1.gfx.PrimitiveMode.LINE_LIST){const r=t.length;for(let c=0;c<r;c+=2)s=3*t[c],l=3*t[c+1],y(tempVec3_a,e,s),y(tempVec3_b,e,l),(u=intersect_1.default.ray_segment(modelRay,tempVec3_a,tempVec3_b,2,o))<=0||u>=narrowDis||(narrowDis=u)}};exports.default=new Raycast;