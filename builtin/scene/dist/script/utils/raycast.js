"use strict";var __importDefault=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(exports,"__esModule",{value:!0}),exports.Raycast=void 0;const cc_1=require("cc"),camera_1=__importDefault(require("../3d/manager/camera")),intersect_1=__importDefault(require("./geom-utils/intersect")),recycle_pool_1=require("./memop/recycle-pool"),ray=cc_1.geometry.Ray,AABB=cc_1.geometry.AABB,triangle=cc_1.geometry.Triangle,testHitPoint=new cc_1.Vec3,hitPoint=new cc_1.Vec3,worldM4=new cc_1.Mat4,inverseM4=new cc_1.Mat4;class Raycast{get rayResultCanvas(){return resultCanvas}get rayResultModels(){return resultModels}get rayResultAll(){return resultAll}get rayResultSingleModel(){return resultSingleModel}get raycastColliderResults(){return raycastColliderResults}raycastAll(e,t,r=cc_1.Layers.Enum.DEFAULT|cc_1.Layers.Enum.UI_2D|cc_1.Layers.Enum.IGNORE_RAYCAST,o=1/0,c){const n=this.raycastAllModels(e,t,r,o,c),s=this.raycastAllCanvas(t,r,o,c),l=n||s;return resultAll.length=0,l&&(Array.prototype.push.apply(resultAll,resultModels),Array.prototype.push.apply(resultAll,resultCanvas)),l}raycastAllForSnap(e,t,r=cc_1.Layers.Enum.DEFAULT|cc_1.Layers.Enum.UI_2D|cc_1.Layers.Enum.IGNORE_RAYCAST,o=1/0,c){const n=this.raycastAllModelsForSnap(e,t,r,o,c),s=this.raycastAllCanvas(t,r,o,c),l=n||s;return resultAll.length=0,l&&(Array.prototype.push.apply(resultAll,resultModels),Array.prototype.push.apply(resultAll,resultCanvas)),l}raycastAllModels(e,t,r=cc_1.Layers.Enum.DEFAULT,o=1/0,c){pool.reset();const n=[];for(const s of e.models){const l=s.transform;if(e.isCulledByLod(camera_1.default.camera.camera,s))continue;if(c&&s.node.layer&c)continue;if(!(l&&s.enabled&&s.node.layer&r&&s.worldBounds))continue;const a=intersect_1.default.ray_aabb(t,s.worldBounds);a<=0||a>=o||n.push([s,a])}n.sort((e,t)=>e[1]-t[1]);let s=Number.MAX_VALUE;return n.every((e,r)=>{const c=e[0];let n=e[1];const l=c.transform;if(c.type===cc_1.renderer.scene.ModelType.DEFAULT){l.getWorldMatrix(worldM4),cc_1.Mat4.invert(m4,l.getWorldMatrix(m4)),cc_1.Vec3.transformMat4(modelRay.o,t.o,m4),cc_1.Vec3.normalize(modelRay.d,cc_1.Vec3.transformMat4Normal(modelRay.d,t.d,m4)),n=1/0;for(let e=0;e<c.subModels.length;++e){const r=c.subModels[e].subMesh;if(r&&r.geometricInfo){const{positions:e,indices:c,doubleSided:s}=r.geometricInfo;if(narrowphase(e,c,r.primitiveMode,s,o,testHitPoint),narrowDis<n){cc_1.Vec3.transformMat4(testHitPoint,testHitPoint,worldM4);const e=cc_1.Vec3.distance(t.o,testHitPoint);e<n&&(n=e,hitPoint.set(testHitPoint))}}}}if(n<o){const e=pool.add();e.node=c.node,e.distance=n,e.hitPoint=new cc_1.Vec3(hitPoint),resultModels[pool.length-1]=e,s=n}return!0}),resultModels.length=pool.length,resultModels.length>0}raycastAllModelsForSnap(e,t,r=cc_1.Layers.Enum.DEFAULT,o=1/0,c){pool.reset();const n=[];for(const s of e.models){const l=s.transform;if(e.isCulledByLod(camera_1.default.camera.camera,s))continue;if(c&&s.node.layer&c)continue;if(!(l&&s.enabled&&s.node.layer&r&&s.worldBounds))continue;const a=intersect_1.default.ray_aabb(t,s.worldBounds);a<=0||a>=o||n.push([s,a])}n.sort((e,t)=>e[1]-t[1]);let s=Number.MAX_VALUE,l=0;return n.every((e,r)=>{const c=e[0];let n=e[1];if(s<=n&&l>1)return!1;const a=c.transform;if(c.type===cc_1.renderer.scene.ModelType.DEFAULT){a.getWorldMatrix(worldM4),cc_1.Mat4.invert(m4,a.getWorldMatrix(m4)),cc_1.Vec3.transformMat4(modelRay.o,t.o,m4),cc_1.Vec3.normalize(modelRay.d,cc_1.Vec3.transformMat4Normal(modelRay.d,t.d,m4)),n=1/0;for(let e=0;e<c.subModels.length;++e){const r=c.subModels[e].subMesh;if(r&&r.geometricInfo){const{positions:e,indices:c,doubleSided:s}=r.geometricInfo;if(narrowphaseForSnap(e,c,r.primitiveMode,s,o,testHitPoint),narrowDis<n){cc_1.Vec3.transformMat4(testHitPoint,testHitPoint,worldM4);const e=cc_1.Vec3.distance(t.o,testHitPoint);e<n&&(n=e,hitPoint.set(testHitPoint))}}}}if(n<o){const e=pool.add();e.node=c.node,e.distance=n,e.hitPoint=new cc_1.Vec3(hitPoint),resultModels[pool.length-1]=e,s=n,l+=1}return!0}),resultModels.length=pool.length,resultModels.length>0}raycastSingleModel(e,t,r=cc_1.Layers.Enum.DEFAULT,o=1/0,c){pool.reset();const n=t,s=n.transform;if(!s||!n.enabled||!(n.node.layer&r)||!n.worldBounds||c&&c&n.node.layer)return!1;let l=intersect_1.default.ray_aabb(e,n.worldBounds);if(l<=0||l>=o)return!1;if(n.type===cc_1.renderer.scene.ModelType.DEFAULT){s.getWorldMatrix(worldM4),cc_1.Mat4.invert(inverseM4,s.getWorldMatrix(inverseM4)),cc_1.Vec3.transformMat4(modelRay.o,e.o,inverseM4),cc_1.Vec3.normalize(modelRay.d,cc_1.Vec3.transformMat4Normal(modelRay.d,e.d,m4)),l=1/0;for(let t=0;t<n.subModels.length;++t){const r=n.subModels[t].subMesh;if(r&&r.geometricInfo){const{positions:t,indices:c,doubleSided:n}=r.geometricInfo;if(narrowphase(t,c,r.primitiveMode,n,o,testHitPoint),narrowDis<l){cc_1.Vec3.transformMat4(testHitPoint,testHitPoint,worldM4);const t=cc_1.Vec3.distance(e.o,testHitPoint);t<l&&(l=t,hitPoint.set(testHitPoint))}}}}if(l<o){const e=pool.add();e.node=n.node,e.distance=l,e.hitPoint=new cc_1.Vec3(hitPoint),resultSingleModel[pool.length-1]=e}return resultSingleModel.length=pool.length,resultSingleModel.length>0}raycastAllCanvas(e,t=cc_1.Layers.Enum.UI_2D,r=1/0,o){poolUI.reset();const c=cc.director.getScene().getComponentsInChildren(cc.Canvas);if(c&&c.length>0)for(let n=c.length-1;n>=0;n--){const s=c[n].node;s&&s.active&&this._raycastUI2DNodeRecursiveChildren(e,s,t,r,o)}return resultCanvas.length=poolUI.length,resultCanvas.length>0}raycastAllColliders(e,t=cc_1.Layers.Enum.DEFAULT){return!!cc_1.PhysicsSystem.instance.raycast(e,void 0,void 0,!1)&&(raycastColliderResults=cc_1.PhysicsSystem.instance.raycastResults,!0)}_raycastUI2DNode(e,t,r=cc_1.Layers.Enum.UI_2D,o=1/0,c){const n=t._uiProps.uiTransformComp;if(!n||!(t.layer&r)||c&&t.layer&c)return null;n.getComputeAABB(aabbUI);const s=intersect_1.default.ray_aabb(e,aabbUI);if(s<=0)return null;if(s<o){const e=poolUI.add();return e.node=t,e.distance=s,e}return null}_raycastUI2DNodeRecursiveChildren(e,t,r=cc_1.Layers.Enum.UI_2D,o=1/0,c){for(let n=t.children.length-1;n>=0;n--){const s=t.children[n];s&&s.active&&this._raycastUI2DNodeRecursiveChildren(e,s,r,o,c)}const n=this._raycastUI2DNode(e,t,r,o,c);n&&(resultCanvas[poolUI.length-1]=n)}}exports.Raycast=Raycast;const modelRay=ray.create(),v3=new cc_1.Vec3,m4=new cc_1.Mat4;let narrowDis=1/0;const tri=triangle.create(),tempVec3_a=new cc_1.Vec3,tempVec3_b=new cc_1.Vec3,pool=new recycle_pool_1.RecyclePool(()=>({node:null,distance:1/0,hitPoint:new cc_1.Vec3}),8),resultModels=[],aabbUI=new AABB,poolUI=new recycle_pool_1.RecyclePool(()=>({node:null,distance:1/0,hitPoint:new cc_1.Vec3}),8),resultCanvas=[],resultAll=[],resultSingleModel=[];let raycastColliderResults=[];const narrowphase=(e,t,r,o,c=1/0,n)=>{if(narrowDis=c,!t){const r=e.length/3;t=new Uint32Array([...Array(r).keys()])}if(r===cc_1.gfx.PrimitiveMode.TRIANGLE_LIST){const r=t.length;for(let c=0;c<r;c+=3){const r=3*t[c],s=3*t[c+1],l=3*t[c+2];cc_1.Vec3.set(tri.a,e[r],e[r+1],e[r+2]),cc_1.Vec3.set(tri.b,e[s],e[s+1],e[s+2]),cc_1.Vec3.set(tri.c,e[l],e[l+1],e[l+2]);const a=intersect_1.default.ray_triangle(modelRay,tri,o,n);a<=0||a>=narrowDis||(narrowDis=a)}}else if(r===cc_1.gfx.PrimitiveMode.TRIANGLE_STRIP){const r=t.length-2;let c=0;for(let s=0;s<r;s+=1){const r=3*t[s-c],l=3*t[s+c+1],a=3*t[s+2];cc_1.Vec3.set(tri.a,e[r],e[r+1],e[r+2]),cc_1.Vec3.set(tri.b,e[l],e[l+1],e[l+2]),cc_1.Vec3.set(tri.c,e[a],e[a+1],e[a+2]),c=~c;const i=intersect_1.default.ray_triangle(modelRay,tri,o,n);i<=0||i>=narrowDis||(narrowDis=i)}}else if(r===cc_1.gfx.PrimitiveMode.TRIANGLE_FAN){const r=t.length-1,c=3*t[0];cc_1.Vec3.set(tri.a,e[c],e[c+1],e[c+2]);for(let c=1;c<r;c+=1){const r=3*t[c],s=3*t[c+1];cc_1.Vec3.set(tri.b,e[r],e[r+1],e[r+2]),cc_1.Vec3.set(tri.c,e[s],e[s+1],e[s+2]);const l=intersect_1.default.ray_triangle(modelRay,tri,o,n);l<=0||l>=narrowDis||(narrowDis=l)}}else if(r===cc_1.gfx.PrimitiveMode.LINE_LIST){const r=t.length;for(let o=0;o<r;o+=2){const r=3*t[o],c=3*t[o+1];cc_1.Vec3.set(tempVec3_a,e[r],e[r+1],e[r+2]),cc_1.Vec3.set(tempVec3_b,e[c],e[c+1],e[c+2]);const s=intersect_1.default.ray_segment(modelRay,tempVec3_a,tempVec3_b,2,n);s<=0||s>=narrowDis||(narrowDis=s)}}},narrowphaseForSnap=(e,t,r,o,c=1/0,n)=>{if(narrowDis=c,!t){const r=e.length/3;t=new Uint32Array([...Array(r).keys()])}let s,l,a;const i=tri.a,d=tri.b,_=tri.c;let u;const y=cc_1.Vec3.fromArray;if(r===cc_1.gfx.PrimitiveMode.TRIANGLE_LIST){const r=t.length,c=t.length>3e6?3*Math.floor(t.length/3e6):3;for(let m=0;m<r;m+=c)s=3*t[m],l=3*t[m+1],a=3*t[m+2],y(i,e,s),y(d,e,l),y(_,e,a),(u=intersect_1.default.ray_triangle(modelRay,tri,o,n))<=0||u>=narrowDis||(narrowDis=u)}else if(r===cc_1.gfx.PrimitiveMode.TRIANGLE_STRIP){const r=t.length-2;let c=0;for(let i=0;i<r;i+=1)s=3*t[i-c],l=3*t[i+c+1],a=3*t[i+2],y(tri.a,e,s),y(tri.b,e,l),y(tri.c,e,a),c=~c,(u=intersect_1.default.ray_triangle(modelRay,tri,o,n))<=0||u>=narrowDis||(narrowDis=u)}else if(r===cc_1.gfx.PrimitiveMode.TRIANGLE_FAN){const r=t.length-1;s=3*t[0],cc_1.Vec3.set(tri.a,e[s],e[s+1],e[s+2]);for(let c=1;c<r;c+=1)l=3*t[c],a=3*t[c+1],y(d,e,l),y(_,e,a),(u=intersect_1.default.ray_triangle(modelRay,tri,o,n))<=0||u>=narrowDis||(narrowDis=u)}else if(r===cc_1.gfx.PrimitiveMode.LINE_LIST){const r=t.length;for(let o=0;o<r;o+=2)s=3*t[o],l=3*t[o+1],y(tempVec3_a,e,s),y(tempVec3_b,e,l),(u=intersect_1.default.ray_segment(modelRay,tempVec3_a,tempVec3_b,2,n))<=0||u>=narrowDis||(narrowDis=u)}};exports.default=new Raycast;