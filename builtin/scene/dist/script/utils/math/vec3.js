"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.MVec3=void 0;const cc_1=require("cc"),utils_1=require("./utils");let _x=0,_y=0,_z=0;const v3_1=new cc_1.Vec3,v3_2=new cc_1.Vec3;class MVec3{static zero(t){return t.x=0,t.y=0,t.z=0,t}static clone(t){return new cc_1.Vec3(t.x,t.y,t.z)}static copy(t,x){return t.x=x.x,t.y=x.y,t.z=x.z,t}static set(t,x,z,y){return t.x=x,t.y=z,t.z=y,t}static add(t,x,z){return t.x=x.x+z.x,t.y=x.y+z.y,t.z=x.z+z.z,t}static subtract(t,x,z){return t.x=x.x-z.x,t.y=x.y-z.y,t.z=x.z-z.z,t}static multiply(t,x,z){return t.x=x.x*z.x,t.y=x.y*z.y,t.z=x.z*z.z,t}static divide(t,x,z){return t.x=x.x/z.x,t.y=x.y/z.y,t.z=x.z/z.z,t}static ceil(t,x){return t.x=Math.ceil(x.x),t.y=Math.ceil(x.y),t.z=Math.ceil(x.z),t}static floor(t,x){return t.x=Math.floor(x.x),t.y=Math.floor(x.y),t.z=Math.floor(x.z),t}static min(t,x,z){return t.x=Math.min(x.x,z.x),t.y=Math.min(x.y,z.y),t.z=Math.min(x.z,z.z),t}static max(t,x,z){return t.x=Math.max(x.x,z.x),t.y=Math.max(x.y,z.y),t.z=Math.max(x.z,z.z),t}static round(t,x){return t.x=Math.round(x.x),t.y=Math.round(x.y),t.z=Math.round(x.z),t}static multiplyScalar(t,x,z){return t.x=x.x*z,t.y=x.y*z,t.z=x.z*z,t}static scaleAndAdd(t,x,z,y){return t.x=x.x+z.x*y,t.y=x.y+z.y*y,t.z=x.z+z.z*y,t}static distance(t,x){return _x=x.x-t.x,_y=x.y-t.y,_z=x.z-t.z,Math.sqrt(_x*_x+_y*_y+_z*_z)}static squaredDistance(t,x){return _x=x.x-t.x,_y=x.y-t.y,_z=x.z-t.z,_x*_x+_y*_y+_z*_z}static len(t){return _x=t.x,_y=t.y,_z=t.z,Math.sqrt(_x*_x+_y*_y+_z*_z)}static lengthSqr(t){return _x=t.x,_y=t.y,_z=t.z,_x*_x+_y*_y+_z*_z}static negate(t,x){return t.x=-x.x,t.y=-x.y,t.z=-x.z,t}static invert(t,x){return t.x=1/x.x,t.y=1/x.y,t.z=1/x.z,t}static invertSafe(t,x){return _x=x.x,_y=x.y,_z=x.z,Math.abs(_x)<utils_1.EPSILON?t.x=0:t.x=1/_x,Math.abs(_y)<utils_1.EPSILON?t.y=0:t.y=1/_y,Math.abs(_z)<utils_1.EPSILON?t.z=0:t.z=1/_z,t}static normalize(t,x){_x=x.x,_y=x.y,_z=x.z;let z=_x*_x+_y*_y+_z*_z;return z>0&&(z=1/Math.sqrt(z),t.x=_x*z,t.y=_y*z,t.z=_z*z),t}static dot(t,x){return t.x*x.x+t.y*x.y+t.z*x.z}static cross(t,x,z){const{x:y,y:_,z:e}=x,{x:r,y:a,z:c}=z;return t.x=_*c-e*a,t.y=e*r-y*c,t.z=y*a-_*r,t}static lerp(t,x,z,y){return t.x=x.x+y*(z.x-x.x),t.y=x.y+y*(z.y-x.y),t.z=x.z+y*(z.z-x.z),t}static random(t,x){x=x||1;const z=2*utils_1.random()*Math.PI,y=2*utils_1.random()-1,_=Math.sqrt(1-y*y);return t.x=_*Math.cos(z)*x,t.y=_*Math.sin(z)*x,t.z=y*x,t}static transformMat4(t,x,z){_x=x.x,_y=x.y,_z=x.z;let y=z.m03*_x+z.m07*_y+z.m11*_z+z.m15;return y=y?1/y:1,t.x=(z.m00*_x+z.m04*_y+z.m08*_z+z.m12)*y,t.y=(z.m01*_x+z.m05*_y+z.m09*_z+z.m13)*y,t.z=(z.m02*_x+z.m06*_y+z.m10*_z+z.m14)*y,t}static transformMat4Normal(t,x,z){_x=x.x,_y=x.y,_z=x.z;let y=z.m03*_x+z.m07*_y+z.m11*_z;return y=y?1/y:1,t.x=(z.m00*_x+z.m04*_y+z.m08*_z)*y,t.y=(z.m01*_x+z.m05*_y+z.m09*_z)*y,t.z=(z.m02*_x+z.m06*_y+z.m10*_z)*y,t}static transformMat3(t,x,z){return _x=x.x,_y=x.y,_z=x.z,t.x=_x*z.m00+_y*z.m03+_z*z.m06,t.y=_x*z.m01+_y*z.m04+_z*z.m07,t.z=_x*z.m02+_y*z.m05+_z*z.m08,t}static transformAffine(t,x,z){return _x=x.x,_y=x.y,_z=x.z,t.x=z.m00*_x+z.m01*_y+z.m02*_z+z.m03,t.y=z.m04*_x+z.m05*_y+z.m06*_z+z.m07,t.x=z.m08*_x+z.m09*_y+z.m10*_z+z.m11,t}static transformQuat(t,x,z){const y=z.w*x.x+z.y*x.z-z.z*x.y,_=z.w*x.y+z.z*x.x-z.x*x.z,e=z.w*x.z+z.x*x.y-z.y*x.x,r=-z.x*x.x-z.y*x.y-z.z*x.z;return t.x=y*z.w+r*-z.x+_*-z.z-e*-z.y,t.y=_*z.w+r*-z.y+e*-z.x-y*-z.z,t.z=e*z.w+r*-z.z+y*-z.y-_*-z.x,t}static transformRTS(t,x,z,y,_){const e=x.x*_.x,r=x.y*_.y,a=x.z*_.z,c=z.w*e+z.y*a-z.z*r,s=z.w*r+z.z*e-z.x*a,n=z.w*a+z.x*r-z.y*e,i=-z.x*e-z.y*r-z.z*a;return t.x=c*z.w+i*-z.x+s*-z.z-n*-z.y+y.x,t.y=s*z.w+i*-z.y+n*-z.x-c*-z.z+y.y,t.z=n*z.w+i*-z.z+c*-z.y-s*-z.x+y.z,t}static transformInverseRTS(t,x,z,y,_){const e=x.x-y.x,r=x.y-y.y,a=x.z-y.z,c=z.w*e-z.y*a+z.z*r,s=z.w*r-z.z*e+z.x*a,n=z.w*a-z.x*r+z.y*e,i=z.x*e+z.y*r+z.z*a;return t.x=(c*z.w+i*z.x+s*z.z-n*z.y)/_.x,t.y=(s*z.w+i*z.y+n*z.x-c*z.z)/_.y,t.z=(n*z.w+i*z.z+c*z.y-s*z.x)/_.z,t}static rotateX(t,x,z,y){_x=x.x-z.x,_y=x.y-z.y,_z=x.z-z.z;const _=Math.cos(y),e=Math.sin(y),r=_x,a=_y*_-_z*e,c=_y*e+_z*_;return t.x=r+z.x,t.y=a+z.y,t.z=c+z.z,t}static rotateY(t,x,z,y){_x=x.x-z.x,_y=x.y-z.y,_z=x.z-z.z;const _=Math.cos(y),e=Math.sin(y),r=_z*e+_x*_,a=_y,c=_z*_-_x*e;return t.x=r+z.x,t.y=a+z.y,t.z=c+z.z,t}static rotateZ(t,x,z,y){_x=x.x-z.x,_y=x.y-z.y,_z=x.z-z.z;const _=Math.cos(y),e=Math.sin(y),r=_x*_-_y*e,a=_x*e+_y*_,c=_z;return t.x=r+z.x,t.y=a+z.y,t.z=c+z.z,t}static toArray(t,x,z=0){return t[z+0]=x.x,t[z+1]=x.y,t[z+2]=x.z,t}static fromArray(t,x,z=0){return t.x=x[z+0],t.y=x[z+1],t.z=x[z+2],t}static strictEquals(t,x){return t.x===x.x&&t.y===x.y&&t.z===x.z}static equals(t,x,z=utils_1.EPSILON){const{x:y,y:_,z:e}=t,{x:r,y:a,z:c}=x;return Math.abs(y-r)<=z*Math.max(1,Math.abs(y),Math.abs(r))&&Math.abs(_-a)<=z*Math.max(1,Math.abs(_),Math.abs(a))&&Math.abs(e-c)<=z*Math.max(1,Math.abs(e),Math.abs(c))}static angle(t,x){MVec3.normalize(v3_1,t),MVec3.normalize(v3_2,x);const z=MVec3.dot(v3_1,v3_2);return z>1?0:z<-1?Math.PI:Math.acos(z)}static projectOnPlane(t,x,z){return MVec3.subtract(t,x,MVec3.project(t,x,z))}static project(t,x,z){const y=MVec3.lengthSqr(z);return y<1e-6?MVec3.set(t,0,0,0):MVec3.multiplyScalar(t,z,MVec3.dot(x,z)/y)}}exports.MVec3=MVec3,MVec3.UNIT_X=Object.freeze(new cc_1.Vec3(1,0,0)),MVec3.UNIT_Y=Object.freeze(new cc_1.Vec3(0,1,0)),MVec3.UNIT_Z=Object.freeze(new cc_1.Vec3(0,0,1)),MVec3.ZERO=Object.freeze(new cc_1.Vec3(0,0,0)),MVec3.ONE=Object.freeze(new cc_1.Vec3(1,1,1)),MVec3.NEG_ONE=Object.freeze(new cc_1.Vec3(-1,-1,-1));