"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.MQuat=void 0;const cc_1=require("cc"),utils_1=require("./utils"),vec3_1=require("./vec3");let _x=0,_y=0,_z=0,_w=0;const qt_1=new cc_1.Quat,qt_2=new cc_1.Quat,v3_1=new cc_1.Vec3,m3_1=new cc_1.Mat3,halfToRad=.5*Math.PI/180;class MQuat{static clone(t){return new cc_1.Quat(t.x,t.y,t.z,t.w)}static copy(t,a){return t.x=a.x,t.y=a.y,t.z=a.z,t.w=a.w,t}static set(t,a,e,s,c){return t.x=a,t.y=e,t.z=s,t.w=c,t}static identity(t){return t.x=0,t.y=0,t.z=0,t.w=1,t}static rotationTo(t,a,e){const s=vec3_1.MVec3.dot(a,e);return s<-.999999?(vec3_1.MVec3.cross(v3_1,vec3_1.MVec3.UNIT_X,a),v3_1.length()<1e-6&&vec3_1.MVec3.cross(v3_1,vec3_1.MVec3.UNIT_Y,a),vec3_1.MVec3.normalize(v3_1,v3_1),cc_1.Quat.fromAxisAngle(t,v3_1,Math.PI),t):s>.999999?(t.x=0,t.y=0,t.z=0,t.w=1,t):(vec3_1.MVec3.cross(v3_1,a,e),t.x=v3_1.x,t.y=v3_1.y,t.z=v3_1.z,t.w=1+s,cc_1.Quat.normalize(t,t))}static getAxisAngle(t,a){const e=2*Math.acos(a.w),s=Math.sin(e/2);return 0!==s?(t.x=a.x/s,t.y=a.y/s,t.z=a.z/s):(t.x=1,t.y=0,t.z=0),e}static multiply(t,a,e){return _x=a.x*e.w+a.w*e.x+a.y*e.z-a.z*e.y,_y=a.y*e.w+a.w*e.y+a.z*e.x-a.x*e.z,_z=a.z*e.w+a.w*e.z+a.x*e.y-a.y*e.x,_w=a.w*e.w-a.x*e.x-a.y*e.y-a.z*e.z,t.x=_x,t.y=_y,t.z=_z,t.w=_w,t}static multiplyScalar(t,a,e){return t.x=a.x*e,t.y=a.y*e,t.z=a.z*e,t.w=a.w*e,t}static scaleAndAdd(t,a,e,s){return t.x=a.x+e.x*s,t.y=a.y+e.y*s,t.z=a.z+e.z*s,t.w=a.w+e.w*s,t}static rotateX(t,a,e){e*=.5;const s=Math.sin(e),c=Math.cos(e);return t.x=a.x*c+a.w*s,t.y=a.y*c+a.z*s,t.z=a.z*c-a.y*s,t.w=a.w*c-a.x*s,t}static rotateY(t,a,e){e*=.5;const s=Math.sin(e),c=Math.cos(e);return t.x=a.x*c-a.z*s,t.y=a.y*c+a.w*s,t.z=a.z*c+a.x*s,t.w=a.w*c-a.y*s,t}static rotateZ(t,a,e){e*=.5;const s=Math.sin(e),c=Math.cos(e);return t.x=a.x*c+a.y*s,t.y=a.y*c-a.x*s,t.z=a.z*c+a.w*s,t.w=a.w*c-a.z*s,t}static rotateAround(t,a,e,s){return cc_1.Quat.invert(qt_1,a),vec3_1.MVec3.transformQuat(v3_1,e,qt_1),cc_1.Quat.fromAxisAngle(qt_1,v3_1,s),cc_1.Quat.multiply(t,a,qt_1),t}static rotateAroundLocal(t,a,e,s){return cc_1.Quat.fromAxisAngle(qt_1,e,s),cc_1.Quat.multiply(t,a,qt_1),t}static calculateW(t,a){return t.x=a.x,t.y=a.y,t.z=a.z,t.w=Math.sqrt(Math.abs(1-a.x*a.x-a.y*a.y-a.z*a.z)),t}static dot(t,a){return t.x*a.x+t.y*a.y+t.z*a.z+t.w*a.w}static lerp(t,a,e,s){return t.x=a.x+s*(e.x-a.x),t.y=a.y+s*(e.y-a.y),t.z=a.z+s*(e.z-a.z),t.w=a.w+s*(e.w-a.w),t}static slerp(t,a,e,s){let c=0,r=0,x=a.x*e.x+a.y*e.y+a.z*e.z+a.w*e.w;if(x<0&&(x=-x,e.x=-e.x,e.y=-e.y,e.z=-e.z,e.w=-e.w),1-x>1e-6){const t=Math.acos(x),a=Math.sin(t);c=Math.sin((1-s)*t)/a,r=Math.sin(s*t)/a}else c=1-s,r=s;return t.x=c*a.x+r*e.x,t.y=c*a.y+r*e.y,t.z=c*a.z+r*e.z,t.w=c*a.w+r*e.w,t}static sqlerp(t,a,e,s,c,r){return cc_1.Quat.slerp(qt_1,a,c,r),cc_1.Quat.slerp(qt_2,e,s,r),cc_1.Quat.slerp(t,qt_1,qt_2,2*r*(1-r)),t}static invert(t,a){const e=a.x*a.x+a.y*a.y+a.z*a.z+a.w*a.w,s=e?1/e:0;return t.x=-a.x*s,t.y=-a.y*s,t.z=-a.z*s,t.w=a.w*s,t}static conjugate(t,a){return t.x=-a.x,t.y=-a.y,t.z=-a.z,t.w=a.w,t}static len(t){return Math.sqrt(t.x*t.x+t.y*t.y+t.z*t.z+t.w*t.w)}static lengthSqr(t){return t.x*t.x+t.y*t.y+t.z*t.z+t.w*t.w}static normalize(t,a){let e=a.x*a.x+a.y*a.y+a.z*a.z+a.w*a.w;return e>0&&(e=1/Math.sqrt(e),t.x=a.x*e,t.y=a.y*e,t.z=a.z*e,t.w=a.w*e),t}static fromAxes(t,a,e,s){return cc_1.Mat3.set(m3_1,a.x,a.y,a.z,e.x,e.y,e.z,s.x,s.y,s.z),cc_1.Quat.normalize(t,cc_1.Quat.fromMat3(t,m3_1))}static fromViewUp(t,a,e){return cc_1.Mat3.fromViewUp(m3_1,a,e),cc_1.Quat.normalize(t,cc_1.Quat.fromMat3(t,m3_1))}static fromAxisAngle(t,a,e){e*=.5;const s=Math.sin(e);return t.x=s*a.x,t.y=s*a.y,t.z=s*a.z,t.w=Math.cos(e),t}static fromMat3(t,a){const{m00:e,m03:s,m06:c,m01:r,m04:x,m07:n,m02:y,m05:z,m08:i}=a,w=e+x+i;if(w>0){const a=.5/Math.sqrt(w+1);t.w=.25/a,t.x=(z-n)*a,t.y=(c-y)*a,t.z=(r-s)*a}else if(e>x&&e>i){const a=2*Math.sqrt(1+e-x-i);t.w=(z-n)/a,t.x=.25*a,t.y=(s+r)/a,t.z=(c+y)/a}else if(x>i){const a=2*Math.sqrt(1+x-e-i);t.w=(c-y)/a,t.x=(s+r)/a,t.y=.25*a,t.z=(n+z)/a}else{const a=2*Math.sqrt(1+i-e-x);t.w=(r-s)/a,t.x=(c+y)/a,t.y=(n+z)/a,t.z=.25*a}return t}static fromEuler(t,a,e,s){a*=halfToRad,e*=halfToRad,s*=halfToRad;const c=Math.sin(a),r=Math.cos(a),x=Math.sin(e),n=Math.cos(e),y=Math.sin(s),z=Math.cos(s);return t.x=c*n*z+r*x*y,t.y=r*x*z+c*n*y,t.z=r*n*y-c*x*z,t.w=r*n*z-c*x*y,t}static fromAngleZ(t,a){a*=halfToRad,t.x=t.y=0,t.z=Math.sin(a),t.w=Math.cos(a)}static toAxisX(t,a){const e=2*a.y,s=2*a.z;return t.x=1-e*a.y-s*a.z,t.y=e*a.x+s*a.w,t.z=s*a.x+e*a.w,t}static toAxisY(t,a){const e=2*a.x,s=2*a.y,c=2*a.z;return t.x=s*a.x-c*a.w,t.y=1-e*a.x-c*a.z,t.z=c*a.y+e*a.w,t}static toAxisZ(t,a){const e=2*a.x,s=2*a.y,c=2*a.z;return t.x=c*a.x-s*a.w,t.y=c*a.y-e*a.w,t.z=1-e*a.x-s*a.y,t}static toEuler(t,a,e){const{x:s,y:c,z:r,w:x}=a;let n=0,y=0,z=0;const i=s*c+r*x;if(i>.499999)n=0,y=utils_1.toDegree(2*Math.atan2(s,x)),z=90;else if(i<-.499999)n=0,y=-utils_1.toDegree(2*Math.atan2(s,x)),z=-90;else{const t=s*s,a=c*c,w=r*r;n=utils_1.toDegree(Math.atan2(2*s*x-2*c*r,1-2*t-2*w)),y=utils_1.toDegree(Math.atan2(2*c*x-2*s*r,1-2*a-2*w)),z=utils_1.toDegree(Math.asin(2*i)),e&&(n=-180*Math.sign(n+1e-6)+n,y=-180*Math.sign(y+1e-6)+y,z=180*Math.sign(z+1e-6)-z)}return t.x=n,t.y=y,t.z=z,t}static toArray(t,a,e=0){return t[e+0]=a.x,t[e+1]=a.y,t[e+2]=a.z,t[e+3]=a.w,t}static fromArray(t,a,e=0){return t.x=a[e+0],t.y=a[e+1],t.z=a[e+2],t.w=a[e+3],t}static strictEquals(t,a){return t.x===a.x&&t.y===a.y&&t.z===a.z&&t.w===a.w}static equals(t,a,e=utils_1.EPSILON){return Math.abs(t.x-a.x)<=e*Math.max(1,Math.abs(t.x),Math.abs(a.x))&&Math.abs(t.y-a.y)<=e*Math.max(1,Math.abs(t.y),Math.abs(a.y))&&Math.abs(t.z-a.z)<=e*Math.max(1,Math.abs(t.z),Math.abs(a.z))&&Math.abs(t.w-a.w)<=e*Math.max(1,Math.abs(t.w),Math.abs(a.w))}}exports.MQuat=MQuat,MQuat.IDENTITY=Object.freeze(new cc_1.Quat);