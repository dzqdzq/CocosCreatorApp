"use strict";Object.defineProperty(exports,"__esModule",{value:!0});const{clamp:clamp}=Editor.Utils.Math,{drawLine:drawLine,calcHermite:calcHermite,calcFunc:calcFunc,Point:Point}=require("./utils"),POINT_LENGTH=2;class Hermite{constructor(t){this.negative=!1,this.multi=1,this.grid=t.grid,this.ctrlConfig=t.ctrlConfig,this.curveConfig=t.curveConfig,this.cxt2D=t.context,this.cxt2D.strokeStyle=t.curveConfig.strokeStyle,this.canvas=t.context.canvas,this.negative=!!t.range}get keyFrames(){return this._keyframes.map(t=>{const e=this.grid.axisToOri(t.point),{w:i,h:n}=this.grid.location;return Object.assign(Object.assign({},e),{inTangent:Number((t.inTangent*i/n).toFixed(POINT_LENGTH)),outTangent:Number((t.outTangent*i/n).toFixed(POINT_LENGTH))})})}get ctrlKey(){return this._keyframes.map((t,e)=>{t.index=e;const i=this.calcCtrl(e);0!==e&&(t.inPoint=i.inPoint),e!==this._keyframes.length-1&&(t.outPoint=i.outPoint);const n=this.grid.axisToCanvas(t.point);return t.point.canvas=n,t})}rePaint(){this.clear(),this.cxt2D.strokeStyle=this.curveConfig.strokeStyle;for(const t of this._keyframes)t.outTangent=t.outTangent/this.multi,t.inTangent=t.inTangent/this.multi;this.draw(this._keyframes)}draw(t){const e=this.cxt2D,{w:i,h:n}=this.grid.location;try{this._keyframes=require("lodash").cloneDeep(t)}catch(t){return void console.error(t)}this.negative?this.multi=n/i/2:this.multi=n/i;for(const t of this._keyframes){const e=this.grid.tranToAxis(t);t.outTangent*=this.multi,t.inTangent*=this.multi,t.point=e}this.hermiteArgs=[];for(let t=0;t<this._keyframes.length-1;t++){const i=this._keyframes[t+1],n=this._keyframes[t];this.hermiteArgs[t]=calcHermite(n.point,n.outTangent,i.point,i.inTangent);const s=calcFunc(this.hermiteArgs[t]);e.beginPath();for(let t=n.point.x;t<=i.point.x;t++){const i=this.grid.axisToCanvas({x:t,y:s(t)});e.lineTo(i.x,i.y)}if(n.outTangent===Number.POSITIVE_INFINITY||i.inTangent===Number.POSITIVE_INFINITY){const t=this.grid.axisToCanvas(i.point);e.lineTo(t.x,t.y)}e.stroke(),e.closePath()}this.drawEdge()}updateTan(t,e,i){if(0===t&&"inTangent"===i||t===this._keyframes.length-1&&"outTangent"===i)return;this._keyframes[t][i]=e;const n=this._keyframes[t];if("outTangent"===i){const e=this._keyframes[t+1];this.hermiteArgs[t]=calcHermite(n.point,n.outTangent,e.point,e.inTangent)}else if("inTangent"===i){const e=this._keyframes[t-1];this.hermiteArgs[t-1]=calcHermite(e.point,e.outTangent,n.point,n.inTangent)}}addKeyFrame(t){t-=this.grid.location.x;let e=null;for(let i=0;i<this._keyframes.length-1;i++){const n=this._keyframes[i].point,s=this._keyframes[i+1].point;if(t>n.x&&s.x>t){e=i;break}}if(null===e)return null;const i=this.calcSlope(t,e),n=calcFunc(this.hermiteArgs[e])(t);return this.hermiteArgs.splice(e+1,0,this.hermiteArgs[e]),this._keyframes.splice(e+1,0,{point:new Point({x:t,y:n}),outTangent:i,inTangent:i}),e+1}delKeyFrame(t){const e=this._keyframes[t+1],i=this._keyframes[t-1];if(e&&this.hermiteArgs.splice(t,1),i&&this.hermiteArgs.splice(t-1,1),e&&i){const n=calcHermite(i.point,i.outTangent,e.point,e.inTangent);this.hermiteArgs.splice(t-1,0,n)}this._keyframes.splice(t,1)}update(t=this.cxt2D){const e=this._keyframes;for(let i=1;i<e.length;i++){const n=e[i],s=e[i-1],r=calcFunc(this.hermiteArgs[i-1]);t.beginPath();for(let e=s.point.x;e<=n.point.x;e++){const i=this.grid.axisToCanvas({x:e,y:r(e)});t.lineTo(i.x,i.y)}if(s.outTangent===Number.POSITIVE_INFINITY||n.inTangent===Number.POSITIVE_INFINITY){const e=this.grid.axisToCanvas(n.point);t.lineTo(e.x,e.y)}t.stroke(),t.closePath()}t===this.cxt2D&&this.drawEdge()}moveY(t){const{h:e}=this.grid.location,i=JSON.parse(JSON.stringify(this._keyframes));for(let n=0;n<this._keyframes.length;n++){const s=this._keyframes[n],{point:r}=s;if(r.y>e||r.y<0)return this._keyframes=i,!1;if(r.y+=t,r.y=clamp(r.y,0,e),r.canvas=this.grid.axisToCanvas(r),n<this._keyframes.length-1){const t=this._keyframes[n+1];this.hermiteArgs[n]=calcHermite(s.point,s.outTangent,t.point,t.inTangent)}}return!0}moveKey(t,e,i){const n=this._keyframes[i];let s=this._keyframes[i+1],r=this._keyframes[i-1];const{point:a}=n,{w:o,h:c}=this.grid.location;let h=[0,c];if(this.negative&&(h=[-c/2,c/2]),(a.x>o||a.x<0)&&(a.y>c||a.y<0))return i;const l=this.grid.canvasToAxis({x:t,y:e});return a.x=clamp(l.x,0,o),a.y=clamp(l.y,h[0],h[1]),s&&a.x>s.point.x?(this._keyframes.splice(i,1),this._keyframes.splice(i+1,0,n),r&&(this.hermiteArgs[i-1]=calcHermite(r.point,r.outTangent,s.point,s.inTangent)),i++,r=s,s=this._keyframes[i+1]):r&&a.x<r.point.x&&(this._keyframes.splice(i,1),this._keyframes.splice(i-1,0,n),s&&(this.hermiteArgs[i]=calcHermite(r.point,r.outTangent,s.point,s.inTangent)),i--,s=r,r=this._keyframes[i-1]),s&&(this.hermiteArgs[i]=calcHermite(n.point,n.outTangent,s.point,s.inTangent)),r&&(this.hermiteArgs[i-1]=calcHermite(r.point,r.outTangent,n.point,n.inTangent)),i}clear(){this.cxt2D.clearRect(0,0,this.canvas.width,this.canvas.height)}calcCtrl(t,e){const i=this._keyframes[t].point;let n=null,s=null;if("outTangent"!==e){const e=this._keyframes[t].inTangent;(s=this.calcCtrlPoint(i,e,"inTangent")).canvas=this.grid.axisToCanvas(s)}if("inTangent"!==e){const e=this._keyframes[t].outTangent;(n=this.calcCtrlPoint(i,e,"outTangent")).canvas=this.grid.axisToCanvas(n)}return{outPoint:n,inPoint:s}}calcSlope(t,e){const{a:i,b:n,c:s}=this.hermiteArgs[e];return 3*i*t*t+2*n*t+s}drawEdge(){const{w:t,x:e}=this.grid.location,i=this.ctrlKey[0].point.canvas,n=this.ctrlKey[this._keyframes.length-1].point.canvas;this.cxt2D.save(),this.cxt2D.strokeStyle="rgba(255, 0, 0, 0.11)",drawLine({x:0,y:i.y},i,this.cxt2D),drawLine({x:2*e+t,y:n.y},n,this.cxt2D),this.cxt2D.restore()}calcCtrlPoint(t,e,i){const{handlerSize:n}=this.ctrlConfig;let s=0,r=0;return e!==Number.POSITIVE_INFINITY?(s=Math.sqrt(n*n/(1+e*e)),s="inTangent"===i?t.x-s:t.x+s,r=t.y-e*(t.x-s)):(s=t.x,r="inTangent"===i?t.y+n:t.y-n),{x:s,y:r,type:i}}}exports.default=Hermite;