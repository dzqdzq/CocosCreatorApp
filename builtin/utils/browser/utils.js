"use strict";const{join:join,basename:basename,relative:relative}=require("path"),{copy:copy,readdir:readdir,existsSync:existsSync,readFile:readFile,outputFile:outputFile,stat:stat}=require("fs-extra"),privateExclude=["browser","browser.d.ts","renderer","renderer.d.ts","private","private.d.ts"],protectExclude=["protect","protect.d.ts"],EditorInfo={App:""},extensionsList={builtinExtensions:"",platformExtensions:"",editorExtensions:"",engineExtensions:""};exports.initEditorInfo=function(e){EditorInfo.App=e,extensionsList.builtinExtensions=join(EditorInfo.App,"builtin"),extensionsList.platformExtensions=join(EditorInfo.App,"modules","platform-extensions","extensions"),extensionsList.editorExtensions=join(EditorInfo.App,"modules","editor-extensions","extensions"),extensionsList.engineExtensions=join(EditorInfo.App,"modules","engine-extensions","extensions")},exports.exportEditorDTS=async function(e,t=!1){const i=join(EditorInfo.App,"@types"),n=t?privateExclude:[...protectExclude,...privateExclude];await exports.recursiveFile(i,async(t,n)=>{if(n.isDirectory())return;const o=relative(i,t),s=join(e,o),r=await readFile(t);await outputFile(s,r)},n);const o=join(e,"message.d.ts");let s=await readFile(o,"utf8");s=s.replace(/'\.\.\/builtin\/([^/]+)\/@types\//g,(e,t)=>`'./packages/${t}/@types/`),await outputFile(o,s);const r=join(e,"editor.d.ts");let a=await readFile(r,"utf8");a="/// <reference path='./electron.d.ts'/>\n\n"+a,await outputFile(r,a)},exports.exportPackageDTS=async function(e,t=!1){const i=t?privateExclude:[...protectExclude,...privateExclude];for(const t of Object.keys(extensionsList))try{const n=await readdir(extensionsList[t]);for(let o of n){const n=join(extensionsList[t],o,"@types");if(!existsSync(n))continue;const s=join(e,"packages",o,"@types");await exports.recursiveFile(n,async(e,t)=>{if(t.isDirectory())return;const i=relative(n,e),o=join(s,i),r=await readFile(e);await outputFile(o,r)},i)}}catch(e){console.error(`Export ${t} .d.ts failed.`),console.error(e)}},exports.recursiveFile=async function(e,t,i){await async function e(n){const o=await readdir(n);for(let s of o){if(i.includes(s))continue;const o=join(n,s),r=await stat(o);await t(o,r),r.isDirectory()&&await e(o)}}(e)};