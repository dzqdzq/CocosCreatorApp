"use strict";const{join:join,basename:basename,relative:relative}=require("path"),{copy:copy,readdir:readdir,existsSync:existsSync,readFile:readFile,outputFile:outputFile,stat:stat}=require("fs-extra"),privateExclude=["browser","browser.d.ts","renderer","renderer.d.ts","private","private.d.ts"],protectExclude=["protected","protected.d.ts","protect","protect.d.ts"],EditorInfo={App:""},extensionsList={builtinExtensions:"",platformExtensions:"",editorExtensions:"",engineExtensions:""};exports.initEditorInfo=function(e){EditorInfo.App=e,extensionsList.builtinExtensions=join(EditorInfo.App,"builtin"),extensionsList.platformExtensions=join(EditorInfo.App,"modules","platform-extensions","extensions"),extensionsList.editorExtensions=join(EditorInfo.App,"modules","editor-extensions","extensions"),extensionsList.engineExtensions=join(EditorInfo.App,"modules","engine-extensions","extensions")},exports.exportEditorDTS=async function(e,t=!1){const i=join(EditorInfo.App,"./node_modules/@editor/creator/@types"),o=t?privateExclude:[...protectExclude,...privateExclude];await exports.recursiveFile(i,async(t,o)=>{if(o.isDirectory())return;const n=relative(i,t),s=join(e,n),r=await readFile(t);await outputFile(s,r)},o);const n=join(e,"message.d.ts");let s=await readFile(n,"utf8");s=s.replace(/'\.\.\/builtin\/([^/]+)\/@types\//g,(e,t)=>`'./packages/${t}/@types/`),await outputFile(n,s);const r=join(e,"editor.d.ts");let a=await readFile(r,"utf8");a="/// <reference path='./electron.d.ts'/>\n\n"+a,await outputFile(r,a)},exports.exportPackageDTS=async function(e,t=!1){const i=t?privateExclude:[...protectExclude,...privateExclude];for(const t of Object.keys(extensionsList))try{const o=await readdir(extensionsList[t]);for(const n of o){const o=join(extensionsList[t],n,"@types");if(!existsSync(o))continue;const s=join(e,"packages",n,"@types");await exports.recursiveFile(o,async(e,t)=>{if(t.isDirectory())return;const i=relative(o,e),n=join(s,i),r=await readFile(e);await outputFile(n,r)},i)}}catch(e){console.error(`Export ${t} .d.ts failed.`),console.error(e)}},exports.recursiveFile=async function(e,t,i){await async function e(o){const n=await readdir(o);for(const s of n){if(i.includes(s))continue;const n=join(o,s),r=await stat(n);await t(n,r),r.isDirectory()&&await e(n)}}(e)};