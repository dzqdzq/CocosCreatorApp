"use strict";const{join:join,basename:basename,relative:relative,extname:extname}=require("path"),{copy:copy,readdir:readdir,existsSync:existsSync,readFile:readFile,outputFile:outputFile,stat:stat,ensureDirSync:ensureDirSync,writeFileSync:writeFileSync,readFileSync:readFileSync,copyFile:copyFile,ensureDir:ensureDir,outputFileSync:outputFileSync}=require("fs-extra"),privateExclude=["browser","browser.d.ts","renderer","renderer.d.ts","private","private.d.ts"],protectExclude=["protected","protected.d.ts","protect","protect.d.ts"],EditorInfo={App:""},extensionsRepos={builtinExtensions:"",platformExtensions:"",editorExtensions:"",engineExtensions:""};async function generateMessageDts(e,t){ensureDirSync(e);const n=join(e,"message.d.ts");let s="",i="";Object.keys(t).forEach(n=>{const o=n.split("-").map(e=>e[0].toLocaleUpperCase()+e.slice(1)).join(""),r="./"+relative(e,t[n]).replace(/\\/g,"/");i+=`        '${n}': ${o}.message;`+"\n",s+=`import * as ${o} from '${r}';`+"\n"});const o=`\n${s}\ndeclare global {\n    interface EditorMessageContent {\n        params: any[],\n        result: any;\n    }\n\n    interface EditorMessageMap {\n        [x: string]: EditorMessageContent;\n    }\n\n    interface EditorMessageMaps {\n        [x: string]: EditorMessageMap;\n${i}\n    }\n}\n`;return await outputFile(n,o),n}exports.initEditorInfo=function(e){EditorInfo.App=e,extensionsRepos.builtinExtensions=join(EditorInfo.App,"builtin"),extensionsRepos.platformExtensions=join(EditorInfo.App,"modules","platform-extensions","extensions"),extensionsRepos.editorExtensions=join(EditorInfo.App,"modules","editor-extensions","extensions"),extensionsRepos.engineExtensions=join(EditorInfo.App,"modules","engine-extensions","extensions")},exports.exportEditorDTS=async function(e,t=!1){const n=join(EditorInfo.App,"./node_modules/@editor/creator/@types"),s=t?privateExclude:[...protectExclude,...privateExclude];await exports.recursiveFile(n,async(t,s)=>{if(s.isDirectory())return;const i=relative(n,t),o=join(e,i),r=await readFile(t);await outputFile(o,r)},s),exports.exportUtilsDTS(e);const{packageMessageList:i,protectedMessageList:o}=await exports.exportPackageDTS(extensionsRepos,e,t);if(await generateMessageDts(e,i),Object.keys(o).length){await generateMessageDts(join(e,"protected"),o);const t=join(e,"protected.d.ts");writeFileSync(t,'/// <reference path="./protected/message.d.ts"/> \n'+readFileSync(t))}},exports.exportUtilsDTS=async function(e){const t=join(EditorInfo.App,"utils/@types"),n=join(e,"utils");await ensureDir(n),await copy(t,n);outputFileSync(join(e,"utils.d.ts"),"\nimport type { Utils as UtilsType } from './utils/index.d';\n\ndeclare global {\n    export namespace Editor {\n        export const Utils = UtilsType;\n    }\n}\n    ")},exports.exportPackageDTS=async function(e,t,n=!1){const s=n?privateExclude:[...protectExclude,...privateExclude],i={},o={};for(const n of Object.keys(e))try{const r=await readdir(e[n]);for(const a of r){const r=join(e[n],a,"@types");if(!existsSync(r))continue;const c=join(t,"packages",a,"@types");await exports.recursiveFile(r,async(e,t)=>{if(t.isDirectory())return;const n=relative(r,e),s=join(c,n),p=await readFile(e);await outputFile(s,p),e.includes("@types\\protected\\message")?i[a]=s.replace(".d.ts",""):basename(e).startsWith("message")&&(o[a]=s.replace(".d.ts",""))},s)}}catch(e){console.error(`Export ${n} .d.ts failed.`),console.error(e)}return{protectedMessageList:i,packageMessageList:o}},exports.recursiveFile=async function(e,t,n){await async function e(s){const i=await readdir(s);for(const o of i){if(n.includes(o))continue;const i=join(s,o),r=await stat(i);await t(i,r),r.isDirectory()&&await e(i)}}(e)};