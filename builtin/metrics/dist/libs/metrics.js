"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.Metrics=void 0;const utils_1=require("../utils"),log_1=require("./log");class Metrics{constructor(){this._clientID="",this._userID="",this._metricsDebugMode=!1,this._init=!1,this._eventGroup={},this._metricsObservers=[]}get trackInfoList(){return Editor.Metrics.__protected__.getTrackInfoList()}get trackTimeStartMap(){return Editor.Metrics.__protected__.getTrackTimeStartMap()}get processMemoryMap(){return Editor.Metrics.__protected__.getProcessMemoryMap()}get metricInitData(){return Editor.Metrics.__protected__.getMetricInitData()}set metricInitData(t){Editor.Metrics.__protected__.setMetricInitData(t)}get trackAwaitHandler(){return Editor.Metrics.__protected__.getTrackAwaitHandler()}replyAsyncFunction(t,e,r){const i=this.trackAwaitHandler.findIndex(e=>e.index===t),s=this.trackAwaitHandler[i];s&&(this.trackAwaitHandler.splice(i,1),e?s.reject(e):s.resolve(r))}addMetricsObserver(t){this._metricsObservers.includes(t)||this._metricsObservers.push(t)}getTrackInfoMapByTime(t){const e=this.trackInfoList.findIndex(e=>e.index===t),r=this.trackInfoList[e];if(r)return this.trackInfoList.splice(e,1),r}register(){const t=Editor.Metrics.__protected__;t.register("init",this.init.bind(this)),t.register("clear",this.clear.bind(this)),t.register("close",this.close.bind(this)),t.register("trackEvent",this.trackEvent.bind(this)),t.register("trackException",this.trackException.bind(this)),t.register("trackProcessMemory",this.trackProcessMemory.bind(this)),t.register("trackTimeStart",this.trackTimeStart.bind(this)),t.register("trackTimeEnd",this.trackTimeEnd.bind(this)),t.register("trackProcessMemoryStart",this.trackProcessMemoryStart.bind(this)),t.register("trackProcessMemoryEnd",this.trackProcessMemoryEnd.bind(this)),t.register("_trackEventWithTimer",this._trackEventWithTimer.bind(this)),t.register("_sendEventGroup",this._sendEventGroup.bind(this)),t.register("_trackCrashEvent",this._trackCrashEvent.bind(this)),setInterval(()=>{this.sync()},18e5)}async sync(){this.metricInitData&&(await this.init(),this.metricInitData=void 0);const t=[...this.trackInfoList];for(let e=0;e<t.length;e++){const r=t[e],i=r.index,s=this[r.funcName];if(!s){console.debug(`Function not queried ${r.funcName}`);continue}let o=null,c=null;try{o="AsyncFunction"===s.constructor.name?await Promise.resolve(s.bind(this)(i)):s.bind(this)(i)}catch(t){c=new Error(t.message)}this.replyAsyncFunction(i,c,o)}Editor.Metrics.__protected__.reset()}clear(){log_1.logMgr.collectToFile("[clear]",JSON.stringify({trackInfoList:this.trackInfoList,trackAwaitHandler:this.trackAwaitHandler}))}async init(){if(!this.metricInitData)return;const{outputMetricLog:t}=this.metricInitData;this._clientID=await(0,utils_1.getClientID)();const e=await Editor.User.getData();this._userID=e&&e.cocos_uid?e.cocos_uid:"-1",this._metricsDebugMode=!!await Editor.Profile.getConfig("utils","features.analytics-debug"),await log_1.logMgr.init(t,this._metricsDebugMode),!!await Editor.Profile.getConfig("utils","features.disable-analytics-ga")||this.addMetricsObserver(require("../observers/google-metrics-observer")),this.addMetricsObserver(require("../observers/google-metrics-observer-v4")),this.addMetricsObserver(require("../observers/cocos-metrics-observer"));const r=(0,utils_1.getMainDisplay)(),i={cid:this._clientID,uid:this._userID,debug:this._metricsDebugMode||!1,resolution:`${r.size.width}x${r.size.height}`,scaleFactor:`${r.scaleFactor}`};this._metricsObservers.forEach(t=>{t.sendAppInfo(i)}),this._init=!0}trackEvent(t){if(!this._userID)return;const e=this.getTrackInfoMapByTime(t);if(!e)return;const r={cid:this._clientID,uid:this._userID,debug:this._metricsDebugMode||!1,useTestServer:this._metricsDebugMode||!1},{info:i}=e;try{i.sendToCocosAnalyticsOnly||delete i.sendToCocosAnalyticsOnly,i.sendToNewCocosAnalyticsOnly||delete i.sendToNewCocosAnalyticsOnly}catch(t){console.debug(t)}i.projectID=Editor.Project.uuid||"";try{log_1.logMgr.collectToFile("[trackEvent]",JSON.stringify(i)),this._metricsObservers.forEach(t=>{t.trackEvent(i,r)})}catch(t){console.debug(t)}}close(){const t={cid:this._clientID,uid:this._userID,debug:this._metricsDebugMode||!1,useTestServer:this._metricsDebugMode||!1};log_1.logMgr.collectToFile("[close]",JSON.stringify(t)),this._metricsObservers.forEach(e=>{e.close(t)})}_trackEventWithTimer(t){const e=this.getTrackInfoMapByTime(t);if(!e||!e.info)return;const r=e.info;try{log_1.logMgr.collectToFile("[trackEventWithTimer]",JSON.stringify(r)),this._eventGroup[r.category]||(this._eventGroup[r.category]={}),this._eventGroup[r.category][r.id]||(this._eventGroup[r.category][r.id]={}),"number"==typeof this._eventGroup[r.category][r.id]?this._eventGroup[r.category][r.id]=(100*(this._eventGroup[r.category][r.id]+r.value)|0)/100:this._eventGroup[r.category][r.id]=r.value,this._timer||(this._timer=setTimeout(()=>{this._timer&&clearTimeout(this._timer),this._timer=void 0,this._sendEventGroup()},3e5))}catch(t){console.debug(t)}}trackException(t){if(!this._userID)return;const e=this.getTrackInfoMapByTime(t);if(!e)return;const r=e.info,i={cid:this._clientID,uid:this._userID,debug:this._metricsDebugMode||!1};try{this._metricsObservers.forEach(t=>{t.trackException(r,i)}),log_1.logMgr.collectToFile("[trackException]",JSON.stringify(r))}catch(t){console.debug(t)}}trackProcessMemory(t){const e=this.getTrackInfoMapByTime(t);if(!e)return;const r=`[trackMemory][${process}]`,i=`${JSON.stringify(e.memoryInfo)}`;log_1.logMgr.collectToFile(r,i),console.debug(`${r}:${i}`)}trackTimeStart(){}trackTimeEnd(t){const e=this.getTrackInfoMapByTime(t);if(!e||!e.info)return-1;const r=e.info,i=r.message,s=r.options,o=this.trackTimeStartMap;if(!s.value&&!o.has(i))return void console.debug(`trackTimeEnd failed! Can not find the track time ${i} start`);const c=s.value||(e.time||Date.now())-o.get(i);if(o.delete(i),log_1.logMgr.collectToFile(`[trackTime]${i}`,`${c}ms`),!s.output)return c;const n="string"==typeof s.label&&(Editor.I18n.t(s.label.replace("i18n:",""))||s.label)||i;return console.debug(n+` (${c}ms)`),c}trackProcessMemoryStart(t){}async trackProcessMemoryEnd(t){const e=this.getTrackInfoMapByTime(t);if(!e||!e.info)return-1;const r=e.info,i=this.processMemoryMap,s=i.get(r.message)||0,o=r.memory.heapUsed,c=o-s;return i.delete(r.message),log_1.logMgr.collectToFile(`[trackProcessMemory]${r.message}`,{start:s,end:o,incremental:c}),c}_sendEventGroup(){if(!Object.keys(this._eventGroup).length)return;log_1.logMgr.collectToFile("[sendCollectData]",String(Object.keys(this._eventGroup).length));const t=JSON.parse(JSON.stringify(this._eventGroup));this._eventGroup={},Object.keys(t).forEach(e=>{Editor.Metrics.trackEvent({category:e,value:t[e],sendToNewCocosAnalyticsOnly:!0})})}async _trackCrashEvent(t){try{if(!this._userID)throw new Error("User ID invalid");const e=this.getTrackInfoMapByTime(t);if(!e)return;const r=e.info,i={cid:this._clientID,uid:this._userID,debug:this._metricsDebugMode||!1,useTestServer:this._metricsDebugMode||!1};r.projectID=Editor.Project.uuid||"",log_1.logMgr.collectToFile("[trackCrashEvent]",JSON.stringify(r));const s=require("../observers/cocos-metrics-observer");return await s._trackCrashEvent(r,i)}catch(t){throw log_1.logMgr.collectToFile("[trackCrashEvent fail]",t),console.debug(t),t}}}exports.Metrics=Metrics,exports.default=new Metrics;