"use strict";var __createBinding=this&&this.__createBinding||(Object.create?function(e,t,r,n){void 0===n&&(n=r),Object.defineProperty(e,n,{enumerable:!0,get:function(){return t[r]}})}:function(e,t,r,n){void 0===n&&(n=r),e[n]=t[r]}),__setModuleDefault=this&&this.__setModuleDefault||(Object.create?function(e,t){Object.defineProperty(e,"default",{enumerable:!0,value:t})}:function(e,t){e.default=t}),__importStar=this&&this.__importStar||function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)"default"!==r&&Object.prototype.hasOwnProperty.call(e,r)&&__createBinding(t,e,r);return __setModuleDefault(t,e),t};Object.defineProperty(exports,"__esModule",{value:!0}),exports.GlTfConformanceError=exports.isDataUri=exports.readGltf=exports.GltfConverter=exports.do_create_socket=exports.getWorldTransformUntilRoot=exports.getPathFromRoot=exports.isFilesystemPath=void 0;const DataURI=__importStar(require("@cocos/data-uri")),cc=__importStar(require("cc")),cc_1=require("cc"),fs=__importStar(require("fs-extra")),path=__importStar(require("path")),glTF_meta_1=require("../../meta-schemas/glTF.meta"),texture_base_1=require("../texture-base"),base64_1=require("./base64"),khr_draco_mesh_compression_1=require("./khr-draco-mesh-compression"),pp_geometry_1=require("./pp-geometry");function isFilesystemPath(e){return!e.isDataUri}function getPathFromRoot(e,t){let r=e,n="";for(;null!==r&&r!==t;)n=`${r.name}/${n}`,r=r.parent;return n.slice(0,-1)}function getWorldTransformUntilRoot(e,t,r,n,s){for(cc_1.Vec3.set(r,0,0,0),cc_1.Quat.set(n,0,0,0,1),cc_1.Vec3.set(s,1,1,1);e!==t;)cc_1.Vec3.multiply(r,r,e.scale),cc_1.Vec3.transformQuat(r,r,e.rotation),cc_1.Vec3.add(r,r,e.position),cc_1.Quat.multiply(n,e.rotation,n),cc_1.Vec3.multiply(s,e.scale,s),e=e.parent}var GltfAssetKind;exports.isFilesystemPath=isFilesystemPath,exports.getPathFromRoot=getPathFromRoot,exports.getWorldTransformUntilRoot=getWorldTransformUntilRoot,function(e){e[e.Node=0]="Node",e[e.Mesh=1]="Mesh",e[e.Texture=2]="Texture",e[e.Skin=3]="Skin",e[e.Animation=4]="Animation",e[e.Image=5]="Image",e[e.Material=6]="Material",e[e.Scene=7]="Scene"}(GltfAssetKind||(GltfAssetKind={}));const v3_1=new cc_1.Vec3,qt_1=new cc_1.Quat,v3_2=new cc_1.Vec3,v3_min=new cc_1.Vec3,v3_max=new cc_1.Vec3;function do_create_socket(e,t,r){const n=getPathFromRoot(r.parent,e);if(r.parent===e)return;let s=t.find(e=>e.path===n);if(!s){const o=new cc.Node;o.name=`${r.parent.name} Socket`,o.parent=e,getWorldTransformUntilRoot(r.parent,e,v3_1,qt_1,v3_2),o.setPosition(v3_1),o.setRotation(qt_1),o.setScale(v3_2),s=new cc.SkeletalAnimation.Socket(n,o),t.push(s)}r.parent=s.target}exports.do_create_socket=do_create_socket;const skinRootNotCalculated=-2,skinRootAbsent=-1,supportedExtensions=new Set(["KHR_draco_mesh_compression","KHR_materials_unlit","KHR_materials_unlit","KHR_texture_transform"]);class GltfConverter{constructor(e,t,r,n){var s,o;this._gltf=e,this._buffers=t,this._gltfFilePath=r,this._parents=[],this._skinRoots=[],this._processedMeshes=[],this._socketMappings=new Map,n=n||{},this._logger=n.logger||GltfConverter._defaultLogger,null===(s=this._gltf.extensionsRequired)||void 0===s||s.forEach(e=>this._warnIfExtensionNotSupported(e,!0)),null===(o=this._gltf.extensionsUsed)||void 0===o||o.forEach(e=>{var t;(null===(t=this._gltf.extensionsRequired)||void 0===t?void 0:t.includes(e))||this._warnIfExtensionNotSupported(e,!1)}),void 0!==this._gltf.nodes&&(this._parents=new Array(this._gltf.nodes.length).fill(-1),this._gltf.nodes.forEach((e,t)=>{if(void 0!==e.children)for(const r of e.children)this._parents[r]=t})),this._gltf.skins&&(this._skinRoots=new Array(this._gltf.skins.length).fill(skinRootNotCalculated)),this._nodePathTable=this._createNodePathTable();const a=n.userData||{};if(this._gltf.meshes){const e=void 0===a.normals?glTF_meta_1.NormalImportSetting.require:a.normals,t=void 0===a.tangents?glTF_meta_1.TangentImportSetting.require:a.tangents;for(let r=0;r<this._gltf.meshes.length;r++){const n=this._gltf.meshes[r],s=new cc_1.Vec3(Number.POSITIVE_INFINITY,Number.POSITIVE_INFINITY,Number.POSITIVE_INFINITY),o=new cc_1.Vec3(Number.NEGATIVE_INFINITY,Number.NEGATIVE_INFINITY,Number.NEGATIVE_INFINITY),{geometries:i,materialIndices:c,jointMaps:l}=pp_geometry_1.PPGeometry.skinningProcess(n.primitives.map((n,a)=>{const i=this._readPrimitive(n);return i.reduceJointInfluences(),this._applySettings(i,e,t,a,r),this._readBounds(n,v3_min,v3_max),cc_1.Vec3.min(s,s,v3_min),cc_1.Vec3.max(o,o,v3_max),i.sanityCheck(),i}),a.disableMeshSplit);this._processedMeshes.push({geometries:i,materialIndices:c,jointMaps:l,minPosition:s,maxPosition:o})}}if(this._gltf.nodes&&this._gltf.skins){const e=this._gltf.nodes,t=[];for(let r=0;r<e.length;r++){const n=e[r];void 0!==n.mesh&&void 0===n.skin&&t.push(r)}for(let e=0;e<t.length;e++){const r=t[e];t.some(e=>this._isAncestorOf(e,r))&&(t[e]=t[t.length-1],t.length--,e--)}for(let r=0;r<t.length;r++){const n=t[r],s=e[this._getParent(n)];s&&this._socketMappings.set(this._getNodePath(n),s.name+" Socket/"+e[n].name)}}}get gltf(){return this._gltf}get path(){return this._gltfFilePath}get processedMeshes(){return this._processedMeshes}createMesh(e){const t=this._processedMeshes[e],r=this._gltf.meshes[e],n=new BufferBlob,s=new Array,o={primitives:t.geometries.map((e,t)=>{const{vertexCount:r,vertexStride:o,formats:a,vertexBuffer:i}=interleaveVertices(e);n.setNextAlignment(0),s.push({view:{offset:n.getLength(),length:i.byteLength,count:r,stride:o},attributes:a}),n.addBuffer(i);const c={primitiveMode:e.primitiveMode,jointMapIndex:e.jointMapIndex,vertexBundelIndices:[t]};if(void 0!==e.indices){const t=e.indices;n.setNextAlignment(t.BYTES_PER_ELEMENT),c.indexView={offset:n.getLength(),length:t.byteLength,count:t.length,stride:t.BYTES_PER_ELEMENT},n.addBuffer(t.buffer)}return c}),vertexBundles:s,minPosition:t.minPosition,maxPosition:t.maxPosition,jointMaps:t.jointMaps};{const e=t.geometries.map(e=>{let t=0;const r=[];if(e.forEachAttribute(e=>{if(e.morphs){if(0===t)t=e.morphs.length;else if(t!==e.morphs.length)throw new Error("Bad morph...");r.push(e)}}),0===t)return null;const s=new Array(t);for(let e=0;e<t;++e)s[e]={displacements:r.map(t=>{const r=t.morphs[e];n.setNextAlignment(r.BYTES_PER_ELEMENT);const s=n.getLength();return n.addBuffer(r.buffer),{offset:s,length:r.byteLength,stride:r.BYTES_PER_ELEMENT,count:r.length}})};return{attributes:r.map(e=>pp_geometry_1.getGfxAttributeName(e)),targets:s}}),s=e.find(e=>null!==e);if(s&&(assertGlTFConformance(e.every(e=>!e||e.targets.length===s.targets.length),"glTF expects that every primitive has same number of targets"),0!==e.length&&assertGlTFConformance(void 0===r.weights||r.weights.length===s.targets.length,'Number of "weights" mismatch number of morph targets'),o.morph={subMeshMorphs:e,weights:r.weights},"object"==typeof r.extras&&Array.isArray(r.extras.targetNames))){const e=r.extras.targetNames;e.length===s.targets.length&&e.every(e=>"string"==typeof e)&&(o.morph.targetNames=e.slice())}}const a=new cc.Mesh;return a.name=this._getGltfXXName(GltfAssetKind.Mesh,e),a.assign(o,n.getCombined()),a.hash,a}createSkeleton(e,t){const r=this._gltf.skins[e],n=new cc.Skeleton;if(n.name=this._getGltfXXName(GltfAssetKind.Skin,e),n._joints=r.joints.map(e=>this._mapToSocketPath(this._getNodePath(e))),void 0!==r.inverseBindMatrices){const e=this._gltf.accessors[r.inverseBindMatrices];if(e.componentType!==WebGLRenderingContext.FLOAT||"MAT4"!==e.type)throw new Error("The inverse bind matrix should be floating-point 4x4 matrix.");const t=new Array(r.joints.length),s=new Float32Array(16*t.length);this._readAccessor(e,createDataViewFromTypedArray(s)),assertGlTFConformance(s.length===16*t.length,"Wrong data in bind-poses accessor.");for(let e=0;e<t.length;++e)t[e]=new cc_1.Mat4(s[16*e+0],s[16*e+1],s[16*e+2],s[16*e+3],s[16*e+4],s[16*e+5],s[16*e+6],s[16*e+7],s[16*e+8],s[16*e+9],s[16*e+10],s[16*e+11],s[16*e+12],s[16*e+13],s[16*e+14],s[16*e+15]);n._bindposes=t}return n.hash,n}getAnimationDuration(e){const t=this._gltf.animations[e];let r=0;return t.channels.forEach(e=>{if(void 0===e.target.node)return;const n=t.samplers[e.sampler],s=this._gltf.accessors[n.input],o=void 0!==s.max&&1===s.max.length?Math.fround(s.max[0]):0;r=Math.max(o,r)}),r}createAnimation(e,t){const r=this._gltf.animations[e],n={},s=e=>{const t=this._mapToSocketPath(this._getNodePath(e));return n[t]||(n[t]={})};let o=0;const a=new Array,i=new Array,c=(e,t)=>{const r=t.findIndex(t=>t>=e);if(r<0)return t.length-1;if(0===r)return 0;{const n=r-1,s=t[n],o=t[r];return n+(e-s)/(o-s)}},l=new Map,f=e=>{let r=l.get(e);if(void 0===r){const n=this._gltf.accessors[e],s=this._readAccessorIntoArray(n);r=a.length;const o=Array.from(s);if(t){const e={from:c(t.from,o),to:c(t.to,o)};i.push(e);const r=this._split(o,e.from,e.to,(e,t,r)=>e+(t-e)*r);a.push(r.map(e=>e-t.from))}else a.push(o);l.set(e,r)}return r},u=[];if(r.channels.forEach(e=>{const n=e.target.node;if(void 0===n)return;const a=s(n),c=r.samplers[e.sampler],l=f(c.input),h=t?i[l]:void 0;"weights"===e.target.path?u.push(this._glTFWeightChannelToCurve(r,e,l,h)):this._gltfChannelToCurveData(r,e,a,l,h);const m=this._gltf.accessors[c.input],d=void 0!==m.max&&1===m.max.length?Math.fround(m.max[0]):0;o=Math.max(d,o)}),this._gltf.nodes){const e=new cc_1.Quat,t=new cc_1.Vec3,r=new cc_1.Vec3;this._gltf.nodes.forEach((n,o)=>{const a=s(o);let i;if(n.matrix&&(i=this._readNodeMatrix(n.matrix),cc_1.Mat4.toRTS(i,e,t,r)),!a.position){const e=new cc_1.Vec3;n.translation?cc_1.Vec3.set(e,n.translation[0],n.translation[1],n.translation[2]):i&&cc_1.Vec3.copy(e,t),a.position={keys:-1,values:[e]}}if(!a.scale){const e=new cc_1.Vec3(1,1,1);n.scale?cc_1.Vec3.set(e,n.scale[0],n.scale[1],n.scale[2]):i&&cc_1.Vec3.copy(e,r),a.scale={keys:-1,values:[e]}}if(!a.rotation){const t=new cc_1.Quat;n.rotation?this._getNodeRotation(n.rotation,t):i&&cc_1.Quat.copy(t,e),a.rotation={keys:-1,values:[t]}}})}const h=new cc.AnimationClip;h.name=this._getGltfXXName(GltfAssetKind.Animation,e);const m=new DynamicArrayBuffer(1024);h.curves=(()=>{const e=u;for(const t in n)if(Object.prototype.hasOwnProperty.call(n,t)){const r=new cc.animation.HierarchyPath(t),s=n[t];for(const t in s)if(Object.prototype.hasOwnProperty.call(s,t)){const n=s[t],{values:o}=n;let a;if(0!==o.length){const e=o[0];let t;if(e instanceof cc_1.Vec3?t=cc.CompactValueTypeArray.ElementType.Vec3:e instanceof cc_1.Quat&&(t=cc.CompactValueTypeArray.ElementType.Quat),void 0!==t){const e=cc.CompactValueTypeArray.StorageUnit.Float32,r=cc.CompactValueTypeArray.lengthFor(o,t,e),n=m.grow(r);a=cc.CompactValueTypeArray.compress(o,t,e,m.arrayBuffer,n,n)}}e.push({modifiers:[r,t],data:{keys:n.keys,values:a||o,interpolate:!!n.interpolate&&void 0}})}}return e})(),h.wrapMode=cc.AnimationClip.WrapMode.Loop,h.duration=t?t.to-t.from:o;const d=a.map(e=>{const t=cc.CompactValueTypeArray.ElementType.Scalar,r=cc.CompactValueTypeArray.StorageUnit.Float32,n=cc.CompactValueTypeArray.lengthFor(e,t,r),s=m.grow(n);return cc.CompactValueTypeArray.compress(e,t,r,m.arrayBuffer,s,s)});return h.keys=d,h.sample=30,h._nativeAsset=m.shrink(),h.hash,h}createMaterial(e,t,r,n){var s,o;const a=null===(s=n.useVertexColors)||void 0===s||s,i=null!==(o=n.depthWriteInAlphaModeBlend)&&void 0!==o&&o,c=this._gltf.materials[e],l=void 0!==(c.extensions&&c.extensions.KHR_materials_unlit),f=new cc.Material;f.name=this._getGltfXXName(GltfAssetKind.Material,e),f._effectAsset=r(`db://internal/effects/builtin-${l?"unlit":"standard"}.effect`);const u={},h={},m={rasterizerState:{},blendState:{targets:[{}]},depthStencilState:{}};if(this._gltf.meshes)for(let t=0;t<this._gltf.meshes.length;t++){const r=this._gltf.meshes[t];for(let t=0;t<r.primitives.length;t++){const n=r.primitives[t];n.material===e&&(n.attributes.COLOR_0&&a&&(u.USE_VERTEX_COLOR=!0),n.attributes.TEXCOORD_1&&(u.HAS_SECOND_UV=!0))}}if(c.pbrMetallicRoughness){const e=c.pbrMetallicRoughness;if(void 0!==e.baseColorTexture&&(u[l?"USE_TEXTURE":"USE_ALBEDO_MAP"]=!0,e.baseColorTexture.texCoord&&(u.ALBEDO_UV="v_uv1"),h.mainTexture=t.find("textures",e.baseColorTexture.index),void 0!==e.baseColorTexture.extensions&&e.baseColorTexture.extensions.KHR_texture_transform)){const t=e.baseColorTexture.extensions.KHR_texture_transform,r=h.tilingOffset=new cc_1.Vec4(1,1,0,0);t.scale&&(r.x=t.scale[0],r.y=t.scale[1]),t.offset&&(r.z=t.offset[0],r.w=t.offset[1])}if(e.baseColorFactor){const t=e.baseColorFactor;l?h.mainColor=new cc_1.Vec4(t[0],t[1],t[2],1):h.albedoScale=new cc_1.Vec3(t[0],t[1],t[2])}void 0!==e.metallicRoughnessTexture&&(u.USE_METALLIC_ROUGHNESS_MAP=!0,h.metallicRoughnessMap=t.find("textures",e.metallicRoughnessTexture.index),h.metallic=1,h.roughness=1),void 0!==e.metallicFactor&&(h.metallic=e.metallicFactor),void 0!==e.roughnessFactor&&(h.roughness=e.roughnessFactor)}if(void 0!==c.normalTexture){const e=c.normalTexture;void 0!==e.index&&(u.USE_NORMAL_MAP=!0,h.normalMap=t.find("textures",e.index),void 0!==e.scale&&(h.normalStrenth=e.scale))}if(c.occlusionTexture){const e=c.occlusionTexture;void 0!==e.index&&(u.USE_OCCLUSION_MAP=!0,h.occlusionMap=t.find("textures",e.index),void 0!==e.strength&&(h.occlusion=e.strength))}if(void 0!==c.emissiveTexture&&(u.USE_EMISSIVE_MAP=!0,c.emissiveTexture.texCoord&&(u.EMISSIVE_UV="v_uv1"),h.emissiveMap=t.find("textures",c.emissiveTexture.index),h.emissive=new cc_1.Vec4(1,1,1,1)),void 0!==c.emissiveFactor){const e=c.emissiveFactor;h.emissiveScale=new cc_1.Vec4(e[0],e[1],e[2],1)}switch(c.doubleSided&&(m.rasterizerState.cullMode=cc_1.gfx.CullMode.NONE),c.alphaMode){case"BLEND":const t=m.blendState.targets[0];t.blend=!0,t.blendSrc=cc_1.gfx.BlendFactor.SRC_ALPHA,t.blendDst=cc_1.gfx.BlendFactor.ONE_MINUS_SRC_ALPHA,t.blendDstAlpha=cc_1.gfx.BlendFactor.ONE_MINUS_SRC_ALPHA,m.depthStencilState.depthWrite=i;break;case"MASK":const r=void 0===c.alphaCutoff?.5:c.alphaCutoff;u.USE_ALPHA_TEST=!0,h.alphaThreshold=r;break;case"OPAQUE":case void 0:break;default:this._logger(GltfConverter.LogLevel.Warning,GltfConverter.ConverterError.UnsupportedAlphaMode,{mode:c.alphaMode,material:e})}return f._defines=[u],f._props=[h],f._states=[m],f}getTextureParameters(e,t){const r=t=>{switch(void 0===t&&(t=10497),t){case 33071:return"clamp-to-edge";case 33648:return"mirrored-repeat";case 10497:return"repeat";default:return this._logger(GltfConverter.LogLevel.Warning,GltfConverter.ConverterError.UnsupportedTextureParameter,{type:"wrapMode",value:t,fallback:10497,sampler:e.sampler,texture:this._gltf.textures.indexOf(e)}),"repeat"}},n=t=>{switch(t){case 9728:return"nearest";case 9729:return"linear";default:return this._logger(GltfConverter.LogLevel.Warning,GltfConverter.ConverterError.UnsupportedTextureParameter,{type:"magFilter",value:t,fallback:9729,sampler:e.sampler,texture:this._gltf.textures.indexOf(e)}),"linear"}},s=t=>{switch(t){case 9728:return["nearest","none"];case 9729:return["linear","none"];case 9984:return["nearest","nearest"];case 9985:return["linear","nearest"];case 9986:return["nearest","linear"];case 9987:return["linear","linear"];default:return this._logger(GltfConverter.LogLevel.Warning,GltfConverter.ConverterError.UnsupportedTextureParameter,{type:"minFilter",value:t,fallback:9729,sampler:e.sampler,texture:this._gltf.textures.indexOf(e)}),["linear","none"]}};if(void 0===e.sampler)t.wrapModeS="repeat",t.wrapModeT="repeat";else{const o=this._gltf.samplers[e.sampler];if(t.wrapModeS=r(o.wrapS),t.wrapModeT=r(o.wrapT),t.magfilter=void 0===o.magFilter?texture_base_1.defaultMagFilter:n(o.magFilter),t.minfilter=texture_base_1.defaultMinFilter,void 0!==o.minFilter){const[e,r]=s(o.minFilter);t.minfilter=e,t.mipfilter=r}}}createScene(e,t,r=!0){const n=this._getSceneNode(e,t,r);return n.getComponentsInChildren(cc.SkinnedMeshRenderer).forEach(e=>e.skinningRoot=n),n}createSockets(e){const t=[];for(const r of this._socketMappings){do_create_socket(e,t,e.getChildByPath(r[0]))}return t}readImageInBufferView(e){return this._readBufferView(e)}_warnIfExtensionNotSupported(e,t){supportedExtensions.has(e)||this._logger(GltfConverter.LogLevel.Warning,GltfConverter.ConverterError.UnsupportedExtension,{name:e,required:t})}_getNodeRotation(e,t){return cc_1.Quat.set(t,e[0],e[1],e[2],e[3]),cc_1.Quat.normalize(t,t),t}_gltfChannelToCurveData(e,t,r,n,s){let o;if("translation"===t.target.path)o="position";else if("rotation"===t.target.path)o="rotation";else{if("scale"!==t.target.path)return"weights"===t.target.path?void console.warn("we currently do not support blend shape animations, data are ignored for now"):void this._logger(GltfConverter.LogLevel.Error,GltfConverter.ConverterError.UnsupportedChannelPath,{channel:e.channels.indexOf(t),animation:this._gltf.animations.indexOf(e),path:t.target.path});o="scale"}const a=e.samplers[t.sampler],i=this._readAccessorIntoArrayAndNormalizeAsFloat(this._gltf.accessors[a.output]);let c=[],l=null,f=null;if("position"===o||"scale"===o){f=cc_1.Vec3,c=new Array(i.length/3);for(let e=0;e<c.length;++e)c[e]=new cc_1.Vec3(i[3*e+0],i[3*e+1],i[3*e+2]);l="additive3D"}else if("rotation"===o){f=cc_1.Quat,c=new Array(i.length/4);for(let e=0;e<c.length;++e)c[e]=new cc_1.Quat(i[4*e+0],i[4*e+1],i[4*e+2],i[4*e+3]);l="additiveQuat"}const u={keys:n,values:c};switch(a.interpolation){case"STEP":u.interpolate=!1,s&&(u.values=this._split(u.values,s.from,s.to,e=>e));break;case"CUBICSPLINE":if(f){u.interpolate=!0;const r=f===cc_1.Vec3?cc.CubicSplineVec3Value:cc.CubicSplineQuatValue,n=new Array(u.values.length/3);for(let e=0;e<n.length;++e)n[e]=new r(u.values[3*e+1],u.values[3*e+0],u.values[3*e+2]);u.values=n,!s||0===s.from&&s.to+1===u.values.length||this._logger(GltfConverter.LogLevel.Error,GltfConverter.ConverterError.DisallowCubicSplineChannelSplit,{channel:e.channels.indexOf(t),animation:this._gltf.animations.indexOf(e)})}break;case"LINEAR":default:if(u.interpolate=!0,s){let e;switch(o){case"position":case"scale":e=((e,t,r)=>cc_1.Vec3.lerp(new cc_1.Vec3,e,t,r));break;case"rotation":e=((e,t,r)=>cc_1.Quat.slerp(new cc_1.Quat,e,t,r));break;default:e=(e=>e)}u.values=this._split(u.values,s.from,s.to,e)}}r[o]=u}_glTFWeightChannelToCurve(e,t,r,n){const s=e.samplers[t.sampler],o=this._readAccessorIntoArrayAndNormalizeAsFloat(this._gltf.accessors[s.output]),a=this._gltf.nodes[t.target.node],i=this._gltf.meshes[a.mesh].primitives[0].targets.length;return{modifiers:[new cc.HierachyModifier(this._mapToSocketPath(this._getNodePath(t.target.node))),new cc.ComponentModifier(cc.js.getClassName(cc.MeshRenderer))],valueAdapter:new cc.animation.MorphWeightsAllValueProxy,data:{keys:r,values:Array.from(o),_arrayLength:i}}}_split(e,t,r,n){let s,o,a=0;{const r=Math.trunc(t),o=t-r;if(0===o)a=r;else{const t=r+1;s=n(e[r],e[t],o),a=t}}let i=0;{const t=Math.trunc(r),s=r-t;if(0===s)i=t;else{const r=t+1;o=n(e[t],e[r],s),i=t}}const c=e.slice(a,i+1);return s&&c.unshift(s),o&&c.push(o),c}_getParent(e){return this._parents[e]}_getRootParent(e){for(let t=e;t>=0;t=this._getParent(e))e=t;return e}_commonRoot(e){let t=1/0;const r=e.map(e=>{const r=[];let n=e;for(;n>=0;)r.unshift(n),n=this._getParent(n);return t=Math.min(t,r.length),r});if(0===r.length)return-1;const n=[];for(let e=0;e<t;++e){const t=r[0][e];if(!r.every(r=>r[e]===t))break;n.push(t)}return 0===n.length?-1:n[n.length-1]}_getSkinRoot(e){let t=this._skinRoots[e];return t===skinRootNotCalculated&&(t=this._commonRoot(this._gltf.skins[e].joints),this._skinRoots[e]=t),t}_readPrimitive(e){let t=null;if(e.extensions)for(const r of Object.keys(e.extensions)){const n=e.extensions[r];switch(r){case"KHR_draco_mesh_compression":t=this._decodeDracoGeometry(e,n)}}const r=this._getPrimitiveMode(void 0===e.mode?4:e.mode);let n;if(void 0!==e.indices){let r;if(t&&t.indices)r=t.indices;else{const t=this._gltf.accessors[e.indices];r=this._readAccessorIntoArray(t)}n=r}if(!("POSITION"in e.attributes))throw new Error("The primitive doesn't contains positions.");const s=t?t.vertices.POSITION.length/3:this._gltf.accessors[e.attributes.POSITION].count,o=new pp_geometry_1.PPGeometry(s,r,n);for(const r of Object.getOwnPropertyNames(e.attributes)){const n=this._gltf.accessors[e.attributes[r]];let s;if(t&&r in t.vertices){s=t.vertices[r]}else{s=this._readAccessorIntoArray(n)}const a=glTFAttributeNameToPP(r),i=this._getComponentsPerAttribute(n.type);o.setAttribute(a,s,i)}if(e.targets){const t=Object.getOwnPropertyNames(e.targets[0]);for(const r of t){const t=glTFAttributeNameToPP(r);if(!pp_geometry_1.PPGeometry.isStdSemantic(t)||![pp_geometry_1.PPGeometry.StdSemantics.position,pp_geometry_1.PPGeometry.StdSemantics.normal,pp_geometry_1.PPGeometry.StdSemantics.tangent].includes(t))throw new Error(`Only position, normal, tangent attribute are morph-able, but provide ${r}`);assertGlTFConformance(o.hasAttribute(t),`Primitive do not have attribute ${r} for morph.`);const n=o.getAttribute(t);n.morphs=new Array(e.targets.length);for(let t=0;t<e.targets.length;++t){const s=e.targets[t];assertGlTFConformance(r in s,"Morph attributes in all target must be same.");const o=this._gltf.accessors[s[r]],a=this._readAccessorIntoArray(o);n.morphs[t]=a}}let r=!1;o.forEachAttribute(e=>{!r&&e.morphs&&e.morphs.some(e=>e.some(e=>0!==e))&&(r=!0)}),r||(this._logger(GltfConverter.LogLevel.Warning,GltfConverter.ConverterError.EmptyMorph,{}),o.forEachAttribute(e=>{e.morphs&&(e.morphs=null)}))}return o}_decodeDracoGeometry(e,t){const r=this._gltf.bufferViews[t.bufferView],n=this._buffers[r.buffer],s=void 0===r.byteOffset?0:r.byteOffset,o=n.slice(s,s+r.byteLength),a={buffer:new Int8Array(o),attributes:{}};void 0!==e.indices&&(a.indices=this._getAttributeBaseTypeStorage(this._gltf.accessors[e.indices].componentType));for(const r of Object.keys(t.attributes))if(r in e.attributes){const n=this._gltf.accessors[e.attributes[r]];a.attributes[r]={uniqueId:t.attributes[r],storageConstructor:this._getAttributeBaseTypeStorage(n.componentType),components:this._getComponentsPerAttribute(n.type)}}return khr_draco_mesh_compression_1.decodeDracoGeometry(a)}_readBounds(e,t,r){const n=e.attributes.POSITION;if(void 0!==n){const e=this._gltf.accessors[n];e.min&&(5126===e.componentType?(t.x=Math.fround(e.min[0]),t.y=Math.fround(e.min[1]),t.z=Math.fround(e.min[2])):(t.x=e.min[0],t.y=e.min[1],t.z=e.min[2])),e.max&&(5126===e.componentType?(r.x=Math.fround(e.max[0]),r.y=Math.fround(e.max[1]),r.z=Math.fround(e.max[2])):(r.x=e.max[0],r.y=e.max[1],r.z=e.max[2]))}}_applySettings(e,t,r,n,s){if(t===glTF_meta_1.NormalImportSetting.recalculate||t===glTF_meta_1.NormalImportSetting.require&&!e.hasAttribute(pp_geometry_1.PPGeometry.StdSemantics.normal)){const t=e.calculateNormals();e.setAttribute(pp_geometry_1.PPGeometry.StdSemantics.normal,t,3)}else t===glTF_meta_1.NormalImportSetting.exclude&&e.hasAttribute(pp_geometry_1.PPGeometry.StdSemantics.normal)&&e.deleteAttribute(pp_geometry_1.PPGeometry.StdSemantics.normal);if(r===glTF_meta_1.TangentImportSetting.recalculate||r===glTF_meta_1.TangentImportSetting.require&&!e.hasAttribute(pp_geometry_1.PPGeometry.StdSemantics.tangent))if(e.hasAttribute(pp_geometry_1.PPGeometry.StdSemantics.normal))if(e.hasAttribute(pp_geometry_1.PPGeometry.StdSemantics.texcoord)){const t=e.calculateTangents();e.setAttribute(pp_geometry_1.PPGeometry.StdSemantics.tangent,t,4)}else this._logger(GltfConverter.LogLevel.Debug,GltfConverter.ConverterError.FailedToCalculateTangents,{reason:"uv",primitive:n,mesh:s});else this._logger(GltfConverter.LogLevel.Warning,GltfConverter.ConverterError.FailedToCalculateTangents,{reason:"normal",primitive:n,mesh:s});else r===glTF_meta_1.TangentImportSetting.exclude&&e.hasAttribute(pp_geometry_1.PPGeometry.StdSemantics.tangent)&&e.deleteAttribute(pp_geometry_1.PPGeometry.StdSemantics.tangent)}_readBufferView(e){const t=this._buffers[e.buffer];return Buffer.from(t.buffer,t.byteOffset+(e.byteOffset||0),e.byteLength)}_readAccessorIntoArray(e){const t=new(this._getAttributeBaseTypeStorage(e.componentType))(e.count*this._getComponentsPerAttribute(e.type));return this._readAccessor(e,createDataViewFromTypedArray(t)),void 0!==e.sparse&&this._applyDeviation(e,t),t}_readAccessorIntoArrayAndNormalizeAsFloat(e){let t=this._readAccessorIntoArray(e);if(!(t instanceof Float32Array)){const e=new Float32Array(t.length),r=(()=>t instanceof Int8Array?e=>Math.max(e/127,-1):t instanceof Uint8Array?e=>e/255:t instanceof Int16Array?e=>Math.max(e/32767,-1):t instanceof Uint16Array?e=>e/65535:e=>e)();for(let n=0;n<t.length;++n)e[n]=r(t[n]);t=e}return t}_getSceneNode(e,t,r=!0){const n=this._getGltfXXName(GltfAssetKind.Scene,e),s=new cc.Node(n),o=this._gltf.scenes[e];if(void 0!==o.nodes){const e=o.nodes,n=new Array(this._gltf.nodes.length).fill(null);for(const e of o.nodes){this._createEmptyNodeRecursive(e,n,r).parent=s}n.forEach((r,o)=>{this._setupNode(o,n,t,s,e)})}return s}_createEmptyNodeRecursive(e,t,r=!0){const n=this._gltf.nodes[e],s=this._createEmptyNode(e,r);if(void 0!==n.children)for(const e of n.children){this._createEmptyNodeRecursive(e,t,r).parent=s}return t[e]=s,s}_setupNode(e,t,r,n,s){const o=t[e];if(null===o)return;const a=this._gltf.nodes[e];if(void 0!==a.mesh){let i=null;if(void 0===a.skin)i=o.addComponent(cc.MeshRenderer);else{const c=o.addComponent(cc.SkinnedMeshRenderer),l=r.find("skeletons",a.skin);l&&(c.skeleton=l);const f=t[this._getSkinRoot(a.skin)];if(null===f){this.gltf.skins[a.skin].joints.every(e=>s.includes(this._getRootParent(e)))?c.skinningRoot=n:this._logger(GltfConverter.LogLevel.Error,GltfConverter.ConverterError.ReferenceSkinInDifferentScene,{node:e,skin:a.skin})}else c.skinningRoot=f;i=c}const c=r.find("meshes",a.mesh);c&&(i._mesh=c);const l=this.gltf.meshes[a.mesh],f=this._processedMeshes[a.mesh].materialIndices.map(e=>{const t=l.primitives[e];if(void 0===t.material)return null;{const e=r.find("materials",t.material);if(e)return e}return null});i._materials=f}}_createEmptyNode(e,t=!0){const r=this._gltf.nodes[e],n=this._getGltfXXName(GltfAssetKind.Node,e),s=new cc.Node(n);if(!t)return s;if(r.translation&&s.setPosition(r.translation[0],r.translation[1],r.translation[2]),r.rotation&&s.setRotation(this._getNodeRotation(r.rotation,new cc_1.Quat)),r.scale&&s.setScale(r.scale[0],r.scale[1],r.scale[2]),r.matrix){const e=r.matrix,t=this._readNodeMatrix(e),n=new cc_1.Vec3,o=new cc_1.Quat,a=new cc_1.Vec3;cc_1.Mat4.toRTS(t,o,n,a),s.setPosition(n),s.setRotation(o),s.setScale(a)}return s}_readNodeMatrix(e){return new cc_1.Mat4(e[0],e[1],e[2],e[3],e[4],e[5],e[6],e[7],e[8],e[9],e[10],e[11],e[12],e[13],e[14],e[15])}_getNodePath(e){return this._nodePathTable[e]}_isAncestorOf(e,t){if(e!==t)for(;t>=0;){if(t===e)return!0;t=this._getParent(t)}return!1}_mapToSocketPath(e){for(const t of this._socketMappings)if(e===t[0]||e.startsWith(t[0]+"/"))return t[1]+e.slice(t[0].length);return e}_createNodePathTable(){if(void 0===this._gltf.nodes)return[];const e=new Array(this._gltf.nodes.length).fill(-1);this._gltf.nodes.forEach((t,r)=>{if(t.children){t.children.forEach(t=>{e[t]=r}),makeUniqueNames(t.children.map(e=>{let t=this._gltf.nodes[e].name;return"string"==typeof t&&0!==t.length||(t=null),t}),uniqueChildNodeNameGenerator).forEach((e,r)=>{this._gltf.nodes[t.children[r]].name=e})}});const t=new Array(this._gltf.nodes.length).fill("");for(let e=0;e<t.length;++e)t[e]=this._getGltfXXName(GltfAssetKind.Node,e);const r=new Array(this._gltf.nodes.length).fill("");return this._gltf.nodes.forEach((n,s)=>{const o=[];for(let r=s;r>=0;r=e[r])o.unshift(t[r]);r[s]=o.join("/")}),r}_readAccessor(e,t,r=0){if(void 0===e.bufferView)return;const n=this._gltf.bufferViews[e.bufferView],s=this._getComponentsPerAttribute(e.type),o=this._getBytesPerComponent(e.componentType);0===r&&(r=s*o);const a=(void 0!==e.byteOffset?e.byteOffset:0)+(void 0!==n.byteOffset?n.byteOffset:0),i=createDataViewFromBuffer(this._buffers[n.buffer],a),c=void 0!==n.byteStride?n.byteStride:s*o,l=this._getComponentReader(e.componentType),f=this._getComponentWriter(e.componentType);for(let n=0;n<e.count;++n){const e=createDataViewFromTypedArray(i,c*n),a=createDataViewFromTypedArray(t,r*n);for(let t=0;t<s;++t){const r=o*t;f(a,r,l(e,r))}}}_applyDeviation(e,t){const{sparse:r}=e,n=this._gltf.bufferViews[r.indices.bufferView],s=this._buffers[n.buffer],o=new(this._getAttributeBaseTypeStorage(r.indices.componentType))(s.buffer,s.byteOffset+(n.byteOffset||0)+(r.indices.byteOffset||0),r.count),a=this._gltf.bufferViews[r.values.bufferView],i=this._buffers[a.buffer],c=new(this._getAttributeBaseTypeStorage(e.componentType))(i.buffer,i.byteOffset+(a.byteOffset||0)+(r.values.byteOffset||0)),l=this._getComponentsPerAttribute(e.type);for(let e=0;e<l;++e)for(let r=0;r<o.length;++r){t[l*o[r]+e]=c[l*r+e]}}_getPrimitiveMode(e){switch(void 0===e&&(e=4),e){case 0:return cc_1.gfx.PrimitiveMode.POINT_LIST;case 1:return cc_1.gfx.PrimitiveMode.LINE_LIST;case 2:return cc_1.gfx.PrimitiveMode.LINE_LOOP;case 3:return cc_1.gfx.PrimitiveMode.LINE_STRIP;case 4:return cc_1.gfx.PrimitiveMode.TRIANGLE_LIST;case 5:return cc_1.gfx.PrimitiveMode.TRIANGLE_STRIP;case 6:return cc_1.gfx.PrimitiveMode.TRIANGLE_FAN;default:throw new Error(`Unrecognized primitive mode: ${e}.`)}}_getAttributeBaseTypeStorage(e){switch(e){case 5120:return Int8Array;case 5121:return Uint8Array;case 5122:return Int16Array;case 5123:return Uint16Array;case 5125:return Uint32Array;case 5126:return Float32Array;default:throw new Error(`Unrecognized component type: ${e}`)}}_getComponentsPerAttribute(e){switch(e){case"SCALAR":return 1;case"VEC2":return 2;case"VEC3":return 3;case"VEC4":case"MAT2":return 4;case"MAT3":return 9;case"MAT4":return 16;default:throw new Error(`Unrecognized attribute type: ${e}.`)}}_getBytesPerComponent(e){switch(e){case 5120:case 5121:return 1;case 5122:case 5123:return 2;case 5125:case 5126:return 4;default:throw new Error(`Unrecognized component type: ${e}`)}}_getComponentReader(e){switch(e){case 5120:return(e,t)=>e.getInt8(t);case 5121:return(e,t)=>e.getUint8(t);case 5122:return(e,t)=>e.getInt16(t,DataViewUseLittleEndian);case 5123:return(e,t)=>e.getUint16(t,DataViewUseLittleEndian);case 5125:return(e,t)=>e.getUint32(t,DataViewUseLittleEndian);case 5126:return(e,t)=>e.getFloat32(t,DataViewUseLittleEndian);default:throw new Error(`Unrecognized component type: ${e}`)}}_getComponentWriter(e){switch(e){case 5120:return(e,t,r)=>e.setInt8(t,r);case 5121:return(e,t,r)=>e.setUint8(t,r);case 5122:return(e,t,r)=>e.setInt16(t,r,DataViewUseLittleEndian);case 5123:return(e,t,r)=>e.setUint16(t,r,DataViewUseLittleEndian);case 5125:return(e,t,r)=>e.setUint32(t,r,DataViewUseLittleEndian);case 5126:return(e,t,r)=>e.setFloat32(t,r,DataViewUseLittleEndian);default:throw new Error(`Unrecognized component type: ${e}`)}}_getGltfXXName(e,t){const r={[GltfAssetKind.Animation]:"animations",[GltfAssetKind.Image]:"images",[GltfAssetKind.Material]:"materials",[GltfAssetKind.Node]:"nodes",[GltfAssetKind.Skin]:"skins",[GltfAssetKind.Texture]:"textures",[GltfAssetKind.Scene]:"scenes"},n=this._gltf[r[e]];if(!n)return"";const s=n[t];return"string"==typeof s.name?s.name:`${GltfAssetKind[e]}-${t}`}}async function readGltf(e){return".glb"===path.extname(e)?await readGlb(e):await readGltfJson(e)}async function readGltfJson(e){const t=await fs.readJSON(e);return{glTF:t,buffers:t.buffers?t.buffers.map(t=>t.uri?resolveBufferUri(e,t.uri):Buffer.alloc(0)):[]}}async function readGlb(e){const t=()=>{throw new Error("Bad glb format.")},r=await fs.readFile(e);if(r.length<12)return t();if(1179937895!==r.readUInt32LE(0))return t();r.readUInt32LE(4),r.readUInt32LE(8);let n,s;for(let e=0,o=12;o+8<=r.length;++e){const a=r.readUInt32LE(o);o+=4;const i=r.readUInt32LE(o);if((o+=4)+a>r.length)return t();const c=Buffer.from(r.buffer,o,a);if(o+=a,0===e){if(1313821514!==i)return t();const e=new TextDecoder("utf-8").decode(c);n=JSON.parse(e)}else 5130562===i&&(s=c)}if(n){return{glTF:n,buffers:n.buffers?n.buffers.map((t,r)=>t.uri?resolveBufferUri(e,t.uri):0===r&&s?s:Buffer.alloc(0)):[]}}return t()}function resolveBufferUri(e,t){const r=DataURI.parse(t);if(r)return Buffer.from(resolveBufferDataURI(r));return path.resolve(path.dirname(e),t)}function isDataUri(e){return e.startsWith("data:")}exports.GltfConverter=GltfConverter,GltfConverter._defaultLogger=((e,t,r)=>{const n=JSON.stringify({error:t,arguments:r},void 0,4);switch(e){case GltfConverter.LogLevel.Info:console.log(n);break;case GltfConverter.LogLevel.Warning:console.warn(n);break;case GltfConverter.LogLevel.Error:console.error(n);break;case GltfConverter.LogLevel.Debug:console.debug(n)}}),function(e){let t,r;!function(e){e[e.Info=0]="Info",e[e.Warning=1]="Warning",e[e.Error=2]="Error",e[e.Debug=3]="Debug"}(t=e.LogLevel||(e.LogLevel={})),function(e){e[e.ReferenceSkinInDifferentScene=0]="ReferenceSkinInDifferentScene",e[e.UnsupportedAlphaMode=1]="UnsupportedAlphaMode",e[e.UnsupportedTextureParameter=2]="UnsupportedTextureParameter",e[e.UnsupportedChannelPath=3]="UnsupportedChannelPath",e[e.DisallowCubicSplineChannelSplit=4]="DisallowCubicSplineChannelSplit",e[e.FailedToCalculateTangents=5]="FailedToCalculateTangents",e[e.EmptyMorph=6]="EmptyMorph",e[e.UnsupportedExtension=7]="UnsupportedExtension"}(r=e.ConverterError||(e.ConverterError={}))}(GltfConverter=exports.GltfConverter||(exports.GltfConverter={})),exports.readGltf=readGltf,exports.isDataUri=isDataUri;class BufferBlob{constructor(){this._arrayBufferOrPaddings=[],this._length=0}setNextAlignment(e){if(0!==e){const t=this._length%e;if(0!==t){const r=e-t;this._arrayBufferOrPaddings.push(r),this._length+=r}}}addBuffer(e){const t=this._length;return this._arrayBufferOrPaddings.push(e),this._length+=e.byteLength,t}getLength(){return this._length}getCombined(){const e=new Uint8Array(this._length);let t=0;return this._arrayBufferOrPaddings.forEach(r=>{"number"==typeof r?t+=r:(e.set(new Uint8Array(r),t),t+=r.byteLength)}),e}}function createDataViewFromBuffer(e,t=0){return new DataView(e.buffer,e.byteOffset+t)}function createDataViewFromTypedArray(e,t=0){return new DataView(e.buffer,e.byteOffset+t)}const DataViewUseLittleEndian=!0;function uniqueChildNodeNameGenerator(e,t,r,n){return`${e||""}(__autogen ${r}${0===n?"":`-${n}`})`}function makeUniqueNames(e,t){const r=new Array(e.length).fill("");for(let n=0;n<e.length;++n){let s=e[n],o=0;for(;;){if(null!==s&&(()=>r.every((e,t)=>t===n||s!==e))()){r[n]=s;break}s=t(e[n],s,n,o++)}}return r}function resolveBufferDataURI(e){if(!e.base64||!e.mediaType||"application/octet-stream"!==e.mediaType.value&&"application/gltf-buffer"!==e.mediaType.value)throw new Error(`Cannot understand data uri(base64: ${e.base64}, mediaType: ${e.mediaType}) for buffer.`);return base64_1.decodeBase64ToArrayBuffer(e.data)}class DynamicArrayBuffer{constructor(e){this._size=0,this._arrayBuffer=new ArrayBuffer(Math.max(e||0,4))}get arrayBuffer(){return this._arrayBuffer}grow(e){const t=this._size;if(e){const r=this._arrayBuffer.byteLength,n=r-t-e;if(n<0){const e=new ArrayBuffer(1.5*(r+-n));new Uint8Array(e,0,r).set(new Uint8Array(this._arrayBuffer)),this._arrayBuffer=e}this._size+=e}return t}shrink(){return this._arrayBuffer.slice(0,this._size)}}function getDataviewWritterOfTypedArray(e,t){switch(e.constructor){case Int8Array:return(e,t,r)=>e.setInt8(t,r);case Uint8Array:return(e,t,r)=>e.setUint8(t,r);case Int16Array:return(e,r,n)=>e.setInt16(r,n,t);case Uint16Array:return(e,r,n)=>e.setUint16(r,n,t);case Int32Array:return(e,r,n)=>e.setInt32(r,n,t);case Uint32Array:return(e,r,n)=>e.setUint32(r,n,t);case Float32Array:return(e,r,n)=>e.setFloat32(r,n,t);default:throw new Error("Bad storage constructor.")}}function interleaveVertices(e){const t=e.vertexCount;let r=0;e.forEachAttribute(e=>{r+=e.data.BYTES_PER_ELEMENT*e.components});const n=new ArrayBuffer(t*r),s=new DataView(n);let o=0;const a=[];return e.forEachAttribute(e=>{let n;try{n=pp_geometry_1.getGfxAttributeName(e)}catch(e){return void console.error(e)}const i=e.data,c=getDataviewWritterOfTypedArray(i,DataViewUseLittleEndian);for(let n=0;n<t;++n){const t=o+r*n;for(let r=0;r<e.components;++r){const o=i[e.components*n+r];c(s,t+i.BYTES_PER_ELEMENT*r,o)}}o+=e.data.BYTES_PER_ELEMENT*e.components,a.push({name:n,format:e.getGFXFormat(),isNormalized:e.isNormalized})}),{vertexCount:t,vertexStride:r,formats:a,vertexBuffer:n}}const glTFAttributeNameToPP=(()=>e=>{if(e.startsWith("_"))return e;const t=/([a-zA-Z]+)(?:_(\d+))?/g.exec(e);if(!t)return e;const r=t[1];let n;const s=parseInt(t[2]||"0");switch(r){case"POSITION":n=pp_geometry_1.PPGeometry.StdSemantics.position;break;case"NORMAL":n=pp_geometry_1.PPGeometry.StdSemantics.normal;break;case"TANGENT":n=pp_geometry_1.PPGeometry.StdSemantics.tangent;break;case"COLOR":n=pp_geometry_1.PPGeometry.StdSemantics.color;break;case"TEXCOORD":n=pp_geometry_1.PPGeometry.StdSemantics.texcoord;break;case"JOINTS":n=pp_geometry_1.PPGeometry.StdSemantics.joints;break;case"WEIGHTS":n=pp_geometry_1.PPGeometry.StdSemantics.weights}return void 0===n?e:pp_geometry_1.PPGeometry.StdSemantics.set(n,s)})();class GlTfConformanceError extends Error{}function assertGlTFConformance(e,t){if(!e)throw new GlTfConformanceError(`glTF non-conformance error: ${t}`)}exports.GlTfConformanceError=GlTfConformanceError;