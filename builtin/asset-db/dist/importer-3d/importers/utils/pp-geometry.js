"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.getNormalizer=exports.getGfxAttributeName=exports.PPGeometry=void 0;const cc_1=require("cc");function getMergedSetSize(t,e){let r=t.size;for(const n of e)t.has(n)||r++;return r}function mergeSets(t,e){const r=new Set;for(const e of t)r.add(e);for(const t of e)r.add(t);return r}function isStrictSubSet(t,e){for(const r of e)if(!t.has(r))return!1;return!0}class PPGeometry{constructor(t,e,r,n){this._vertices={},this._vertexCount=t,this._primitiveMode=e,this._jointSet=n,r&&r.BYTES_PER_ELEMENT<Uint16Array.BYTES_PER_ELEMENT&&(r=Uint16Array.from(r)),this._indices=r}static skinningProcess(t,e){const r=[],n=[],o=cc_1.pipeline.JOINT_UNIFORM_CAPACITY;for(let i=0;i<t.length;i++){const s=t[i];if(e||!s._jointSet||s._jointSet.size<=o){r.push(s),n.push(i);continue}const c=s.getAttribute(PPGeometry.StdSemantics.joints).data,a=s._getTriangleIndices(),m=EditorExtends.GeometryUtils.splitBasedOnJoints(c,a,s.primitiveMode,o);if(m.length)for(const t of m){const e=Array.from(t.indices.reduce((t,e)=>t.add(e),new Set).values()),o=new(EditorExtends.GeometryUtils.getUintArrayCtor(e.length))(t.indices.length);t.indices.forEach((t,r)=>o[r]=e.indexOf(t));const c=new PPGeometry(e.length,t.primitiveMode,o,t.jointSet);s.forEachAttribute(t=>{const{semantic:r}=t,n=t.components,o=t.data,i=new o.constructor(e.length*n);if(e.forEach((t,e)=>{for(let r=0;r<n;r++)i[e*n+r]=o[t*n+r]}),c.setAttribute(r,i,n,t.isNormalized),t.morphs){const n=c.getAttribute(r);n.morphs=new Array(t.morphs.length);for(let r=0;r<t.morphs.length;++r){const o=3,i=t.morphs[r],s=new i.constructor(e.length*o);e.forEach((t,e)=>{for(let r=0;r<o;++r)s[e*o+r]=i[t*o+r]}),n.morphs[r]=s}}}),r.push(c),n.push(i)}else r.push(s),n.push(i)}const i=r.reduce((t,e)=>(e._jointSet&&t.push(e._jointSet),t),[]);let s=i.length>1;for(;s;){s=!1;let t=1/0,e=-1,r=-1;for(let n=0;n<i.length;n++){const c=i[n];for(let a=n+1;a<i.length;a++){const m=i[a],u=getMergedSetSize(c,m);if(u<=o){const o=Math.min(Math.abs(u-c.size),Math.abs(u-m.size));o<t&&(s=!0,t=o,e=n,r=a)}}}if(s){const n=i[e],o=i[r];if(i[e]=mergeSets(n,o),i[r]=i[i.length-1],--i.length<=1)break;t=1/0}}let c=i.map(t=>Array.from(t.values()).sort((t,e)=>t-e));if(!c.length||c.every(t=>1===t.length&&!t[0]))c=void 0;else for(let t=0;t<r.length;t++){const e=r[t],n=e._jointSet;n&&(e._jointMapIndex=i.findIndex(t=>isStrictSubSet(t,n)))}return{geometries:r,materialIndices:n,jointMaps:c}}get vertexCount(){return this._vertexCount}get indices(){return this._indices}get primitiveMode(){return this._primitiveMode}get jointMapIndex(){return this._jointMapIndex}calculateNormals(t=Float32Array){const e=this._assertAttribute(PPGeometry.StdSemantics.position).data,r=this._getTriangleIndices(),n=new t(3*this._vertexCount);return EditorExtends.GeometryUtils.calculateNormals(e,r,n)}calculateTangents(t=Float32Array,e=0){const r=this._assertAttribute(PPGeometry.StdSemantics.position).data,n=this._getTriangleIndices(),o=this._assertAttribute(PPGeometry.StdSemantics.normal).data,i=this._assertAttribute(PPGeometry.StdSemantics.set(PPGeometry.StdSemantics.texcoord,e)).data,s=new t(4*this._vertexCount);return EditorExtends.GeometryUtils.calculateTangents(r,n,o,i,s)}sanityCheck(){if(!this.hasAttribute(PPGeometry.StdSemantics.weights)||!this.hasAttribute(PPGeometry.StdSemantics.joints))return;const t=this.getAttribute(PPGeometry.StdSemantics.weights),e=this.getAttribute(PPGeometry.StdSemantics.joints),r=this.vertexCount;if(e.data.constructor!==Uint16Array){const t=new Uint16Array(e.data.length);for(let r=0;r<t.length;r++)t[r]=e.data[r];e.data=t}const[n,o]=getTargetJointWeightCheckParams(t.data.constructor);for(let e=0;e<r;++e){let r=0;for(let n=0;n<t.components;n++)r+=t.data[t.components*e+n]+o;if(r!==n&&0!==r)if(1===n)for(let o=0;o<t.components;o++)t.data[t.components*e+o]*=n/r;else{const i=[];for(let n=0;n<t.components;n++)i.push((t.data[t.components*e+n]+o)/r);let s=0;for(let r=0;r<t.components;r++){const c=i[r],a=cc_1.clamp(Math.floor((c+s)*n),0,n);s=c-a/n,t.data[t.components*e+r]=a-o}}}this._jointSet=new Set,this._jointSet.add(0);for(let n=0;n<r;++n)for(let r=0;r<e.components;r++)t.data[e.components*n+r]>0?this._jointSet.add(e.data[e.components*n+r]):e.data[e.components*n+r]=0}getAttribute(t){return this._vertices[t]}hasAttribute(t){return t in this._vertices}deleteAttribute(t){delete this._vertices[t]}setAttribute(t,e,r,n){if(void 0===n)if(e.constructor===Float32Array)n=!1;else if("number"==typeof t)switch(PPGeometry.StdSemantics.decode(t).semantic0){case PPGeometry.StdSemantics.texcoord:case PPGeometry.StdSemantics.color:case PPGeometry.StdSemantics.weights:n=!0}this._vertices[t]=new PPGeometry.Attribute(t,e,r,n)}forEachAttribute(t){Object.values(this._vertices).forEach(t)}reduceJointInfluences(){if((t=>Object.values(this._vertices).reduce((e,r)=>e+=equalStdSemantic(r.semantic,t)?1:0,0))(PPGeometry.StdSemantics.joints)<=1)return;let t;for(const e of Object.values(this._vertices))if(equalStdSemantic(e.semantic,PPGeometry.StdSemantics.weights)){const r=e.data.constructor;if(t){if(t!==r)return void console.error("All weights attribute should be of same component type.")}else t=r}if(!t)return void console.error("The number of joints attribute and weights attribute are not matched.");const e=new Uint16Array(4*this._vertexCount),r=new t(4*this._vertexCount);for(const t of Object.values(this._vertices)){if(!PPGeometry.isStdSemantic(t.semantic))continue;const{semantic0:n,set:o}=PPGeometry.StdSemantics.decode(t.semantic);if(n!==PPGeometry.StdSemantics.joints)continue;const i=PPGeometry.StdSemantics.set(PPGeometry.StdSemantics.weights,o);if(!(i in this._vertices)){console.error(`Vertex attribute joints-${o} has no corresponding weights attribute`);continue}const s=t,c=this._vertices[i].data,a=4;for(let t=0;t<a;++t)for(let n=0;n<this._vertexCount;++n){const o=n*a+t,i=c[o];for(let t=0;t<4;++t){const c=4*n+t;if(i>=r[c]){for(let t=4*(n+1)-1-1;t>=c;--t)r[t+1]=r[t],e[t+1]=e[t];r[c]=i,e[c]=s.data[o];break}}}this.deleteAttribute(t.semantic),this.deleteAttribute(i)}this.setAttribute(PPGeometry.StdSemantics.set(PPGeometry.StdSemantics.joints,0),e,4),this.setAttribute(PPGeometry.StdSemantics.set(PPGeometry.StdSemantics.weights,0),r,4)}_getTriangleIndices(){if(this._primitiveMode!==cc_1.gfx.PrimitiveMode.TRIANGLE_LIST)throw new Error("Triangles expected.");return this._indices||this._generatedIndices||(this._generatedIndices=(()=>{const t=new(this._vertexCount>=1<<8*Uint16Array.BYTES_PER_ELEMENT?Uint32Array:Uint16Array)(this._vertexCount);for(let e=0;e<this._vertexCount;++e)t[e]=e;return t})())}_assertAttribute(t){if(this.hasAttribute(t))return this.getAttribute(t);{let e;if(PPGeometry.isStdSemantic(t)){const{semantic0:r,set:n}=PPGeometry.StdSemantics.decode(t);e=`${PPGeometry.StdSemantics[r]}`,0!==n&&(e+=`(set ${n})`)}else e=t;throw new Error(`${e} attribute is expect but not present`)}}}function getTargetJointWeightCheckParams(t){switch(t){case Int8Array:return[255,128];case Uint8Array:return[255,0];case Int16Array:return[65535,32768];case Uint16Array:return[65535,0];case Int32Array:return[4294967295,2147483648];case Uint32Array:return[4294967295,0];case Float32Array:return[1,0]}return[1,0]}exports.PPGeometry=PPGeometry,function(t){let e;!function(t){t[t.position=0]="position",t[t.normal=1]="normal",t[t.texcoord=2]="texcoord",t[t.tangent=3]="tangent",t[t.joints=4]="joints",t[t.weights=5]="weights",t[t.color=6]="color"}(e=t.StdSemantics||(t.StdSemantics={})),function(t){t.set=function(t,e){return(e<<4)+t},t.decode=function(t){return{semantic0:15&t,set:t>>4}}}(e=t.StdSemantics||(t.StdSemantics={})),t.isStdSemantic=function(t){return"number"==typeof t};t.Attribute=class{constructor(t,e,r,n=!1){this.morphs=null,this.semantic=t,this.data=e,this.components=r,this.isNormalized=n}getGFXFormat(){const t=attributeFormatMap.get(this.data.constructor);if(void 0!==t&&this.components in t)return t[this.components];throw new Error("No corresponding gfx format for attribute.")}}}(PPGeometry=exports.PPGeometry||(exports.PPGeometry={}));const stdSemanticInfoMap={[PPGeometry.StdSemantics.position]:{gfxAttributeName:cc_1.gfx.AttributeName.ATTR_POSITION,components:3},[PPGeometry.StdSemantics.normal]:{gfxAttributeName:cc_1.gfx.AttributeName.ATTR_NORMAL,components:3},[PPGeometry.StdSemantics.texcoord]:{gfxAttributeName:cc_1.gfx.AttributeName.ATTR_TEX_COORD,components:2,multisets:{1:cc_1.gfx.AttributeName.ATTR_TEX_COORD1,2:cc_1.gfx.AttributeName.ATTR_TEX_COORD2,3:cc_1.gfx.AttributeName.ATTR_TEX_COORD3,4:cc_1.gfx.AttributeName.ATTR_TEX_COORD4,5:cc_1.gfx.AttributeName.ATTR_TEX_COORD5,6:cc_1.gfx.AttributeName.ATTR_TEX_COORD6,7:cc_1.gfx.AttributeName.ATTR_TEX_COORD7,8:cc_1.gfx.AttributeName.ATTR_TEX_COORD8}},[PPGeometry.StdSemantics.tangent]:{gfxAttributeName:cc_1.gfx.AttributeName.ATTR_TANGENT,components:4},[PPGeometry.StdSemantics.joints]:{gfxAttributeName:cc_1.gfx.AttributeName.ATTR_JOINTS,components:4},[PPGeometry.StdSemantics.weights]:{gfxAttributeName:cc_1.gfx.AttributeName.ATTR_WEIGHTS,components:4},[PPGeometry.StdSemantics.color]:{gfxAttributeName:cc_1.gfx.AttributeName.ATTR_COLOR,components:[3,4]}},attributeFormatMap=new Map([[Int8Array,{1:cc_1.gfx.Format.R8SN,2:cc_1.gfx.Format.RG8SN,3:cc_1.gfx.Format.RGB8SN,4:cc_1.gfx.Format.RGBA8SN}],[Uint8Array,{1:cc_1.gfx.Format.R8,2:cc_1.gfx.Format.RG8,3:cc_1.gfx.Format.RGB8,4:cc_1.gfx.Format.RGBA8}],[Int16Array,{1:cc_1.gfx.Format.R16I,2:cc_1.gfx.Format.RG16I,3:cc_1.gfx.Format.RGB16I,4:cc_1.gfx.Format.RGBA16I}],[Uint16Array,{1:cc_1.gfx.Format.R16UI,2:cc_1.gfx.Format.RG16UI,3:cc_1.gfx.Format.RGB16UI,4:cc_1.gfx.Format.RGBA16UI}],[Int32Array,{1:cc_1.gfx.Format.R32I,2:cc_1.gfx.Format.RG32I,3:cc_1.gfx.Format.RGB32I,4:cc_1.gfx.Format.RGBA32I}],[Uint32Array,{1:cc_1.gfx.Format.R32UI,2:cc_1.gfx.Format.RG32UI,3:cc_1.gfx.Format.RGB32UI,4:cc_1.gfx.Format.RGBA32UI}],[Float32Array,{1:cc_1.gfx.Format.R32F,2:cc_1.gfx.Format.RG32F,3:cc_1.gfx.Format.RGB32F,4:cc_1.gfx.Format.RGBA32F}]]);function getGfxAttributeName(t){const{semantic:e}=t;let r;if(PPGeometry.isStdSemantic(e)){const{semantic0:n,set:o}=PPGeometry.StdSemantics.decode(e),i=stdSemanticInfoMap[n];if(!(Array.isArray(i.components)?i.components.includes(t.components):i.components===t.components))throw new Error(`Mismatched ${PPGeometry.StdSemantics[n]} components, expect ${i.components}.`);if(0===o)r=i.gfxAttributeName;else{if(!(i.multisets&&o in i.multisets))throw new Error(`${PPGeometry.StdSemantics[n]} doesn't allow ${o}.`);r=i.multisets[o]}}else r=e;return r}exports.getGfxAttributeName=getGfxAttributeName,exports.getNormalizer=(()=>{const t=t=>t/255,e=t=>t/65535,r=t=>t/(2**32-1),n=t=>Math.max(t/127,-1),o=t=>Math.max(t/32767,-1),i=t=>Math.max(t/(2**31-1),-1);return s=>{switch(!0){case s instanceof Int8Array:return n;case s instanceof Int16Array:return o;case s instanceof Int32Array:return i;case s instanceof Uint8Array:return t;case s instanceof Uint16Array:return e;case s instanceof Uint32Array:return r;default:return}}})();const equalStdSemantic=(t,e)=>PPGeometry.isStdSemantic(t)&&PPGeometry.StdSemantics.decode(t).semantic0==e;