"use strict";Object.defineProperty(exports,"__esModule",{value:!0});const asset_db_1=require("@editor/asset-db"),cc_1=require("cc"),fs_extra_1=require("fs-extra"),path_1=require("path"),plist=require("plist"),BRACE_REGEX=/[\{\}]/g,PATH_SEPERATOR=/[\\\/]/g;function _parseSize(e){const t=(e=e.slice(1,-1)).split(","),r=parseInt(t[0],10),s=parseInt(t[1],10);return cc.size(r,s)}function _parseVec2(e){const t=(e=e.slice(1,-1)).split(","),r=parseInt(t[0],10),s=parseInt(t[1],10);return new cc.Vec2(r,s)}function _parseTriangles(e){return e.split(" ").map(e=>parseInt(e,10))}function _parseVertices(e){return e.split(" ").map(e=>parseInt(e,10))}function _parseRect(e){const t=(e=e.replace(BRACE_REGEX,"")).split(",");return{x:parseInt(t[0]||0,10),y:parseInt(t[1]||0,10),w:parseInt(t[2]||0,10),h:parseInt(t[3]||0,10)}}class TexturePackerImporter extends asset_db_1.Importer{get version(){return"1.0.0"}get name(){return"texture-packer"}async validate(e){const t=plist.parse(await fs_extra_1.readFile(e.source,"utf8"));return void 0!==t.frames&&void 0!==t.metadata}async import(e){let t=!1;if(!await e.existsInLibrary(".json")){const r=plist.parse(await fs_extra_1.readFile(e.source,"utf8")),s=r.metadata,a=path_1.join(path_1.dirname(e.source),s.realTextureFileName||s.textureFileName);let i;if(e.depend(a),this.assetDB&&!(i=this.assetDB.pathToUuid(a)))return!1;e.userData.size=_parseSize(s.size);const n=Object.keys(r.frames);for(const t of n){(await this.createSubSpriteFrame(e,t,r.frames[t],s)).userData.textureUuid=i}const c=this.createSpriteAtlas(e);await e.saveToLibrary(".json",EditorExtends.serialize(c)),t=!0}return t}createSpriteAtlas(e){const t=new cc.SpriteAtlas;t._name=e.basename+e.extname;const r=Object.keys(e.subAssets),s=/\.[^.]+$/;for(let a of r){const r=e.subAssets[a];a=a.replace(s,""),t._spriteFrames[a]=EditorExtends.serialize.asAsset(r.uuid,cc_1.SpriteFrame)}return t}async createSubSpriteFrame(e,t,r,s){const a=t.replace(PATH_SEPERATOR,"-"),i=await e.createSubAsset(a,"sprite-frame");let n,c,u,o,p=!1;switch(s.format){case 0:p=!1,c=`{${r.originalWidth},${r.originalHeight}}`,u=`{${r.offsetX},${r.offsetY}}`,o=`{{${r.x},${r.y}},{${r.width},${r.height}}}`;break;case 1:case 2:p=r.rotated,n=r.trimmed,c=r.sourceSize,u=r.offset,o=r.frame;break;case 3:p=r.textureRotated,n=r.trimmed,c=r.spriteSourceSize,u=r.spriteOffset,o=r.textureRect}i.userData.rotated=!!p,i.userData.trimType=n?"custom":"auto",i.userData.spriteType="normal";const l=_parseSize(c);i.userData.rawWidth=l.width,i.userData.rawHeight=l.height;const f=_parseVec2(u);i.userData.offsetX=f.x,i.userData.offsetY=f.y;const h=_parseRect(o);if(i.userData.trimX=h.x,i.userData.trimY=h.y,i.userData.width=h.w,i.userData.height=h.h,i.userData.vertices=void 0,r.triangles){const e=_parseTriangles(r.triangles),s=_parseVertices(r.vertices),a=_parseVertices(r.verticesUV);if(s.length!==a.length)console.warn(`\n                    [${t}] vertices.                     length [${s.length}] is different with verticesUV.length [${a.length}]                `);else{i.userData.vertices={triangles:e,x:[],y:[],u:[],v:[]};for(let e=0;e<s.length;e+=2)i.userData.vertices.x.push(s[e]),i.userData.vertices.y.push(s[e+1]);for(let e=0;e<a.length;e+=2)i.userData.vertices.u.push(a[e]),i.userData.vertices.v.push(a[e+1])}}return i}}exports.default=TexturePackerImporter;