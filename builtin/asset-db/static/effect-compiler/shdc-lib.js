"use strict";const tokenizer=require("glsl-tokenizer/string"),parser=require("glsl-parser/direct"),mappings=require("./offline-mappings"),yaml=require("js-yaml"),tabAsSpaces=2,includeRE=/#include +[<"]([^>"]+)[>"]/g,plainDefineRE=/#define\s+(\w+)\s+(.*)\n/g,precisionRE=/precision\s+(low|medium|high)p\s+(\w+)/,whitespaces=/\s+/g,ident=/[_a-zA-Z]\w*/g,comparators=/^[<=>]+$/,ifprocessor=/#(el)?if/,labelRE=/(\w+)\((.*?)\)/,precision=/(low|medium|high)p/,arithmetics=/^[\d\+\-*/%\s]+$/,locationRE=/location\s*=\s*(\d+)/,inDecl=/(?:layout\s*\((.*?)\)\s*)?in ((?:\w+\s+)?\w+\s+(\w+)\s*(?:\[[\d\s]+])?)\s*;/g,outDecl=/(?:layout\s*\((.*?)\)\s*)?out ((?:\w+\s+)?\w+\s+(\w+)\s*(?:\[[\d\s]+])?)\s*;/g,texLookup=/\btexture((?!2D|Cube)\w*)\s*\(\s*(\w+)\s*([,\[])/g,layoutRE=/layout\s*\(.*?\)\s*/g,layoutCapture=/layout\s*\((.*?)\)(\s*)(\w+)/g,layoutExtract=/layout\s*\((.*?)\)(\s*)$/,bindingExtract=/(?:location|binding)\s*=\s*(\d+)/,builtinRE=/^cc\w+$/i,pragmasToStrip=/^\s*(?:#pragma\s*)(?!STDGL|optimize|debug).*$\n/gm,tokenizerOpt={version:"300 es"};let effectName="",shaderName="",shaderTokens=[];const formatMsg=(e,t)=>`${effectName}.effect - ${shaderName}`+(void 0!==t?` - ${t}: `:": ")+e,options={throwOnError:!0,throwOnWarning:!1,noSource:!1,skipParserTest:!1,chunkSearchFn:e=>({}),getAlternativeChunkPaths:e=>[]},dumpSource=e=>{let t=0;return e.reduce((e,n)=>n.line>t?e+`\n${t=n.line}\t${n.data.replace(/\n/g,"")}`:e+n.data,"")},warn=(e,t)=>{options.noSource&&(t=void 0);let n=void 0!==t?" ↓↓↓↓↓ EXPAND THIS MESSAGE FOR MORE INFO ↓↓↓↓↓"+dumpSource(shaderTokens)+"\n":"";const r=formatMsg("Warning "+e,t)+n;if(options.throwOnWarning)throw r;console.warn(r)},error=(e,t)=>{options.noSource&&(t=void 0);let n=void 0!==t?" ↓↓↓↓↓ EXPAND THIS MESSAGE FOR MORE INFO ↓↓↓↓↓"+dumpSource(shaderTokens)+"\n":"";const r=formatMsg("Error "+e,t)+n;if(options.throwOnError)throw r;console.error(r)},convertType=e=>{let t=mappings.typeMap[e];return void 0===t?e:t},stripComments=(()=>{const e=/\r\n/g,t=/\/\*.*?\*\//gs,n=/\s*\/\/.*$/gm;return r=>{let s=r.replace(t,"");return s=(s=s.replace(n,"")).replace(e,"\n")}})(),chunksCache={},addChunk=(e,t)=>(chunksCache[e]=stripComments(t),chunksCache),invokeSearch=e=>{const{name:t,content:n}=options.chunkSearchFn(e);if(void 0!==n)return addChunk(t,n),t},unwindIncludes=(e,t,n=new Set)=>{return e.replace(includeRE,(e,r)=>{if(r.endsWith(".chunk")&&(r=r.slice(0,-6)),n.has(r))return"";let s=void 0;do{if(void 0!==(s=t[r]))break;const n=options.getAlternativeChunkPaths(r);if(n.some(e=>{if(void 0!==t[e])return r=e,s=t[e],!0}))break;if(r=invokeSearch([].concat(r,n)),void 0!==(s=chunksCache[r]))break;return error(`EFX2001: can not resolve ${e}`),""}while(0);return n.add(r),unwindIncludes(s,t,n)})},expandFunctionalMacro=(()=>{const e=(e,t)=>{if("("!==e[t])return t;let n=1,r=t+1;for(;r<e.length&&("("===e[r]&&n++,")"===e[r]&&n--,0!==n);r++);return r},t=t=>{const n=[];let r=0;for(let s=0;s<t.length;s++)"("===t[s]&&(s=e(t,s)+1),","===t[s]&&(r!==s&&n.push(t.substring(r,s).trim()),r=s+1);return r!==t.length&&n.push(t.substring(r).trim()),n},n=/#define\s+(\w+)\(([\w,\s]+)\)\s+(.*?)\n/g,r=/(?<=\w)##(?=\w)/g,s=/\\\n/g,i=/@@/g;return o=>{o=o.replace(s,"@@");let a=n.exec(o);for(;null!=a;){const s=a[1],l=t(a[2]),c=a[3],p=a.index,d=a.index+a[0].length,f=new RegExp("^(.*?)"+s+"\\s*\\(","gm");if(new RegExp("\\b"+s+"\\b").test(c))warn(`EFX2002: recursive macro processor '${s}'`);else for(let n=f.exec(o);null!=n;n=f.exec(o)){const s=n.index+n[0].length-1;if(s>p&&s<d)continue;const a=n[1],m=n.index+a.length,u=e(o,s)+1,g=t(o.slice(n.index+n[0].length,u-1));let h=[];for(let e=0;e<l.length;e++){const t=new RegExp("\\b"+l[e]+"\\b","g");let n;for(;null!==(n=t.exec(c));)h.push({beg:n.index,end:t.lastIndex,target:g[e]})}let b="",y=0;for(const e of h.sort((e,t)=>e.beg-t.beg))b+=c.slice(y,e.beg)+e.target,y=e.end;b+=c.slice(y,c.length),-1===a.indexOf("#define")&&(b=(b=b.replace(r,"")).replace(i,"\n")),o=o.substring(0,m)+b+o.substring(u),f.lastIndex-=n[0].length}o=o.substring(0,p)+o.substring(d),n.lastIndex=0,a=n.exec(o)}return o.replace(i,"\\\n"),o}})(),expandLiteralMacro=e=>{const t={};let n=plainDefineRE.exec(e);for(;null!=n;){t[n[1]]=n[2];const r=n.index,s=n.index+n[0].length;e=e.substring(0,r)+e.substring(s),plainDefineRE.lastIndex=r,n=plainDefineRE.exec(e)}const r=Object.keys(t).map(e=>new RegExp(`\\b${e}\\b`,"g")),s=Object.values(t);for(let t=0;t<s.length;t++){let n=s[t];for(let e=0;e<t;e++)n=n.replace(r[e],s[e]);e=e.replace(r[t],n)}return e},eliminateDeadCode=(()=>{const e=/[{}()]/g,t=/(?:\w+p\s+)?\w+\s+(\w+)\s*$/,n=/^\s*$/;let r="",s=0,i=0;const o=(e,n)=>{const o=e.substring(i,n).match(t)||["",""];r=o[1],s=n-o[0].length},a=(e,t)=>{const n=[];let r=t.exec(e);for(;r;)n.push(r),r=t.exec(e);return n},l=new Set,c=(e,t)=>{if(!l.has(t)){l.add(t);for(const n of e[t].deps)c(e,n)}};return(t,p,d)=>{let f=0,m=0,u=0;i=0,e.lastIndex=0,l.clear();const g=[];for(const l of a(t,e)){const e=l[0];if(0===f&&("("===e?(m=1,o(t,l.index)):")"===e?1===m?(m=2,u=l.index+1):m=0:"{"===e&&(m=2===m&&n.test(t.substring(u,l.index))?3:0)),"{"===e&&f++,"}"===e&&0==--f){if(3!==m)continue;i=l.index+1,m=0,g.push({name:r,beg:s,end:i,paramListEnd:u,deps:[]})}}let h=g.findIndex(e=>e.name===p);h<0&&(error(`EFX2403: entry function '${p}' not found.`),h=0);for(let e=0;e<g.length;e++){const n=g[e],r=a(t,new RegExp("\\b"+n.name+"\\b","g"));for(const t of r){const n=g.findIndex(e=>t.index>e.beg&&t.index<e.end);n>=0&&n!==e&&g[n].deps.push(e)}}c(g,h);let b="",y=0,x=0;for(let e=0;e<g.length;e++){const n=g[e],{name:r,beg:s,end:i}=n;l.has(e)||"main"===r?(n.beg-=x,n.end-=x,n.paramListEnd-=x,d.push(n)):(b+=t.substring(y,s),y=i,x+=i-s)}return b+t.substring(y)}})(),parseCustomLabels=(e,t={})=>{let n=e.join(" "),r=labelRE.exec(n);for(;r;){try{t[r[1]]=yaml.safeLoad(r[2]||"true")}catch(e){warn(`EFX2102: parameter for label '${r[1]}' is not legal YAML: ${e.message}`)}n=n.substring(r.index+r[0].length),r=labelRE.exec(n)}return t},extractDefines=(e,t,n)=>{let r=[],s=e=>{n[e]=r.reduce((e,t)=>e.concat(t),[]),n.lines.push(e)},i=0;for(let o=0;o<e.length;o++){let a,l,c=e[o],p=c.data;if("preprocessor"!==c.type||p.startsWith("#extension"))continue;if("#endif"===(p=p.split(whitespaces))[0]){for(;i>0;)r.pop(),i--;r.pop(),s(c.line);continue}if("#else"===p[0]||"#elif"===p[0]){const e=r[r.length-1];if(e.forEach((t,n)=>e[n]="!"===t[0]?t.slice(1):"!"+t),s(c.line),"#else"===p[0])continue;i++}else{if("#pragma"===p[0]){if(p.length<=1)continue;if("define"===p[1]){if(p.length<=2){warn("EFX2101: define pragma: missing info",c.line);continue}if(ident.lastIndex=0,!ident.test(p[2]))continue;let e=r.reduce((e,t)=>e.concat(t),[]),n=t.find(e=>e.name===p[2]);n||t.push(n={name:p[2],type:"boolean",defines:e,dummyDependency:!0});const s=parseCustomLabels(p.splice(3));for(const e in s)if("range"===e)n.type="number",n.range=[0,3],n.fixedType=!0,Array.isArray(s.range)?n.range=s.range:warn(`EFX2103: invalid range for macro '${n.name}'`,c.line);else if("options"===e)n.type="string",n.options=[],n.fixedType=!0,Array.isArray(s.options)?n.options=s.options:warn(`EFX2104: invalid options for macro '${n.name}'`,c.line);else{if("editor"!==e){warn(`EFX2105: define pragma: illegal label '${e}'`,c.line);continue}n.editor=s.editor}}else{const e=parseCustomLabels(p.splice(1));e.extension?n.extensions[e.extension[0]]={cond:e.extension[1],level:e.extension[2]}:n[c.line]=e}continue}if(!ifprocessor.test(p[0]))continue}let d=[],f=!1,m=!1;p.splice(1).some(e=>{if(ident.lastIndex=0,(a=ident.exec(e))&&"defined"===a[0]&&(a=ident.exec(e),m=!0),a){if(a[0].startsWith("__")||a[0].startsWith("GL_")||"VULKAN"===a[0])return f=!0;let n=r.reduce((e,t)=>e.concat(t),d.slice());if(l=t.find(e=>e.name===a[0])){let e=n.length<l.defines.length;l.dummyDependency&&(e=!0,delete l.dummyDependency),e&&(l.defines=n)}else t.push(l={name:a[0],type:"boolean",defines:n});d.push(("!"===e[0]?"!":"")+a[0])}else if(l&&comparators.test(e)&&!l.fixedType)l.type="number",l.range=[0,3];else if("||"===e)return d=[]}),r.push(d),s(c.line),f||"#ifdef"!==p[0]&&!m||error("EFX2106: for custom macros, #ifdef or #if defined() will always return true at runtime. please use #if instead.",c.line)}t.forEach(e=>(delete e.fixedType,delete e.dummyDependency))},extractParams=(()=>{const getDefs=(e,t)=>{let n=t.lines.findIndex(t=>t>e);return t[t.lines[n-1]]||[]},extractInfo=(tokens,i,cache)=>{const param={},definedPrecision=precision.exec(tokens[i].data);let offset=definedPrecision?2:0;if(param.name=tokens[i+offset+2].data,param.typename=tokens[i+offset].data,param.type=convertType(tokens[i+offset].data),param.count=1,definedPrecision&&(param.precision=definedPrecision[0]+" "),"["===tokens[offset=nextWord(tokens,i+offset+2)].data){let expr="",end=offset;for(;"]"!==tokens[++end].data;)expr+=tokens[end].data;try{if(arithmetics.test(expr))param.count=eval(expr);else{if(!builtinRE.test(param.name))throw expr;param.count=expr}param.isArray=!0}catch(e){error(`EFX2202: ${param.name}: illegal array length: ${e}`,tokens[offset].line)}}return param},stripDuplicates=e=>{const t={};return e.filter(e=>!t[e]&&(t[e]=!0))},exMap={whitespace:!0},nextWord=(e,t)=>{for(;exMap[e[++t].type];);return t},nextSemicolon=(e,t,n=(e=>{}))=>{for(;";"!==e[t].data;)n(e[t++]);return t},isFunctionParameter=(e,t)=>e.some(e=>t>e.beg&&t<e.paramListEnd);return(e,t,n,r,s,i,o,a)=>{const l=[];for(let c=0;c<e.length;c++){let p,d,f=e[c],m=f.data;if("uniform"===m)p=n,d="blocks";else if("in"!==m||isFunctionParameter(a,f.position)){if("out"!==m||isFunctionParameter(a,f.position)||!o)continue;p=i,d="varyings"}else p=o?s:i,d=o?"attributes":"varyings";let u=getDefs(f.line,t),g={};g.tags=t[f.line-1];let h=nextWord(e,c+2);if("{"!==e[h].data){Object.assign(g,extractInfo(e,c+2,t)),p===n&&(e[c+(g.precision?4:2)].data.indexOf("sampler")<0&&error("EFX2201: non-sampler uniforms must be declared in blocks.",f.line),p=r,d="samplers"),p.find(e=>e.name===g.name)&&(g.duplicate=!0),h=nextSemicolon(e,h)}else{for(g.name=e[c+2].data,g.members=[];"}"!==e[h=nextWord(e,h)].data;){const n=extractInfo(e,h,t);mappings.isSampler(n.type)&&error("EFX2208: sampler uniforms must be declared outside blocks.",e[h].line),g.members.push(n),h=nextSemicolon(e,h)}g.members.reduce((e,t)=>{let n=mappings.GetTypeSize(t.type);switch(t.typename){case"mat2":n/=2;case"mat3":n/=3;case"mat4":n/=4}if(t.count>1&&n<16){const e=`uniform ${convertType(t.type)} ${t.name}[${t.count}]`;error("EFX2203: "+e+": array UBO members need to be 16-bytes-aligned to avoid implicit padding"),n=16}else if(12===n){const e=`uniform ${convertType(t.type)} ${t.name}`;error("EFX2204: "+e+": please use 1, 2 or 4-component vectors to avoid implicit padding"),n=16}else if(mappings.isPaddedMatrix(t.type)){const e=`uniform ${convertType(t.type)} ${t.name}`;error("EFX2210: "+e+": use only 4x4 matrices to avoid implicit padding")}const r=Math.ceil(e/n)*n,s=r-e;return s&&error(`EFX2205: UBO '${g.name}' introduces implicit padding: `+`${s} bytes before '${t.name}', consider re-ordering the members`),r+n*t.count},0);let n=t.lines.find(t=>t>=e[c].line&&t<e[h].line);n&&error(`EFX2206: ${g.name}: no preprocessors allowed inside uniform blocks!`,n),g.members.forEach(t=>{"string"==typeof t.type&&error(`EFX2211: '${t.type} ${t.name}' in block '${g.name}': `+"struct-typed member within UBOs is not supported due to compatibility reasons.",e[h].line)});let r=p.find(e=>e.name===g.name);r&&(JSON.stringify(r.members)!==JSON.stringify(g.members)&&error(`EFX2207: different UBO using the same name '${g.name}'`,f.line),r.stageFlags|=mappings.getShaderStage(o?"vertex":"fragment"),g.duplicate=!0),h=nextWord(e,h),";"!==e[h].data&&error("EFX2209: Block declarations must be semicolon-terminated，non-array-typed and instance-name-free. "+`Please check your '${g.name}' block declaration.`,e[h].line)}l.push({beg:e[c].position,end:e[h].position,name:g.name,type:d}),g.duplicate||(g.defines=stripDuplicates(u),g.stageFlags=mappings.getShaderStage(o?"vertex":"fragment"),p.push(g)),c=h}return l}})(),miscChecks=(()=>{const e=new RegExp("\\b(?:asm|class|union|enum|typedef|template|this|packed|goto|switch|default|inline|noinline|volatile|public|static|extern|external|interface|flat|long|short|double|half|fixed|unsigned|superp|input|output|hvec2|hvec3|hvec4|dvec2|dvec3|dvec4|fvec2|fvec3|fvec4|sampler1D|sampler3D|sampler1DShadow|sampler2DShadow|sampler2DRect|sampler3DRect|sampler2DRectShadow|sizeof|cast|namespace|using|texture)\\b");return t=>{const n=precisionRE.exec(t);n?/#extension/.test(t.slice(n.index))&&warn("EFX2400: precision declaration should come after extensions"):warn("EFX2401: precision declaration not found.");const r=e.exec(t);if(r&&error(`EFX2402: using reserved keyword in glsl1: ${r[0]}`),options.skipParserTest)return;const s=tokenizer(t).filter(e=>"preprocessor"!==e.type);shaderTokens=s;try{parser(s)}catch(e){error(`EFX2404: glsl1 parser failed: ${e}`,0)}}})(),finalTypeCheck=(()=>{let e=null,t=!0;const n=(t,n)=>{let r=e.createShader(n);if(e.shaderSource(r,t),e.compileShader(r),!e.getShaderParameter(r,e.COMPILE_STATUS)){let n=1;const s=t.replace(/^|\n/g,()=>`\n${n++} `),i=e.getShaderInfoLog(r);e.deleteShader(r),r=null,error(`EFX2406: compilation failed: ↓↓↓↓↓ EXPAND THIS MESSAGE FOR MORE INFO ↓↓↓↓↓\n${i}\n${s}`)}return r};return(r,s,i)=>{if(!(()=>(e||"undefined"==typeof document||((e=document.createElement("canvas").getContext("webgl",{depth:!0,stencil:!0})).getSupportedExtensions().forEach(t=>e.getExtension(t)),t=t&&e.getParameter(e.MAX_VERTEX_TEXTURE_IMAGE_UNITS)>=8),t&&e))())return;const o="#version 100\n"+(e=>e.reduce((e,t)=>{let n=1;switch(t.type){case"string":n=t.options[0];break;case"number":n=t.range[0]}return`${e}#define ${t.name} ${n}\n`},""))(i),a=n(o+r,e.VERTEX_SHADER),l=n(o+s,e.FRAGMENT_SHADER),c=((...t)=>{let n=e.createProgram();if(t.forEach(t=>e.attachShader(n,t)),e.linkProgram(n),!e.getProgramParameter(n,e.LINK_STATUS)){const t=e.getProgramInfoLog(n);e.deleteProgram(n),n=null,error(`EFX2407: link failed: ${t}`)}return n})(a,l);e.deleteProgram(c),e.deleteShader(l),e.deleteShader(a)}})(),stripToSpecificVersion=(()=>{const globalSearch=/#(if|elif|else|endif)(.*)?/g,legalExpr=/^[\d<=>!|&^\s]*(__VERSION__)?[\d<=>!|&^\s]*$/,declareExtension=(e,t)=>"require"===t?`#extension ${e}: require`:`\n#ifdef ${e}\n#extension ${e}: enable\n#endif\n`;return(code,version,extensions,isVert)=>{version<310&&(code=code.replace(layoutCapture,(e,t,n,r)=>isVert||"out"!==r?t.indexOf("std140")>=0?"layout(std140)"+n+r:r:e));const instances=[];let cap=null,temp=null;for(;cap=globalSearch.exec(code),cap;)if("if"===cap[1]){if(temp){temp.level++;continue}if(!legalExpr.test(cap[2]))continue;temp={start:cap.index,end:cap.index,conds:[cap[2]],content:[cap.index+cap[0].length],level:1}}else if("elif"===cap[1]){if(!temp||temp.level>1)continue;legalExpr.test(cap[2])||(error(`EFX2301: #elif conditions after a constant #if should be constant too; get '${cap[2]}'`),cap[2]=""),temp.conds.push(cap[2]),temp.content.push(cap.index,cap.index+cap[0].length)}else if("else"===cap[1]){if(!temp||temp.level>1)continue;temp.conds.push("true"),temp.content.push(cap.index,cap.index+cap[0].length)}else if("endif"===cap[1]){if(!temp||--temp.level)continue;temp.content.push(cap.index),temp.end=cap.index+cap[0].length,instances.push(temp),temp=null}let res=code;if(instances.length){res=res.substring(0,instances[0].start);for(let j=0;j<instances.length;j++){const ins=instances[j];for(let i=0;i<ins.conds.length;i++)if(eval(ins.conds[i].replace("__VERSION__",version))){const e=code.substring(ins.content[2*i],ins.content[2*i+1]);res+=stripToSpecificVersion(e,version,isVert);break}const next=instances[j+1]&&instances[j+1].start||code.length;res+=code.substring(ins.end,next)}}for(const ext in extensions){const{cond:cond,level:level}=extensions[ext];eval(cond.replace("__VERSION__",version))&&(res=declareExtension(ext,level)+res)}return res}})(),glsl300to100=(e,t,n,r,s,i,o)=>{let a="",l=0;if(r.forEach(n=>{"blocks"===n.type&&(a+=e.slice(l,n.beg),t.find(e=>e.name===n.name).members.forEach(t=>{const n=e.match(new RegExp(`\\b${t.name}\\b`,"g"));if(!n||n.length<=1)return;const r=convertType(t.type),s=t.precision||"";a+=`uniform ${s}${r} ${t.name}${"string"==typeof t.count||t.isArray?`[${t.count}]`:""};\n`}),l=n.end+(";"===e[n.end]))}),a=(a+=e.slice(l)).replace(texLookup,(e,t,r,i,o)=>{const l="texture"+t;if(s.find(e=>e.name===l))return e;let c=new RegExp("sampler(\\w+)\\s+"+r);const p=s.find(e=>o>e.beg&&o<e.end);let d=p&&c.exec(a.substring(p.beg,p.eng))||c.exec(a);if(!d){const t=n.find(e=>e.name===r);if(t&&t.options)for(const e of t.options)if(d=(c=new RegExp("sampler(\\w+)\\s+"+e)).exec(a))break;if(!d)return error(`EFX2300: sampler '${r}' does not exist`),e}return`texture${d[1]}${t}(${r}${i}`}),o)a=(a=a.replace(inDecl,(e,t,n)=>`attribute ${n};`)).replace(outDecl,(e,t,n)=>`varying ${n};`);else{const e=[];if(a=(a=a.replace(inDecl,(e,t,n)=>`varying ${n};`)).replace(outDecl,(t,n,r,s)=>{const i=n&&locationRE.exec(n);return i||error("EFX2302: fragment output location must be specified"),e.push({name:s,location:i[1]}),""}),1===e.length){const t=new RegExp(e[0].name,"g");a=a.replace(t,"gl_FragColor")}else if(e.length>1){for(const t of e){const e=new RegExp(t.name,"g");a=a.replace(e,`gl_FragData[${t.location}]`)}i.GL_EXT_draw_buffers={cond:"__VERSION__ <= 100",level:"require"}}}return(a=a.replace(layoutRE,()=>"")).replace(pragmasToStrip,"")},decorateBlockMemoryLayouts=(e,t)=>{let n=0;const r=[];t.forEach((t,s)=>{if("blocks"!==t.type)return;const i=e.slice(n,t.beg),o=layoutExtract.exec(i);r[s]=o?n+o.index+o[0].length-o[2].length-1:-1,n=t.end});let s="";return n=0,t.forEach((t,i)=>{const o=r[i];void 0!==o&&(o<0?(s+=e.slice(n,t.beg),s+="layout(std140) "):(s+=e.slice(n,o),s+=", std140",s+=e.slice(o,t.beg)),s+=e.slice(t.beg,t.end),n=t.end)}),s+=e.slice(n)},decorateBindings=(e,t,n)=>{let r=0;const s=[],i={};(n=n.filter(e=>!builtinRE.test(e.name))).forEach(n=>{const o=e.slice(r,n.beg),a={prop:t[n.type].find(e=>e.name===n.name)},l=layoutExtract.exec(o),c=i[n.type]||(i[n.type]={});if(l){a.position=r+l.index+l[0].length-l[2].length-1;const e=bindingExtract.exec(l[1]);if(e){a.position=-1;const r=parseInt(e[1]);t[n.type][r]?(c[r]&&c[r]!==n.name&&error(`EFX2603: duplicated binding/location declaration for '${c[r]}' and '${n.name}'`),c[c[r]=n.name]=r):"blocks"===n.type?error(`EFX2600: illegal custom binding for '${n.name}', block bindings should be consecutive and start from 0`):"samplers"===n.type?error(`EFX2601: illegal custom binding for '${n.name}', sampler bindings should be consecutive and after all the blocks`):error(`EFX2602: illegal custom location for '${n.name}', locations should be consecutive and start from 0`)}}s.push(a),r=n.end}),n.forEach((e,n)=>{const r="blocks"===e.type||"samplers"===e.type?"binding":"location",o=i[e.type];if("attributes"===e.type)if(e.name in o)s[n].prop[r]=o[e.name];else{let t=0;for(;o[t];)t++;s[n].prop[r]=t,o[t]=e.name}else if(e.name in o){const i=s[n].prop[r];s[n].prop[r]=o[e.name],t[e.type][i][r]=i}});let o="";r=0;const a=mappings.SetIndex.MATERIAL;return n.forEach((t,n)=>{const i="blocks"===t.type||"samplers"===t.type,l=i?"binding":"location",{position:c,prop:p}=s[n],d=i?`set = ${a}, `:"";void 0===c?(o+=e.slice(r,t.beg),o+=`layout(${d+l} = ${p[l]}) `):c>=0?(o+=e.slice(r,c),o+=`${d+l} = ${p[l]}`,o+=e.slice(c,t.beg)):o+=e.slice(r,t.beg),o+=e.slice(t.beg,t.end),r=t.end}),o+=e.slice(r)},buildShader=(()=>{const e=/\s+$/gm,t=/(^\s*\n){2,}/gm,n=n=>{let r=n.replace(pragmasToStrip,"");return r=(r=r.replace(t,"\n")).replace(e,"")},r=(e,t)=>n=>{if(!builtinRE.test(n.name))return!0;const r=n.tags;let s;s=r&&r.builtin?r.builtin:"global",t[`${s}s`][e].push({name:n.name,defines:n.defines})},s=(e,t,n)=>"main"===t?e:e+((e,t)=>e?`\nvoid main() { gl_Position = ${t}(); }\n`:`\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = ${t}(); }\n`)(n,t),i=/([^:]+)(?::(\w+))?/,o=(e,t,n,r,o,a,l,c)=>{const p={};shaderName=e;const d={lines:[],extensions:{}};let{code:f,record:m,functions:u}=((e,t,n,r="main")=>{const o=i.exec(e),a=o[2]||r,l=new Set,c=[];let p=unwindIncludes(`#include <${o[1]}>`,t,l);return p=s(p,a,n),p=expandLiteralMacro(p),p=expandFunctionalMacro(p),{code:p=eliminateDeadCode(p,a,c),record:l,functions:c}})(e,t,n);const g=shaderTokens=tokenizer(f,tokenizerOpt);extractDefines(g,r,d);const h=extractParams(g,d,o,a,l,c,n,u);return p.blockInfo=h,p.record=m,p.extensions=d.extensions,p.glsl4=f,p.glsl3=stripToSpecificVersion(decorateBlockMemoryLayouts(f,h),300,d.extensions,n),p.glsl1=stripToSpecificVersion(glsl300to100(f,o,r,h,u,d.extensions,n),100,d.extensions,n),miscChecks(p.glsl1),p};return(e,t,s)=>{let i=[],a=[],l=[],c=[],p=[];const d={};d.vert=o(e,s,!0,i,a,l,c,p),d.frag=o(t,s,!1,i,a,l,c,p),finalTypeCheck(d.vert.glsl1,d.frag.glsl1,i);const f={globals:{blocks:[],samplers:[]},locals:{blocks:[],samplers:[]}};a=a.filter(r("blocks",f)),l=l.filter(r("samplers",f)),c.forEach(e=>{if(e.format=mappings.formatMap[e.typename],e.defines.indexOf("USE_INSTANCING")>=0&&(e.isInstanced=!0),e.tags&&e.tags.format){const t=mappings.getFormat(e.tags.format);void 0!==t&&(e.format=t),mappings.isNormalized(t)&&(e.isNormalized=!0)}}),a.forEach(e=>(delete e.tags,e.members.forEach(e=>(delete e.typename,delete e.precision,delete e.isArray)))),l.forEach(e=>(delete e.tags,delete e.typename,delete e.precision,delete e.isArray)),c.forEach(e=>(delete e.tags,delete e.typename,delete e.precision,delete e.isArray)),p.forEach(e=>(delete e.tags,delete e.typename,delete e.precision,delete e.isArray));let m=0;a.forEach(e=>e.binding=m++),l.forEach(e=>e.binding=m++);let u=0;c.forEach(e=>e.location=u++),u=0,p.forEach(e=>e.location=u++);const g={blocks:a,samplers:l,attributes:c,varyings:p};d.vert.glsl4=stripToSpecificVersion(decorateBindings(d.vert.glsl4,g,d.vert.blockInfo),460,d.vert.extensions,!0),d.frag.glsl4=stripToSpecificVersion(decorateBindings(d.frag.glsl4,g,d.frag.blockInfo),460,d.frag.extensions,!1);const h={vert:n(d.vert.glsl4),frag:n(d.frag.glsl4)},b={vert:n(d.vert.glsl3),frag:n(d.frag.glsl3)},y={vert:n(d.vert.glsl1),frag:n(d.frag.glsl1)},x=mappings.murmurhash2_32_gc(y.vert+y.frag,666);return d.frag.record.forEach(d.vert.record.add,d.vert.record),{hash:x,glsl4:h,glsl3:b,glsl1:y,builtins:f,defines:i,blocks:a,samplers:l,attributes:c,varyings:p,record:d.vert.record}}})(),parseEffect=(()=>{const e=/CCEffect\s*%{([^]+?)(?:}%|%})/,t=/CCProgram\s*([\w-]+)\s*%{([^]+?)(?:}%|%})/,n=/#.*$/gm,r=/^\s*$/,s=/\n[^\s]/,i=/^[^\S\n]/gm,o=/\t/g,a=(e,t,n="effect")=>{if(Array.isArray(e)){if(!Array.isArray(t))return void error(`EFX1002: ${n} must be an array`);if(e[0])for(let r=0;r<t.length;r++)a(e[0],t[r],n+`[${r}]`)}else{if(!t||"object"!=typeof t||Array.isArray(t))return void error(`EFX1003: ${n} must be an object`);for(const e of Object.keys(t))-1!==e.indexOf(":")&&error(`EFX1004: syntax error at '${e}', you might need to insert a space after colon`);if(e.any)for(const r of Object.keys(t))a(e.any,t[r],n+`.${r}`);else for(const r of Object.keys(e)){let s=r;if("$"===s[0])s=s.substring(1);else if(!t[s])continue;a(e[r],t[s],n+`.${s}`)}}};return(l,c)=>{shaderName="syntax",c=stripComments(c).replace(o," ".repeat(tabAsSpaces));let p={},d={},f=e.exec((e=>e.replace(n,""))(c));if(f){try{const e=yaml.safeLoad(f[1]);p=JSON.parse(JSON.stringify(e))}catch(e){error(`EFX1001: CCEffect parser failed: ${e}`)}p.name||(p.name=l),a(mappings.effectStructure,p)}else error("EFX1000: CCEffect is not defined");let m=t.exec(c);for(;m;){let e=m[2];if(!r.test(e))for(;!s.test(e);)e=e.replace(i,"");d[m[1]]=e,c=c.substring(m.index+m[0].length),m=t.exec(c)}return{effect:p,templates:d}}})(),mapPassParam=(()=>{const e=(e,t)=>{let n=0,r=t=>t.name===e&&(n=t.type,!0);return t.blocks.some(e=>e.members.some(r))||t.samplers.some(r),n},t=(e,t,n)=>{if(t<=0)return"no matching uniform";if(void 0!==e)if("string"===n){if(!mappings.isSampler(t))return"string for non-samplers"}else{if(!Array.isArray(e))return"non-array for buffer members";if(e.length!==mappings.GetTypeSize(t)/4)return"wrong array length"}},n=/^(\w+)(?:\.([xyzw]+|[rgba]+))?$/,r={x:0,y:1,z:2,w:3,r:0,g:1,b:2,a:3},s=(t,s)=>{const i=[t,0,0],o=n.exec(t);if(!o)return error(`EFX3303: illegal property target '${t}'`),i;const a=o[2]&&o[2].toLowerCase()||"",l=r[a[0]]||0;return a.split("").map((e,t)=>r[e]-l-t).some(e=>e)&&error(`EFX3304: '${t}': random component swizzle is not supported`),i[0]=o[1],i[1]=l,i[2]=e(o[1],s),a.length&&(i[2]-=Math.max(0,mappings.GetTypeSize(i[2])/4-a.length)),i[2]<=0&&error(`EFX3305: no matching uniform target '${t}'`),i},i=(e,t)=>{for(const n of Object.keys(t)){const r=t[n];"object"==typeof r&&"object"==typeof e[n]?i(e[n],r):void 0===e[n]&&(e[n]=r)}},o=e=>{for(let t in e){let n=e[t];if("string"==typeof n){let r=parseInt(n);isNaN(r)&&(r=mappings.passParams[n.toUpperCase()]),void 0!==r&&(e[t]=r)}else if(Array.isArray(n)){if(!n.length)continue;switch(typeof n[0]){case"object":n.forEach(o);break;case"string":o(n);break;case"number":e[t]=(255*n[0]<<24|255*n[1]<<16|255*n[2]<<8|255*(n[3]||255))>>>0}}else"object"==typeof n&&o(n)}return e},a=e=>{const t=[];for(const n of Object.keys(e)){const r=e[n],s=mappings.SamplerInfoIndex[n];void 0!==r&&void 0!==s||warn(`EFX3301: illegal sampler info '${n}'`),"borderColor"===n?(t[s]=r.r,t[s+1]=r.g,t[s+2]=r.b,t[s+3]=r.a):t[s]=r}return mappings.genSamplerHash(t)},l=/^(\w+)\s*([+-])\s*([\dxabcdef]+)$/i,c=mappings.RenderPriority.DEFAULT,p=mappings.RenderPriority.MIN,d=mappings.RenderPriority.MAX;return(n,r)=>{shaderName="type error";const f={};n.priority&&(f.priority=(e=>{let t=-1;const n=l.exec(e);return t=n?mappings.RenderPriority[n[1].toUpperCase()]+parseInt(n[3])*("+"===n[2]?1:-1):parseInt(e),isNaN(t)||t<p||t>d?(warn(`EFX3000: illegal pass priority: ${e}`),c):t})(n.priority),delete n.priority),n.depthStencilState&&(f.depthStencilState=(e=>{for(const t of Object.keys(e))t.startsWith("stencil")&&(t.endsWith("Front")||t.endsWith("Back")||(e[t+"Front"]=e[t+"Back"]=e[t],delete e[t]));return e.stencilWriteMaskFront!==e.stencilWriteMaskBack&&warn("EFX3100: WebGL(2) doesn't support inconsistent front/back stencil write mask"),e.stencilReadMaskFront!==e.stencilReadMaskBack&&warn("EFX3101: WebGL(2) doesn't support inconsistent front/back stencil read mask"),e.stencilRefFront!==e.stencilRefBack&&warn("EFX3102: WebGL(2) doesn't support inconsistent front/back stencil ref"),o(e)})(n.depthStencilState),delete n.depthStencilState),n.switch&&(f.switch=((e,t)=>(t.defines.find(t=>t.name===e)&&error("EFX3200: existing shader macros cannot be used as pass switch"),e))(n.switch,r),delete n.switch),n.properties&&(f.properties=((n,r)=>{let l={};for(const i of Object.keys(n)){if("__metadata__"===i){l=n[i],delete n[i];continue}const c=n[i],p=e(i,r);if(void 0!==c.type&&warn(`EFX3300: property '${i}': you don't have to specify type in here`),c.type=p,c.target){c.handleInfo=s(c.target,r),delete c.target,c.type=c.handleInfo[2];const t=c.editor&&c.editor.visible,i=c.handleInfo[0],o=e(c.handleInfo[0],r);n[i]||(n[i]={type:o,editor:{visible:!1}}),(void 0===t||t)&&(n[i].editor?void 0===n[i].editor.deprecated&&(n[i].editor.deprecated=!0):n[i].editor={deprecated:!0}),mappings.isSampler(o)?c.value&&(n[i].value=c.value):(n[i].value||(n[i].value=Array(mappings.GetTypeSize(o)/4).fill(0)),Array.isArray(c.value)?n[i].value.splice(c.handleInfo[1],c.value.length,...c.value):void 0!==c.value&&n[i].value.splice(c.handleInfo[1],1,c.value))}c.sampler&&(c.samplerHash=a(o(c.sampler)),delete c.sampler);const d=typeof c.value;"number"!==d&&"boolean"!==d||(c.value=[c.value]);const f=t(c.value,c.type,d);f&&error(`EFX3302: illegal property declaration for '${i}': ${f}`)}for(const e of Object.keys(n))i(n[e],l);return n})(n.properties,r),delete n.properties),n.migrations&&(f.migrations=n.migrations,delete n.migrations),o(n),Object.assign(n,f)}})(),reduceHeaderRecord=e=>{const t=new Set;for(const n of e)n.record.forEach(t.add,t);return[...t.values()]},buildEffect=(e,t)=>{effectName=e;let{effect:n,templates:r}=parseEffect(e,t);if(!n||!Array.isArray(n.techniques))return null;r=Object.assign({},chunksCache,r);const s=n.shaders=[];for(const e of n.techniques)for(const t of e.passes){let e=t.vert,n=t.frag;delete t.vert,delete t.frag;let i=t.program=`${effectName}|${e}|${n}`,o=s.find(e=>e.name===i);o||((o=buildShader(e,n,r)).name=i,s.push(o)),mapPassParam(t,o)}return n.dependencies=reduceHeaderRecord(s),n};module.exports={options:options,addChunk:addChunk,buildEffect:buildEffect};