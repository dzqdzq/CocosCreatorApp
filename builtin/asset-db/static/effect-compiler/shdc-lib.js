"use strict";const tokenizer=require("glsl-tokenizer/string"),parser=require("glsl-parser/direct"),mappings=require("./offline-mappings"),yaml=require("js-yaml"),tabAsSpaces=2,plainDefineRE=/#define\s+(\w+)\s+(.*)\n/g,ident=/[_a-zA-Z]\w*/g,labelRE=/(\w+)\((.*?)\)/,locationRE=/location\s*=\s*(\d+)/,inDecl=/(?:layout\s*\((.*?)\)\s*)?in ((?:\w+\s+)?\w+\s+(\w+)\s*(?:\[[\d\s]+])?)\s*;/g,outDecl=/(?:layout\s*\((.*?)\)\s*)?out ((?:\w+\s+)?\w+\s+(\w+)\s*(?:\[[\d\s]+])?)\s*;/g,layoutExtract=/layout\s*\((.*?)\)(\s*)$/,bindingExtract=/(?:location|binding)\s*=\s*(\d+)/,builtinRE=/^cc\w+$/i,pragmasToStrip=/^\s*(?:#pragma\s*)(?!STDGL|optimize|debug).*$\n/gm;let effectName="",shaderName="",shaderTokens=[];const formatMsg=(e,t)=>`${effectName}.effect - ${shaderName}`+(void 0!==t?` - ${t}: `:": ")+e,options={throwOnError:!0,throwOnWarning:!1,noSource:!1,skipParserTest:!1,chunkSearchFn:e=>({}),getAlternativeChunkPaths:e=>[]},dumpSource=e=>{let t=0;return e.reduce((e,n)=>n.line>t?e+`\n${t=n.line}\t${n.data.replace(/\n/g,"")}`:e+n.data,"")},throwFnFactory=(e,t)=>(n,r)=>{options.noSource&&(r=void 0);let s=void 0!==r?" ↓↓↓↓↓ EXPAND THIS MESSAGE FOR MORE INFO ↓↓↓↓↓"+dumpSource(shaderTokens)+"\n":"";const i=formatMsg(e+" "+n,r)+s;if(options.throwOnWarning)throw i;t(i)},warn=throwFnFactory("Warning",console.warn),error=throwFnFactory("Error",console.error),convertType=e=>{let t=mappings.typeMap[e];return void 0===t?e:t},VSBit=mappings.getShaderStage("vertex"),FSBit=mappings.getShaderStage("fragment"),stripComments=(()=>{const e=/\r\n/g,t=/\/\*.*?\*\//gs,n=/\s*\/\/.*$/gm;return r=>{let s=r.replace(t,"");return s=(s=s.replace(n,"")).replace(e,"\n")}})(),globalChunks={},globalDeprecations={chunks:{},identifiers:{}},addChunk=(()=>{const e=/#pragma\s+deprecate-(chunk|identifier)\s+([\w-]+)(?:\s+(.*))?/g;return(t,n,r=globalChunks,s=globalDeprecations)=>{const i=stripComments(n);let a=e.exec(i),o="",l=0;for(;a;){const t=`${a[1]}s`;s[t]||(s[t]={}),s[t][a[2]]=a[3],o+=i.slice(l,a.index),l=a.index+a[0].length,a=e.exec(i)}r[t]=o+i.slice(l)}})(),invokeSearch=e=>{const{name:t,content:n}=options.chunkSearchFn(e);if(void 0!==n)return addChunk(t,n),t},unwindIncludes=(()=>{const e=/^(.*)#include\s+[<"]([^>"]+)[>"](.*)$/gm;let t;return(n,r,s,i=new Set)=>{if(t=((n,r,s)=>(i,a,o,l)=>{(o=o.trim()).endsWith(".chunk")&&(o=o.slice(0,-6));const c=o;if(s.has(o))return"";void 0!==r[o]&&error(`EFX2003: header '${o}' is deprecated: ${r[o]}`);let p=void 0;do{if(void 0!==(p=n[o]))break;const e=options.getAlternativeChunkPaths(o);if(e.some(e=>{if(void 0!==n[e])return o=e,p=n[e],!0}))break;if(o=invokeSearch([].concat(o,e)),void 0!==(p=globalChunks[o]))break;return error(`EFX2001: can not resolve '${c}'`),""}while(0);return s.add(o),a&&(p=p.replace(/^/gm,a)),l&&(p=p.replace(/\n/g,l+"\n")+l),p=p.replace(e,t)})(r,s.chunks,i),n=n.replace(e,t),s.identifierRE){let e=s.identifierRE.exec(n);for(;e;){const t=s.identifiers[e[1]];t&&error(`EFX2004: identifier '${e[1]}' is deprecated: ${t}`),e=s.identifierRE.exec(n)}}return n}})(),expandFunctionalMacro=(()=>{const e=(e,t)=>{if("("!==e[t])return t;let n=1,r=t+1;for(;r<e.length&&("("===e[r]&&n++,")"===e[r]&&n--,0!==n);r++);return r},t=t=>{const n=[];let r=0;for(let s=0;s<t.length;s++)"("===t[s]&&(s=e(t,s)+1),","===t[s]&&(n.push(t.substring(r,s).trim()),r=s+1);return r===t.length&&","!==t[t.length-1]||n.push(t.substring(r).trim()),n},n=/#define\s+(\w+)\(([\w,\s]*)\)\s+(.*?)\n/g,r=/(?<=\w)##(?=\w)/g,s=/\\\n/g,i=/@@/g;return a=>{a=a.replace(s,"@@");let o=n.exec(a);for(;null!=o;){const s=o[1],l=t(o[2]),c=o[3],p=o.index,d=o.index+o[0].length,f=new RegExp("^(.*?)"+s+"\\s*\\(","gm");if(new RegExp("\\b"+s+"\\b").test(c))warn(`EFX2002: recursive macro processor '${s}'`);else for(let n=f.exec(a);null!=n;n=f.exec(a)){const o=n.index+n[0].length-1;if(o>p&&o<d)continue;const u=n[1],g=n.index+u.length,m=e(a,o)+1,h=t(a.slice(n.index+n[0].length,m-1));h.length!==l.length&&warn(`EFX2005: not enough arguments for function-like macro invocation '${s}'`);let b=[];for(let e=0;e<l.length;e++){const t=new RegExp("\\b"+l[e]+"\\b","g");let n;for(;null!==(n=t.exec(c));)b.push({beg:n.index,end:t.lastIndex,target:h[e]})}let y="",x=0;for(const e of b.sort((e,t)=>e.beg-t.beg))y+=c.slice(x,e.beg)+e.target,x=e.end;if(y+=c.slice(x,c.length),-1===u.indexOf("#define")){let e=u.search(/\S/);e<0&&(e=u.length),y=(y=y.replace(r,"")).replace(i,"\n"+" ".repeat(e))}else{let e=u.lastIndexOf("@@"),t=e<0?u:u.slice(e+2),n=t.search(/\S/);n<0&&(n=t.length),y=y.replace(i,"@@"+" ".repeat(n))}a=a.substring(0,g)+y+a.substring(m),f.lastIndex-=n[0].length}a=a.substring(0,p)+a.substring(d),n.lastIndex=0,o=n.exec(a)}return a.replace(i,"\\\n"),a}})(),expandLiteralMacro=e=>{const t={};let n=plainDefineRE.exec(e);for(;null!=n;){let r=n[2];r.endsWith("\\")&&(r=r.slice(0,-1)),t[n[1]]=r.trim();const s=n.index,i=n.index+n[0].length;e=e.substring(0,s)+e.substring(i),plainDefineRE.lastIndex=s,n=plainDefineRE.exec(e)}const r=Object.keys(t).map(e=>new RegExp(`\\b${e}\\b`,"g")),s=Object.values(t);for(let t=0;t<s.length;t++){let n=s[t];for(let e=0;e<t;e++)n=n.replace(r[e],s[e]);e=e.replace(r[t],n)}return e},eliminateDeadCode=(()=>{const e=/[{}()]/g,t=/(?:\w+p\s+)?\w+\s+(\w+)\s*$/,n=/^\s*$/;let r="",s=0,i=0;const a=(e,n)=>{const a=e.substring(i,n).match(t)||["",""];r=a[1],s=n-a[0].length},o=(e,t)=>{const n=[];let r=t.exec(e);for(;r;)n.push(r),r=t.exec(e);return n},l=new Set,c=(e,t)=>{if(!l.has(t)){l.add(t);for(const n of e[t].deps)c(e,n)}};return(t,p,d)=>{let f=0,u=0,g=0;i=0,e.lastIndex=0,l.clear();const m=[];for(const l of o(t,e)){const e=l[0];if(0===f&&("("===e?(u=1,a(t,l.index)):")"===e?1===u?(u=2,g=l.index+1):u=0:"{"===e&&(u=2===u&&n.test(t.substring(g,l.index))?3:0)),"{"===e&&f++,"}"===e&&0==--f){if(3!==u)continue;i=l.index+1,u=0,m.push({name:r,beg:s,end:i,paramListEnd:g,deps:[]})}}let h=m.findIndex(e=>e.name===p);h<0&&(error(`EFX2403: entry function '${p}' not found.`),h=0);for(let e=0;e<m.length;e++){const n=m[e],r=o(t,new RegExp("\\b"+n.name+"\\b","g"));for(const t of r){const n=m.findIndex(e=>t.index>e.beg&&t.index<e.end);n>=0&&n!==e&&m[n].deps.push(e)}}c(m,h);let b="",y=0,x=0;for(let e=0;e<m.length;e++){const n=m[e],{name:r,beg:s,end:i}=n;l.has(e)||"main"===r?(n.beg-=x,n.end-=x,n.paramListEnd-=x,d.push(n)):(b+=t.substring(y,s),y=i,x+=i-s)}return b+t.substring(y)}})(),parseCustomLabels=(e,t={})=>{let n=e.join(" "),r=labelRE.exec(n);for(;r;){try{t[r[1]]=yaml.safeLoad(r[2]||"true")}catch(e){warn(`EFX2102: parameter for label '${r[1]}' is not legal YAML: ${e.message}`)}n=n.substring(r.index+r[0].length),r=labelRE.exec(n)}return t},getDefs=(e,t)=>{let n=t.lines.findIndex(t=>t>e);return n<0&&(n=t.lines.length),t[t.lines[n-1]]||[]},extractDefines=(e,t,n)=>{let r=[],s=e=>{n[e]=r.reduce((e,t)=>e.concat(t),[]),n.lines.push(e)},i=0;for(let a=0;a<e.length;a++){let o,l,c=e[a],p=c.data;if("preprocessor"!==c.type||p.startsWith("#extension"))continue;if("#endif"===(p=p.split(/\s+/))[0]){for(;i>0;)r.pop(),i--;r.pop(),s(c.line);continue}if("#else"===p[0]||"#elif"===p[0]){const e=r[r.length-1];if(e.forEach((t,n)=>e[n]="!"===t[0]?t.slice(1):"!"+t),s(c.line),"#else"===p[0])continue;i++}else{if("#pragma"===p[0]){if(p.length<=1)continue;if("define"===p[1]){if(p.length<=2){warn("EFX2101: define pragma: missing info",c.line);continue}if(ident.lastIndex=0,!ident.test(p[2]))continue;let e=r.reduce((e,t)=>e.concat(t),[]),n=t.find(e=>e.name===p[2]);n||t.push(n={name:p[2],type:"boolean",defines:e,dummyDependency:!0});const s=parseCustomLabels(p.splice(3));for(const e in s)if("range"===e)n.type="number",n.range=[0,3],n.fixedType=!0,Array.isArray(s.range)?n.range=s.range:warn(`EFX2103: invalid range for macro '${n.name}'`,c.line);else if("options"===e)n.type="string",n.options=[],n.fixedType=!0,Array.isArray(s.options)?n.options=s.options:warn(`EFX2104: invalid options for macro '${n.name}'`,c.line);else if("default"===e)n.type="constant",n.default=s.default,n.fixedType=!0;else{if("editor"!==e){warn(`EFX2105: define pragma: illegal label '${e}'`,c.line);continue}n.editor=s.editor}}else if("warning"===p[1])warn(`EFX2107: ${p.slice(2).join(" ")}`);else if("error"===p[1])error(`EFX2108: ${p.slice(2).join(" ")}`);else{const e=parseCustomLabels(p.slice(1));e.extension?n.extensions[e.extension[0]]={defines:getDefs(c.line,n),cond:e.extension[1],level:e.extension[2]}:n[c.line]=e}continue}if(!/#(el)?if/.test(p[0]))continue}let d=[],f=!1,u=!1;p.splice(1).some(e=>{if(ident.lastIndex=0,(o=ident.exec(e))&&"defined"===o[0]&&(o=ident.exec(e),u=!0),o){if(o[0].startsWith("__")||o[0].startsWith("GL_")||"VULKAN"===o[0])return f=!0;let n=r.reduce((e,t)=>e.concat(t),d.slice());if(l=t.find(e=>e.name===o[0])){let e=n.length<l.defines.length;l.dummyDependency&&(e=!0,delete l.dummyDependency),e&&(l.defines=n)}else t.push(l={name:o[0],type:"boolean",defines:n});d.push(("!"===e[0]?"!":"")+o[0])}else if(l&&/^[<=>]+$/.test(e)&&!l.fixedType)l.type="number",l.range=[0,3];else if("||"===e)return d=[]}),r.push(d),s(c.line),f||"#ifdef"!==p[0]&&!u||error("EFX2106: for custom macros, #ifdef or #if defined() will always return true at runtime. please use #if instead.",c.line)}t.forEach(e=>(delete e.fixedType,delete e.dummyDependency))},extractParams=(()=>{const precision=/(low|medium|high)p/,extractInfo=(tokens,i)=>{const param={},definedPrecision=precision.exec(tokens[i].data);let offset=definedPrecision?2:0;if(param.name=tokens[i+offset+2].data,param.typename=tokens[i+offset].data,param.type=convertType(tokens[i+offset].data),param.count=1,definedPrecision&&(param.precision=definedPrecision[0]+" "),"["===tokens[offset=nextWord(tokens,i+offset+2)].data){let expr="",end=offset;for(;"]"!==tokens[++end].data;)expr+=tokens[end].data;try{if(/^[\d\+\-*/%\s]+$/.test(expr))param.count=eval(expr);else{if(!builtinRE.test(param.name))throw expr;param.count=expr}param.isArray=!0}catch(e){error(`EFX2202: ${param.name}: non-builtin array length must be compile-time constant: ${e}`,tokens[offset].line)}}return param},stripDuplicates=e=>{const t={};return e.filter(e=>!t[e]&&(t[e]=!0))},exMap={whitespace:!0},nextWord=(e,t)=>{for(;exMap[e[++t].type];);return t},nextSemicolon=(e,t,n=(e=>{}))=>{for(;";"!==e[t].data;)n(e[t++]);return t},isFunctionParameter=(e,t)=>e.some(e=>t>e.beg&&t<e.paramListEnd);return(e,t,n,r,s,i,a,o,l)=>{const c=[];for(let p=0;p<e.length;p++){let d,f,u=e[p],g=u.data;if("uniform"===g)d=n,f="blocks";else if("in"!==g||isFunctionParameter(l,u.position)){if("out"!==g||isFunctionParameter(l,u.position))continue;d=o?i:a,f=o?"varyings":"fragColors"}else d=o?s:i,f=o?"attributes":"varyings";let m=getDefs(u.line,t),h={};h.tags=t[u.line-1];let b=nextWord(e,p+2);if("{"!==e[b].data){Object.assign(h,extractInfo(e,p+2)),d===n&&(e[p+(h.precision?4:2)].data.indexOf("sampler")<0&&error("EFX2201: vector uniforms must be declared in blocks.",u.line),d=r,f="samplerTextures"),d.find(e=>e.name===h.name)&&(h.duplicate=!0),b=nextSemicolon(e,b)}else{for(h.name=e[p+2].data,h.members=[];"}"!==e[b=nextWord(e,b)].data;){const t=extractInfo(e,b);mappings.isSampler(t.type)&&error("EFX2208: texture uniforms must be declared outside blocks.",e[b].line),h.members.push(t),b=nextSemicolon(e,b)}h.members.reduce((e,t)=>{let n=mappings.GetTypeSize(t.type);switch(t.typename){case"mat2":n/=2;case"mat3":n/=3;case"mat4":n/=4}if(t.count>1&&n<16){const e=`uniform ${convertType(t.type)} ${t.name}[${t.count}]`;error("EFX2203: "+e+": array UBO members need to be 16-bytes-aligned to avoid implicit padding"),n=16}else if(12===n){const e=`uniform ${convertType(t.type)} ${t.name}`;error("EFX2204: "+e+": please use 1, 2 or 4-component vectors to avoid implicit padding"),n=16}else if(mappings.isPaddedMatrix(t.type)){const e=`uniform ${convertType(t.type)} ${t.name}`;error("EFX2210: "+e+": use only 4x4 matrices to avoid implicit padding")}const r=Math.ceil(e/n)*n,s=r-e;return s&&error(`EFX2205: UBO '${h.name}' introduces implicit padding: `+`${s} bytes before '${t.name}', consider re-ordering the members`),r+n*t.count},0);let n=t.lines.find(t=>t>=e[p].line&&t<e[b].line);n&&error(`EFX2206: ${h.name}: no preprocessors allowed inside uniform blocks!`,n),h.members.forEach(t=>{"string"==typeof t.type&&error(`EFX2211: '${t.type} ${t.name}' in block '${h.name}': `+"struct-typed member within UBOs is not supported due to compatibility reasons.",e[b].line)});let r=d.find(e=>e.name===h.name);r&&(JSON.stringify(r.members)!==JSON.stringify(h.members)&&error(`EFX2207: different UBO using the same name '${h.name}'`,u.line),r.stageFlags|=o?VSBit:FSBit,h.duplicate=!0),b=nextWord(e,b),";"!==e[b].data&&error("EFX2209: Block declarations must be semicolon-terminated，non-array-typed and instance-name-free. "+`Please check your '${h.name}' block declaration.`,e[b].line)}c.push({beg:e[p].position,end:e[b].position,name:h.name,type:f}),h.duplicate||(h.defines=stripDuplicates(m),h.stageFlags=o?VSBit:FSBit,d.push(h)),p=b}return c}})(),miscChecks=(()=>{const e=new RegExp("\\b(?:asm|class|union|enum|typedef|template|this|packed|goto|switch|default|inline|noinline|volatile|public|static|extern|external|interface|flat|long|short|double|half|fixed|unsigned|superp|input|output|hvec2|hvec3|hvec4|dvec2|dvec3|dvec4|fvec2|fvec3|fvec4|sampler1D|sampler3D|sampler1DShadow|sampler2DShadow|sampler2DRect|sampler3DRect|sampler2DRectShadow|sizeof|cast|namespace|using|texture)\\b"),t=/precision\s+(low|medium|high)p\s+(\w+)/;return n=>{const r=t.exec(n);r?/#extension/.test(n.slice(r.index))&&warn("EFX2400: precision declaration should come after extensions"):warn("EFX2401: precision declaration not found.");const s=e.exec(n);if(s&&error(`EFX2402: using reserved keyword in glsl1: ${s[0]}`),options.skipParserTest)return;const i=tokenizer(n).filter(e=>"preprocessor"!==e.type);shaderTokens=i;try{parser(i)}catch(e){error(`EFX2404: glsl1 parser failed: ${e}`,0)}}})(),finalTypeCheck=(()=>{let e=null,t=!0;const n=(t,n)=>{let r=e.createShader(n);if(e.shaderSource(r,t),e.compileShader(r),!e.getShaderParameter(r,e.COMPILE_STATUS)){let n=1;const s=t.replace(/^|\n/g,()=>`\n${n++} `),i=e.getShaderInfoLog(r);e.deleteShader(r),r=null,error(`EFX2406: compilation failed: ↓↓↓↓↓ EXPAND THIS MESSAGE FOR MORE INFO ↓↓↓↓↓\n${i}\n${s}`)}return r};return(r,s,i,a,o)=>{if(!(()=>(e||"undefined"==typeof document||((e=document.createElement("canvas").getContext("webgl",{depth:!0,stencil:!0})).getSupportedExtensions().forEach(t=>e.getExtension(t)),t=t&&e.getParameter(e.MAX_VERTEX_TEXTURE_IMAGE_UNITS)>=8),t&&e))())return;const l="#version 100\n"+(e=>e.reduce((e,t)=>{let n=1;switch(t.type){case"string":n=t.options[0];break;case"number":n=t.range[0];break;case"constant":n=t.default}return`${e}#define ${t.name} ${n}\n`},""))(i);shaderName=a;const c=n(l+r,e.VERTEX_SHADER);shaderName=o;const p=n(l+s,e.FRAGMENT_SHADER);shaderName="linking";const d=((...t)=>{let n=e.createProgram();if(t.forEach(t=>e.attachShader(n,t)),e.linkProgram(n),!e.getProgramParameter(n,e.LINK_STATUS)){const t=e.getProgramInfoLog(n);e.deleteProgram(n),n=null,error(`EFX2407: link failed: ${t}`)}return n})(c,p);e.deleteProgram(d),e.deleteShader(p),e.deleteShader(c)}})(),stripToSpecificVersion=(()=>{const globalSearch=/#(if|elif|else|endif)(.*)?/g,legalExpr=/^[\d<=>!|&^\s]*(__VERSION__)?[\d<=>!|&^\s]*$/,macroWrap=(e,t)=>e,declareExtension=(e,t)=>"require"===t?`#extension ${e}: require\n`:`\n#ifdef ${e}\n#extension ${e}: enable\n#endif\n`;return(code,version,extensions,isVert)=>{version<310&&(code=code.replace(/layout\s*\((.*?)\)(\s*)(\w+)/g,(e,t,n,r)=>isVert||"out"!==r?t.indexOf("std140")>=0?"layout(std140)"+n+r:r:e));const instances=[];let cap=null,temp=null;for(;cap=globalSearch.exec(code),cap;)if("if"===cap[1]){if(temp){temp.level++;continue}if(!legalExpr.test(cap[2]))continue;temp={start:cap.index,end:cap.index,conds:[cap[2]],content:[cap.index+cap[0].length],level:1}}else if("elif"===cap[1]){if(!temp||temp.level>1)continue;legalExpr.test(cap[2])||(error(`EFX2301: #elif conditions after a constant #if should be constant too; get '${cap[2]}'`),cap[2]=""),temp.conds.push(cap[2]),temp.content.push(cap.index,cap.index+cap[0].length)}else if("else"===cap[1]){if(!temp||temp.level>1)continue;temp.conds.push("true"),temp.content.push(cap.index,cap.index+cap[0].length)}else if("endif"===cap[1]){if(!temp||--temp.level)continue;temp.content.push(cap.index),temp.end=cap.index+cap[0].length,instances.push(temp),temp=null}let res=code;if(instances.length){res=res.substring(0,instances[0].start);for(let j=0;j<instances.length;j++){const ins=instances[j];for(let i=0;i<ins.conds.length;i++)if(eval(ins.conds[i].replace("__VERSION__",version))){const e=code.substring(ins.content[2*i],ins.content[2*i+1]);res+=stripToSpecificVersion(e,version,isVert);break}const next=instances[j+1]&&instances[j+1].start||code.length;res+=code.substring(ins.end,next)}}for(const ext in extensions){const{defines:defines,cond:cond,level:level}=extensions[ext];eval(cond.replace("__VERSION__",version))&&(res=macroWrap(declareExtension(ext,level),defines)+res)}return res}})(),glsl300to100=(e,t,n,r,s,i,a)=>{let o="",l=0;if(r.forEach(n=>{if("blocks"!==n.type)return;const r=(o+=e.slice(l,n.beg)).length-o.search(/\s*$/)+1;t.find(e=>e.name===n.name).members.forEach(t=>{const n=e.match(new RegExp(`\\b${t.name}\\b`,"g"));if(!n||n.length<=1)return;const s=convertType(t.type),i=t.precision||"",a="string"==typeof t.count||t.isArray?`[${t.count}]`:"";o+=" ".repeat(r)+`uniform ${i}${s} ${t.name}${a};\n`}),l=n.end+(";"===e[n.end])}),o=(o+=e.slice(l)).replace(/\btexture((?!2D|Cube)\w*)\s*\(\s*(\w+)\s*([,\[])/g,(e,t,r,i,a)=>{const l="texture"+t;if(s.find(e=>e.name===l))return e;let c=new RegExp("sampler(\\w+)\\s+"+r);const p=s.find(e=>a>e.beg&&a<e.end);let d=p&&c.exec(o.substring(p.beg,p.eng))||c.exec(o);if(!d){const t=n.find(e=>e.name===r);if(t&&t.options)for(const e of t.options)if(d=(c=new RegExp("sampler(\\w+)\\s+"+e)).exec(o))break;if(!d)return error(`EFX2300: sampler '${r}' does not exist`),e}return`texture${d[1]}${t}(${r}${i}`}),a)o=(o=o.replace(inDecl,(e,t,n)=>`attribute ${n};`)).replace(outDecl,(e,t,n)=>`varying ${n};`);else{const e=[];if(o=(o=o.replace(inDecl,(e,t,n)=>`varying ${n};`)).replace(outDecl,(t,n,r,s)=>{const i=n&&locationRE.exec(n);return i||error("EFX2302: fragment output location must be specified"),e.push({name:s,location:i[1]}),""}),1===e.length){const t=new RegExp(e[0].name,"g");o=o.replace(t,"gl_FragColor")}else if(e.length>1){for(const t of e){const e=new RegExp(t.name,"g");o=o.replace(e,`gl_FragData[${t.location}]`)}i.extensions.GL_EXT_draw_buffers||(i.extensions.GL_EXT_draw_buffers={defines:[],cond:"__VERSION__ <= 100",level:"enable"})}}return(o=o.replace(/layout\s*\(.*?\)\s*/g,()=>"")).replace(pragmasToStrip,"")},decorateBlockMemoryLayouts=(e,t)=>{let n=0;const r=[];t.forEach((t,s)=>{if("blocks"!==t.type)return;const i=e.slice(n,t.beg),a=layoutExtract.exec(i);r[s]=a?n+a.index+a[0].length-a[2].length-1:-1,n=t.end});let s="";return n=0,t.forEach((t,i)=>{const a=r[i];void 0!==a&&(a<0?(s+=e.slice(n,t.beg),s+="layout(std140) "):(s+=e.slice(n,a),s+=", std140",s+=e.slice(a,t.beg)),s+=e.slice(t.beg,t.end),n=t.end)}),s+=e.slice(n)},decorateBindings=(e,t,n)=>{let r=0;const s=[],i={};(n=n.filter(e=>!builtinRE.test(e.name))).forEach(n=>{if(!t[n.type])return;const a=e.slice(r,n.beg),o={prop:t[n.type].find(e=>e.name===n.name)},l=layoutExtract.exec(a),c=i[n.type]||(i[n.type]={});if(l){o.position=r+l.index+l[0].length-l[2].length-1;const e=bindingExtract.exec(l[1]);if(e){o.position=-1;const r=parseInt(e[1]);t[n.type][r]?(c[r]&&c[r]!==n.name&&error(`EFX2603: duplicated binding/location declaration for '${c[r]}' and '${n.name}'`),c[c[r]=n.name]=r):"blocks"===n.type?error(`EFX2600: illegal custom binding for '${n.name}', block bindings should be consecutive and start from 0`):"samplerTextures"===n.type?error(`EFX2601: illegal custom binding for '${n.name}', texture bindings should be consecutive and after all the blocks`):error(`EFX2602: illegal custom location for '${n.name}', locations should be consecutive and start from 0`)}}s.push(o),r=n.end}),n.forEach((e,n)=>{if(!i[e.type])return;const r="blocks"===e.type||"samplerTextures"===e.type?"binding":"location",a=i[e.type];if("attributes"===e.type)if(e.name in a)s[n].prop[r]=a[e.name];else{let t=0;for(;a[t];)t++;s[n].prop[r]=t,a[t]=e.name}else if(e.name in a){const i=s[n].prop[r];s[n].prop[r]=a[e.name],t[e.type][i][r]=i}});let a="";r=0;const o=mappings.SetIndex.MATERIAL;return n.forEach((t,n)=>{if(!s[n])return;const i="blocks"===t.type||"samplerTextures"===t.type,l=i?"binding":"location",{position:c,prop:p}=s[n],d=i?`set = ${o}, `:"";void 0===c?(a+=e.slice(r,t.beg),a+=`layout(${d+l} = ${p[l]}) `):c>=0?(a+=e.slice(r,c),a+=`${d+l} = ${p[l]}`,a+=e.slice(c,t.beg)):a+=e.slice(r,t.beg),a+=e.slice(t.beg,t.end),r=t.end}),a+=e.slice(r)},shaderFactory=(()=>{const e=/\s+$/gm,t=/(^\s*\n){2,}/gm,n=n=>{let r=n.replace(pragmasToStrip,"");return r=(r=r.replace(t,"\n")).replace(e,"")},r=(e,t)=>n=>{if(!builtinRE.test(n.name))return!0;const r=n.tags;let s;s=r&&r.builtin?r.builtin:"global",t[`${s}s`][e].push({name:n.name,defines:n.defines})},s=(e,t,n)=>"main"===t?e:e+((e,t)=>e?`\nvoid main() { gl_Position = ${t}(); }\n`:`\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = ${t}(); }\n`)(n,t),i=/([^:]+)(?::(\w+))?/,a={version:"300 es"},o=(e,t,n=[],r=[],o=[],l=[],c=[],p=[],d=globalChunks,f=globalDeprecations)=>{const u={};shaderName=e;const g={lines:[],extensions:{}};let{code:m,record:h,functions:b}=((e,t,n,r,a="main")=>{const o=i.exec(e),l=o[2]||a,c=new Set,p=[];let d=unwindIncludes(`#include <${o[1]}>`,t,n,c);return d=s(d,l,r),d=expandLiteralMacro(d),d=expandFunctionalMacro(d),{code:d=eliminateDeadCode(d,l,p),record:c,functions:p}})(e,d,f,t);const y=shaderTokens=tokenizer(m,a);extractDefines(y,n,g);const x=extractParams(y,g,r,o,l,c,p,t,b);return u.blockInfo=x,u.record=h,u.extensions=g.extensions,u.glsl4=m,u.glsl3=stripToSpecificVersion(decorateBlockMemoryLayouts(m,x),300,g.extensions,t),u.glsl1=stripToSpecificVersion(glsl300to100(m,r,n,x,b,g,t),100,g.extensions,t),miscChecks(u.glsl1),u};return{compile:o,build:(e,t,s=globalChunks,i=globalDeprecations)=>{let a=[],l=[],c=[],p=[],d=[],f=[];const u={};u.vert=o(e,!0,a,l,c,p,d,f,s,i),u.frag=o(t,!1,a,l,c,p,d,f,s,i),finalTypeCheck(u.vert.glsl1,u.frag.glsl1,a,e,t);const g={globals:{blocks:[],samplerTextures:[]},locals:{blocks:[],samplerTextures:[]},statistics:{}};a=a.filter(e=>"constant"!==e.type);let m=0,h=0;l.forEach(e=>{let t=e.members.reduce((e,t)=>"number"!=typeof t.count?e:e+Math.ceil(mappings.GetTypeSize(t.type)/16)*t.count,0);e.stageFlags&VSBit&&(m+=t),e.stageFlags&FSBit&&(h+=t)},0),g.statistics.CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS=m,g.statistics.CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS=h,l=l.filter(r("blocks",g)),c=c.filter(r("samplerTextures",g)),p.forEach(e=>{if(e.format=mappings.formatMap[e.typename],e.defines.indexOf("USE_INSTANCING")>=0&&(e.isInstanced=!0),e.tags&&e.tags.format){const t=mappings.getFormat(e.tags.format);void 0!==t&&(e.format=t),mappings.isNormalized(t)&&(e.isNormalized=!0)}}),l.forEach(e=>(delete e.tags,e.members.forEach(e=>(delete e.typename,delete e.precision,delete e.isArray)))),c.forEach(e=>(delete e.tags,delete e.typename,delete e.precision,delete e.isArray)),p.forEach(e=>(delete e.tags,delete e.typename,delete e.precision,delete e.isArray)),d.forEach(e=>(delete e.tags,delete e.typename,delete e.precision,delete e.isArray));let b=0;l.forEach(e=>e.binding=b++),c.forEach(e=>e.binding=b++);let y=0;p.forEach(e=>e.location=y++),y=0,d.forEach(e=>e.location=y++);const x={blocks:l,samplerTextures:c,attributes:p,varyings:d};u.vert.glsl4=stripToSpecificVersion(decorateBindings(u.vert.glsl4,x,u.vert.blockInfo),460,u.vert.extensions,!0),u.frag.glsl4=stripToSpecificVersion(decorateBindings(u.frag.glsl4,x,u.frag.blockInfo),460,u.frag.extensions,!1);const E={vert:n(u.vert.glsl4),frag:n(u.frag.glsl4)},v={vert:n(u.vert.glsl3),frag:n(u.frag.glsl3)},$={vert:n(u.vert.glsl1),frag:n(u.frag.glsl1)},k=mappings.murmurhash2_32_gc(E.vert+E.frag+v.vert+v.frag+$.vert+$.frag,666);return u.frag.record.forEach(u.vert.record.add,u.vert.record),{hash:k,glsl4:E,glsl3:v,glsl1:$,builtins:g,defines:a,blocks:l,samplerTextures:c,attributes:p,varyings:d,record:u.vert.record}}}})(),compileShader=shaderFactory.compile,parseEffect=(()=>{const e=/CCEffect\s*%{([^]+?)(?:}%|%})/,t=/CCProgram\s*([\w-]+)\s*%{([^]*?)(?:}%|%})/,n=/#.*$/gm,r=/^\s*$/,s=/\n[^\s]/,i=/^[^\S\n]/gm,a=/\t/g,o=(e,t,n="effect")=>{if(Array.isArray(e)){if(!Array.isArray(t))return void error(`EFX1002: ${n} must be an array`);if(e[0])for(let r=0;r<t.length;r++)o(e[0],t[r],n+`[${r}]`)}else{if(!t||"object"!=typeof t||Array.isArray(t))return void error(`EFX1003: ${n} must be an object`);for(const e of Object.keys(t))-1!==e.indexOf(":")&&error(`EFX1004: syntax error at '${e}', you might need to insert a space after colon`);if(e.any)for(const r of Object.keys(t))o(e.any,t[r],n+`.${r}`);else for(const r of Object.keys(e)){let s=r;if("$"===s[0])s=s.substring(1);else if(!t[s])continue;o(e[r],t[s],n+`.${s}`)}}};return(l,c)=>{shaderName="syntax",c=stripComments(c).replace(a," ".repeat(tabAsSpaces));let p={},d={},f={},u=e.exec((e=>e.replace(n,""))(c));if(u){try{const e=yaml.safeLoad(u[1]);p=JSON.parse(JSON.stringify(e))}catch(e){error(`EFX1001: CCEffect parser failed: ${e}`)}p.name||(p.name=l),o(mappings.effectStructure,p)}else error("EFX1000: CCEffect is not defined");let g=t.exec(c);for(;g;){let e=g[2];if(!r.test(e))for(;!s.test(e);)e=e.replace(i,"");addChunk(g[1],e,d,f),c=c.substring(g.index+g[0].length),g=t.exec(c)}return{effect:p,templates:d,localDeprecations:f}}})(),mapPassParam=(()=>{const e=(e,t)=>{let n=0,r=t=>t.name===e&&(n=t.type,!0);return t.blocks.some(e=>e.members.some(r))||t.samplerTextures.some(r),n},t=(e,t,n)=>{if(t<=0)return"no matching uniform";if(void 0!==e)if("string"===n){if(!mappings.isSampler(t))return"string for vectors"}else{if(!Array.isArray(e))return"non-array for buffer members";if(e.length!==mappings.GetTypeSize(t)/4)return"wrong array length"}},n=/^(\w+)(?:\.([xyzw]+|[rgba]+))?$/,r={x:0,y:1,z:2,w:3,r:0,g:1,b:2,a:3},s=(t,s)=>{const i=[t,0,0],a=n.exec(t);if(!a)return error(`EFX3303: illegal property target '${t}'`),i;const o=a[2]&&a[2].toLowerCase()||"",l=r[o[0]]||0;return o.split("").map((e,t)=>r[e]-l-t).some(e=>e)&&error(`EFX3304: '${t}': random component swizzle is not supported`),i[0]=a[1],i[1]=l,i[2]=e(a[1],s),o.length&&(i[2]-=Math.max(0,mappings.GetTypeSize(i[2])/4-o.length)),i[2]<=0&&error(`EFX3305: no matching uniform target '${t}'`),i},i=(e,t)=>{for(const n of Object.keys(t)){const r=t[n];"object"==typeof r&&"object"==typeof e[n]?i(e[n],r):void 0===e[n]&&(e[n]=r)}},a=e=>{for(let t in e){let n=e[t];if("string"==typeof n){let r=parseInt(n);isNaN(r)&&(r=mappings.passParams[n.toUpperCase()]),void 0!==r&&(e[t]=r)}else if(Array.isArray(n)){if(!n.length)continue;switch(typeof n[0]){case"object":n.forEach(a);break;case"string":a(n);break;case"number":e[t]=(255*n[0]<<24|255*n[1]<<16|255*n[2]<<8|255*(n[3]||255))>>>0}}else"object"==typeof n&&a(n)}return e},o=e=>{const t=[];for(const n of Object.keys(e)){const r=e[n],s=mappings.SamplerInfoIndex[n];void 0!==r&&void 0!==s||warn(`EFX3301: illegal sampler info '${n}'`),"borderColor"===n?(t[s]=r.r,t[s+1]=r.g,t[s+2]=r.b,t[s+3]=r.a):t[s]=r}return mappings.genSamplerHash(t)},l=/^(\w+)\s*([+-])\s*([\dxabcdef]+)$/i,c=mappings.RenderPriority.DEFAULT,p=mappings.RenderPriority.MIN,d=mappings.RenderPriority.MAX;return(n,r)=>{shaderName="type error";const f={};n.priority&&(f.priority=(e=>{let t=-1;const n=l.exec(e);return t=n?mappings.RenderPriority[n[1].toUpperCase()]+parseInt(n[3])*("+"===n[2]?1:-1):parseInt(e),isNaN(t)||t<p||t>d?(warn(`EFX3000: illegal pass priority: ${e}`),c):t})(n.priority),delete n.priority),n.depthStencilState&&(f.depthStencilState=(e=>{for(const t of Object.keys(e))t.startsWith("stencil")&&(t.endsWith("Front")||t.endsWith("Back")||(e[t+"Front"]=e[t+"Back"]=e[t],delete e[t]));return e.stencilWriteMaskFront!==e.stencilWriteMaskBack&&warn("EFX3100: WebGL(2) doesn't support inconsistent front/back stencil write mask"),e.stencilReadMaskFront!==e.stencilReadMaskBack&&warn("EFX3101: WebGL(2) doesn't support inconsistent front/back stencil read mask"),e.stencilRefFront!==e.stencilRefBack&&warn("EFX3102: WebGL(2) doesn't support inconsistent front/back stencil ref"),a(e)})(n.depthStencilState),delete n.depthStencilState),n.switch&&(f.switch=((e,t)=>(t.defines.find(t=>t.name===e)&&error("EFX3200: existing shader macros cannot be used as pass switch"),e))(n.switch,r),delete n.switch),n.properties&&(f.properties=((n,r)=>{let l={};for(const i of Object.keys(n)){if("__metadata__"===i){l=n[i],delete n[i];continue}const c=n[i],p=e(i,r);if(void 0!==c.type&&warn(`EFX3300: property '${i}': you don't have to specify type in here`),c.type=p,c.target){c.handleInfo=s(c.target,r),delete c.target,c.type=c.handleInfo[2];const t=c.editor&&c.editor.visible,i=c.handleInfo[0],a=e(c.handleInfo[0],r);n[i]||(n[i]={type:a,editor:{visible:!1}}),(void 0===t||t)&&(n[i].editor?void 0===n[i].editor.deprecated&&(n[i].editor.deprecated=!0):n[i].editor={deprecated:!0}),mappings.isSampler(a)?c.value&&(n[i].value=c.value):(n[i].value||(n[i].value=Array(mappings.GetTypeSize(a)/4).fill(0)),Array.isArray(c.value)?n[i].value.splice(c.handleInfo[1],c.value.length,...c.value):void 0!==c.value&&n[i].value.splice(c.handleInfo[1],1,c.value))}c.sampler&&(c.samplerHash=o(a(c.sampler)),delete c.sampler);const d=typeof c.value;"number"!==d&&"boolean"!==d||(c.value=[c.value]);const f=t(c.value,c.type,d);f&&error(`EFX3302: illegal property declaration for '${i}': ${f}`)}for(const e of Object.keys(n))i(n[e],l);return n})(n.properties,r),delete n.properties),n.migrations&&(f.migrations=n.migrations,delete n.migrations),a(n),Object.assign(n,f)}})(),reduceHeaderRecord=e=>{const t=new Set;for(const n of e)n.record.forEach(t.add,t);return[...t.values()]},buildEffect=(e,t)=>{effectName=e;let{effect:n,templates:r,localDeprecations:s}=parseEffect(e,t);if(!n||!Array.isArray(n.techniques))return null;r=Object.assign({},globalChunks,r);let i={};for(const e in globalDeprecations)i[e]=Object.assign({},globalDeprecations[e],s[e]);const a=Object.keys(i.identifiers).reduce((e,t)=>`|${t}`+e,"").slice(1);a.length&&(i.identifierRE=new RegExp(`\\b(${a})\\b`,"g"));const o=n.shaders=[];for(const e of n.techniques)for(const t of e.passes){let e=t.vert,n=t.frag;delete t.vert,delete t.frag;let s=t.program=`${effectName}|${e}|${n}`,a=o.find(e=>e.name===s);a||((a=shaderFactory.build(e,n,r,i)).name=s,o.push(a)),mapPassParam(t,a)}return n.dependencies=reduceHeaderRecord(o),n};module.exports={options:options,addChunk:addChunk,compileShader:compileShader,buildEffect:buildEffect};