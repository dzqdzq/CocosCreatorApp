"use strict";Object.defineProperty(exports,"__esModule",{value:!0});const fs_1=require("fs"),fs_extra_1=require("fs-extra"),path_1=require("path"),index_1=require("./../utils/index"),packer_1=require("./packer"),crypto_1=require("crypto"),config_1=require("./config"),Lodash=require("lodash");class PacInfo{constructor(){this.spriteFrames=[],this.relativePath="",this.relativeDir=""}async init(e){if(this.asset=e,this.meta=await Editor.Message.request("asset-db","query-asset-meta",e.uuid),!this.meta||!this.asset)return console.warn(`Can't get meta info of ${e.uuid} from asset-db.`),this;let s=await Editor.Message.request("asset-db","query-assets",{pattern:path_1.dirname(this.asset.path)+"/**/*",ccType:"cc.SpriteFrame"});if(!s||0===s.length)return console.debug(`There is no spriteFrame in dictionary(${this.asset.path}).`),this;const t=await Editor.Message.request("asset-db","query-assets",{pattern:path_1.dirname(this.asset.path)+"/+(**)/*.pac"}),a=t.map(e=>path_1.dirname(e.file));if(0!==t.length&&0===(s=s.filter(e=>{for(const s of a)if(Editor.Utils.Path.contains(s,Build.Utils.dbUrlToRawPath(e.path)))return!1;return!0})).length)return console.warn(`No SpriteFrame find in folder [{link(${path_1.dirname(this.asset.file)})}]. Please check the AutoAtlas [${this.asset.file}].`),this;let i=await Promise.all(s.map(async s=>new Promise((t,a)=>{cc.assetManager.loadAny(s.uuid,(i,r)=>{if(i)return a(i);r.pacUuid=e.uuid,r.displayName=s.displayName,r.file=index_1.dbUrlToRawPath(s.fatherInfo.source),t(r)})})));i=Lodash.sortBy(i,"_uuid");const r=path_1.join(Editor.Project.path,"assets");return this.spriteFrames=i,this.relativePath=path_1.relative(r,this.asset.file),this.relativeDir=path_1.relative(r,path_1.dirname(this.asset.file)),this}}class TexturePacker{constructor(){this.spriteFrames=[],this.pacInfos=[],this.assetsUuids=[],this.unpackedUuids=[]}static async generatePreviewFiles(e){fs_1.existsSync(config_1.previewTempDir)||fs_extra_1.ensureDirSync(config_1.previewTempDir);const s=await Editor.Message.request("asset-db","query-asset-info",e);if(!s)return console.warn(`query-asset-info failed! can't get asset info of {asset(${s.url})}.`),null;const t=await queryAtlases(s),a=await internalPack({pacInfos:t.pacInfos,destTempDir:config_1.previewTempDir});return 0===a.length?null:{atlasImagePaths:a[0].atlases.map(e=>e.imagePath),unpackedImages:Array.from(a[0].unpackedImages),dirty:Boolean(a[0].dirty)}}static async queryPreviewFiles(e){const s=path_1.join(config_1.previewTempDir,e,"pac-info.json");if(!fs_1.existsSync(s))return;const t=fs_extra_1.readJSONSync(s);return{atlasImagePaths:t.result.atlases.map(e=>e.imagePath),unpackedImages:t.result.unpackedImages}}get spriteFrameUuids(){return this.spriteFrames.map(e=>e._uuid)}async init(e){const s=await queryAtlases(e);this.spriteFrames=s.spriteFrames,this.pacInfos=s.pacInfos,this.assetsUuids=s.assetsUuids}needPack(e){return 0===this.unpackedUuids.length?this.assetsUuids.includes(e):!(!this.assetsUuids.includes(e)||this.unpackedUuids.includes(e))}needResolve(e){return!this.assetsUuids.includes(e)||!(!this.assetsUuids.includes(e)||!this.spriteFrameUuids.includes(e))}async pack(e){console.time("Pack atlas");let s=this.pacInfos;for(const t of s){t.meta.userData.filterUnused&&(t.spriteFrames=t.spriteFrames.filter(s=>e.includes(s._uuid)))}s=s.filter(s=>e.includes(s.meta.uuid)||s.spriteFrames.filter(s=>e.includes(s._uuid)).length>0);const t=await internalPack({pacInfos:s,destTempDir:config_1.buildTempDir});return console.timeEnd("Pack atlas"),t}}async function internalPack(e){const{pacInfos:s,destTempDir:t}=e,a=[];for(const e of s){const s=e.meta.userData,i=(await index_1.containInBundle(e.asset.url),path_1.join(t,e.asset.uuid)),r=e.spriteFrames,{storedPacInfoPath:n,newStoredPacInfo:u,storedPacInfo:c}=await getStoredPacInfo(i,e,r);let o,d=c&&!Lodash.isEqual(u.mtimes,c.mtimes);if(!d&&c){o=c.result;for(const e of o.atlases){if(!fs_1.existsSync(e.imagePath)){d=!0;break}e.spriteFrameInfos.forEach(e=>{e.spriteFrame=r.find(s=>s._uuid===e.uuid)})}}if(d||!o){fs_extra_1.emptyDirSync(i);const t=cc.js.mixin({name:path_1.basename(e.asset.file,path_1.extname(e.asset.file)),width:s.maxWidth,height:s.maxHeight,destDir:i},s);(o=await packer_1.packer(r,t)).unpackedImages=Array.from(o.unpackedImages),u.result=o,fs_extra_1.writeJSON(n,u,{spaces:2})}o.pacInfo=e,o.dirty=d,o.mtimeMd5=Build.Utils.calcMd5(JSON.stringify(u.mtimes)),a.push(o)}return a}async function getStoredPacInfo(e,s,t){const a=path_1.join(e,"pac-info.json"),i={mtimes:{},sharpMd5:crypto_1.createHash("md5").update(JSON.stringify(require("sharp").versions)).digest("hex")};let r=[s.meta.uuid];return t.forEach(e=>{r.push(e._uuid),r.push(e.texture._uuid),r.push(e.texture._mipmaps[0]._uuid)}),r=Lodash.uniq(r),await Promise.all(r.map(async e=>{const s=await Editor.Message.request("asset-db","query-asset-mtime",e);i.mtimes[e]=s})),{storedPacInfoPath:a,newStoredPacInfo:i,storedPacInfo:fs_1.existsSync(a)&&fs_extra_1.readJSONSync(a)||null}}async function queryAtlases(e){const s={assetsUuids:[],spriteFrames:[],pacInfos:[]};return e=Array.isArray(e)?e:[e],await Promise.all(e.map(async e=>{const t=await(new PacInfo).init(e);s.assetsUuids.push(t.asset.uuid),0!==t.spriteFrames.length&&(t.spriteFrames.forEach(e=>{const t=e.texture._uuid,a=e.texture._mipmaps[0]._uuid;s.assetsUuids.push(t,e._uuid,a)}),s.spriteFrames=s.spriteFrames.concat(t.spriteFrames),s.pacInfos.push(t))})),s.spriteFrames=Lodash.uniq(s.spriteFrames),s}exports.default=TexturePacker;