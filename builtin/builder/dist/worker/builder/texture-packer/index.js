"use strict";Object.defineProperty(exports,"__esModule",{value:!0});const fs_1=require("fs"),fs_extra_1=require("fs-extra"),path_1=require("path"),index_1=require("./../utils/index"),packer_1=require("./packer"),config_1=require("./config"),asset_library_1=require("../manager/asset-library"),Lodash=require("lodash"),DB_TEMP_DIR=(0,path_1.join)(Editor.Project.tmpDir,"asset-db");class PacInfo{constructor(){this.spriteFrames=[],this.spriteAssets=[],this.relativePath="",this.relativeDir=""}async init(s){if(this.asset=s,this.meta=await asset_library_1.buildAssetLibrary.getMeta(s.uuid),!this.meta||!this.asset)return console.warn(`Can't get meta info of ${s.uuid} from asset-db.`),this;let e=asset_library_1.buildAssetLibrary.queryAssetsByOptions({pattern:(0,path_1.dirname)(this.asset.path)+"/**/*",importer:"sprite-frame",deep:!0});if(!(e=e.filter(s=>{var e;return null===(e=s.userData)||void 0===e?void 0:e.packable}))||0===e.length)return console.debug(`There is no spriteFrame in dictionary(${this.asset.path}).`),this;const t=asset_library_1.buildAssetLibrary.queryAssetsByOptions({pattern:(0,path_1.dirname)(this.asset.path)+"/+(**)/*.pac"}),a=t.map(s=>(0,path_1.dirname)(s.file));if(0!==t.length&&(e=e.filter(s=>{for(const e of a)if(Editor.Utils.Path.contains(e,Build.Utils.dbUrlToRawPath(s.path)))return!1;return!0})),0===e.length)return console.warn(`No SpriteFrame find in folder [{link(${(0,path_1.dirname)(this.asset.file)})}]. Please check the AutoAtlas [${this.asset.file}].`),this;let i=await Promise.all(e.map(async e=>new Promise((t,a)=>{cc.assetManager.loadAny(e.uuid,(i,r)=>{if(i)return a(i);r.pacUuid=s.uuid,r.displayName=e.displayName,r.file=(0,index_1.dbUrlToRawPath)(e.fatherInfo.source),r.packable=!1,this.spriteAssets.push(e),t(r)})})));this.spriteAssets=Lodash.sortBy(this.spriteAssets,"uuid"),i=Lodash.sortBy(i,"_uuid");const r=(0,path_1.join)(Editor.Project.path,"assets");return this.spriteFrames=i,this.relativePath=(0,path_1.relative)(r,this.asset.file),this.relativeDir=(0,path_1.relative)(r,(0,path_1.dirname)(this.asset.file)),this}}class TexturePacker{constructor(){this.spriteFrames=[],this.pacInfos=[],this.assetsUuids=[],this.unpackedUuids=[]}static async generatePreviewFiles(s){(0,fs_1.existsSync)(config_1.previewTempDir)||(0,fs_extra_1.ensureDirSync)(config_1.previewTempDir);const e=asset_library_1.buildAssetLibrary.queryAssetInfo(s);if(!e)return console.warn(`query-asset-info failed! can't get asset info of {asset(${s})}.`),null;const t=await queryAtlases(e),a=await internalPack({pacInfos:t.pacInfos,destTempDir:config_1.previewTempDir});return 0===a.length?null:{atlasImagePaths:a[0].atlases.map(s=>s.imagePath),unpackedImages:Array.from(a[0].unpackedImages),dirty:Boolean(a[0].dirty)}}static async queryPreviewFiles(s){const e=(0,path_1.join)(config_1.previewTempDir,s,"pac-info.json");if(!(0,fs_1.existsSync)(e))return;const t=(0,fs_extra_1.readJSONSync)(e);return{atlasImagePaths:t.result.atlases.map(s=>s.imagePath),unpackedImages:t.result.unpackedImages}}get spriteFrameUuids(){return this.spriteFrames.map(s=>s._uuid)}async init(s){const e=await queryAtlases(s);this.spriteFrames=e.spriteFrames,this.pacInfos=e.pacInfos,this.assetsUuids=e.assetsUuids}needPack(s){return 0===this.unpackedUuids.length?this.assetsUuids.includes(s):!(!this.assetsUuids.includes(s)||this.unpackedUuids.includes(s))}needResolve(s){return!this.assetsUuids.includes(s)||!(!this.assetsUuids.includes(s)||!this.spriteFrameUuids.includes(s))}async pack(s,e){Editor.Metrics.trackTimeStart("builder: pack atlas");let t=this.pacInfos;for(const e of t){e.meta.userData.filterUnused&&(e.spriteFrames=e.spriteFrames.filter(e=>s.includes(e._uuid)))}t=t.filter(e=>s.includes(e.meta.uuid)||e.spriteFrames.filter(e=>s.includes(e._uuid)).length>0),console.debug(`Start pack atlas ${e?"with":"without"} cache.`);const a=await internalPack({pacInfos:t,destTempDir:config_1.buildTempDir,useCache:e});return Editor.Metrics.trackTimeEnd("builder: pack atlas",{output:!0}),a}}async function internalPack(s){const{pacInfos:e,destTempDir:t}=s,a=[];for(const i of e){const e=i.meta.userData,r=(0,path_1.join)(t,i.asset.uuid),n=i.spriteFrames,{storedPacInfoPath:u,newStoredPacInfo:c,storedPacInfo:o}=getStoredPacInfo(r,i);let d,l=!(o&&c.md5===o.md5);if(s.useCache&&!l&&o){d=o.result;for(const s of d.atlases){if(!(0,fs_1.existsSync)(s.imagePath)){l=!0;break}s.spriteFrameInfos.forEach(s=>{s.spriteFrame=n.find(e=>e._uuid===s.uuid)})}}if(s.useCache&&!l&&d)console.debug(`Use Cache of pack result about asset ${i.asset.url}`);else{(0,fs_extra_1.emptyDirSync)(r);const s=cc.js.mixin({name:(0,path_1.basename)(i.asset.file,(0,path_1.extname)(i.asset.file)),width:e.maxWidth,height:e.maxHeight,destDir:r},e);console.group(`pack asset ${i.asset.url}`),(d=await(0,packer_1.packer)(n,s)).unpackedImages=Array.from(d.unpackedImages),c.result=d,(0,fs_extra_1.writeJSON)(u,c,{spaces:2}),Object.values(c.cacheFiles).forEach(s=>{(0,fs_extra_1.outputFileSync)(s,"")}),console.groupEnd()}d.pacInfo=i,d.dirty=l,d.mtimeMd5=c.md5,a.push(d)}return a}function getStoredPacInfo(s,e){const t=(0,path_1.join)(s,"pac-info.json");let a=(0,fs_1.existsSync)(t)&&(0,fs_extra_1.readJSONSync)(t)||null;const i={cacheFiles:{},sharpMd5:Build.Utils.calcMd5(JSON.stringify(require("sharp").versions)),md5:"",versionDev:config_1.versionDev};let r=[e.meta.uuid];try{const s=(0,path_1.join)(DB_TEMP_DIR,e.asset.url.match(/db:\/\/([^\/]*)/)[1],e.asset.uuid.substr(0,2),e.asset.uuid,"build",e.asset.uuid);i.cacheFiles[e.asset.uuid]=s,(0,fs_1.existsSync)(s)||(a=null),e.spriteAssets.forEach(s=>{const t=(0,path_1.join)(DB_TEMP_DIR,s.url.match(/db:\/\/([^\/]*)/)[1],s.uuid.substr(0,2),s.uuid,"build",e.asset.uuid);i.cacheFiles[s.uuid]=t,(0,fs_1.existsSync)(t)||a&&(a.cacheFiles[s.uuid]=null)})}catch(s){console.error(s),a=null}return r=Lodash.uniq(r),i.md5=Build.Utils.calcMd5(JSON.stringify({cacheFiles:i.cacheFiles,asset:e.asset,meta:e.meta,spriteAssets:e.spriteAssets})+i.sharpMd5+config_1.versionDev),{storedPacInfoPath:t,newStoredPacInfo:i,storedPacInfo:a}}async function queryAtlases(s){const e={assetsUuids:[],spriteFrames:[],pacInfos:[]};return s=Array.isArray(s)?s:[s],await Promise.all(s.map(async s=>{const t=await(new PacInfo).init(s);e.assetsUuids.push(t.asset.uuid),0!==t.spriteFrames.length&&(t.spriteFrames.forEach(s=>{const t=s.texture._uuid,a=s.texture._mipmaps[0]._uuid;e.assetsUuids.push(t,s._uuid,a)}),e.spriteFrames=e.spriteFrames.concat(t.spriteFrames),e.pacInfos.push(t))})),e.spriteFrames=Lodash.uniq(e.spriteFrames),e}exports.default=TexturePacker;