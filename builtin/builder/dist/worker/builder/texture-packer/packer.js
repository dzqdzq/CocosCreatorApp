"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.packer=void 0;const fs_extra_1=require("fs-extra"),path_1=require("path"),config_1=require("./config"),Algorithm=require("./algorithm"),Sharp=require("sharp"),HashUuid=require("../utils/hash-uuid"),applyBleed=require("./bleeding").applyBleed;async function packer(t,e={}){if(!t)return null;e.name=e.name||"spritesheet",e.forceSquared="boolean"==typeof e.forceSquared&&e.forceSquared,e.powerOfTwo="boolean"==typeof e.powerOfTwo&&e.powerOfTwo,e.padding="number"==typeof e.padding?e.padding:0,e.algorithm="string"==typeof e.algorithm?e.algorithm:"MaxRects",e.contourBleed="boolean"==typeof e.contourBleed&&e.contourBleed,e.paddingBleed="boolean"==typeof e.paddingBleed&&e.paddingBleed,e.bleed=e.paddingBleed?1:0;const i=filterUnpacked(t.map(t=>new SpriteFrameInfo(t,e)));await trimImages(i.result);const r=determineAtlasSize(i.result,e),a=Array.from(i.unpackedImages.concat(r.unpackedImages));return await Promise.all(r.packAtlas.map(t=>generateAtlas(t,e))),{atlases:r.packAtlas,options:e,unpackedImages:a}}function determineAtlasSize(t,e){const i=t.concat(),r=[];let a=[],h=Algorithm[e.algorithm];h||(console.warn(`determineAtlasSize failed: Can not find algorithm ${e.algorithm}, use MaxRects`),h=Algorithm.MaxRects);const o=e.width,s=e.height,n=e.allowRotation;let d=0;for(;i.length>0;){const t=h(i,o,s,n);if(0===t.length){a=a.concat(i);break}t.forEach(t=>{i.splice(i.indexOf(t),1)});let l=0,u=0;for(let e=0;e<t.length;e++){const i=t[e];i.rotatedWidth=i.rotated?i.height:i.width,i.rotatedHeight=i.rotated?i.width:i.height,i.trim.rotatedWidth=i.rotated?i.trim.height:i.trim.width,i.trim.rotatedHeight=i.rotated?i.trim.width:i.trim.height;const r=i.x+i.rotatedWidth,a=i.y+i.rotatedHeight;r>l&&(l=r),a>u&&(u=a)}const g=e.name+"-"+d;d++;const p=path_1.join(e.destDir,g+"."+e.format);r.push(new AtlasInfo(t,l,u,g,p))}return r.forEach(t=>{applySquareAndPowerConstraints(t,e.forceSquared,e.powerOfTwo),t.spriteFrameInfos.forEach(t=>{t.trim.x=t.x+e.padding+e.bleed,t.trim.y=t.y+e.padding+e.bleed})}),{packAtlas:r,unpackedImages:a}}function applySquareAndPowerConstraints(t,e,i){e&&(t.width=t.height=Math.max(t.width,t.height)),i&&(t.width=roundToPowerOfTwo(t.width),t.height=roundToPowerOfTwo(t.height))}function roundToPowerOfTwo(t){if("number"!=typeof t)return 0;let e=2;for(;t>e;)e*=2;return e}function filterUnpacked(t){const e=[],i=t.filter(t=>t.trim.width>0&&t.trim.height>0||(t.width=t.rawWidth,t.height=t.rawHeight,e.push(t),!1));return{unpackedImages:e,result:i}}async function generateAtlas(t,e){const i=t.spriteFrameInfos,r=t.width,a=t.height,h={raw:{width:r,height:a,channels:4}};let o=await Sharp({create:{width:r,height:a,channels:4,background:{r:0,b:0,g:0,alpha:0}}}).toBuffer();let s=0;let n=0,d=[];for(let t=0;t<i.length;t++){const e=i[t],r=e.trim.x,a=e.trim.y;s+=e.trim.width*e.trim.height*4,n++;try{(s>=2097152||n>=100)&&(o=await Sharp(o,h).composite(d).toBuffer(),d=[],s=0,n=0);let t=Sharp(e.libraryPath);e.rotated&&(t=t.rotate(90));const i=await t.toBuffer();d.push({input:i,left:r,top:a})}catch(t){console.error(`Handle image [${e.libraryPath} error]. \n Origin path is [${e.originalPath}:${e.name}]. \n Error : ${t.toString()}`);continue}}o=await Sharp(o,h).composite(d).toBuffer(),(e.contourBleed||e.paddingBleed)&&applyBleed(e,t,o,o),await Sharp(o,h).png().toFile(t.imagePath)}async function trimImages(t){const e=path_1.join(config_1.buildTempDir,"trimImages");fs_extra_1.ensureDirSync(e),await Promise.all(t.map((t,i)=>{t.originalPath=t.libraryPath,t.libraryPath=path_1.join(e,"spritesheet_js_"+t.uuid+"_image_"+i+++".png");const r=t.trim,a=Sharp(t.originalPath).extract({left:r.x,top:r.y,width:r.rotatedWidth,height:r.rotatedHeight});return t.spriteFrame.isRotated()&&a.rotate(270),a.toFile(t.libraryPath).catch(e=>{console.error(`trimImages(${t.originalPath}) failed!`)})})).catch(t=>{console.error(t),console.error("packer: trimImages failed!")})}exports.packer=packer;class AtlasInfo{constructor(t,e,i,r,a){this.imageUuid="",this.textureUuid="",this.compressed={imagePathNoExt:"",suffixs:[]};const h=t.map(t=>t.uuid);this.imageUuid=HashUuid.calculate([h],HashUuid.BuiltinHashType.AutoAtlasImage)[0],this.textureUuid=this.imageUuid+"@"+require("@editor/asset-db/libs/utils").nameToId("texture"),this.spriteFrameInfos=t,this.width=e,this.height=i,this.name=r,this.imagePath=a.replace(r,this.imageUuid),this.compressed.suffixs.push(path_1.extname(a))}toJSON(){return Object.assign({},this)}}class SpriteFrameInfo{constructor(t,e){if(this.name="",this.spriteFrame=null,this.uuid="",this.imageUuid="",this.textureUuid="",this.file="",this.libraryPath="",this.trim={width:0,height:0,rotatedWidth:0,rotatedHeight:0,x:0,y:0},this.rawWidth=0,this.rawHeight=0,this.width=0,this.height=0,this.originalPath="",this.rotated=!1,!t||!e)return;const i=t.getRect();i.rotatedWidth=t.isRotated()?i.height:i.width,i.rotatedHeight=t.isRotated()?i.width:i.height,this.name=t.displayName,this.spriteFrame=t,this.uuid=t._uuid,this.imageUuid=t.texture._mipmaps[0]._uuid,this.textureUuid=t.texture._uuid,this.file=t.file,this.libraryPath=path_1.join(Editor.Project.path,"library",t.texture._mipmaps[0].url.replace("import://","")),this.trim={rotatedWidth:i.rotatedWidth,rotatedHeight:i.rotatedHeight,x:i.x,y:i.y,width:i.width,height:i.height},this.rawWidth=t.getOriginalSize().width,this.rawHeight=t.getOriginalSize().height,this.width=i.width+2*(e.padding+e.bleed),this.height=i.height+2*(e.padding+e.bleed)}toJSON(){const t=Object.assign({},this);return t.spriteFrame=void 0,t}clone(){const t=new SpriteFrameInfo;return Object.assign(t,this),t}}