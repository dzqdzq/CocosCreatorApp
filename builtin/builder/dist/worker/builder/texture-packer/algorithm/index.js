"use strict";const ipacker=require("max-rects-packing"),MaxRectsBinPack=require("./maxrects");function getRectsFromInputs(e){return e.map(e=>({width:e.width,height:e.height,origin:e}))}function getInputsFromRects(e){return e.map(e=>{let t=e.origin;for(let r in e)"origin"!==r&&(t[r]=e[r]);return t})}function scoreMaxRects(e,t,r,c,i,s){let a=new MaxRectsBinPack(t,r,i).insertRects(e,c),o=0,n=0,l=0,h=0;for(let e=0;e<a.length;e++){let t=a[e];o+=t.width*t.height;let r=t.x+(t.rotated?t.height:t.width),c=t.y+(t.rotated?t.width:t.height);r>l&&(l=r),c>h&&(h=c)}let u=o/(n=l*h);(o>s.packedArea||u>s.score&&o>=s.packedArea)&&(s.packedRects=a,s.unpackedRects=e,s.score=u,s.packedArea=o,s.binWidth=t,s.binHeight=r,s.heuristice=c)}function scoreMaxRectsForAllHeuristics(e,t,r,c,i){for(let s=0;s<=5;s++)4!==s&&scoreMaxRects(getRectsFromInputs(e),t,r,s,c,i)}module.exports={ipacker(e,t,r,c){let i=new ipacker.Packer(t,r,{allowRotate:c}),s=getRectsFromInputs(e);return i.fit(s).rects.map(e=>Object.assign(e.origin,e.fitInfo))},MaxRects(e,t,r,c){let i=0;for(let t=0;t<e.length;t++)i+=e[t].width*e[t].height;let s={packedRects:[],unpackedRects:[],score:-1/0,packedArea:-1/0};if(i<t*r){let a=4;for(let o=a;o<=t;o=Math.min(2*o,t)){for(let t=a;t<=r;t=Math.min(2*t,r)){let a=o*t;if(a>=i){let r=i;for(;;){let i=Math.pow(r,.5);i<=o&&i<=t&&scoreMaxRectsForAllHeuristics(e,i,i,c,s),scoreMaxRectsForAllHeuristics(e,r/t,t,c,s),scoreMaxRectsForAllHeuristics(e,o,r/o,c,s);let n=s.unpackedRects;if(n.length>0){let e=0;for(let t=0;t<n.length;t++)e+=n[t].width*n[t].height;r+=e/2}if(r>=a||0===n.length)break}}if(t>=r)break}if(o>=t)break}}else scoreMaxRectsForAllHeuristics(e,t,r,c,s);return getInputsFromRects(s.packedRects)}};