"use strict";const ipacker=require("max-rects-packing"),MaxRectsBinPack=require("./maxrects");function getRectsFromInputs(e){return e.map(e=>({width:e.width,height:e.height,origin:e}))}function getInputsFromRects(e){return e.map(e=>{const t=e.origin;for(const c in e)"origin"!==c&&(t[c]=e[c]);return t})}function scoreMaxRects(e,t,c,r,s,i){const o=new MaxRectsBinPack(t,c,s).insertRects(e,r);let n=0,a=0,h=0,l=0;for(let e=0;e<o.length;e++){const t=o[e];n+=t.width*t.height;const c=t.x+(t.rotated?t.height:t.width),r=t.y+(t.rotated?t.width:t.height);c>h&&(h=c),r>l&&(l=r)}const u=n/(a=h*l);(n>i.packedArea||u>i.score&&n>=i.packedArea)&&(i.packedRects=o,i.unpackedRects=e,i.score=u,i.packedArea=n,i.binWidth=t,i.binHeight=c,i.heuristice=r)}function scoreMaxRectsForAllHeuristics(e,t,c,r,s){for(let i=0;i<=5;i++)4!==i&&scoreMaxRects(getRectsFromInputs(e),t,c,i,r,s)}module.exports={ipacker(e,t,c,r){const s=new ipacker.Packer(t,c,{allowRotate:r}),i=getRectsFromInputs(e);return s.fit(i).rects.map(e=>Object.assign(e.origin,e.fitInfo))},MaxRects(e,t,c,r){let s=0;for(let t=0;t<e.length;t++)s+=e[t].width*e[t].height;const i={packedRects:[],unpackedRects:[],score:-1/0,packedArea:-1/0};if(s<t*c){const o=4;for(let n=o;n<=t;n=Math.min(2*n,t)){for(let t=o;t<=c;t=Math.min(2*t,c)){const o=n*t;if(o>=s){let c=s;for(;;){const s=Math.pow(c,.5);s<=n&&s<=t&&scoreMaxRectsForAllHeuristics(e,s,s,r,i),scoreMaxRectsForAllHeuristics(e,c/t,t,r,i),scoreMaxRectsForAllHeuristics(e,n,c/n,r,i);const a=i.unpackedRects;if(a.length>0){let e=0;for(let t=0;t<a.length;t++)e+=a[t].width*a[t].height;c+=e/2}if(c>=o||0===a.length)break}}if(t>=c)break}if(n>=t)break}}else scoreMaxRectsForAllHeuristics(e,t,c,r,i);return getInputsFromRects(i.packedRects)}};