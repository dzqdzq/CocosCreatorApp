"use strict";var __createBinding=this&&this.__createBinding||(Object.create?function(t,e,s,i){void 0===i&&(i=s),Object.defineProperty(t,i,{enumerable:!0,get:function(){return e[s]}})}:function(t,e,s,i){void 0===i&&(i=s),t[i]=e[s]}),__setModuleDefault=this&&this.__setModuleDefault||(Object.create?function(t,e){Object.defineProperty(t,"default",{enumerable:!0,value:e})}:function(t,e){t.default=e}),__importStar=this&&this.__importStar||function(t){if(t&&t.__esModule)return t;var e={};if(null!=t)for(var s in t)"default"!==s&&Object.prototype.hasOwnProperty.call(t,s)&&__createBinding(e,t,s);return __setModuleDefault(e,t),e};Object.defineProperty(exports,"__esModule",{value:!0}),exports.SingleTask=void 0;const events_1=require("events"),path_1=require("path"),fs_extra_1=require("fs-extra"),Editor=__importStar(require("editor")),console_1=require("./utils/console"),utils_1=require("./utils"),tempDir=path_1.join(Editor.Project.tmpDir,"builder","compile");class SingleTask extends events_1.EventEmitter{constructor(t,e,s,i){super(),this.taskInfo={},this.options=null,this.progress=0,this.errMessage="",this.logDest="",this.name=t,this.hooksInfo=e,this.root=s,this.options=i,this.taskInfo={[`onBefore${t}`]:.2,[t]:.2,[`onAfter${t}`]:.2}}init(){if(this.logDest=path_1.join(Build.projectTempDir,this.name,path_1.basename(this.root)+".log"),fs_extra_1.outputFileSync(this.logDest,""),this.console=new console_1.MessageConsole((t,e)=>{if(!t||!e)return;let s=`${utils_1.getCurrentTime()}-${t}:[${this.name}]`;try{Array.isArray(e)?e.forEach(t=>{s+=`${JSON.stringify(t)}`}):s+=JSON.stringify(e),fs_extra_1.appendFileSync(this.logDest,s)}catch(t){}}),!this.options)try{this.options=fs_extra_1.readJSONSync(path_1.join(this.root,SingleTask.optionsFileName)),console.debug(`Use build file ${SingleTask.optionsFileName} in root(${this.root})`)}catch(t){console.warn("Get cache build options failed!")}}async run(){this.init(),this.updateProcess("init options success",.1),fs_extra_1.emptyDirSync(tempDir);try{for(const t of Object.keys(this.taskInfo))await this._runPluginTask(t)}catch(t){console.warn(t),this.errMessage=t.toString()}}async _runPluginTask(t){for(let e=0;e<this.hooksInfo.pkgNameOrder.length;e++){const s=this.hooksInfo.pkgNameOrder[e],i=this.hooksInfo.infos[s];let o,r=this.taskInfo[t]*(e+1);try{(o=require(i.path))[t]&&(this.updateProcess(`${s}:(${t}) start...`),this.console.debug(`// ---- ${s}:(${t}) ----`),i.internal?await o[t].call(this,this.root,this.options):await o[t](this.root,this.options),this.console.debug(`// ---- ${s}:(${t}) success ----`),this.updateProcess(`${s}:(${t}) âˆš`,r))}catch(e){const i=Editor.I18n.t("builder.error.run_hooks_failed",{pkgName:s,funcName:t});if(o&&o.throwError)throw this.updateProcess(i,0,"error"),e;this.updateProcess(i,0,"warn"),this.updateProcess(e,0,"warn")}}}updateProcess(t,e=0,s="debug"){this.progress=Editor.Utils.Math.clamp01(this.progress+e),this.emit("update",t,this.progress),this.console[s](t)}}exports.SingleTask=SingleTask,SingleTask.optionsFileName="cocos.compile.config.json";