"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.packer=void 0;const fs_extra_1=require("fs-extra"),path_1=require("path"),config_1=require("./config"),pac_info_1=require("./pac-info"),Algorithm=require("./algorithm"),Sharp=require("sharp"),applyBleed=require("./bleeding").applyBleed;async function packer(t,e){const r=filterUnpacked(t);console.debug("Start trim sprite image ..."),await trimImages(r.result),console.debug("determine atlas size...");const a=determineAtlasSize(r.result,e),i=Array.from(r.unpackedImages.concat(a.unpackedImages));return console.debug("Start generate atlas image..."),await Promise.all(a.packAtlas.map(t=>generateAtlas(t,e))),{atlases:a.packAtlas.map(t=>t.toJSON()),unpackedImages:i.map(t=>({imageUuid:t.uuid,libraryPath:t._file})),pacUuid:t[0]._pacUuid}}function determineAtlasSize(t,e){const r=t.concat(),a=[];let i=[],o=Algorithm[e.algorithm];o||(console.warn(`determineAtlasSize failed: Can not find algorithm ${e.algorithm}, use MaxRects`),o=Algorithm.MaxRects);const n=e.maxWidth,h=e.maxHeight,l=e.allowRotation;let s=0;for(;r.length>0;){const t=o(r,n,h,l);if(0===t.length){i=i.concat(r);break}t.forEach(t=>{r.splice(r.indexOf(t),1)});let c=0,d=0;for(let e=0;e<t.length;e++){const r=t[e];r.rotatedWidth=r.rotated?r.height:r.width,r.rotatedHeight=r.rotated?r.width:r.height,r.trim.rotatedWidth=r.rotated?r.trim.height:r.trim.width,r.trim.rotatedHeight=r.rotated?r.trim.width:r.trim.height;const a=r.x+r.rotatedWidth,i=r.y+r.rotatedHeight;a>c&&(c=a),i>d&&(d=i)}const p=e.name+"-"+s;s++;const g=(0,path_1.join)(e.destDir,p+"."+e.format);a.push(new pac_info_1.AtlasInfo(t,c,d,p,g))}return a.forEach(t=>{applySquareAndPowerConstraints(t,e.forceSquared,e.powerOfTwo),t.spriteFrameInfos.forEach(t=>{t.trim.x=t.x+e.padding+e.bleed,t.trim.y=t.y+e.padding+e.bleed})}),{packAtlas:a,unpackedImages:i}}function applySquareAndPowerConstraints(t,e,r){e&&(t.width=t.height=Math.max(t.width,t.height)),r&&(t.width=roundToPowerOfTwo(t.width),t.height=roundToPowerOfTwo(t.height))}function roundToPowerOfTwo(t){if("number"!=typeof t)return 0;let e=2;for(;t>e;)e*=2;return e}function filterUnpacked(t){const e=[],r=t.filter(t=>t.trim.width>0&&t.trim.height>0||(t.width=t.rawWidth,t.height=t.rawHeight,e.push(t),!1));return{unpackedImages:e,result:r}}async function generateAtlas(t,e){const r=t.spriteFrameInfos,a=t.width,i=t.height,o={raw:{width:a,height:i,channels:4}};let n=await Sharp({create:{width:a,height:i,channels:4,background:{r:0,b:0,g:0,alpha:0}}}).toBuffer();let h=0;let l=0,s=[];for(let t=0;t<r.length;t++){const e=r[t],a=e.trim.x,i=e.trim.y;h+=e.trim.width*e.trim.height*4,l++;try{(h>=2097152||l>=100)&&(n=await Sharp(n,o).composite(s).toBuffer(),s=[],h=0,l=0);let t=Sharp(e._libraryPath);e.rotated&&(t=t.rotate(90));const r=await t.toBuffer();s.push({input:r,left:a,top:i})}catch(t){console.error(`Handle image [${e._libraryPath} error]. \n Origin path is [${e.originalPath}:${e.name}]. \n Error : ${t.toString()}`);continue}}n=await Sharp(n,o).composite(s).toBuffer(),(e.contourBleed||e.paddingBleed)&&applyBleed(e,t,n,n),await Sharp(n,o).png().toFile(t.imagePath)}async function trimImages(t){const e=(0,path_1.join)(config_1.buildTempDir,"trimImages");(0,fs_extra_1.ensureDirSync)(e),await Promise.all(t.map((t,r)=>{t.originalPath=t._libraryPath,t._libraryPath=(0,path_1.join)(e,"spritesheet_js_"+t.uuid+"_image_"+r+++".png");const a=t.trim,i=Sharp(t.originalPath).extract({left:a.x,top:a.y,width:a.rotatedWidth,height:a.rotatedHeight});return t.rotated&&i.rotate(270),i.toFile(t._libraryPath).catch(e=>{console.error(`trimImages(${t.originalPath}) failed!`),console.warn(e)})})).catch(t=>{console.error(t),console.error("packer: trimImages failed!")})}exports.packer=packer;