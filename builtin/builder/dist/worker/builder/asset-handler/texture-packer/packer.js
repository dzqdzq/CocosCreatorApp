"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.packer=packer;const fs_extra_1=require("fs-extra"),path_1=require("path"),config_1=require("./config"),pac_info_1=require("./pac-info"),Algorithm=require("./algorithm"),Sharp=require("sharp"),applyBleed=require("./bleeding").applyBleed;async function packer(t,e){var a=filterUnpacked(t),r=(console.debug("Start trim sprite image ..."),await trimImages(a.result),console.debug("determine atlas size..."),determineAtlasSize(a.result,e)),a=Array.from(a.unpackedImages.concat(r.unpackedImages));return console.debug("Start generate atlas image..."),await Promise.all(r.packAtlas.map(t=>generateAtlas(t,e))),{atlases:r.packAtlas.map(t=>t.toJSON()),unpackedImages:a.map(t=>({imageUuid:t.uuid,libraryPath:t._file})),pacUuid:t[0]._pacUuid}}function determineAtlasSize(t,r){const i=t.concat();var o=[];let n=[],h=Algorithm[r.algorithm];h||(console.warn(`determineAtlasSize failed: Can not find algorithm ${r.algorithm}, use MaxRects`),h=Algorithm.MaxRects);var l=r.maxWidth,d=r.maxHeight,s=r.allowRotation;let c=0;for(;0<i.length;){var p=h(i,l,d,s);if(0===p.length){n=n.concat(i);break}p.forEach(t=>{i.splice(i.indexOf(t),1)});let e=0,a=0;for(let t=0;t<p.length;t++){var g=p[t],m=(g.rotatedWidth=g.rotated?g.height:g.width,g.rotatedHeight=g.rotated?g.width:g.height,g.trim.rotatedWidth=g.rotated?g.trim.height:g.trim.width,g.trim.rotatedHeight=g.rotated?g.trim.width:g.trim.height,g.x+g.rotatedWidth),g=g.y+g.rotatedHeight;m>e&&(e=m),g>a&&(a=g)}var u=r.name+"-"+c,f=(c++,(0,path_1.join)(r.destDir,u+"."+r.format));o.push(new pac_info_1.AtlasInfo(p,e,a,u,f))}return o.forEach(t=>{applySquareAndPowerConstraints(t,r.forceSquared,r.powerOfTwo),t.spriteFrameInfos.forEach(t=>{t.trim.x=t.x+r.padding+r.bleed,t.trim.y=t.y+r.padding+r.bleed})}),{packAtlas:o,unpackedImages:n}}function applySquareAndPowerConstraints(t,e,a){e&&(t.width=t.height=Math.max(t.width,t.height)),a&&(t.width=roundToPowerOfTwo(t.width),t.height=roundToPowerOfTwo(t.height))}function roundToPowerOfTwo(t){if("number"!=typeof t)return 0;let e=2;for(;t>e;)e*=2;return e}function filterUnpacked(t){const e=[];t=t.filter(t=>0<t.trim.width&&0<t.trim.height||(t.width=t.rawWidth,t.height=t.rawHeight,e.push(t),!1));return{unpackedImages:e,result:t}}async function generateAtlas(t,e){var a=t.spriteFrameInfos;const r=t.width,i=t.height;var o={raw:{width:r,height:i,channels:4}};let n=await Sharp({create:{width:r,height:i,channels:4,background:{r:0,b:0,g:0,alpha:0}}}).toBuffer();let h=0;let l=0,d=[];for(let t=0;t<a.length;t++){var s=a[t],c=s.trim.x,p=s.trim.y;const r=s.trim.width,i=s.trim.height;h+=r*i*4,l++;try{(2097152<=h||100<=l)&&(n=await Sharp(n,o).composite(d).toBuffer(),d=[],h=0,l=0);let t=Sharp(s._libraryPath);var g=await(t=s.rotated?t.rotate(90):t).toBuffer();d.push({input:g,left:c,top:p})}catch(t){console.error(`Handle image [${s._libraryPath} error]. 
 Origin path is [${s.originalPath}:${s.name}]. 
 Error : `+t.toString());continue}}n=await Sharp(n,o).composite(d).toBuffer(),(e.contourBleed||e.paddingBleed)&&applyBleed(e,t,n,n),await Sharp(n,o).png().toFile(t.imagePath)}async function trimImages(t){const a=(0,path_1.join)(config_1.buildTempDir,"trimImages");(0,fs_extra_1.ensureDirSync)(a),await Promise.all(t.map((e,t)=>{e.originalPath=e._libraryPath,e._libraryPath=(0,path_1.join)(a,"spritesheet_js_"+e.uuid+"_image_"+t+++".png");t=e.trim,t=Sharp(e.originalPath).extract({left:t.x,top:t.y,width:t.rotatedWidth,height:t.rotatedHeight});return e.rotated&&t.rotate(270),t.toFile(e._libraryPath).catch(t=>{throw console.error(`trimImages(${e.originalPath}) failed!`),t})}))}