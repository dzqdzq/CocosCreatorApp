"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.BundleManager=void 0;const fs_extra_1=require("fs-extra"),path_1=require("path"),texture_compress_1=require("../texture-compress"),bundle_1=require("./bundle"),texture_compress_2=require("./texture-compress"),index_1=require("../texture-packer/index"),pac_info_1=require("../texture-packer/pac-info"),pac_1=require("./pac"),cconb_1=require("./cconb"),script_1=require("../script"),bundle_utils_1=require("../../../../share/bundle-utils"),asset_library_1=require("../../manager/asset-library"),asset_1=require("../../manager/asset"),utils_1=require("../../utils"),global_1=require("./../../../global"),json_group_1=require("./json-group"),utils_2=require("../../../../share/utils"),common_options_validator_1=require("../../../../share/common-options-validator"),plugin_1=require("../../../plugin"),task_base_1=require("../../manager/task-base"),load_script_1=require("../script/load-script"),utils_3=require("../../../../share/utils"),{MAIN:MAIN,START_SCENE:START_SCENE,INTERNAL:INTERNAL,RESOURCES:RESOURCES}=bundle_utils_1.BuiltinBundleName;class BundleManager extends task_base_1.BuildTaskBase{get bundleGroupInPriority(){if(this._bundleGroupInPriority)return this._bundleGroupInPriority;let e=new Array(21);return this.bundles.forEach(s=>{e[s.priority-1]||(e[s.priority-1]=[]),e[s.priority-1].push(s)}),e=e.filter(e=>e).reverse(),this._bundleGroupInPriority=e,e}constructor(e,s){super("Bundle Task"),this.bundleMap={},this.bundles=[],this._pacAssets=[],this.packResults=[],this.hookMap={onBeforeBundleInit:"onBeforeBundleInit",onAfterBundleInit:"onAfterBundleInit",onBeforeBundleDataTask:"onBeforeBundleDataTask",onAfterBundleDataTask:"onAfterBundleDataTask",onBeforeBundleBuildTask:"onBeforeBundleBuildTask",onAfterBundleBuildTask:"onAfterBundleBuildTask"},this.pipeline=[this.initOptions,this.hookMap.onBeforeBundleInit,this.loadScript,this.initBundle,this.hookMap.onAfterBundleInit,this.hookMap.onBeforeBundleDataTask,this.initAsset,this.bundleDataTask,this.hookMap.onAfterBundleDataTask,this.hookMap.onBeforeBundleBuildTask,this.clearBundleDest,this.buildScript,this.buildAsset,this.hookMap.onAfterBundleBuildTask,this.outputBundle],this.options=e,e.skipCompressTexture||(this.updateProcess("Skip compress image"),this.imageCompressManager=new texture_compress_1.TextureCompress(e.platform),this.imageCompressManager.on("update-progress",e=>{this.updateProcess(e)})),this._task=s,this.destDir=e.dest&&Editor.UI.__protected__.File.resolveToRaw(e.dest)||(0,path_1.join)(Editor.Project.path,"build","assetBundle"),this.scriptBuilder=new script_1.ScriptBuilder,this.cache=s?s.cache:new asset_1.BuilderAssetCache,this.hooksInfo=s?s.hooksInfo:plugin_1.pluginManager.getHooksInfo(e.platform)}async loadScript(){await(0,load_script_1.loadScript)(this.cache)}async initStaticBundleConfig(){const e=await Editor.Profile.getProject("builder","bundleConfig.custom")||{},s=await Editor.Message.request("builder","query-bundle-config");e.default||(e.default=bundle_utils_1.DefaultBundleConfig);const t={};Object.keys(e).forEach(i=>{const n=e[i].configs;t[i]={},Object.keys(n).forEach(e=>{if(!s[e])return;const a=(0,bundle_utils_1.transformPlatformSettings)(n[e],s[e].platformConfigs);Object.assign(t[i],a)})}),BundleManager.BundleConfigs=t}getUserConfig(e="default"){const s=BundleManager.BundleConfigs[e];return s?s[this.options.platform]:null}async initOptions(){var e;await(0,common_options_validator_1.checkProjectSetting)(this.options),this.options.buildScriptParam={experimentalEraseModules:this.options.experimentalEraseModules,outputName:"project",flags:Object.assign({DEBUG:!!this.options.debug},this.options.flags),polyfills:this.options.polyfills,hotModuleReload:!1,platform:"HTML5",commonDir:"",bundleCommonChunk:null!==(e=this.options.bundleCommonChunk)&&void 0!==e&&e},this.options.assetSerializeOptions={"cc.EffectAsset":{glsl1:this.options.includeModules.includes("gfx-webgl"),glsl3:this.options.includeModules.includes("gfx-webgl2"),glsl4:!1},exportCCON:!1}}clearBundleDest(){this.bundles.forEach(e=>{e.output&&(0,fs_extra_1.emptyDirSync)(e.dest)})}async initAsset(){await this.initBundleRootAssets(),await this.initBundleShareAssets(),await this.initBundleConfig()}async initBundleConfig(){for(const e of this.bundles)e.initConfig(),this.options.preview&&await e.initAssetPaths()}async buildAsset(){await this.packImage(),await this.compressImage(),await this.outputAssets()}async run(){return this.options.bundleCommonChunk=!0,await this.runAllTask(),!0}async outputBundle(){this.updateProcess("Output asset in bundles start"),await Promise.all(this.bundles.map(async e=>{e.output&&await e.build()})),this.updateProcess("Output asset in bundles success")}addBundle(e){if(this.bundleMap[e.name]){const s=e.name+Date.now();console.error(Editor.I18n.t("builder.asset_bundle.duplicate_name_messaged_auto_rename",{name:e.name,newName:s,url:this.bundleMap[e.name].root,newUrl:e.root})),e.name=s}this.bundleMap[e.name]=new bundle_1.Bundle(e)}getDefaultBundleConfig(e){const s=(0,path_1.join)(this.destDir,e),t=BundleManager.internalBundlePriority[e];return{name:e,dest:s,root:"",scriptDest:(0,path_1.join)(s,global_1.BuildGlobalInfo.SCRIPT_NAME),priority:t||1,compressionType:bundle_utils_1.BundleCompressionTypes.MERGE_DEP,isRemote:!1,md5Cache:this.options.md5Cache,debug:this.options.debug}}async initBundle(){await this.initStaticBundleConfig();const e=this.options,s=[MAIN,START_SCENE,INTERNAL],t={};this.updateProcess("Init all bundles start...");const i=await asset_library_1.buildAssetLibrary.queryAssetsByOptions({isBundle:!0});e.bundleConfigs=e.bundleConfigs||[],e.bundleConfigs.length&&e.bundleConfigs.forEach(e=>{if(s.includes(e.name))return void(t[e.name]=e);const i=this.patchProjectBundleConfig(e);i?this.addBundle(i):console.warn("Invalid bundle config: ",e)});const n=!e.bundleConfigs.length&&!!this._task;if(e.buildBundleOnly||i.forEach(e=>{const s=this.patchProjectBundleConfig({root:e.url,name:""});s&&!this.bundleMap[s.name]&&(s.output=n,this.addBundle(s))}),e.buildBundleOnly&&!Object.keys(t).length||this.initInternalBundleConfigs(t),this.bundles=Object.values(this.bundleMap).sort((e,s)=>s.priority-e.priority||(0,utils_3.compareUUID)(e.name,s.name)),!this.bundles.length)throw new Error("Invalid bundle config, please check your bundle config");this.updateProcess(`Num of bundles: ${this.bundles.length}...`)}initInternalBundleConfigs(e){const s=[MAIN,START_SCENE,INTERNAL],t=!this.options.buildBundleOnly;s.forEach(s=>{var i,n;if(s===START_SCENE&&!this.options.startSceneAssetBundle&&!e[s])return;if(this.options.buildBundleOnly&&!e[s])return;let a=this.getDefaultBundleConfig(s);const o=e[s]||{name:s};if(a=(0,utils_2.defaultsDeep)(Object.assign({},o),a),e[s]=a,a.output=null!==(i=o.output)&&void 0!==i?i:t,o.name===MAIN){const e=this.options.mainBundleIsRemote;!e||this.options.server||this.options.preview||console.warn(Editor.I18n.t("builder.warn.assetBundleIsRemoteInvalid",{directoryName:"main"})),a.isRemote=o.isRemote||e,a.compressionType=o.compressionType||this.options.mainBundleCompressionType}else a.isRemote=!!(null!==(n=o.isRemote)&&void 0!==n?n:!this.options.startSceneAssetBundle&&e[MAIN].isRemote),o.compressionType||(a.compressionType=this.options.startSceneAssetBundle||e[MAIN].compressionType===bundle_utils_1.BundleCompressionTypes.MERGE_DEP?bundle_utils_1.BundleCompressionTypes.MERGE_ALL_JSON:e[MAIN].compressionType);o.dest||"subpackage"!==a.compressionType?o.dest||(a.dest=a.isRemote?(0,path_1.join)((0,path_1.dirname)(this.destDir),global_1.BuildGlobalInfo.REMOTE_HEADER,a.name):(0,path_1.join)(this.destDir,a.name),a.scriptDest=(0,path_1.join)(a.dest,global_1.BuildGlobalInfo.SCRIPT_NAME)):(a.dest=(0,path_1.join)((0,path_1.dirname)(this.destDir),global_1.BuildGlobalInfo.SUBPACKAGES_HEADER,a.name),a.scriptDest=(0,path_1.join)(a.dest,global_1.BuildGlobalInfo.SCRIPT_NAME)),this.options.moveRemoteBundleScript&&a.isRemote&&!o.scriptDest&&(a.scriptDest=this._task?(0,path_1.join)(this._task.result.paths.bundleScripts,a.name,Build.SCRIPT_NAME):(0,path_1.join)(a.dest,global_1.BuildGlobalInfo.SCRIPT_NAME)),this.addBundle(a)})}patchProjectBundleConfig(e){if(!e.root)return console.debug(`Invalid Bundle config with bundle root:${e.root}`),null;const s=asset_library_1.buildAssetLibrary.url2uuid(e.root);if(!s)return console.debug(`Invalid Bundle config with bundle ${e.root}`),null;const t=asset_library_1.buildAssetLibrary.getAssetInfo(s);if(!t)return console.debug(`Invalid Bundle config with bundle ${e.root}`),null;const{bundleFilterConfig:i,priority:n,bundleConfigID:a,bundleName:o}=t.meta.userData,r=e.name||o||(0,bundle_utils_1.getBundleDefaultName)(t),u=this.getUserConfig(a);let l=this.getDefaultBundleConfig(r);const d=(0,utils_2.defaultsDeep)({compressionType:u&&u.compressionType,isRemote:u&&u.isRemote,priority:n,bundleFilterConfig:i,name:r},e);return l=(0,utils_2.defaultsDeep)(d,l),u||console.warn(`Invalid Bundle config ID ${a} in bundle ${e.root}, the bundle config will use the default config ${JSON.stringify(l)}`),!l.isRemote||this.options.server||this.options.preview||console.warn(Editor.I18n.t("builder.warn.assetBundleIsRemoteInvalid",{directoryName:r})),e.dest||"subpackage"!==l.compressionType?!e.dest&&l.isRemote&&(l.dest=(0,path_1.join)((0,path_1.dirname)(this.destDir),global_1.BuildGlobalInfo.REMOTE_HEADER,l.name),l.scriptDest=(0,path_1.join)(l.dest,global_1.BuildGlobalInfo.SCRIPT_NAME)):(l.dest=(0,path_1.join)((0,path_1.dirname)(this.destDir),global_1.BuildGlobalInfo.SUBPACKAGES_HEADER,l.name),l.scriptDest=(0,path_1.join)(l.dest,global_1.BuildGlobalInfo.SCRIPT_NAME)),this.options.moveRemoteBundleScript&&l.isRemote&&!e.scriptDest&&(l.scriptDest=this._task?(0,path_1.join)(this._task.result.paths.bundleScripts,l.name,Build.SCRIPT_NAME):(0,path_1.join)(l.dest,global_1.BuildGlobalInfo.SCRIPT_NAME)),l}async initBundleRootAssets(){if(this.updateProcess("Init bundle root assets start..."),this.bundleMap[INTERNAL]){const e=await queryPreloadAssetList(this.options.includeModules);console.debug(`Query preload assets from cc.config.json: ${e.toString()}`),e.forEach(e=>{this.bundleMap[INTERNAL].addRootAsset(asset_library_1.buildAssetLibrary.getAssetInfo(e))})}const e=this.bundleMap[START_SCENE]||this.bundleMap[MAIN],s=await asset_library_1.buildAssetLibrary.initAssets();for(let t=0;t<s.length;t++){const i=s[t];let n=this.bundles.find(e=>i.url.startsWith(e.root+"/"));if("cc.Script"!==i.type)if("cc.SceneAsset"!==i.type||this.options.scenes&&!this.options.scenes.find(e=>e.uuid===i.uuid))"auto-atlas"===i.importer&&this._pacAssets.push(i.uuid),n&&"cc.SceneAsset"!==i.type&&n.addRootAsset(i);else{if(e&&this.options.startScene===i.uuid){e.addRootAsset(i);continue}n?n.addRootAsset(i):this.bundleMap[MAIN]&&this.bundleMap[MAIN].addRootAsset(i)}else(n=n||e)&&n.addAsset(i)}if(e&&(this.options.renderPipeline&&e.addRootAsset(asset_library_1.buildAssetLibrary.getAssetInfo(this.options.renderPipeline)),this.options.physicsConfig.defaultMaterial)){const s=asset_library_1.buildAssetLibrary.getAssetInfo(this.options.physicsConfig.defaultMaterial);e.addRootAsset(s)}this.updateProcess("Init bundle root assets success...")}async initBundleShareAssets(){if(1===this.bundles.length||this.options.preview)return;this.updateProcess("Init bundle share assets start...");const e={},s=this;async function t(i,n,a,o){var r,u;if(a.has(i))return;const l=asset_library_1.buildAssetLibrary.getAssetInfo(i);if(!l)return void(o||console.warn(Editor.I18n.t("builder.error.missing_asset",{uuid:`{asset(${i})}`})));if(a.add(i),n.addAsset(l),(0,cconb_1.hasCCONFormatAssetInLibrary)(l)){const e=(0,cconb_1.getDesiredCCONExtensionMap)(s.options.assetSerializeOptions);(null!==(r=(u=n.config.extensionMap)[e])&&void 0!==r?r:u[e]=[]).push(l.uuid)}if(e[i])return void n.addRedirect(i,e[i]);const d=await asset_library_1.buildAssetLibrary.getDependUuids(i);await Promise.all(d.map(async e=>await t(e,n,a,i)))}const i=this.bundleGroupInPriority;for(const s of i)await Promise.all(s.map(async e=>{const s=new Set;return await Promise.all(e.rootAssets.map(async i=>await t(i,e,s)))})),s.forEach(s=>{s.assetsWithoutRedirect.forEach(t=>{e[t]||(e[t]=s.name)})});this.updateProcess("Init bundle share assets success...")}async bundleDataTask(){const e=this.imageCompressManager;e&&await e.init(),await Promise.all(this.bundles.map(async s=>{s.output&&(await(0,json_group_1.handleJsonGroup)(s),e&&await(0,texture_compress_2.bundleDataTask)(s,e))}))}async compressImage(){this.imageCompressManager&&(this.updateProcess("Compress image start..."),await this.imageCompressManager.run(),this.updateProcess("Compress image success..."))}async packImage(){this.updateProcess("Pack Images start"),Editor.Metrics.trackTimeStart("builder:pack-auto-atlas-image");let e=[];this.options.buildBundleOnly?this._pacAssets.reduce((e,s)=>{const t=asset_library_1.buildAssetLibrary.getAssetInfo(s);return this.bundles.some(e=>!!e.output&&(!(!Editor.Utils.Path.contains(t.url,e.root)&&!Editor.Utils.Path.contains(e.root,t.url))||void 0))&&e.push(t),e},e):e=this._pacAssets.map(e=>asset_library_1.buildAssetLibrary.getAssetInfo(e));const s=new Set;this.bundles.forEach(e=>e.assets.forEach(e=>s.add(e))),this.packResults=await(await(new index_1.TexturePacker).init(e,Array.from(s))).pack();const t=this.imageCompressManager,i=[];this.bundles.map(e=>i.push(...e._assets));const n={};await Promise.all(this.packResults.map(async e=>{const s=e.result.atlases,a=asset_library_1.buildAssetLibrary.getAssetInfo(e.uuid);(0,pac_info_1.createAssetInstance)(s,a,e.spriteFrames).forEach(e=>{this.cache.addInstance(e)}),await collectDependAssets(e.uuid,i,n);for(const s of e.spriteFrameInfos)await collectDependAssets(s.uuid,i,n),await collectDependAssets(s.textureUuid,i,n),n[s.textureUuid]&&(n[s.textureUuid]=n[s.textureUuid].filter(e=>e!==s.uuid),n[s.textureUuid].length||delete n[s.textureUuid]),await collectDependAssets(s.imageUuid,i,n),n[s.imageUuid]&&(n[s.imageUuid]=n[s.imageUuid].filter(e=>e!==s.textureUuid),n[s.imageUuid].length||delete n[s.imageUuid],t&&t.removeTask((0,utils_1.queryImageAssetFromSubAssetByUuid)(s.uuid)));await Promise.all(s.map(async s=>{await(0,pac_1.sortBundleInPac)(this.bundles,s,e,n,t)}))})),await Editor.Metrics.trackTimeEnd("builder:pack-auto-atlas-image",{output:!0}),this.updateProcess("Pack Images success")}async buildScript(){this.updateProcess("Build script in bundle start"),this.options.buildScriptParam&&!this.options.buildScriptParam.commonDir&&(this.options.buildScriptParam.commonDir=(0,path_1.join)(this.destDir,"src","chunks")),await this.scriptBuilder.initProjectOptions(this.options);const e=await this.scriptBuilder.buildBundleScript(this.bundles);return this.updateProcess("Build script in bundle success"),e}async outputAssets(){this.updateProcess("Ouput asset in bundles start");const e=new Set;await Promise.all(this.bundles.map(async s=>{s.output&&(this.imageCompressManager&&await(0,texture_compress_2.bundleOutputTask)(s,this.cache),await(0,json_group_1.outputJsonGroup)(s,this),await Promise.all(s.assetsWithoutRedirect.map(async t=>{if(t.length<=15||s.compressTask[t])return Promise.resolve();const i=asset_library_1.buildAssetLibrary.getAssetInfo(t);i?(e.has(t)||(e.add(t),await checkEffectTextureMipmap(i,t)),await copyAssetFile(i,s,this.options)):console.error(`Can not get asset info with uuid(${t})`)})))})),this.updateProcess("Output asset in bundles success")}async handleHook(e,s,...t){s?await e.call(this,this.options,this.bundles,this.cache):await e()}async runAllTask(){const e=1/this.pipeline.length;for(const s of this.pipeline)"string"==typeof s?await this.runPluginTask(s,e):"function"==typeof s&&await this.runBuildTask(s,e)}async runBuildTask(e,s){if(this.breakResolve)return this.breakResolve(),void await this.onError(new Error(`Build task ${this.options.taskName||this.options.outputName} is break!`));try{await e.bind(this)(),this.updateProcess(`run bundle task ${e.name} success!`,s)}catch(e){this.updateProcess("run bundle task failed!",s),await this.onError(e)}}}async function collectDependAssets(e,s,t){if(s.includes(e)){const s=await asset_library_1.buildAssetLibrary.queryAssetDependeds(e);s&&s.length&&(t[e]=s)}}exports.BundleManager=BundleManager,BundleManager.BuiltinBundleName=bundle_utils_1.BuiltinBundleName,BundleManager.BundleConfigs={},BundleManager.internalBundlePriority={[MAIN]:7,[START_SCENE]:20,[INTERNAL]:21,[RESOURCES]:8};const featuresWithDependencies=[],preloadAssets=[],LIBRARY_NAME="library";function copyAssetFile(e,s,t){const i=[".json"];return Promise.all(Object.keys(e.library).map(n=>{if(i.includes(n))return Promise.resolve();if(n.startsWith("__"))return Promise.resolve();const a=(0,cconb_1.isCCONAssetInLibrary)(e,n),o=a,r=(0,path_1.join)(s.dest,o?s.importBase:s.nativeBase),u=e.library[n],l=(0,path_1.relative)((0,path_1.join)(Editor.Project.path,LIBRARY_NAME),u);if(!(0,fs_extra_1.existsSync)(u))return console.error(Editor.I18n.t("builder.error.missing_import_files",{path:`{link(${u})}`,url:`{asset(${e.url})}`})),Promise.resolve();const d=(0,path_1.join)((0,path_1.join)(r,l));if(a){const s=!(t.assetSerializeOptions&&t.assetSerializeOptions.exportCCON);return asset_library_1.buildAssetLibrary.outputCCONAsset(e.uuid,d,s,t)}return(0,fs_extra_1.existsSync)(d)?Promise.resolve():(0,fs_extra_1.copy)(u,d)}))}function traversalDependencies(e,s){e.forEach(e=>{if(s[e]&&!featuresWithDependencies.includes(e)&&(featuresWithDependencies.push(e),s[e].dependentAssets&&preloadAssets.push(...s[e].dependentAssets),s[e].dependentModules)){traversalDependencies(s[e].dependentModules,s)}})}async function queryPreloadAssetList(e){const s=(await Editor.Message.request("engine","query-engine-info")).typescript.path,t=(await(0,fs_extra_1.readJSON)((0,path_1.join)(s,"cc.config.json"))).features;return featuresWithDependencies.length=0,preloadAssets.length=0,traversalDependencies(e,t),Array.from(new Set(preloadAssets))}async function checkEffectTextureMipmap(e,s){try{if("cc.Material"===e.type){const s=await asset_library_1.buildAssetLibrary.getInstance(e);if(s.effectAsset&&s.effectAsset._uuid){const e=await asset_library_1.buildAssetLibrary.getInstance(asset_library_1.buildAssetLibrary.getAssetInfo(s.effectAsset._uuid));e.techniques[s._techIdx].passes.forEach(async(t,i)=>{if(t.properties&&t.properties.mainTexture&&t.properties.mainTexture.requireMipmaps){const t=s._props&&s._props[i];if(t.mainTexture&&t.mainTexture._uuid){const s=await asset_library_1.buildAssetLibrary.getMeta(t.mainTexture._uuid);["nearest","linear"].includes(s.userData.mipfilter)||console.warn(Editor.I18n.t("builder.warn.requireMipmaps",{effectUUID:e._uuid,textureUUID:t.mainTexture._uuid}))}}})}}}catch(e){console.debug(e)}}