"use strict";var __importDefault=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(exports,"__esModule",{value:!0}),exports.queryCompressCache=exports.previewCompressImage=exports.TextureCompress=void 0;const fs_extra_1=require("fs-extra"),path_1=require("path"),minimaps_1=require("./minimaps"),compress_tool_1=require("./compress-tool"),cc_1=require("cc"),asset_library_1=require("../../manager/asset-library"),utils_1=require("./utils"),plugin_1=require("../../../plugin"),metric_1=require("../../metric"),stream_1=require("stream"),os_1=require("os"),numCPUs=(0,os_1.cpus)().length,sharp_1=__importDefault(require("sharp")),lodash_1=__importDefault(require("lodash")),utils_2=require("../../../../share/utils");class TextureCompress extends stream_1.EventEmitter{constructor(e){super(),this._taskMap={},this._waitingCompressQueue=new Set,this._compressAssetLen=0,this._compressExecuteInfo=null,this.platform=e}static async initCommonOptions(){TextureCompress.allTextureCompressConfig=await Editor.Message.request("builder","query-compress-config"),(0,fs_extra_1.existsSync)(TextureCompress.storedCompressInfoPath)?TextureCompress.storedCompressInfo=(0,fs_extra_1.readJsonSync)(TextureCompress.storedCompressInfoPath):TextureCompress.storedCompressInfo={},TextureCompress.enableMipMaps=await Editor.Profile.getProject("builder","textureCompressConfig.genMipmaps")}async init(){await this.updateUserConfig()}async updateUserConfig(){await TextureCompress.initCommonOptions(),TextureCompress.userCompressConfig=await Editor.Profile.getProject("builder","textureCompressConfig");const{customConfigs:e}=TextureCompress.userCompressConfig,s={};e&&Object.values(e).length&&Object.values(e).forEach(e=>{e.overwrite&&(s[e.format]=e.id,console.debug(`compress format (${e.format}) will be overwrited by custom compress ${e.id}(${e.name})`))}),TextureCompress.overwriteFormats=s,TextureCompress._presetIdToCompressOption={}}static queryTextureCompressCache(e){return TextureCompress.storedCompressInfo[e]}addTask(e,s){return this._taskMap[e]?Object.assign(this._taskMap[e],s):this._taskMap[e]=s,this._taskMap[e]}addTaskWithAssetInfo(e){if(this._taskMap[e.uuid])return this._taskMap[e.uuid];if("auto-atlas"===e.importer)return;const s=this.genTaskInfoFromAssetInfo(e);return s?(this._taskMap[e.uuid]=s,s):void 0}genTaskInfoFromAssetInfo(e){if(this._taskMap[e.uuid])return this._taskMap[e.uuid];const s=e.meta.userData.compressSettings;if(!s||!s.useCompressTexture)return null;const t=(0,path_1.extname)(e.source),r=e.library[t]||e.library[".png"];if("auto-atlas"!==e.importer&&!r)return void console.warn(`genTaskInfoFromAssetInfo failed ! Image asset does not exist: ${e.source}`);const o=this.getCompressOptions(s.presetId);return o?{src:r,presetId:s.presetId,compressOptions:o,hasAlpha:e.meta.userData.hasAlpha,mtime:e.mtime,hasMipmaps:!!TextureCompress.enableMipMaps&&(0,minimaps_1.checkHasMipMaps)(e.meta),dest:[],suffix:[]}:void 0}getCompressOptions(e){if(TextureCompress._presetIdToCompressOption[e])return TextureCompress._presetIdToCompressOption[e];const{userPreset:s,defaultConfig:t,customConfigs:r}=TextureCompress.userCompressConfig,{platformConfig:o,customFormats:i}=TextureCompress.allTextureCompressConfig;if(!o[this.platform])return null;const a=o[this.platform].textureCompressConfig;if(!a)return null;const n=a.platformType,m=s[e]||t[e]||t.default;if(!m||!m.options[n])return console.debug(`Invalid compress task: ${JSON.stringify(m)}`),null;const u=a.support,p={};Object.keys(m.options[n]).forEach(e=>{([...u.rgba,...u.rgb].includes(e)||Object.keys(i).includes(e))&&(p[e]=JSON.parse(JSON.stringify(m.options[n][e])))});const c={};return r&&Object.values(r).length&&Object.values(r).forEach(e=>{e.overwrite&&(c[e.format]=e.id,console.debug(`compress format (${e.format}) will be overwrited by custom compress ${e.id}(${e.name})`))}),Object.keys(c).forEach(e=>{p[e]&&(p[c[e]]=p[e],delete p[e])}),Object.keys(p).length?(TextureCompress._presetIdToCompressOption[e]=p,p):null}queryTask(e){return this._taskMap[e]}removeTask(e){delete this._taskMap[e]}async run(e=this._taskMap){console.group("Compress image...");const{customConfigs:s}=TextureCompress.userCompressConfig,t=await this.sortImageTask(e);if(console.debug(`Num of all image compress task ${Object.keys(e).length}, really: ${this._compressAssetLen}, configTasks: ${t.length}`),collectCustomCompressInfo(s),!t.length)return console.debug("No image need to compress"),void console.groupEnd();const r=JSON.parse(JSON.stringify(t)),o=plugin_1.pluginManager.getAssetHandlers("compressTextures");o.pkgNameOrder.length&&(this.emit("update-progress","start compress custom compress hooks..."),Editor.Metrics.trackTimeStart("builder:custom-compress-texture"),await this.customCompressImage(r,o),await Editor.Metrics.trackTimeEnd("builder:custom-compress-texture",{output:!0})),this._waitingCompressQueue=new Set(r),Editor.Metrics.trackTimeStart("builder:compress-texture"),await this.executeCompressQueue();const i=await Editor.Metrics.trackTimeEnd("builder:compress-texture",{output:!0});return console.debug(`builder:compress-texture: ${(0,utils_2.formatMSTime)(i)}`),await Promise.all(t.map(async s=>{(0,fs_extra_1.existsSync)(s.dest)?(e[s.uuid].dest.push(s.dest),e[s.uuid].suffix.push(s.suffix)):console.error(`texture compress task width asset ${s.uuid}, format: ${s.format} failed!`)})),await(0,fs_extra_1.outputJSON)(TextureCompress.storedCompressInfoPath,TextureCompress.storedCompressInfo),console.groupEnd(),console.debug(`Num of sorted image asset: ${Object.keys(e).length}`),e}async sortImageTask(e){const s=[],{textureFormatConfigs:t,formatsInfo:r}=TextureCompress.allTextureCompressConfig,{customConfigs:o}=TextureCompress.userCompressConfig,i={};for(const a of Object.keys(e)){const n=e[a],m=n.compressOptions;let u=[];if(n.hasMipmaps&&TextureCompress.enableMipMaps)try{const e=await(0,minimaps_1.genMipmapFiles)(n.src,asset_library_1.buildAssetLibrary.getAssetTempDirByUuid(a));if(!e.length)continue;u=e}catch(e){e instanceof Error&&(e.message=`{asset(${a})}`+e.message),console.warn(e);continue}const p={};Object.keys(m).forEach(e=>o[e]&&(p[e]=o[e]));const c={option:{mtime:n.mtime,src:n.src,compressOptions:m},mipmapFiles:u,customConfigs:p},l=!lodash_1.default.isEqual(TextureCompress.storedCompressInfo[a]&&TextureCompress.storedCompressInfo[a].option,c.option);n.dest=[],n.dirty=l,n.suffix=[];let f=!1;Object.keys(m).forEach(e=>{var p;let c=e;TextureCompress.userCompressConfig.customConfigs[e]&&(c=TextureCompress.userCompressConfig.customConfigs[e].format);const C=null===(p=r[c])||void 0===p?void 0:p.formatType;if(!C)return void console.error(`Invalid format ${e}`);const d=(0,path_1.join)(TextureCompress.compressCacheDir,a.substr(0,2),a+t[C].suffix);if(!l&&(0,fs_extra_1.existsSync)(d))return n.dest.push(d),n.suffix.push((0,utils_1.getSuffix)(r[c],t[C].suffix)),void console.debug(`Use cache compress image of {Asset(${a})} ({link(${d})})`);n.dirty=!0,TextureCompress.userCompressConfig.customConfigs[e]&&increaseCustomCompressNum(TextureCompress.userCompressConfig.customConfigs[e]),f=!0,s.push({format:e,src:n.src,dest:d,compressOptions:m[e],customConfig:o[e],uuid:a,mipmapFiles:u,suffix:(0,utils_1.getSuffix)(r[c],t[C].suffix),formatType:C}),i[C]=(i[C]||0)+1}),f&&this._compressAssetLen++,c.dest=n.dest,TextureCompress.storedCompressInfo[a]=c}return console.debug(`sort compress task ${JSON.stringify(i)}`),s}executeCompressQueue(){return new Promise((e,s)=>{try{this._compressExecuteInfo={reject:s,resolve:e,state:"progress",busyFormatType:{},busyAsset:new Set,complete:0,total:this._waitingCompressQueue.size,childProcess:0},this.emit("update-progress",`start compress task 0 / ${this._waitingCompressQueue.size}`);for(let e=0;e<this._compressAssetLen;e++){const e=this._getNextTask();e&&this._compressImage(e).catch(e=>{s(e)})}}catch(e){s(e)}})}_getNextTask(){for(const e of this._waitingCompressQueue.values())if(this._checkTaskCanExecute(e))return e;return null}_checkTaskCanExecute(e){const{busyAsset:s,busyFormatType:t}=this._compressExecuteInfo;return!s.has(e.uuid)&&!(t[e.formatType]&&!TextureCompress.allTextureCompressConfig.textureFormatConfigs[e.formatType].parallelism)}async _compressImage(e){const{busyAsset:s,busyFormatType:t,total:r,childProcess:o}=this._compressExecuteInfo;if(TextureCompress.allTextureCompressConfig.textureFormatConfigs[e.formatType].childProcess){if(o>numCPUs)return void console.debug(`${e.formatType} wait for child process ${o}`);this._compressExecuteInfo.childProcess++}let i=t[e.formatType];if(i&&i>0){if(!TextureCompress.allTextureCompressConfig.textureFormatConfigs[e.formatType].parallelism)return;t[e.formatType]=++i}else t[e.formatType]=1;s.add(e.uuid),this.emit("update-progress",`execute compress task ${this._compressExecuteInfo.complete}/${r}, ${s.size} in progress}`),this._waitingCompressQueue.delete(e);try{await this.compressImageByConfig(e)}catch(e){console.error(e)}this._compressExecuteInfo.childProcess--,s.delete(e.uuid),t[e.formatType]=--t[e.formatType],this._compressExecuteInfo.complete++,await this._step()}async _step(){if(this._waitingCompressQueue.size){const e=this._getNextTask();return void(e&&this._compressImage(e))}const{busyAsset:e,resolve:s}=this._compressExecuteInfo;if(!e.size)return s()}async customCompressImage(e,s){for(let t=0;t<s.pkgNameOrder.length;t++){const r=s.pkgNameOrder[t],o=s.handles[r];if(o)try{return console.debug(`Start custom compress(${r})`),await o(e)}catch(e){console.error(e),console.error(`Custom Compress (${r}) failed!`)}}}async compressImageByConfig(e){const{dest:s}=e;let t,r=e.src;await(0,fs_extra_1.ensureDir)((0,path_1.dirname)(s));try{if(100===e.compressOptions.quality&&(0,path_1.extname)(e.src).endsWith(e.format))return console.log(`${e.format} with quality is 100, will copy the image from ${e.src} to ${e.dest}`),void await(0,fs_extra_1.copy)(e.src,e.dest,{overwrite:!0})}catch(e){console.warn(e)}if(".webp"===(0,path_1.extname)(r)){const e=(0,sharp_1.default)(r);r=r.replace("webp","png"),await e.toFile(r)}if(e.customConfig)try{return console.debug(`start custom compress config ${e.format}(${e.customConfig.name})`),await(0,compress_tool_1.compressCustomFormat)(Object.assign(Object.assign({},e),{src:r})),void console.debug("Custom compress config",`${e.format}(${e.customConfig.name})`,"sucess")}catch(s){if(console.warn(`Compress {asset(${e.uuid})} with custom config failed!`),console.warn(s),!(t=(0,compress_tool_1.getCompressFunc)(e.customConfig.format)))return void console.warn(`Invalid format ${e.customConfig.format}`)}if(t=t||(0,compress_tool_1.getCompressFunc)(e.format)){if(await t(Object.assign(Object.assign({},e),{src:r})),TextureCompress.enableMipMaps)try{const s=await(0,minimaps_1.compressMipmapFiles)(Object.assign(Object.assign({},e),{src:r}),t);if(s.length){s.splice(0,0,(0,fs_extra_1.readFileSync)(e.dest));const t=cc_1.ImageAsset.mergeCompressedTextureMips(s);await(0,fs_extra_1.outputFile)(e.dest,t)}}catch(s){console.error(s),await(0,fs_extra_1.remove)(e.dest),console.error(`Generate {asset(${e.uuid})} compress texture mipmap files failed!`)}try{if((0,path_1.extname)(e.src).endsWith(e.format)){const s=await(0,fs_extra_1.stat)(e.src),t=await(0,fs_extra_1.stat)(e.dest);t.size>s.size&&(console.log(`The compressed image(${e.dest}) size(${t.size}) is larger than the original image(${e.src}) size(${s.size}), and the original image will be used. To ignore this protection mechanism, please configure it in Project Settings -> Texture Compression Configuration.`),await(0,fs_extra_1.copy)(e.src,e.dest,{overwrite:!0}))}}catch(e){console.warn(e)}}else console.warn(`Invalid format ${e.format}`)}}async function previewCompressImage(e,s="web-mobile"){const t=new TextureCompress(s);await t.init();const r=asset_library_1.buildAssetLibrary.getAssetInfo(e),o=t.addTaskWithAssetInfo(r);if(o)return await t.run(),o}async function queryCompressCache(e){return await TextureCompress.initCommonOptions(),TextureCompress.queryTextureCompressCache(e)}function increaseCustomCompressNum(e){e&&(e.num||(e.num=0),e.num++)}function collectCustomCompressInfo(e){let s=0;Object.values(e).map(e=>{if(!e.num)return;s+=e.num;const t=(0,utils_1.changeInfoToLabel)({format:e.format,overwrite:e.overwrite,value:e.num,file:(0,path_1.basename)(e.path),command:e.command});(0,metric_1.sendSingleMetric)({category:"Build",action:"custom-compress",label:t}),(0,metric_1.sendSingleMetric)({sendToNewCocosAnalyticsOnly:!0,category:"buildSystem",value:{B100040:t}})}),(0,metric_1.sendSingleMetric)({sendToNewCocosAnalyticsOnly:!0,category:"buildSystem",value:{B100145:s}})}exports.TextureCompress=TextureCompress,TextureCompress.overwriteFormats={},TextureCompress._presetIdToCompressOption={},TextureCompress.compressCacheDir=(0,path_1.join)(Editor.Project.path,"temp","builder","CompressTexture"),TextureCompress.storedCompressInfo={},TextureCompress.storedCompressInfoPath=(0,path_1.join)(TextureCompress.compressCacheDir,"compress-info.json"),TextureCompress.enableMipMaps=!1,exports.previewCompressImage=previewCompressImage,exports.queryCompressCache=queryCompressCache;