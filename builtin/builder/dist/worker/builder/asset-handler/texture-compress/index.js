"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.queryCompressCache=exports.previewCompressImage=exports.TextureCompress=void 0;const fs_extra_1=require("fs-extra"),path_1=require("path"),minimaps_1=require("./minimaps"),compress_tool_1=require("./compress-tool"),cc_1=require("cc"),asset_library_1=require("../../manager/asset-library"),utils_1=require("./utils"),plugin_1=require("../../../plugin"),metric_1=require("../../metric"),Sharp=require("sharp"),Lodash=require("lodash");class TextureCompress{constructor(e){this._taskMap={},this.platform=e}static async initCommonOptions(){TextureCompress.allTextureCompressConfig=await Editor.Message.request("builder","query-compress-config"),(0,fs_extra_1.existsSync)(TextureCompress.storedCompressInfoPath)?TextureCompress.storedCompressInfo=(0,fs_extra_1.readJsonSync)(TextureCompress.storedCompressInfoPath):TextureCompress.storedCompressInfo={},TextureCompress.enableMipMaps=await Editor.Profile.getProject("builder","textureCompressConfig.genMipmaps")}async init(){await this.updateUserConfig()}async updateUserConfig(){await TextureCompress.initCommonOptions(),TextureCompress.userCompressConfig=await Editor.Profile.getProject("builder","textureCompressConfig");const{customConfigs:e}=TextureCompress.userCompressConfig,s={};e&&Object.values(e).length&&Object.values(e).forEach(e=>{e.overwrite&&(s[e.format]=e.id,console.debug(`compress format (${e.format}) will be overwrited by custom compress ${e.id}(${e.name})`))}),TextureCompress.overwriteFormats=s,TextureCompress._presetIdToCompressOption={}}static queryTextureCompressCache(e){return TextureCompress.storedCompressInfo[e]}addTask(e,s){return this._taskMap[e]?Object.assign(this._taskMap[e],s):this._taskMap[e]=s,this._taskMap[e]}addTaskWithAssetInfo(e){if(this._taskMap[e.uuid])return this._taskMap[e.uuid];if("auto-atlas"===e.importer)return;const s=this.genTaskInfoFromAssetInfo(e);return s?(this._taskMap[e.uuid]=s,s):void 0}genTaskInfoFromAssetInfo(e){if(this._taskMap[e.uuid])return this._taskMap[e.uuid];const s=e.meta.userData.compressSettings;if(!s||!s.useCompressTexture)return null;const t=(0,path_1.extname)(e.source),r=e.library[t]||e.library[".png"];if("auto-atlas"!==e.importer&&!r)return void console.warn(`genTaskInfoFromAssetInfo failed ! Image asset does not exist: ${e.source}`);const o=this.getCompressOptions(s.presetId);return o?{src:r,presetId:s.presetId,compressOptions:o,hasAlpha:e.meta.userData.hasAlpha,mtime:e.mtime,hasMipmaps:!!TextureCompress.enableMipMaps&&(0,minimaps_1.checkHasMipMaps)(e.meta),dest:[],suffix:[]}:void 0}getCompressOptions(e){if(TextureCompress._presetIdToCompressOption[e])return TextureCompress._presetIdToCompressOption[e];const{userPreset:s,defaultConfig:t,customConfigs:r}=TextureCompress.userCompressConfig,{platformConfig:o,customFormats:i}=TextureCompress.allTextureCompressConfig;if(!o[this.platform])return null;const a=o[this.platform].textureCompressConfig;if(!a)return null;const n=a.platformType,m=s[e]||t[e]||t.default;if(!m||!m.options[n])return console.debug(`Invalid compress task: ${JSON.stringify(m)}`),null;const p=a.support,c={};Object.keys(m.options[n]).forEach(e=>{([...p.rgba,...p.rgb].includes(e)||Object.keys(i).includes(e))&&(c[e]=JSON.parse(JSON.stringify(m.options[n][e])))});const u={};return r&&Object.values(r).length&&Object.values(r).forEach(e=>{e.overwrite&&(u[e.format]=e.id,console.debug(`compress format (${e.format}) will be overwrited by custom compress ${e.id}(${e.name})`))}),Object.keys(u).forEach(e=>{c[e]&&(c[u[e]]=c[e],delete c[e])}),Object.keys(c).length?(TextureCompress._presetIdToCompressOption[e]=c,c):null}queryTask(e){return this._taskMap[e]}removeTask(e){delete this._taskMap[e]}async run(e=this._taskMap){console.group("Compress image...");const{customConfigs:s}=TextureCompress.userCompressConfig;console.debug(`Num of image compress task ${Object.keys(e).length}`);const t=await this.sortImageTask(e),r=JSON.parse(JSON.stringify(t));if(collectCustomCompressInfo(s),!Object.keys(t).length)return console.debug("No image need to compress"),void console.groupEnd();const o=plugin_1.pluginManager.getAssetHandlers("compressTextures");return o.pkgNameOrder.length&&(Editor.Metrics.trackTimeStart("builder:custom-compress-texture"),await this.customCompressImage(r,o),await Editor.Metrics.trackTimeEnd("builder:custom-compress-texture",{output:!0})),Editor.Metrics.trackTimeStart("builder:compress-texture"),await Promise.all(Object.keys(r).map(e=>this.compressImageList(r[e]))),await Editor.Metrics.trackTimeEnd("builder:compress-texture",{output:!0}),Object.values(t).forEach(s=>{s.forEach(s=>{(0,fs_extra_1.existsSync)(s.dest)&&(e[s.uuid].dest.push(s.dest),e[s.uuid].suffix.push(s.suffix))})}),(0,fs_extra_1.outputJSONSync)(TextureCompress.storedCompressInfoPath,TextureCompress.storedCompressInfo),console.groupEnd(),console.debug(`Num of sorted image asset: ${Object.keys(e).length}`),e}async sortImageTask(e){const s={},{textureFormatConfigs:t,formatsInfo:r}=TextureCompress.allTextureCompressConfig,{customConfigs:o}=TextureCompress.userCompressConfig;for(const i of Object.keys(e)){const a=e[i],n=a.compressOptions;let m=[];if(a.hasMipmaps&&TextureCompress.enableMipMaps)try{const e=await(0,minimaps_1.genMipmapFiles)(a.src,asset_library_1.buildAssetLibrary.getAssetTempDirByUuid(i));if(!e.length)continue;m=e}catch(e){e instanceof Error&&(e.message=`{asset(${i})}`+e.message),console.warn(e);continue}const p={};Object.keys(n).forEach(e=>o[e]&&(p[e]=o[e]));const c={option:{mtime:a.mtime,src:a.src,compressOptions:n},mipmapFiles:m,customConfigs:p},u=!Lodash.isEqual(TextureCompress.storedCompressInfo[i]&&TextureCompress.storedCompressInfo[i].option,c.option);a.dest=[],a.dirty=u,a.suffix=[],Object.keys(n).forEach(e=>{var p;let c=e;TextureCompress.userCompressConfig.customConfigs[e]&&(c=TextureCompress.userCompressConfig.customConfigs[e].format);const f=null===(p=r[c])||void 0===p?void 0:p.formatType;if(!f)return void console.error(`Invalid format ${e}`);const l=(0,path_1.join)(TextureCompress.compressCacheDir,i.substr(0,2),i+t[f].suffix);if(!u&&(0,fs_extra_1.existsSync)(l))return a.dest.push(l),a.suffix.push((0,utils_1.getSuffix)(r[c],t[f].suffix)),void console.debug(`Use cache compress image of {Asset(${i})} ({link(${l})})`);a.dirty=!0,TextureCompress.userCompressConfig.customConfigs[e]&&increaseCustomCompressNum(TextureCompress.userCompressConfig.customConfigs[e]),s[f]||(s[f]=[]),s[f].push({format:e,src:a.src,dest:l,compressOptions:n[e],customConfig:o[e],uuid:i,mipmapFiles:m,suffix:(0,utils_1.getSuffix)(r[c],t[f].suffix)})}),c.dest=a.dest,TextureCompress.storedCompressInfo[i]=c}return s}async customCompressImage(e,s){for(let t=0;t<s.pkgNameOrder.length;t++){const r=s.pkgNameOrder[t],o=s.handles[r];if(o)try{console.debug(`Start custom compress(${r})`),await Promise.all(Object.keys(e).map(s=>{const t=e[s];return o(t)}))}catch(e){console.error(e),console.error(`Custom Compress (${r}) failed!`)}}}async compressImageList(e){for(const s of e){const{dest:e}=s;let t,r=s.src;(0,fs_extra_1.ensureDirSync)((0,path_1.dirname)(e));try{if(100===s.compressOptions.quality&&(0,path_1.extname)(s.src).endsWith(s.format)){console.log(`${s.format} with quality is 100, will copy the image from ${s.src} to ${s.dest}`),(0,fs_extra_1.copySync)(s.src,s.dest,{overwrite:!0});continue}}catch(e){console.warn(e)}if(".webp"===(0,path_1.extname)(r)){const e=Sharp(r);r=r.replace("webp","png"),await e.toFile(r)}if(s.customConfig)try{console.debug(`start custom compress config ${s.format}(${s.customConfig.name})`),await(0,compress_tool_1.compressCustomFormat)(Object.assign(Object.assign({},s),{src:r})),console.debug("Custom compress config",`${s.format}(${s.customConfig.name})`,"sucess");continue}catch(e){if(console.warn(`Compress {asset(${s.uuid})} with custom config failed!`),console.warn(e),!(t=(0,compress_tool_1.getCompressFunc)(s.customConfig.format))){console.warn(`Invalid format ${s.customConfig.format}`);continue}}if(t=t||(0,compress_tool_1.getCompressFunc)(s.format)){if(await t(Object.assign(Object.assign({},s),{src:r})),TextureCompress.enableMipMaps)try{const e=await(0,minimaps_1.compressMipmapFiles)(Object.assign(Object.assign({},s),{src:r}),t);if(e.length){e.splice(0,0,(0,fs_extra_1.readFileSync)(s.dest));const t=cc_1.ImageAsset.mergeCompressedTextureMips(e);await(0,fs_extra_1.outputFile)(s.dest,t)}}catch(e){console.error(e),await(0,fs_extra_1.remove)(s.dest),console.error(`Generate {asset(${s.uuid})} compress texture mipmap files failed!`)}try{if((0,path_1.extname)(s.src).endsWith(s.format)){const e=await(0,fs_extra_1.stat)(s.src),t=await(0,fs_extra_1.stat)(s.dest);t.size>e.size&&(console.log(`The compressed image(${s.dest}) size(${t.size}) is larger than the original image(${s.src}) size(${e.size}), and the original image will be used. To ignore this protection mechanism, please configure it in Project Settings -> Texture Compression Configuration.`),(0,fs_extra_1.copySync)(s.src,s.dest,{overwrite:!0}))}}catch(e){console.warn(e)}}else console.warn(`Invalid format ${s.format}`)}}}async function previewCompressImage(e,s="web-mobile"){const t=new TextureCompress(s);await t.init();const r=asset_library_1.buildAssetLibrary.getAssetInfo(e),o=t.addTaskWithAssetInfo(r);if(o)return await t.run(),o}async function queryCompressCache(e){return await TextureCompress.initCommonOptions(),TextureCompress.queryTextureCompressCache(e)}function increaseCustomCompressNum(e){e&&(e.num||(e.num=0),e.num++)}function collectCustomCompressInfo(e){let s=0;Object.values(e).map(e=>{if(!e.num)return;s+=e.num;const t=(0,utils_1.changeInfoToLabel)({format:e.format,overwrite:e.overwrite,value:e.num,file:(0,path_1.basename)(e.path),command:e.command});(0,metric_1.sendSingleMetric)({category:"Build",action:"custom-compress",label:t}),(0,metric_1.sendSingleMetric)({sendToNewCocosAnalyticsOnly:!0,category:"buildSystem",value:{B100040:t}})}),(0,metric_1.sendSingleMetric)({sendToNewCocosAnalyticsOnly:!0,category:"buildSystem",value:{B100145:s}})}exports.TextureCompress=TextureCompress,TextureCompress.overwriteFormats={},TextureCompress._presetIdToCompressOption={},TextureCompress.compressCacheDir=(0,path_1.join)(Editor.Project.path,"temp","builder","CompressTexture"),TextureCompress.storedCompressInfo={},TextureCompress.storedCompressInfoPath=(0,path_1.join)(TextureCompress.compressCacheDir,"compress-info.json"),TextureCompress.enableMipMaps=!1,exports.previewCompressImage=previewCompressImage,exports.queryCompressCache=queryCompressCache;