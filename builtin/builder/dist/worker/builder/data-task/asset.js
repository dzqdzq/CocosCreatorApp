"use strict";var __createBinding=this&&this.__createBinding||(Object.create?function(e,t,s,n){void 0===n&&(n=s),Object.defineProperty(e,n,{enumerable:!0,get:function(){return t[s]}})}:function(e,t,s,n){void 0===n&&(n=s),e[n]=t[s]}),__setModuleDefault=this&&this.__setModuleDefault||(Object.create?function(e,t){Object.defineProperty(e,"default",{enumerable:!0,value:t})}:function(e,t){e.default=t}),__importStar=this&&this.__importStar||function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var s in e)"default"!==s&&Object.prototype.hasOwnProperty.call(e,s)&&__createBinding(t,e,s);return __setModuleDefault(t,e),t};Object.defineProperty(exports,"__esModule",{value:!0}),exports.handle=exports.title=void 0;const Editor=__importStar(require("editor")),bundle_utils_1=require("../../../share/bundle-utils");async function handle(e,t,s){const{MAIN:n,START_SCENE:r}=bundle_utils_1.BuiltinBundleName,o=t.bundleMap[r]||t.bundleMap[n];for(const r of s.sceneUuids){const i=s.getAssetInfo(r),a=t.bundles.find(e=>i.url.startsWith(e.root+"/"));if(a)a.addScene(i);else{let s=!0;e.scenes&&0!==e.scenes.length&&(s=e.scenes.some(e=>e.uuid===r)),s&&t.bundleMap[n].addScene(i)}e.startScene===r&&o.addScene(i)}console.debug(`Number of scenes: ${t.bundleMap[n].scenes.length}`);for(const e of s.assetUuids){const n=s.getAssetInfo(e),r=t.bundles.find(e=>n.url.startsWith(e.root+"/"));r&&r.addRootAsset(n)}if(e.renderPipeline){const t=s.getAssetInfo(e.renderPipeline);o.addRootAsset(t)}if(e.preview)return;const i={};async function a(e,t,n=new Set,r){if(n.has(e))return;const o=s.getAssetInfo(e);if(!o){if(r){const t=s.getAssetInfo(r);console.error(Editor.I18n.t("builder.error.required_asset_missing",{uuid:`{asset(${e})}`,fatherUrl:`{asset(${t.url})}`}))}else console.error(Editor.I18n.t("builder.error.missing_asset",{uuid:`{asset(${e})}`}));return}if(n.add(e),t.addAsset(o),i[e])return void t.addRedirect(o,i[e]);const d=await s.getDependUuids(e);await Promise.all(d.map(async s=>await a(s,t,n,e)))}let d=new Array(20);t.bundles.forEach(e=>{d[e.priority-1]||(d[e.priority-1]=[]),d[e.priority-1].push(e)}),d=d.filter(e=>e).reverse();for(const e of d)await Promise.all(e.map(async e=>await Promise.all(e.scenes.concat(e.rootAssets).map(async t=>await a(t,e))))),e.forEach(e=>{e.assetsWithoutRedirect.forEach(t=>{i[t]||(i[t]=e.name)})});console.debug(`Number of assets: ${Object.keys(i).length}`),console.debug(`Number of asset bundle: ${t.bundles.length}`)}exports.title="i18n:tasks.sort_asset",exports.handle=handle;