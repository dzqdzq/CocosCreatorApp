"use strict";var __importDefault=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(exports,"__esModule",{value:!0}),exports.handle=exports.name=exports.title=void 0;const fs_extra_1=require("fs-extra"),path_1=require("path"),bundle_utils_1=require("../../../share/bundle-utils"),texture_packer_1=__importDefault(require("../texture-packer")),_lodash=require("lodash"),EditorExtends=require("@base/electron-module").require("EditorExtends");async function handle(e,t,s){console.debug("Start collect pack info");const a=await collectPackInfoFromBundles(s,t.bundles);if(!a)return;const{allAssets:r,useTextureMap:i,useSpriteAtlas:u,useImageMap:n,packInfos:o}=a,d=new texture_packer_1.default;console.debug("init texturePacker"),await d.init(o),e.useBuildAutoAtlasCache=!1!==e.useBuildAutoAtlasCache,console.debug("start pack images");const c=await d.pack(Array.from(new Set(r)),e.useBuildAutoAtlasCache);if(!c.length)return;console.debug("sort pack result");let p=new Set;console.group("Pack atlases..."),await Promise.all(c.map(async e=>{if(e.unpackedImages&&(p=new Set([...p,...e.unpackedImages])),0===e.atlases.length)return;const a=new cc.SpriteAtlas;a._uuid=e.pacInfo.asset.uuid,a.name=(0,path_1.basename)(e.pacInfo.asset.name,(0,path_1.extname)(e.pacInfo.asset.name));const{removeSpriteAtlasInBundle:o,removeImageInBundle:d,removeTextureInBundle:c}=e.options;r.includes(e.pacInfo.asset.uuid)&&!o&&s.addInstance(a);const{useCompressTexture:l,presetId:m}=e.pacInfo.meta.userData.compressSettings||{};for(const r of e.atlases){const p=r.imageUuid,f=r.textureUuid,{image:g,texture:h}=createTextureFromAtlas(r,e.pacInfo);s.addInstance(g),s.addInstance(h),r.spriteFrameInfos&&r.spriteFrameInfos.forEach(e=>{const r=generateSpriteFrame(e,h);delete t.imageTaskMap[e.uuid.replace(/@.+/,"")],a.spriteFrames[e.name]=EditorExtends.serialize.asAsset(r._uuid),s.addInstance(r)});let _=null;for(const s of t.bundles){const g=s.assetsWithoutRedirect,h=new Set(g);if(!h.has(e.pacInfo.asset.uuid)&&!e.pacInfo.spriteFrames.find(e=>h.has(e._uuid)))continue;const A=s.atlasRes;A.atlasToImages[a._uuid]=[];const I=e.pacInfo.asset.url.startsWith(s.root+"/");I&&console.debug(`Asset {asset(${e.pacInfo.asset.url})} is Bundle`);const x=[];for(const t of r.spriteFrameInfos)s.getRedirect(t.uuid)||e.options.filterUnused&&!h.has(t.uuid)||(s.addAssetWithUuid(t.uuid),s.removeFromGroups(t.uuid),i.has(t.textureUuid)||!c&&I?i.has(t.textureUuid)&&!I&&console.warn(Editor.I18n.t("builder.tips.use_texture_in_atlas",{info:`{asset(${t.textureUuid})}`,useInfo:`{asset(${i.get(t.textureUuid)})}`})):s.removeAsset(t.textureUuid),n.has(t.imageUuid)||!d&&I?n.has(t.imageUuid)&&!I&&console.warn(Editor.I18n.t("builder.tips.use_image_in_atlas",{info:`{asset(${t.imageUuid})}`,useInfo:`{asset(${n.get(t.imageUuid)})}`})):s.removeAsset(t.imageUuid),x.push(t.uuid),A.assetsToImage[t.uuid]=p,A.assetsToImage[t.imageUuid]=p);if(_&&_.priority!==s.priority)s.addRedirectWithUuid(f,_.name);else{s.addAssetWithUuid(p),s.addAssetWithUuid(f),s.compressionType===bundle_utils_1.BundleCompressionTypes.MERGE_ALL_JSON?s.groups[0]?s.groups[0].uuids.push(p,f):s.addGroup("NORMAL",[p,f]):s.compressionType!==bundle_utils_1.BundleCompressionTypes.NONE&&(s.addToGroup("IMAGE",p),s.addToGroup("TEXTURE",f));const a=(0,path_1.join)(p.slice(0,2),p+(0,path_1.extname)(r.imagePath));(0,fs_extra_1.copySync)(r.imagePath,(0,path_1.join)(s.dest,s.nativeBase,a)),l&&(t.imageTaskMap[p]?(t.imageTaskMap[p].dest.push(a),t.imageTaskMap[p].bundleNames.push(s.name),t.imageTaskMap[p].mtime=e.mtimeMd5):t.imageTaskMap[p]={src:r.imagePath,dest:[a],hasAlpha:!0,presetId:m,mtime:e.mtimeMd5,bundleNames:[s.name]}),_||(_=s)}const T=[...x];u.has(a._uuid)||I&&!o?(u.has(a._uuid)||I)&&T.push(a._uuid):(s.removeAsset(a._uuid),console.debug(`remove spriteAtlas._uuid : {asset(${a._uuid})}`)),s.compressionType===bundle_utils_1.BundleCompressionTypes.MERGE_ALL_JSON?s.groups[0]?s.groups[0].uuids.push(...T):s.addGroup("NORMAL",T):s.compressionType!==bundle_utils_1.BundleCompressionTypes.NONE&&s.addGroup("NORMAL",T),A.imageToAtlas[p]=a._uuid,A.assetsToImage[f]=p,A.atlasToImages[a._uuid].push(p)}}})),console.debug("pack atlas success"),console.groupEnd()}function createTextureFromAtlas(e,t){const s=e.imageUuid,a=e.textureUuid;if(e.compressd&&(e.compressed=e.compressd),!e.compressed)throw new Error("Can't find atlas.compressed.");const r=new cc.ImageAsset;r._setRawAsset(".png"),r._uuid=s,r._width=r._nativeAsset.width=e.width,r._height=r._nativeAsset.height=e.height;const i=new cc.Texture2D;return t.meta.userData.textureSetting||console.warn(`meta.userData.textureSetting in asset(${t.asset.uuid}) is missing.`),applyTextureBaseAssetUserData(t.meta.userData.textureSetting,i),i._mipmaps=[r],i._uuid=a,{texture:i,image:r}}function collectUsedAssets(e,t,s,a,r){t.uuid.endsWith("@6c48a")?s.set(t.uuid,e):"cc.ImageAsset"!==t.type?"cc.SpriteAtlas"===t.type&&r.set(t.uuid,e):a.set(t.uuid,e)}async function collectPackInfoFromBundles(e,t){const s=[];for(const t of e.assetUuids){const a=e.getAssetInfo(t);"auto-atlas"===a.importer&&s.push(a)}if(s.sort((e,t)=>-e.source.localeCompare(t.source,"en",{numeric:!0})),!s.length)return null;const a=[],r=new Map,i=new Map,u=new Map,n=[];t.forEach(e=>{a.push(...e.assetsWithoutRedirect)});for(let t=0;t<a.length;t++){const s=a[t],o=e.getAssetInfo(s);if(!o){console.error(Editor.I18n.t("builder.error.missing_asset",{uuid:s}));continue}const d=await getDependUuidsDeep(o,e);if(d.length)for(const t of d)n.includes(t)||(n.push(s),e.getAssetInfo(t)&&collectUsedAssets(o.url,e.getAssetInfo(t),r,i,u))}return{allAssets:a,useTextureMap:r,useSpriteAtlas:u,useImageMap:i,packInfos:s}}async function getDependUuidsDeep(e,t){const s=["cc.SpriteFrame","cc.Texture2D"];if(s.includes(e.type))return[];let a=[],r=[];const{uuid:i}=e,u=await t.getDependUuids(i);if(!u||!u.length)return[];r=[...u],a=[...u];do{const e=[];for(const a of r){const r=t.getAssetInfo(a);if(!r)continue;if(s.includes(r.type))continue;const i=await t.getDependUuids(a);e.push(...i)}r=e.filter(e=>!a.includes(e)),a.push(...r)}while(r.length>0);return Array.from(new Set(a))}function applyTextureBaseAssetUserData(e,t){e=e||{wrapModeS:"repeat",wrapModeT:"repeat",minfilter:"nearest",magfilter:"linear",mipfilter:"none",anisotropy:1};const s=e=>{switch(e){case"clamp-to-edge":return cc.TextureBase.WrapMode.CLAMP_TO_EDGE;case"repeat":return cc.TextureBase.WrapMode.REPEAT;case"mirrored-repeat":return cc.TextureBase.WrapMode.MIRRORED_REPEAT}},a=e=>{switch(e){case"nearest":return cc.TextureBase.Filter.NEAREST;case"linear":return cc.TextureBase.Filter.LINEAR;case"none":return cc.TextureBase.Filter.NONE}};t.setWrapMode(s(e.wrapModeS),s(e.wrapModeT)),t.setFilters(a(e.minfilter),a(e.magfilter)),t.setMipFilter(a(e.mipfilter)),t.setAnisotropy(e.anisotropy)}function generateSpriteFrame(e,t){const s=new cc.SpriteFrame,a=e.spriteFrame;s._name=e.name,s._uuid=a._uuid,s.texture=t;const r=e.trim;return s._rect=cc.rect(r.x,r.y,r.width,r.height),s._offset=a.getOffset(),s._originalSize=cc.size(e.rawWidth,e.rawHeight),s._rotated=e.rotated,s._capInsets=[a.insetLeft,a.insetTop,a.insetRight,a.insetBottom],s}exports.title="i18n:builder.tasks.build_atlas",exports.name="build-task/image",exports.handle=handle;