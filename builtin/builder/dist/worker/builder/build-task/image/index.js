"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.handle=exports.title=void 0;const texture_compress_1=require("./texture-compress"),path_1=require("path"),fs_extra_1=require("fs-extra"),plugin_1=require("../../../plugin"),utils_1=require("./utils"),Lodash=require("lodash"),compressCacheDir=path_1.join(Editor.Project.path,"temp","builder","CompressTexture");async function handle(e,s,t){if(e.skipCompressTexture)return console.debug("skip compress texture");if(0===Object.keys(s.imageTaskMap).length)return;const{platformConfig:r,formatsInfo:o}=await Editor.Message.request("builder","query-compress-config");if(!r[e.platform])return;console.group("Compress image...");const a=await sortImageCompressQueue(s.imageTaskMap,e.platform,s);if(!a)return;const{compressQueueMap:n,suffixMap:i,storedCompressInfo:c}=a;if(Object.keys(n).length){const e=plugin_1.pluginManager.getAssetHandlers("compressTextures");if(e.pkgNameOrder.length){const s=JSON.parse(JSON.stringify(n));await customCompressImage(s,e),Object.assign(n,s)}await Promise.all(Object.keys(n).map(e=>texture_compress_1.compressImageList(n[e])))}let u=0;for(const e of Object.keys(i)){const r=await t.getInstance(e),o=addSuffixToAsset(c[e].dest,s.imageTaskMap[e].dest,i[e],r);s.imageTaskMap[e].bundleNames.forEach(t=>{s.bundleMap[t].compressRes[e]=o}),s.compressImageResult[e]={files:o,formats:i[e]},t.addInstance(r),u++}console.groupEnd(),console.debug(`Num of sorted image asset: ${u}`)}async function customCompressImage(e,s){for(let t=0;t<s.pkgNameOrder.length;t++){const r=s.pkgNameOrder[t],o=s.handles[r];if(o)try{console.debug(`Start custom compress(${r})`),await Promise.all(Object.keys(e).map(s=>{const t=e[s];return o(t)}))}catch(e){console.error(e),console.error(`Custom Compress (${r}) failed!`)}}}async function sortImageCompressQueue(e,s,t){const{userPreset:r,defaultConfig:o,customConfigs:a}=await Editor.Profile.getProject("builder","textureCompressConfig"),{platformConfig:n,customFormats:i,formatsInfo:c,textureFormatConfigs:u}=await Editor.Message.request("builder","query-compress-config");let p={};const f=path_1.join(compressCacheDir,"compress-info.json");fs_extra_1.existsSync(f)&&(p=fs_extra_1.readJsonSync(f));const m=n[s].textureCompressConfig;let l="unknown",d={rgb:[],rgba:[]};m&&(l=m.platformType,d=m.support);const g={},h={},_={};a&&Object.values(a).length&&Object.values(a).forEach(e=>{e.overwrite&&(_[e.format]=e.id,console.debug(`compress format (${e.format}) will be overwirted by custom compress ${e.id}(${e.name})`))});for(const s of Object.keys(e)){const n=e[s],{presetId:f,hasAlpha:m,src:x}=n,b=r[f]||o[f]||o.default;if(!b||!b.options[l]){console.debug(`Invalid compress task: ${JSON.stringify(b)}`);continue}n.dest=n.dest.map((e,s)=>{const r=t.bundleMap[n.bundleNames[s]],o=path_1.join(r.dest,r.nativeBase),a=path_1.join(o,e);return fs_extra_1.ensureDirSync(path_1.dirname(a)),a});const y=n.dest,k={};if(Object.keys(b.options[l]).forEach(e=>{([...d.rgba,...d.rgb].includes(e)||Object.keys(i).includes(e))&&(k[e]=JSON.parse(JSON.stringify(b.options[l][e])))}),checkCompressOption(k,m,s),0===Object.keys(k).length)continue;try{await Promise.all(n.dest.map(async e=>{fs_extra_1.existsSync(e)&&await fs_extra_1.remove(e)}))}catch(e){console.error(e)}Object.keys(k).forEach(e=>{a[e]&&a[e].num++});const C=path_1.extname(y[0]),O=path_1.join(compressCacheDir,s.substr(0,2),s+C);fs_extra_1.ensureDirSync(path_1.dirname(O)),y.forEach(e=>{fs_extra_1.ensureDirSync(path_1.dirname(e))}),Object.keys(_).forEach(e=>{k[e]&&(k[_[e]]=k[e],delete k[e])});let j=[];const E={option:{mtime:n.mtime||await Editor.Message.request("asset-db","query-asset-mtime",s)||(new Date).getTime(),src:x,compressOption:k},suffix:j,dest:O};if(!!Lodash.isEqual(p[s]&&p[s].option,E.option)&&checkCacheImageExist(p[s].dest,p[s].suffix))j=p[s].suffix,console.debug(`Use cache compress image of {Asset(${s})} ({link(${O})}). suffix: ${j}`);else{const e=Object.keys(k);e.forEach(e=>{const t=c[e].formatType;g[t]||(g[t]=[]),g[t].push({format:e,src:x,dest:utils_1.changeSuffix(O,u[c[e].formatType].suffix),compressOptions:k[e],customConfig:a[e],uuid:s})}),j=e.map(e=>utils_1.getSuffix(c[e],u[c[e].formatType].suffix))}h[s]=j,E.suffix=j,p[s]=E}return fs_extra_1.outputJSONSync(f,p),collectCustomCompressInfo(a),{compressQueueMap:g,suffixMap:h,storedCompressInfo:p}}function collectCustomCompressInfo(e){Object.values(e).map(e=>{if(!e.num)return;const s={format:e.format,overwrite:e.overwrite,value:e.num,file:path_1.basename(e.path),command:e.command};Editor.Metrics.trackEvent({category:"Build",action:"custom-compress",label:utils_1.changeInfoToLabel(s)})})}function addSuffixToAsset(e,s,t,r){const o=[],a=path_1.extname(s[0]);if(t&&t.length>0){const n=path_1.extname(e),i=[];for(const r of t){const t=r.replace(/@.*/,""),c=e.replace(n,t);fs_extra_1.existsSync(c)?(s.forEach(e=>{o.push(e.replace(a,t)),fs_extra_1.copyFileSync(c,e.replace(a,t))}),i.push(r)):console.error(Editor.I18n.t("builder.error.cache_compress_texture_missing",{format:r,path:`{link(${c})}`}))}r._exportedExts=i}else r._exportedExts=[a];return o}function checkCacheImageExist(e,s){for(let t of s){t=t.replace(/@.*/,"");const s=e.replace(path_1.extname(e),t);if(!fs_extra_1.existsSync(s))return!1}return!0}function checkCompressOption(e,s,t){const r=Object.keys(e).filter(e=>e.startsWith("etc")),o=Object.keys(e).filter(e=>e.startsWith("pvr"));if(r.length>1){r.filter(e=>s?e.endsWith("rgb"):!e.endsWith("rgb")).forEach(s=>delete e[s])}if(o.length>1){o.filter(e=>s?e.endsWith("rgb"):!e.endsWith("rgb")).forEach(s=>delete e[s])}else!s&&o[0]&&o[0].endsWith("rgb_a")&&(delete e[o[0]],console.warn(Editor.I18n.t("builder.warn.compress_rgb_a",{uuid:`{asset(${t})}`})))}exports.title="i18n:builder.tasks.build_img",exports.handle=handle;