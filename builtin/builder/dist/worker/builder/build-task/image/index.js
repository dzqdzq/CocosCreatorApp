"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.handle=exports.title=void 0;const index_1=require("./texture-compress/index"),path_1=require("path"),fs_extra_1=require("fs-extra"),plugin_1=require("../../../plugin"),utils_1=require("./texture-compress/utils"),minimaps_1=require("./minimaps"),asset_library_1=require("../../manager/asset-library"),Lodash=require("lodash"),compressCacheDir=(0,path_1.join)(Editor.Project.path,"temp","builder","CompressTexture");async function handle(e,s,t){if(e.skipCompressTexture)return console.debug("skip compress texture");const r=Object.keys(s.imageCompressTaskMap);if(0===r.length)return;Object.assign(this.staticsInfo.extras,{B100033:r.length}),await sortMipmapTask(s,t),console.group("Compress image...");const o=await sortImageCompressQueue(s.imageCompressTaskMap,e.platform,s);if(!o)return;const{compressQueueMap:a,suffixMap:i,storedCompressInfo:n}=o;if(Object.keys(a).length){const e=plugin_1.pluginManager.getAssetHandlers("compressTextures");if(e.pkgNameOrder.length){Editor.Metrics.trackTimeStart("builder:custom-compress-texture");const s=JSON.parse(JSON.stringify(a));await customCompressImage(s,e),Object.assign(a,s),await Editor.Metrics.trackTimeEnd("builder:custom-compress-texture",{output:!0})}Editor.Metrics.trackTimeStart("builder:compress-texture"),await Promise.all(Object.keys(a).map(e=>(0,index_1.compressImageList)(a[e]))),await Editor.Metrics.trackTimeEnd("builder:compress-texture",{output:!0})}let c=0;for(const e of Object.keys(i)){const r=await t.getInstance(e),o=addSuffixToAsset(n[e].dest,s.imageCompressTaskMap[e].dest,i[e],r);s.imageCompressTaskMap[e].bundleNames.forEach(t=>{s.bundleMap[t].compressRes[e]=o}),s.compressImageResult[e]={files:o,formats:i[e]},t.addInstance(r),c++}console.groupEnd(),console.debug(`Num of sorted image asset: ${c}`)}async function sortMipmapTask(e,s){if(await Editor.Profile.getProject("builder","textureCompressConfig.genMipmaps"))for(const t of Object.keys(e.imageCompressTaskMap)){const r=e.imageCompressTaskMap[t],o=await s.getMeta(t);if((0,minimaps_1.checkHasMipMaps)(o))try{const s=await e.getMipmapFiles(r.src,asset_library_1.buildAssetLibrary.getAssetTempDirByUuid(t));if(!s.length)continue;r.mipmapFiles=s}catch(s){s instanceof Error&&(s.message=`{asset(${t})}`+s.message),console.warn(s),delete e.imageCompressTaskMap[t]}}}async function customCompressImage(e,s){for(let t=0;t<s.pkgNameOrder.length;t++){const r=s.pkgNameOrder[t],o=s.handles[r];if(o)try{console.debug(`Start custom compress(${r})`),await Promise.all(Object.keys(e).map(s=>{const t=e[s];return o(t)}))}catch(e){console.error(e),console.error(`Custom Compress (${r}) failed!`)}}}async function sortImageCompressQueue(e,s,t){const{customConfigs:r}=await Editor.Profile.getProject("builder","textureCompressConfig"),{platformConfig:o,customFormats:a,formatsInfo:i,textureFormatConfigs:n}=await Editor.Message.request("builder","query-compress-config");let c={};const m=(0,path_1.join)(compressCacheDir,"compress-info.json");(0,fs_extra_1.existsSync)(m)&&(c=(0,fs_extra_1.readJsonSync)(m));const p=o[s].textureCompressConfig;let u="unknown",f={rgb:[],rgba:[]};p&&(u=p.platformType,f=p.support);const l={},d={},g={};r&&Object.values(r).length&&Object.values(r).forEach(e=>{e.overwrite&&(g[e.format]=e.id,console.debug(`compress format (${e.format}) will be overwrited by custom compress ${e.id}(${e.name})`))});for(const s of Object.keys(e)){const o=e[s],{src:a,compressOptions:m,mipmapFiles:p}=o;o.dest=o.dest.map((e,s)=>{const r=t.bundleMap[o.bundleNames[s]],a=(0,path_1.join)(r.dest,r.nativeBase),i=(0,path_1.join)(a,e);return(0,fs_extra_1.ensureDirSync)((0,path_1.dirname)(i)),i});const u=o.dest;try{await Promise.all(o.dest.map(async e=>{(0,fs_extra_1.existsSync)(e)&&await(0,fs_extra_1.remove)(e)}))}catch(e){console.error(e)}Object.keys(m).forEach(e=>{r[e]&&increaseCustomCompressNum(r[e])});const f=(0,path_1.extname)(u[0]),x=(0,path_1.join)(compressCacheDir,s.substr(0,2),s+f);(0,fs_extra_1.ensureDirSync)((0,path_1.dirname)(x)),u.forEach(e=>{(0,fs_extra_1.ensureDirSync)((0,path_1.dirname)(e))}),Object.keys(g).forEach(e=>{m[e]&&(m[g[e]]=m[e],delete m[e],increaseCustomCompressNum(r[e]))});let h=[];const _={option:{mtime:o.mtime||await Editor.Message.request("asset-db","query-asset-mtime",s)||(new Date).getTime(),src:a,compressOptions:m},suffix:h,dest:x,mipmapFiles:p};if(!!Lodash.isEqual(c[s]&&c[s].option,_.option)&&checkCacheImageExist(c[s].dest,c[s].suffix))h=c[s].suffix,console.debug(`Use cache compress image of {Asset(${s})} ({link(${x})}). suffix: ${h}`);else{console.debug(`Get cache compress image failed with ${JSON.stringify(_)}`);const e=Object.keys(m);e.forEach(e=>{const t=i[e].formatType;l[t]||(l[t]=[]),l[t].push({format:e,src:a,dest:(0,utils_1.changeSuffix)(x,n[i[e].formatType].suffix),compressOptions:m[e],customConfig:r[e],uuid:s,mipmapFiles:p})}),h=e.map(e=>(0,utils_1.getSuffix)(i[e],n[i[e].formatType].suffix))}d[s]=h,_.suffix=h,c[s]=_}return(0,fs_extra_1.outputJSONSync)(m,c),collectCustomCompressInfo(r),{compressQueueMap:l,suffixMap:d,storedCompressInfo:c}}function collectCustomCompressInfo(e){Object.values(e).map(e=>{if(!e.num)return;const s=(0,utils_1.changeInfoToLabel)({format:e.format,overwrite:e.overwrite,value:e.num,file:(0,path_1.basename)(e.path),command:e.command});Editor.Metrics.trackEvent({category:"Build",action:"custom-compress",label:s}),Editor.Metrics.trackEvent({sendToNewCocosAnalyticsOnly:!0,category:"buildSystem",value:{B100040:s}})})}function increaseCustomCompressNum(e){e&&(e.num||(e.num=0),e.num++)}function addSuffixToAsset(e,s,t,r){const o=[],a=(0,path_1.extname)(s[0]);if(t&&t.length>0){const i=(0,path_1.extname)(e),n=[];for(const r of t){const t=r.replace(/@.*/,""),c=e.replace(i,t);(0,fs_extra_1.existsSync)(c)?(s.forEach(e=>{o.push(e.replace(a,t)),(0,fs_extra_1.copyFileSync)(c,e.replace(a,t))}),n.push(r)):console.error(Editor.I18n.t("builder.error.cache_compress_texture_missing",{format:r,path:`{link(${c})}`}))}r._exportedExts=n}else r._exportedExts=[a];return o}function checkCacheImageExist(e,s){for(let t of s){t=t.replace(/@.*/,"");const s=e.replace((0,path_1.extname)(e),t);if(!(0,fs_extra_1.existsSync)(s))return!1}return!0}exports.title="i18n:builder.tasks.build_img",exports.handle=handle;