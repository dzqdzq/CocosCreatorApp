"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.handle=exports.title=void 0;const texture_compress_1=require("./texture-compress"),path_1=require("path"),fs_extra_1=require("fs-extra"),plugin_1=require("../../../plugin"),Lodash=require("lodash"),compressCacheDir=path_1.join(Editor.Project.path,"temp","builder","CompressTexture");async function handle(e,s,t){if(0===Object.keys(s.imageTaskMap).length)return;const{platformConfig:r}=await Editor.Message.request("builder","query-compress-config");if(!r[e.platform])return;console.group("Compress image...");const o=await sortImageCompressQueue(s.imageTaskMap,e.platform,s);if(!o)return;const{compressQueueMap:a,suffixMap:n,storedCompressInfo:i}=o;if(Object.keys(a).length){const e=plugin_1.pluginManager.getAssetHandlers("compressTextures");if(e.pkgNameOrder.length){const s=JSON.parse(JSON.stringify(a));await customCompressImage(s,e),Object.assign(a,s)}await Promise.all(Object.keys(a).map(e=>texture_compress_1.compressImageList(a[e])))}let c=0;for(const e of Object.keys(n)){const r=await t.getInstance(e),o=addSuffixToAsset(i[e].dest,s.imageTaskMap[e].dest,n[e],r);s.imageTaskMap[e].bundleNames.forEach(t=>{s.bundleMap[t].compressRes[e]=o}),s.compressImageResult[e]={files:o,formats:n[e]},t.addInstance(r),c++}console.groupEnd(),console.debug(`Num of sorted image asset: ${c}`)}async function customCompressImage(e,s){for(let t=0;t<s.pkgNameOrder.length;t++){const r=s.pkgNameOrder[t],o=s.handles[r];if(o)try{console.debug(`Start custom compress(${r})`),await Promise.all(Object.keys(e).map(s=>{const t=e[s];return o(t)}))}catch(e){console.error(e),console.error(`Custom Compress (${r}) failed!`)}}}async function sortImageCompressQueue(e,s,t){const{userPreset:r,defaultConfig:o}=await Editor.Profile.getProject("builder","textureCompressConfig"),{platformConfig:a}=await Editor.Message.request("builder","query-compress-config");let n={};const i=path_1.join(compressCacheDir,"compress-info.json");fs_extra_1.existsSync(i)&&(n=fs_extra_1.readJsonSync(i));const c=a[s].textureCompressConfig;let p="unknown",u={rgb:[],rgba:[]};c&&(p=c.platformType,u=c.support);const f={},l={};for(const s of Object.keys(e)){const a=e[s],{presetId:i,hasAlpha:c,src:m}=a,d=r[i]||o[i]||o.default;if(!d||!d.options[p]){console.debug(`Invalid compress task: ${JSON.stringify(d)}`);continue}a.dest=a.dest.map((e,s)=>{const r=t.bundleMap[a.bundleNames[s]],o=path_1.join(r.dest,r.nativeBase),n=path_1.join(o,e);return fs_extra_1.ensureDirSync(path_1.dirname(n)),n});const g=a.dest,h={};if(Object.keys(d.options[p]).forEach(e=>{[...u.rgba,...u.rgb].includes(e)&&(h[e]=JSON.parse(JSON.stringify(d.options[p][e])))}),checkCompressOption(h,c,s),0===Object.keys(h).length)continue;try{await Promise.all(a.dest.map(async e=>{fs_extra_1.existsSync(e)&&await fs_extra_1.remove(e)}))}catch(e){console.error(e)}const _=path_1.extname(g[0]),x=path_1.join(compressCacheDir,s.substr(0,2),s+_);fs_extra_1.ensureDirSync(path_1.dirname(x)),g.forEach(e=>{fs_extra_1.ensureDirSync(path_1.dirname(e))});let b=[];const y={option:{mtime:a.mtime||await Editor.Message.request("asset-db","query-asset-mtime",s)||(new Date).getTime(),src:m,compressOption:h},suffix:b,dest:x};if(!!Lodash.isEqual(n[s]&&n[s].option,y.option)&&checkCacheImageExist(n[s].dest,n[s].suffix))b=n[s].suffix,console.debug(`Use cache compress image of {Asset(${s})} ({link(${x})}). suffix: ${b}`);else{const e=Object.keys(h);e.forEach(e=>{const s=e.slice(0,3);f[s]||(f[s]=[]),f[s].push({format:e,src:m,dest:x,quality:h[e]})}),b=texture_compress_1.getSuffix(e)}l[s]=b,y.suffix=b,n[s]=y}return fs_extra_1.outputJSONSync(i,n),{compressQueueMap:f,suffixMap:l,storedCompressInfo:n}}function addSuffixToAsset(e,s,t,r){const o=[],a=path_1.extname(s[0]);if(t&&t.length>0){const n=path_1.extname(e),i=[];for(const r of t){const t=r.replace(/@.*/,""),c=e.replace(n,t);fs_extra_1.existsSync(c)?(s.forEach(e=>{o.push(e.replace(a,t)),fs_extra_1.copyFileSync(c,e.replace(a,t))}),i.push(r)):console.error(Editor.I18n.t("builder.error.cache_compress_texture_missing",{format:r,path:`{link(${c})}`}))}r._exportedExts=i}else r._exportedExts=[a];return o}function checkCacheImageExist(e,s){for(let t of s){t=t.replace(/@.*/,"");const s=e.replace(path_1.extname(e),t);if(!fs_extra_1.existsSync(s))return!1}return!0}function checkCompressOption(e,s,t){const r=Object.keys(e).filter(e=>e.startsWith("etc")),o=Object.keys(e).filter(e=>e.startsWith("pvr"));if(r.length>1){r.filter(e=>s?e.endsWith("rgb"):!e.endsWith("rgb")).forEach(s=>delete e[s])}if(o.length>1){o.filter(e=>s?e.endsWith("rgb"):!e.endsWith("rgb")).forEach(s=>delete e[s])}else!s&&o[0]&&o[0].endsWith("rgb_a")&&(delete e[o[0]],console.warn(Editor.I18n.t("builder.warn.compress_rgb_a",{uuid:`{asset(${t})}`})))}exports.title="i18n:tasks.build_img",exports.handle=handle;