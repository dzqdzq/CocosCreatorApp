"use strict";var __createBinding=this&&this.__createBinding||(Object.create?function(e,t,r,s){void 0===s&&(s=r),Object.defineProperty(e,s,{enumerable:!0,get:function(){return t[r]}})}:function(e,t,r,s){void 0===s&&(s=r),e[s]=t[r]}),__setModuleDefault=this&&this.__setModuleDefault||(Object.create?function(e,t){Object.defineProperty(e,"default",{enumerable:!0,value:t})}:function(e,t){e.default=t}),__importStar=this&&this.__importStar||function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)"default"!==r&&Object.prototype.hasOwnProperty.call(e,r)&&__createBinding(t,e,r);return __setModuleDefault(t,e),t},__importDefault=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(exports,"__esModule",{value:!0}),exports.buildProjectScriptsX=void 0;const fs_extra_1=require("fs-extra"),path_1=require("path"),babel=__importStar(require("@babel/core")),rollup=__importStar(require("rollup")),rollup_plugin_sourcemaps_1=__importDefault(require("rollup-plugin-sourcemaps")),rollup_plugin_terser_1=require("rollup-plugin-terser"),babel_preset_cc_1=__importDefault(require("@cocos/babel-preset-cc")),path_2=__importDefault(require("path")),pack_mods_1=require("../../utils/pack-mods"),utils_1=require("../../utils"),mod_lo_1=require("@editor/lib-programming/dist/mod-assembling/mod-lo/mod-lo"),rollup_plugin_mod_lo_1=__importDefault(require("@editor/lib-programming/dist/mod-assembling/rollup-plugin-mod-lo")),to_named_register_1=__importDefault(require("../../utils/to-named-register")),url_1=require("url");async function buildProjectScriptsX(e,t,r,s,o){var i,a;t.scriptPackages.length=0;const n={};(null===(i=e.buildScriptParam.polyfills)||void 0===i?void 0:i.asyncFunctions)||(null!==(a=n.excludes)&&void 0!==a?a:n.excludes=[]).push("transform-regenerator"),e.buildScriptParam.targets&&(n.targets=e.buildScriptParam.targets);let u="facade";e.buildScriptParam.experimentalEraseModules&&(u="erase");const l=await Editor.Message.request("programming","query-shared-settings");await buildScript(Object.assign({bundles:t.bundles.map(e=>({id:e.name,scripts:e.scripts.map(e=>r.getAssetInfo(e)),outFile:e.scriptDest})),debug:e.debug,sourceMaps:e.sourceMaps,modulePreservation:u,moduleFormat:"system",transform:n,outDir:t.paths.dir},l),r,t,o);for(let e=0;e<t.plugins.length;e++){const s=r.getAssetInfo(t.plugins[e]),o=utils_1.removeDbHeader(s.url),i=path_1.join(t.paths.dir,"src",o);fs_extra_1.ensureDirSync(path_1.dirname(i)),fs_extra_1.copyFileSync(s.library[".js"],i)}console.debug("Copy externalScripts success!")}async function buildScript(e,t,r,s){var o,i,a,n,u,l;if(0===e.bundles.length)return;const c=Object.entries(s).map(([e,t])=>`export const ${e} = ${t};`).join("\n"),{bundles:p,modulePreservation:d}=e,_={},m=[],f=[],h={},g={},b=[];for(let e=0;e<p.length;++e){const t=p[e];for(const r of t.scripts){const t=url_1.pathToFileURL(r.file).href;h[t]=r.uuid,"facade"!==d&&"preserve"!==d||f.push(t),"preserve"!==d&&(g[t]=e)}if("preserve"!==d){const r=`virtual:///prerequisite-imports/${t.id}`;_[r]=t.scripts.map(e=>e.file).map(e=>`import "${url_1.pathToFileURL(e).href}";`).join("\n"),g[r]=e,f.push(r),b.push(r),m.push(r)}}const v=new mod_lo_1.ModLo({targets:e.transform.targets,loose:e.loose,exportsConditions:e.exportsConditions,guessCommonJsExports:e.guessCommonJsExports,_cc:[babel_preset_cc_1.default,{useDefineForClassFields:e.useDefineForClassFields,allowDeclareFields:e.allowDeclareFields}],_internalTransform:{excludes:null!==(i=null===(o=e.transform)||void 0===o?void 0:o.excludes)&&void 0!==i?i:[],includes:null!==(n=null===(a=e.transform)||void 0===a?void 0:a.includes)&&void 0!==n?n:[]},_compressUUID:e=>Build.Utils.compressUuid(e,!1),_helperModule:rollup_plugin_mod_lo_1.default.helperModule}),M=e.importMap,j={},y=M?new url_1.URL(M.url):new url_1.URL("foo:/bar");j.imports={"cc/env":"virtual:/cc/env"};const w=await Editor.Message.request("asset-db","query-db-list"),k=[];for(const e of w){const t=await Editor.Message.request("asset-db","query-db-info",e),r=`db://${e}/`,s=url_1.pathToFileURL(path_2.default.join(t.target,path_2.default.join(path_2.default.sep))).href;j.imports[r]=s,k.push(s)}if(M&&(M.json.imports&&(j.imports=Object.assign(Object.assign({},j.imports),M.json.imports)),M.json.scopes))for(const[e,t]of Object.entries(M.json.scopes)){const r=null!==(u=j.scopes)&&void 0!==u?u:j.scopes={};r[e]=Object.assign(Object.assign({},null!==(l=r[e])&&void 0!==l?l:{}),t)}v.setImportMap(j,y),v.setAssetPrefixes(k),v.addMemoryModule("virtual:/cc/env",c);for(const[e,t]of Object.entries(_))v.addMemoryModule(e,t);for(const[e,t]of Object.entries(h))v.setUUID(e,t);const D=[rollup_plugin_mod_lo_1.default({modLo:v})];"facade"!==d&&"erase"!==d||D.push(rpNamedChunk()),e.sourceMaps&&D.push(rollup_plugin_sourcemaps_1.default()),e.debug||D.push(rollup_plugin_terser_1.terser()),"erase"===d&&D.push({name:"cocos-creator/resolve-import-meta",resolveImportMeta(e,{moduleId:t}){switch(e){default:return;case"url":try{return`'${new url_1.URL(t).href}'`}catch(e){return void console.error(`Can not access import.meta.url of module '${t}'. '${t}' is not a valid URL.`)}}}});let x=!1;const q={input:f,plugins:D,preserveModules:"erase"!==d,external:["cc"],onwarn:(e,t)=>{var r;if(x&&"object"==typeof e&&"EMPTY_BUNDLE"===e.code)return;if("string"!=typeof e&&"CIRCULAR_DEPENDENCY"===e.code&&(null===(r=e.importer)||void 0===r?void 0:r.includes("node_modules")))return;const s="object"==typeof e&&e.message||e;console.warn(`[[Build.Script.Rollup]] ${s}`)}},P=await rollup.rollup(q),S={sourcemap:e.sourceMaps,exports:"named"};if("preserve"===e.modulePreservation){const t=Object.assign(Object.assign({},S),{format:e.moduleFormat});await P.write(t)}else{const t=Object.assign(Object.assign({},S),{format:"system",dir:"chunks:///",systemNullSetters:!0});x=!0;const s=await P.generate(t),o=path_2.default.join(e.outDir,"src","chunks","bundle.js"),i=new ChunkBundler(o);let a=0;const n=p.map(e=>new ChunkBundler(e.outFile));for(const e of s.output)if("chunk"===e.type)if(e.isEntry){const{facadeModuleId:t}=e,r=t?g[t]:null;null===r||void 0===n[r]?(console.warn(`Unexpected: entry chunk name ${e.name} is not in list.`),i.add(e),++a):(n[r].add(e),t&&m.includes(t)&&n[r].addModuleMapping(t,getChunkUrl(e)))}else i.add(e),++a;if(await Promise.all(n.map(async(t,r)=>{await t.write({sourceMaps:e.sourceMaps,wrap:!1})})),a){await i.write({sourceMaps:e.sourceMaps,wrap:!0});const t=utils_1.relativeUrl(path_2.default.dirname(r.paths.applicationJS),o);r.scriptPackages.push(`./${t}`)}}}exports.buildProjectScriptsX=buildProjectScriptsX;class ChunkBundler{constructor(e){this._parts=[],this._chunkMappings={},this._out=e}add(e){var t;this._parts.push({code:e.code,map:null===(t=e.map)||void 0===t?void 0:t.toString()})}addModuleMapping(e,t){this._chunkMappings[e]=t}async write(e){return await pack_mods_1.packMods(this._parts,this._chunkMappings,this._out,e)}}function rpNamedChunk(){return{name:"named-chunk",renderChunk:async function(e,t,r){const s=getChunkUrl(t),o=await babel.transformAsync(e,{sourceMaps:!0,compact:!1,plugins:[[to_named_register_1.default,{name:s}]]});return o?{code:o.code,map:o.map}:(this.warn("Failed to render chunk."),null)}}}function getChunkUrl(e){return`chunks:///${e.fileName}`}