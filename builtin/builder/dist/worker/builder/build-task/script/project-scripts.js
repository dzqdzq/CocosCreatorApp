"use strict";var __createBinding=this&&this.__createBinding||(Object.create?function(e,r,t,s){void 0===s&&(s=t),Object.defineProperty(e,s,{enumerable:!0,get:function(){return r[t]}})}:function(e,r,t,s){void 0===s&&(s=t),e[s]=r[t]}),__setModuleDefault=this&&this.__setModuleDefault||(Object.create?function(e,r){Object.defineProperty(e,"default",{enumerable:!0,value:r})}:function(e,r){e.default=r}),__importStar=this&&this.__importStar||function(e){if(e&&e.__esModule)return e;var r={};if(null!=e)for(var t in e)"default"!==t&&Object.prototype.hasOwnProperty.call(e,t)&&__createBinding(r,e,t);return __setModuleDefault(r,e),r},__importDefault=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(exports,"__esModule",{value:!0}),exports.buildProjectScriptsX=void 0;const fs_extra_1=require("fs-extra"),path_1=require("path"),babel=__importStar(require("@babel/core")),rollup=__importStar(require("rollup")),rollup_plugin_sourcemaps_1=__importDefault(require("rollup-plugin-sourcemaps")),rollup_plugin_terser_1=require("rollup-plugin-terser"),path_2=__importDefault(require("path")),pack_mods_1=require("../../utils/pack-mods"),utils_1=require("../../utils"),to_named_register_1=__importDefault(require("../../utils/to-named-register")),url_1=require("url"),mod_lo_1=require("@cocos/creator-programming-mod-lo/lib/mod-lo"),creator_programming_rollup_plugin_mod_lo_1=__importDefault(require("@cocos/creator-programming-rollup-plugin-mod-lo"));async function buildProjectScriptsX(e,r,t,s,o){var a,i;r.scriptPackages.length=0;const n={};(null===(a=e.buildScriptParam.polyfills)||void 0===a?void 0:a.asyncFunctions)||(null!==(i=n.excludes)&&void 0!==i?i:n.excludes=[]).push("transform-regenerator"),e.buildScriptParam.targets&&(n.targets=e.buildScriptParam.targets);let u="facade";e.buildScriptParam.experimentalEraseModules&&(u="erase");const l=await Editor.Message.request("programming","query-shared-settings");await buildScript(Object.assign({bundles:r.bundles.map(e=>({id:e.name,scripts:e.scripts.map(e=>t.getAssetInfo(e)).sort((e,r)=>e.name.localeCompare(r.name)),outFile:e.scriptDest})),debug:e.debug,sourceMaps:e.sourceMaps,modulePreservation:u,moduleFormat:"system",transform:n,outDir:r.paths.dir},l),t,r,o);for(let e=0;e<r.plugins.length;e++){const s=t.getAssetInfo(r.plugins[e]),o=utils_1.removeDbHeader(s.url),a=path_1.join(r.paths.dir,"src",o);fs_extra_1.ensureDirSync(path_1.dirname(a)),fs_extra_1.copyFileSync(s.library[".js"],a)}console.debug("Copy externalScripts success!")}async function buildScript(e,r,t,s){var o,a,i,n,u,l;if(0===e.bundles.length)return;const c=Object.entries(s).map(([e,r])=>`export const ${e} = ${r};`).join("\n"),{bundles:p,modulePreservation:d}=e,m={},_=[],f=[],g={},h={},b=[];for(let e=0;e<p.length;++e){const r=p[e];for(const t of r.scripts){const r=url_1.pathToFileURL(t.file).href;g[r]=t.uuid,"facade"!==d&&"preserve"!==d||f.push(r),"preserve"!==d&&(h[r]=e)}if("preserve"!==d){const t=`virtual:///prerequisite-imports/${r.id}`;m[t]=r.scripts.map(e=>e.file).sort().map(e=>`import "${url_1.pathToFileURL(e).href}";`).join("\n"),h[t]=e,f.push(t),b.push(t),_.push(t)}}const v=new mod_lo_1.ModLo({targets:e.transform.targets,loose:e.loose,exportsConditions:e.exportsConditions,guessCommonJsExports:e.guessCommonJsExports,useDefineForClassFields:e.useDefineForClassFields,allowDeclareFields:e.allowDeclareFields,_internalTransform:{excludes:null!==(a=null===(o=e.transform)||void 0===o?void 0:o.excludes)&&void 0!==a?a:[],includes:null!==(n=null===(i=e.transform)||void 0===i?void 0:i.includes)&&void 0!==n?n:[]},_compressUUID:e=>Build.Utils.compressUuid(e,!1),_helperModule:creator_programming_rollup_plugin_mod_lo_1.default.helperModule}),M=e.importMap,j={},y=M?new url_1.URL(M.url):new url_1.URL("foo:/bar");j.imports={"cc/env":"virtual:/cc/env","cc/userland/macro":"virtual:/cc/userland/macro"};const w=await Editor.Message.request("asset-db","query-db-list"),k=[];for(const e of w){const r=await Editor.Message.request("asset-db","query-db-info",e),t=`db://${e}/`,s=url_1.pathToFileURL(path_2.default.join(r.target,path_2.default.join(path_2.default.sep))).href;j.imports[t]=s,k.push(s)}if(M&&(M.json.imports&&(j.imports=Object.assign(Object.assign({},j.imports),M.json.imports)),M.json.scopes))for(const[e,r]of Object.entries(M.json.scopes)){const t=null!==(u=j.scopes)&&void 0!==u?u:j.scopes={};t[e]=Object.assign(Object.assign({},null!==(l=t[e])&&void 0!==l?l:{}),r)}v.setImportMap(j,y),v.setAssetPrefixes(k),v.addMemoryModule("virtual:/cc/env",c);const x=await Editor.Profile.getProject("engine","macroCustom");v.addMemoryModule("virtual:/cc/userland/macro",x.map(e=>`export const ${e.key} = ${e.value};`).join("\n"));for(const[e,r]of Object.entries(m))v.addMemoryModule(e,r);for(const[e,r]of Object.entries(g))v.setUUID(e,r);const C=[creator_programming_rollup_plugin_mod_lo_1.default({modLo:v})];"facade"!==d&&"erase"!==d||C.push(rpNamedChunk()),e.sourceMaps&&C.push(rollup_plugin_sourcemaps_1.default()),e.debug||C.push(rollup_plugin_terser_1.terser()),"erase"===d&&C.push({name:"cocos-creator/resolve-import-meta",resolveImportMeta(e,{moduleId:r}){switch(e){default:return;case"url":try{return`'${new url_1.URL(r).href}'`}catch(e){return void console.error(`Can not access import.meta.url of module '${r}'. '${r}' is not a valid URL.`)}}}});let D=!1;const P={input:f,plugins:C,preserveModules:"erase"!==d,external:["cc"],onwarn:(e,r)=>{var t;if(D&&"object"==typeof e&&"EMPTY_BUNDLE"===e.code)return;if("string"!=typeof e&&"CIRCULAR_DEPENDENCY"===e.code&&(null===(t=e.importer)||void 0===t?void 0:t.includes("node_modules")))return;const s="object"==typeof e&&e.message||e;console.warn(`[[Build.Script.Rollup]] ${s}`)}},S=await rollup.rollup(P),q={sourcemap:e.sourceMaps,exports:"named"};if("preserve"===e.modulePreservation){const r=Object.assign(Object.assign({},q),{format:e.moduleFormat});await S.write(r)}else{const r=Object.assign(Object.assign({},q),{format:"system",dir:"chunks:///",systemNullSetters:!0});D=!0;const s=await S.generate(r),o=path_2.default.join(e.outDir,"src","chunks","bundle.js"),a=new ChunkBundler(o);let i=0;const n=p.map(e=>new ChunkBundler(e.outFile));for(const e of s.output)if("chunk"===e.type)if(e.isEntry){const{facadeModuleId:r}=e,t=r?h[r]:null;null===t||void 0===n[t]?(console.warn(`Unexpected: entry chunk name ${e.name} is not in list.`),a.add(e),++i):(n[t].add(e),r&&_.includes(r)&&n[t].addModuleMapping(r,getChunkUrl(e)))}else a.add(e),++i;if(await Promise.all(n.map(async(r,t)=>{await r.write({sourceMaps:e.sourceMaps,wrap:!1})})),i){await a.write({sourceMaps:e.sourceMaps,wrap:!0});const r=utils_1.relativeUrl(path_2.default.dirname(t.paths.applicationJS),o);t.scriptPackages.push(`./${r}`)}}}exports.buildProjectScriptsX=buildProjectScriptsX;class ChunkBundler{constructor(e){this._parts=[],this._chunkMappings={},this._out=e}add(e){var r;this._parts.push([e.fileName,{code:e.code,map:null===(r=e.map)||void 0===r?void 0:r.toString()}])}addModuleMapping(e,r){this._chunkMappings[e]=r}async write(e){return await pack_mods_1.packMods(this._parts.sort(([e],[r])=>e.localeCompare(r)).map(([e,r])=>r),this._chunkMappings,this._out,e)}}function rpNamedChunk(){return{name:"named-chunk",renderChunk:async function(e,r,t){const s=getChunkUrl(r),o=await babel.transformAsync(e,{sourceMaps:!0,compact:!1,plugins:[[to_named_register_1.default,{name:s}]]});return o?{code:o.code,map:o.map}:(this.warn("Failed to render chunk."),null)}}}function getChunkUrl(e){return`chunks:///${e.fileName}`}