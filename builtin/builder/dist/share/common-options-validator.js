"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.checkProjectSetting=exports.checkBuildCommondOptions=exports.checkBuildCommonOptionsByKey=exports.getCommonOptionDefaultByKey=exports.getCommonOptions=void 0;const path_1=require("path"),bundle_utils_1=require("./bundle-utils"),platforms_options_1=require("./platforms-options"),validator_manager_1=require("./validator-manager");function supportPlatform(e){return e&&!!platforms_options_1.builtinPlugins.includes(e)}async function checkScenes(e){if(!Array.isArray(e))return!1;for(const t of e){if(!t||!t.uuid)return!1;if(!await checkAssetExsit(t.uuid))return console.debug(` scene(${t.uuid}) does not exist in library!`),!1}return!0}async function checkAssetExsit(e){if("string"!=typeof e)return!1;return!!await Editor.Message.request("asset-db","query-asset-info",e)}async function checkStartScene(e){if("string"!=typeof e)return!1;const t=await Editor.Message.request("asset-db","query-asset-info",e);return!!t&&!(await Editor.Message.request("asset-db","query-assets",{isBundle:!0})).find(e=>t.url.startsWith(e.url+"/"))}function checkIncludeModules(e){return!!Array.isArray(e)||` includeModules(${e}) should be an array!`}const commonOptionsCheckRules={name:["required"],buildPath:["required"],platform:["required","supportPlatform"],outputName:["required","normalName"]};async function getCommonOptions(e=!1){const t=await Editor.Profile.getConfig("builder","common",e?"default":void 0);return t.scenes=await getCommonOptionDefaultByKey("scenes"),t.startScene=e?t.scenes&&t.scenes[0].uuid:t.startScene||t.scenes&&t.scenes[0].uuid,t.packages={},t}async function getCommonOptionDefaultByKey(e,t){switch(e){case"scenes":{const e=await Editor.Message.request("asset-db","query-assets",{type:"scene"});if(!e)return[];const t=await Editor.Message.request("asset-db","query-assets",{isBundle:!0});return e.map(e=>({url:e.url,uuid:e.uuid,inBundle:!!t.find(t=>e.url.startsWith(t.url+"/"))}))}case"startScene":{const e=(await getCommonOptionDefaultByKey("scenes")).filter(e=>!e.inBundle);return e[0]&&e[0].uuid}default:return await Editor.Profile.getConfig("builder",`common.${e}`)}}async function checkBuildCommonOptionsByKey(e,t,r){const n={error:"",newValue:t};switch(e){case"scenes":return await checkScenes(t)||""||(n.error=`scene ${t} is invalid.`),n.error&&(n.newValue=await getCommonOptionDefaultByKey("scenes")),n;case"startScene":return await checkStartScene(t)||""||(n.error=` startScene (${t}) does not exist in library or is in Bundle!`),n.error&&(n.newValue=await getCommonOptionDefaultByKey("startScene")),n;case"mainBundleIsRemote":return t&&r.mainBundleCompressionType===bundle_utils_1.BundleCompressionTypes.SUBPACKAGE?(n.newValue=!1,n.error=" bundle can not be remote when compression type is subpackage!"):t||r.mainBundleCompressionType!==bundle_utils_1.BundleCompressionTypes.ZIP||(n.newValue=!0,n.error=" bundle must be remote when compression type is zip!"),n;case"buildPath":t?path_1.isAbsolute(Editor.UI.File.resolveToRaw(t))||(n.error=`buildPath(${t}) is invalid!`,n.newValue="project://build"):(n.error=" buildPath can not be empty",n.newValue="project://build");break;case"md5Cache":case"debug":case"sourceMaps":case"replaceSplashScreen":case"mainBundleIsRemote":case"mergeStartScene":case"experimentalEraseModules":"false"===t&&(n.error=`typeof ${e} should be boolean but get ${t}`,n.newValue=!1),n.newValue=!!t;break;default:const o=commonOptionsCheckRules[e];if(o)return n.error=validator_manager_1.validatorManager.check(t,r,o)||"",n.error&&(n.newValue=await getCommonOptionDefaultByKey(e)),n}return n}async function checkBuildCommondOptions(e){const t=await Editor.Profile.getConfig("builder","common","default"),r={};for(const n of Object.keys(t))r[n]=await checkBuildCommonOptionsByKey(n,e[n],e);return r}async function checkProjectSetting(e,t=!1){e.includeModules&&t||(e.includeModules=await Editor.Profile.getProject("engine","modules.includeModules")||[]),e.designResolution&&t||(e.designResolution=await Editor.Profile.getProject("project","general.designResolution")),e.renderPipeline&&t||(e.renderPipeline=await Editor.Profile.getProject("project","general.renderPipeline")),e.physicsConfig&&t||(e.physicsConfig=await Editor.Profile.getProject("project","physics"))}validator_manager_1.validatorManager.addRule("supportPlatform",supportPlatform),validator_manager_1.validatorManager.addRule("checkStartScene",checkStartScene),validator_manager_1.validatorManager.addMessage("supportPlatform","i18n:builder.error.unknown_platform"),validator_manager_1.validatorManager.addMessage("checkStartScene","StartScene is invalid."),exports.getCommonOptions=getCommonOptions,exports.getCommonOptionDefaultByKey=getCommonOptionDefaultByKey,exports.checkBuildCommonOptionsByKey=checkBuildCommonOptionsByKey,exports.checkBuildCommondOptions=checkBuildCommondOptions,exports.checkProjectSetting=checkProjectSetting;