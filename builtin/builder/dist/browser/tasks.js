"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.buildWithCommand=exports.manager=exports.TaskManager=void 0;const events_1=require("events"),path_1=require("path"),fs_extra_1=require("fs-extra"),plugin_1=require("./plugin"),utils_1=require("../share/utils"),migration_1=require("./migration"),common_options_validator_1=require("../share/common-options-validator"),worker=require("@base/electron-worker");class TaskItem{constructor(t,s,e,i=!1){this.state="waiting",this.progress=0,this.message="",this.time="",this.dirty=!1,this.isCommandBuild=!1,this.free=!0,this.type="build",this.options=s,this.id=t||String(Date.now()),this.isCommandBuild=i,e&&(this.resolve=e)}build(){return new Promise(async t=>{let s;this.time=utils_1.getCurrentTime(),console.debug("Check and complete build options",this.options);let e=!0;try{const t=await common_options_validator_1.checkBuildCommondOptions(this.options);for(const s of Object.keys(t))t[s].error&&(t[s].newValue?(console.warn(t[s].error,`will use the new value ${t[s].newValue}`),this.options[s]=t[s].newValue):(console.error(t[s].error),e=!1));s=await plugin_1.pluginManager.checkOptions(this.options)}catch(t){console.error(t)}if(!s||!e)return this.update(0,"failure",Editor.I18n.t("builder.error.check_options_failed")),this.resolve&&this.resolve(332),void t();this.options=s,this.dirty=!1,delete this.rawOptions;const i=worker.query("Build"),a=plugin_1.pluginManager.getHooksInfo(this.options.platform);this._resolve=t,i.send("build-worker:build",this.id,this.options,a,!!this.isCommandBuild)})}compile(){return new Promise(t=>{this.dirty=!1,this.time=utils_1.getCurrentTime();const s=worker.query("Build"),e=plugin_1.pluginManager.getHooksInfo(this.options.platform),i=path_1.join(Editor.UI.File.resolveToRaw(this.options.buildPath),this.options.outputName);this._resolve=t,s.send("build-worker:compile",e,i,this.id,!!this.isCommandBuild)})}break(){this.message="The build process was interrupted",this.state="failure",this.free=!0,this.emitChange()}reset(){this.progress=0,this.state="waiting",this.message="",this.emitChange()}update(t,s,e){return this.progress=Editor.Utils.Math.clamp01(t),this.state="string"==typeof s?s:this.state,this.message="string"==typeof e?e:this.message,this.isCommandBuild?("failure"===this.state?(console.log("build failed!"),this.resolve(334)):"success"===this.state&&(console.log("build success!"),this.resolve(336)),void this.emitChange()):"success"===this.state||"failure"===this.state?(Editor.Task.addNotice({title:this.options.outputName,message:this.time+" "+this.message,source:"builder",type:"success"===this.state?"success":"error"}),this.free=!0,this.emitChange(),void(this._resolve&&this._resolve())):(this.free=!1,void this.emitChange())}toJSON(){return{id:this.id,progress:this.progress,state:this.state,message:this.message,options:this.options,time:this.time,dirty:this.dirty,rawOptions:this.rawOptions}}emitChange(){Editor.Message.broadcast("builder:task-changed",this.id,this.toJSON(),TaskManager.supportTaskQueue||this.free)}}class TaskManager extends events_1.EventEmitter{constructor(){super(...arguments),this.command=!1,this.currentTaskId="",this.workerReady=!1,this.dbReady=!1,this.queue=[],this.map={},this.waitingTaskIDs=[]}get ready(){return this.workerReady&&this.dbReady}get free(){return TaskManager.supportTaskQueue||!this.waitingTaskIDs.length}async init(){const t=await Editor.Profile.getConfig("builder","BuildTaskManager.taskMap")||{};Object.keys(t).sort((t,s)=>t.localeCompare(s,"en",{numeric:!0})).forEach(s=>{const e=t[s],i=new TaskItem(e.id,e.options);i.state=e.state||"waiting",1!==e.progress&&(i.state="failure"),i.rawOptions=e.rawOptions,i.progress=e.progress,i.message=e.message,i.time=e.time?e.time:utils_1.changeToLocalTime(e.id),this.map[e.id]?console.warn("The same task name has exists!"):(this.map[e.id]=i,this.queue.push(i))})}async checkCanAddTask(t){return t&&this.waitingTaskIDs.includes(t)?(console.log(Editor.I18n.t("builder.tips.task_exist")),!1):!(this.waitingTaskIDs.length&&!TaskManager.supportTaskQueue)||(console.warn(Editor.I18n.t("builder.tips.task_busy")),!1)}async save(){if(this.command)return;const t={};this.queue.map(s=>{t[s.id]=s.toJSON()}),await Editor.Profile.setConfig("builder","BuildTaskManager.taskMap",t,"local"),await new Promise(t=>{setTimeout(()=>{t()},800)})}async push(t,s,e){if(!this.checkCanAddTask())return;const i=this._getId(),a=this.queue.indexOf(this.map[i]);-1!==a&&this.queue.splice(a,1);const r=new TaskItem(i,t,s,e);r.type="build",this.map[i]=r,this.queue.push(r),this.waitingTaskIDs.push(i),await this.step()}async pop(t){if(!this.map[t])return;const s=this.map[t];delete this.map[t];const e=this.queue.indexOf(s);-1!==e&&this.queue.splice(e,1);const i=this.waitingTaskIDs.indexOf(t);-1!==i&&this.waitingTaskIDs.splice(i,1),await this.save(),fs_extra_1.removeSync(path_1.join(Editor.Project.path,"temp","build-log",s.id+".log")),Editor.Message.broadcast("builder:task-changed",t,null)}async recompile(t,s,e){if(!this.checkCanAddTask(t))return;const i=this.map[t];i&&(this.waitingTaskIDs.includes(t)?i.update(0,"waiting","Wait a moment, build task is busy"):(i.resolve=e,i.options=s||i.options,i.type="build",this.waitingTaskIDs.push(t),await this.step()))}async compile(t,s){if(!this.checkCanAddTask(t))return;if(!this.map[t])return;if(this.waitingTaskIDs.includes(t))return void console.log("Wait a moment, build task is busy");this.map[t].type="compile",this.waitingTaskIDs.push(t),await this.step()}async run(t){this.map[t]}break(){this.queue.forEach(t=>{t.free=!0,1!==t.progress&&(!this.command||this.currentTaskId===t.id&&this.command)&&t.break()}),this.waitingTaskIDs=[],Editor.Message.broadcast("builder:task-changed")}async step(){if(0===this.waitingTaskIDs.length||!this.ready)return;const t=this.waitingTaskIDs[0],s=this.map[t];s&&s.free&&(this.ready?(s.free=!1,s.reset(),this.currentTaskId=t,"build"===s.type?await s.build():await s.compile(),await this.save(),s.free=!0,this.waitingTaskIDs.shift(),await this.step()):s.update(0,"waiting","Wait DB or worker ready"))}_getId(){return String((new Date).getTime())}}async function buildWithCommand(t,s){if(t.configPath){if(!fs_extra_1.existsSync(t.configPath))return void console.error(`${t.configPath} is not exist!`);const s=fs_extra_1.readJSONSync(t.configPath);t=Object.assign(t,s)}if(t.packages&&"string"==typeof t.packages)try{t.packages=JSON.parse(t.packages)}catch(s){t.packages={}}if(!t.platform)return console.error("build failed! Please to specify a packaging platform"),void(s&&s(332));!1!==t.migrate&&await migration_1.migrateOptions(t);const e=await common_options_validator_1.checkBuildCommonOptionsByKey("buildPath",t.buildPath,t);if(e.error&&!e.newValue)return console.error(e.error),void(s&&s(332));t.buildPath=e.newValue,t.outputName||(t.outputName=t.platform),exports.manager.command=!0,exports.manager.push(t,s,!0)}exports.TaskManager=TaskManager,TaskManager.supportTaskQueue=!1,exports.manager=new TaskManager,exports.buildWithCommand=buildWithCommand;