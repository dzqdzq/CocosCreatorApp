"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.buildWithCommand=exports.manager=exports.TaskManager=void 0;const events_1=require("events"),path_1=require("path"),fs_extra_1=require("fs-extra"),plugin_1=require("./plugin"),utils_1=require("../share/utils"),migration_1=require("./migration"),common_options_validator_1=require("../share/common-options-validator"),worker=require("@base/electron-worker");class TaskItem{constructor(s,t,e,i=!1){this.state="waiting",this.progress=0,this.message="",this.time="",this.dirty=!1,this.isCommandBuild=!1,this.free=!0,this.type="build",this.breakType="",this.options=t,this.id=s||String(Date.now()),this.isCommandBuild=i,e&&(this.resolve=e)}build(){return new Promise(async s=>{let t;this.time=utils_1.getCurrentTime(),console.debug("Check and complete build options",this.options);let e=!0;try{const s=await common_options_validator_1.checkBuildCommondOptions(this.options);for(const t of Object.keys(s)){const i=s[t].newValue;s[t].error&&(null!==i?console.warn(s[t].error,`will use the new value ${s[t].newValue}`):(console.error(s[t].error),e=!1)),null!==i&&void 0!==i&&(this.options[t]=i)}t=await plugin_1.pluginManager.checkOptions(this.options)}catch(s){console.error(s)}if(!t||!e)return this.update(0,"failure",Editor.I18n.t("builder.error.check_options_failed")),this.resolve&&this.resolve(32),void s();this.options=t,this.dirty=!1,delete this.rawOptions;const i=worker.query("Build"),a=plugin_1.pluginManager.getHooksInfo(this.options.platform);this.isCommandBuild||(this.resolve=s);const r=await i.send("build-worker:build",this.id,this.options,a,!!this.isCommandBuild);this.state=r?"success":"failure",this.free=!0,s()})}async compile(){this.dirty=!1,this.time=utils_1.getCurrentTime();const s=worker.query("Build"),t=plugin_1.pluginManager.getHooksInfo(this.options.platform),e=path_1.join(Editor.UI.File.resolveToRaw(this.options.buildPath),this.options.outputName);await s.send("build-worker:compile",t,e,this.id,!!this.isCommandBuild)}break(s){this.breakType=s?"crashed":"",this.message=`The build process was ${this.breakType||"interrupted"}`,this.state="failure",this.free=!0,this.emitChange()}reset(){this.progress=0,this.state="waiting",this.message="",this.emitChange()}update(s,t,e){this.progress=Editor.Utils.Math.clamp01(s),this.state="string"==typeof t?t:this.state,this.message="string"==typeof e?e:this.message,["success","failure"].includes(this.state)&&(Editor.Task.addNotice({title:this.options.outputName,message:this.time+" "+this.message,source:"builder",type:"success"===this.state?"success":"error"}),this.free=!0,"success"!==this.state?this.resolve&&this.resolve(34):this.resolve&&this.resolve(36)),this.emitChange()}toJSON(){return{id:this.id,progress:this.progress,state:this.state,message:this.message,options:this.options,time:this.time,dirty:this.dirty,rawOptions:this.rawOptions}}emitChange(){Editor.Message.broadcast("builder:task-changed",this.id,this.toJSON(),TaskManager.supportTaskQueue||this.free)}}class TaskManager extends events_1.EventEmitter{constructor(){super(...arguments),this.command=!1,this.currentTaskId="",this.hasBuildNum=0,this.workerReady=!1,this.dbReady=!1,this.queue=[],this.map={},this.waitingTaskIDs=[],this.crashNum=0}get ready(){return this.workerReady&&this.dbReady}get free(){return TaskManager.supportTaskQueue||!this.waitingTaskIDs.length}async init(){const s=await Editor.Profile.getConfig("builder","BuildTaskManager.taskMap")||{};Object.keys(s).sort((s,t)=>s.localeCompare(t,"en",{numeric:!0})).forEach(t=>{const e=s[t],i=new TaskItem(e.id,e.options);i.state=e.state||"waiting",1!==e.progress&&(i.state="failure"),i.rawOptions=e.rawOptions,i.progress=e.progress,i.message=e.message,i.time=e.time?e.time:utils_1.changeToLocalTime(e.id),this.map[e.id]?console.warn("The same task name has exists!"):(this.map[e.id]=i,this.queue.push(i))})}waitingForReady(){return new Promise(s=>{if(isM1()&&this.hasBuildNum){const t=worker.query("Build");this.waitingForReadyResolve=s,t.win.webContents.reload()}else this.waitingForReadyResolve=null,s()})}async checkCanAddTask(s){return s&&this.waitingTaskIDs.includes(s)?(console.log(Editor.I18n.t("builder.tips.task_exist")),!1):!(this.waitingTaskIDs.length&&!TaskManager.supportTaskQueue)||(console.warn(Editor.I18n.t("builder.tips.task_busy")),!1)}async save(){if(this.command)return;const s={};this.queue.map(t=>{s[t.id]=t.toJSON()}),await Editor.Profile.setConfig("builder","BuildTaskManager.taskMap",s,"local"),await new Promise(s=>{setTimeout(()=>{s()},800)})}async push(s,t,e){if(!this.checkCanAddTask())return;const i=this._getId(),a=this.queue.indexOf(this.map[i]);-1!==a&&this.queue.splice(a,1);const r=new TaskItem(i,s,t,e);r.type="build",this.map[i]=r,this.queue.push(r),this.waitingTaskIDs.push(i),await this.step()}async pop(s){if(!this.map[s])return;const t=this.map[s];delete this.map[s];const e=this.queue.indexOf(t);-1!==e&&this.queue.splice(e,1);const i=this.waitingTaskIDs.indexOf(s);-1!==i&&this.waitingTaskIDs.splice(i,1),await this.save(),fs_extra_1.removeSync(path_1.join(Editor.Project.path,"temp","build-log",t.id+".log")),Editor.Message.broadcast("builder:task-changed",s,null)}async recompile(s,t,e){if(!this.checkCanAddTask(s))return;const i=this.map[s];i&&(this.waitingTaskIDs.includes(s)?i.update(0,"waiting","Wait a moment, build task is busy"):(i.resolve=e,i.options=t||i.options,i.type="build",this.waitingTaskIDs.push(s),this.currentTaskId||await this.step()))}async compile(s,t){if(!this.checkCanAddTask(s))return;if(!this.map[s])return;if(this.waitingTaskIDs.includes(s))return void console.log("Wait a moment, build task is busy");this.map[s].type="compile",this.waitingTaskIDs.push(s),await this.step()}async run(s){this.map[s]}break(s){this.currentTaskId="",!s&&this.waitingForReadyResolve||(this.queue.forEach(t=>{t.free=!0,1!==t.progress&&(!this.command||this.currentTaskId===t.id&&this.command)&&t.break(s)}),this.waitingTaskIDs=[],Editor.Message.broadcast("builder:task-changed"))}async step(){if(0===this.waitingTaskIDs.length||!this.ready)return;const s=this.waitingTaskIDs[0],t=this.map[s];t&&t.free&&(this.ready?(t.free=!1,t.reset(),this.currentTaskId=s,"build"===t.type?await t.build():await t.compile(),this.hasBuildNum++,await this.save(),"success"===t.state&&(this.crashNum=0),this.waitingTaskIDs.shift(),this.currentTaskId="",t.free=!0,await this.step()):t.update(0,"waiting","Wait DB or worker ready"))}_getId(){return String((new Date).getTime())}}async function buildWithCommand(s,t){if(s.configPath){if(!fs_extra_1.existsSync(s.configPath))return console.error(`${s.configPath} is not exist!`),void(t&&t(32));const e=fs_extra_1.readJSONSync(s.configPath);s=Object.assign(s,e)}if(s.packages&&"string"==typeof s.packages)try{s.packages=JSON.parse(s.packages)}catch(t){s.packages={}}if(!s.platform)return console.error("build failed! Please to specify a packaging platform"),void(t&&t(32));!1!==s.migrate&&await migration_1.migrateOptions(s);const e=await common_options_validator_1.checkBuildCommonOptionsByKey("buildPath",s.buildPath,s);if(e.error&&!e.newValue)return console.error(e.error),void(t&&t(32));s.buildPath=e.newValue,s.outputName||(s.outputName=s.platform),exports.manager.command=!0,exports.manager.push(s,t,!0)}function isM1(){const s=require("os").cpus(),t=s&&s[0]&&s[0].model?s[0].model:"";return/Apple/.test(t)}exports.TaskManager=TaskManager,TaskManager.supportTaskQueue=!1,exports.manager=new TaskManager,exports.buildWithCommand=buildWithCommand;