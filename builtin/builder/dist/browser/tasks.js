"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.manager=exports.TaskManager=void 0;const events_1=require("events"),path_1=require("path"),fs_extra_1=require("fs-extra"),plugin_1=require("./plugin"),utils_1=require("../share/utils"),worker=require("@base/electron-worker");class TaskItem{constructor(s,t,e,i=!1){this.state="waiting",this.progress=0,this.message="",this.time="",this.dirty=!1,this.isCommandBuild=!1,this.free=!0,this.type="build",this.options=t,this.id=s,this.isCommandBuild=i,e&&(this.resolve=e)}build(){return new Promise(async s=>{if(this.time=utils_1.getCurrentTime(),this.isCommandBuild){let t;console.debug("Check and complete build options",this.options);try{t=await plugin_1.pluginManager.checkOptions(this.options)}catch(s){console.error(s)}if(!t)return this.update(0,"failure","Check build options failed!"),this.resolve&&this.resolve(332),void s();this.options=t}console.debug("Check and complete build options success!"),console.debug(this.options),this.dirty=!1,delete this.rawOptions;const t=worker.query("Build"),e=plugin_1.pluginManager.getHooksInfo(this.options.platform);this._resolve=s,t.send("build-worker:build",this.id,this.options,e,!!this.isCommandBuild)})}compile(){return new Promise(s=>{this.dirty=!1,this.time=utils_1.getCurrentTime();const t=worker.query("Build"),e=plugin_1.pluginManager.getHooksInfo(this.options.platform),i=path_1.join(utils_1.getBuildDist(this.options.buildPath),this.options.outputName);this._resolve=s,t.send("build-worker:compile",e,i,this.id,!!this.isCommandBuild)})}break(){this.message="The build process was interrupted",this.state="failure",this.free=!0,this.emitChange()}reset(){this.progress=0,this.state="waiting",this.message="",this.emitChange()}update(s,t,e){return this.progress=Editor.Utils.Math.clamp01(s),this.state="string"==typeof t?t:this.state,this.message="string"==typeof e?e:this.message,this.isCommandBuild?("failure"===this.state?(console.log("build failed!"),this.resolve(334)):"success"===this.state&&(console.log("build success!"),this.resolve(336)),void this.emitChange()):"success"===this.state||"failure"===this.state?(Editor.Task.addNotice({title:this.options.outputName,message:this.time+" "+this.message,source:"builder",type:"success"===this.state?"success":"error"}),this.free=!0,this.emitChange(),void(this._resolve&&this._resolve())):(this.free=!1,void this.emitChange())}toJSON(){return{id:this.id,progress:this.progress,state:this.state,message:this.message,options:this.options,time:this.time,dirty:this.dirty,rawOptions:this.rawOptions}}emitChange(){Editor.Message.broadcast("builder:task-changed",this.id,this.toJSON(),TaskManager.supportTaskQueue||this.free)}}class TaskManager extends events_1.EventEmitter{constructor(){super(...arguments),this.command=!1,this.currentTaskId="",this.workerReady=!1,this.dbReady=!1,this.queue=[],this.map={},this.waitingTaskIDs=[]}get ready(){return this.workerReady&&this.dbReady}get free(){return TaskManager.supportTaskQueue||!this.waitingTaskIDs.length}async init(){const s=await Editor.Profile.getConfig("builder","BuildTaskManager.taskMap")||{};Object.keys(s).sort((s,t)=>s.localeCompare(t,"en",{numeric:!0})).forEach(t=>{const e=s[t],i=new TaskItem(e.id,e.options);i.state=e.state||"waiting",1!==e.progress&&(i.state="failure"),i.rawOptions=e.rawOptions,i.progress=e.progress,i.message=e.message,i.time=e.time?e.time:utils_1.changeToLocalTime(e.id),this.map[e.id]?console.warn("The same task name has exists!"):(this.map[e.id]=i,this.queue.push(i))})}async checkCanAddTask(s){return s&&this.waitingTaskIDs.includes(s)?(console.log(Editor.I18n.t("builder.tips.task_exist")),!1):!(this.waitingTaskIDs.length&&!TaskManager.supportTaskQueue)||(console.warn(Editor.I18n.t("builder.tips.task_busy")),!1)}async save(){if(this.command)return;const s={};this.queue.map(t=>{s[t.id]=t.toJSON()}),await Editor.Profile.setConfig("builder","BuildTaskManager.taskMap",s,"local"),await new Promise(s=>{setTimeout(()=>{s()},800)})}async push(s,t,e){if(!this.checkCanAddTask())return;const i=this._getId(),a=this.queue.indexOf(this.map[i]);-1!==a&&this.queue.splice(a,1);const r=new TaskItem(i,s,t,e);r.type="build",this.map[i]=r,this.queue.push(r),this.waitingTaskIDs.push(i),await this.step()}async pop(s){if(!this.map[s])return;const t=this.map[s];delete this.map[s];const e=this.queue.indexOf(t);-1!==e&&this.queue.splice(e,1);const i=this.waitingTaskIDs.indexOf(s);-1!==i&&this.waitingTaskIDs.splice(i,1),await this.save(),fs_extra_1.removeSync(path_1.join(Editor.Project.path,"temp","build-log",t.id+".log")),Editor.Message.broadcast("builder:task-changed",s,null)}async recompile(s,t,e){if(!this.checkCanAddTask(s))return;const i=this.map[s];i&&(this.waitingTaskIDs.includes(s)?i.update(0,"waiting","Wait a moment, build task is busy"):(i.resolve=e,i.options=t||i.options,i.type="build",this.waitingTaskIDs.push(s),await this.step()))}async compile(s,t){if(!this.checkCanAddTask(s))return;if(!this.map[s])return;if(this.waitingTaskIDs.includes(s))return void console.log("Wait a moment, build task is busy");this.map[s].type="compile",this.waitingTaskIDs.push(s),await this.step()}async run(s){this.map[s]}break(){this.queue.forEach(s=>{s.free=!0,1!==s.progress&&(!this.command||this.currentTaskId===s.id&&this.command)&&s.break()}),this.waitingTaskIDs=[],Editor.Message.broadcast("builder:task-changed")}async step(){if(0===this.waitingTaskIDs.length||!this.ready)return;const s=this.waitingTaskIDs[0],t=this.map[s];t&&t.free&&(this.ready?(t.free=!1,t.reset(),this.currentTaskId=s,"build"===t.type?await t.build():await t.compile(),await this.save(),t.free=!0,this.waitingTaskIDs.shift(),await this.step()):t.update(0,"waiting","Wait DB or worker ready"))}_getId(){return String((new Date).getTime())}}exports.TaskManager=TaskManager,TaskManager.supportTaskQueue=!1,exports.manager=new TaskManager;