"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.getCachePath=exports.animationClipCacheManager=void 0;const path_1=require("path"),fs_extra_1=require("fs-extra"),fs_1=require("fs"),electron_1=require("electron"),_=require("lodash"),ANIMATION_CACHE_DIR=(0,path_1.join)(Editor.Project.tmpDir,"animator/cache");class AnimationClipCacheManager{constructor(){this.cacheTimerList={},this.cacheJsonList={},this._saveInterval=5e3,this._maxFileNum=5,this._disabled=!1,this._hasInit=!1}set disabled(e){e!==this._disabled&&(this._disabled=e,e||this.init())}get disabled(){return this._disabled}async updateConfig(){const e=await Editor.Profile.getConfig("animator","clip_cache");this.disabled=!e.use,this._saveInterval=e.interval,this._maxFileNum=e.maxFileNum}async _initClipCacheMap(){if((0,fs_1.existsSync)(ANIMATION_CACHE_DIR)){const e=await(0,fs_extra_1.readdir)(ANIMATION_CACHE_DIR);await Promise.all(e.map(async e=>{if(!await Editor.Message.request("asset-db","query-asset-info",e))return;const t=(await(0,fs_extra_1.readdir)((0,path_1.join)(ANIMATION_CACHE_DIR,e))).map(e=>Number((0,path_1.basename)(e,(0,path_1.extname)(e))));t.sort((e,t)=>Number(t)-Number(e));const a=t.splice(0,this._maxFileNum-1);t.length&&await Promise.all(t.map(t=>electron_1.shell.trashItem(getCachePath(e,t)))),this.cacheTimerList[e]=a}))}}async init(){if(this._hasInit)return!0;if(await this.updateConfig(),this.disabled)return console.log("The clip cache function is turned off"),!1;if(this.save=_.throttle((e,t)=>{this._saveClipDump(e,t)},this._saveInterval,{leading:!0,trailing:!0}),this.saveJsonToFile=_.debounce((e,t,a)=>{this._saveJsonToFile(e,t,a)},this._saveInterval+300,{leading:!0}),await Editor.Message.request("asset-db","query-ready"))await this._initClipCacheMap();else{const e=async()=>{await this._initClipCacheMap(),Editor.Message.__protected__.removeBroadcastListener("asset-db:ready",e)};Editor.Message.__protected__.addBroadcastListener("asset-db:ready",e)}this._hasInit=!0}async queryLatestCache(e){if(this.disabled||!this.cacheJsonList[e]&&!this.cacheTimerList[e])return null;const t=await Editor.Message.request("asset-db","query-asset-info",e);if(!t)return null;const a=this.cacheTimerList[e],s=(0,fs_1.statSync)(t.file).mtimeMs;if(this.cacheJsonList[e]&&this.cacheJsonList[e][0].time>s)return Object.assign({url:t.url},this.cacheJsonList[e][0]);if(a&&a[a.length-1]>s){const s=getCachePath(e,a[a.length-1]);if((0,fs_1.existsSync)(s))return{time:a[a.length-1],file:s,url:t.url}}return null}async _saveClipDump(e,t){const a=await Editor.Message.request("scene","execute-scene-script",{name:"animator",method:"queryClipDump",args:[e,t]});this.cacheJsonList[t]||(this.cacheJsonList[t]=[]);const s=this.cacheJsonList[t];if(s.length&&s[0].data===a||!a)return!1;const i=Date.now();s.unshift({time:i,data:a}),s.length=Math.min(this._maxFileNum,s.length),this.saveJsonToFile(t,i,a)}async _saveJsonToFile(e,t,a){return await(0,fs_extra_1.outputFile)(getCachePath(e,t),a)}}function getCachePath(e,t){return(0,path_1.join)(ANIMATION_CACHE_DIR,e,`${t}.json`)}exports.animationClipCacheManager=new AnimationClipCacheManager,exports.getCachePath=getCachePath;