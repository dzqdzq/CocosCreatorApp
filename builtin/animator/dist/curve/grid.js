"use strict";var __importDefault=this&&this.__importDefault||function(i){return i&&i.__esModule?i:{default:i}};Object.defineProperty(exports,"__esModule",{value:!0}),exports.Grid=void 0;const linear_ticks_1=__importDefault(require("./linear-ticks")),EditorMath=Editor.Utils.Math;class Grid{constructor(i,s){if(this.multi=1,this.axisMargin=20,this.negative=!1,this.lineWidth=1,this.showX=!1,this.showY=!1,this.xAxisScale=1,this.yAxisScale=1,this.axisXConfig={lods:[5,2,3,2],minScale:20,maxScale:100,startOffset:50,showLine:!0,lineWidth:.5,lineColor:"#ccc"},this.axisYConfig={lods:[5,2,3,2],minScale:20,maxScale:100,startOffset:0,showLine:!0,lineWidth:.5,lineColor:"#ccc"},this.xAxisOffset=0,this.xAnchor=.5,this.yAxisOffset=0,this.yAnchor=.5,this.xAxisMinStep=50,this.yAxisMinStep=50,this.xMaxValue=0,this.yMaxValue=0,this.canvas=i,this.ctx=i.getContext("2d"),this.ctx.strokeStyle="#ccc",!s.axisXConfig&&!s.axisYConfig)throw new Error("至少显示一种坐标轴");this.axisMargin=s.axisMargin||0,this.showX=!!s.axisXConfig,this.showY=!!s.axisYConfig,this.showX&&(this.axisXConfig=Object.assign(this.axisXConfig,s.axisXConfig)),this.showY&&(this.axisYConfig=Object.assign(this.axisYConfig,s.axisYConfig)),this.showX&&this._initXAxios(),this.showY&&this._initYAxios()}get height(){return this.negative?this.canvas.height/2:this.canvas.height}get anchorInfo(){return{x:0+this.axisMargin-this.lineWidth-.5,y:0+this.axisMargin-this.lineWidth-.5,w:this.canvas.width-2*this.axisMargin+2*this.lineWidth+.5,h:this.canvas.height-2*this.axisMargin+2*this.lineWidth+.5}}resize(i,s){if(!i||!s){const t=this.canvas.getBoundingClientRect();i=i||t.width,s=s||t.height,i=Math.round(i),s=Math.round(s)}this.canvas.width===i&&this.canvas.height===s||(this.canvas.width=i,this.canvas.height=s,this.render())}render(){this.clear(),this.updateGrids(),this.updateLabels()}transfer(i,s){this.transferX&&this.transferX(i),this.transferY&&this.transferY(s)}updateLabels(){this.renderLabelX&&this.renderLabelX(),this.renderLabelY&&this.renderLabelY()}clear(){var i;null===(i=this.ctx)||void 0===i||i.clearRect(-10,-10,this.canvas.width+10,this.canvas.height+10)}updateGrids(){this.ctx.save(),this.ctx.rect(this.anchorInfo.x,this.anchorInfo.y,this.anchorInfo.w,this.anchorInfo.h),this.ctx.clip(),this.renderX&&this.renderX(),this.renderY&&this.renderY(),this.ctx.restore()}valueToPixel(i){var s,t;return{x:null!==(s=this.valueToPixelX&&this.valueToPixelX(i.x))&&void 0!==s?s:i.x,y:null!==(t=this.valueToPixelY&&this.valueToPixelY(i.y))&&void 0!==t?t:i.y}}pixelToValue(i){var s,t;return{x:null!==(s=this.pixelToValueX&&this.pixelToValueX(i.x))&&void 0!==s?s:i.x,y:null!==(t=this.pixelToValueY&&this.pixelToValueY(i.y))&&void 0!==t?t:i.y}}_initXAxios(){const{lods:i,minScale:s,maxScale:t,startOffset:e,showLine:a,$container:h,format:n,maxValue:l}=this.axisXConfig;this.xAxisOffset=null!==e&&void 0!==e?e:0;const{w:o}=this.anchorInfo;this.xTicks=new linear_ticks_1.default,this.xTicks.initTicks(i,s,t).spacing(10,100),this.xAxisScale=EditorMath.clamp(this.xAxisScale,this.xTicks.minValueScale,this.xTicks.maxValueScale),this.pixelToValueX=(i=>((i-=this.axisMargin)-this.xAxisOffset)/this.xAxisScale),this.valueToPixelX=(i=>i*this.xAxisScale+this.xAxisOffset+this.axisMargin);const r=this.pixelToValueX(0+this.axisMargin),x=this.pixelToValueX(this.canvas.width-2*this.axisMargin);this.xTicks.range(r,x,this.canvas.width-2*this.axisMargin),this.xMaxValue=this.xTicks.maxValue,this.transferX=(i=>{const{startOffset:s}=this.axisXConfig;if(this.xAxisOffset===s&&i>0)return;let t=this.xAxisOffset+i;t>s&&(t=s),this.xAxisOffset=t}),this.xAxisScaleAt=((i,s)=>{const t=this.pixelToValueX(i);this.xAxisScale=EditorMath.clamp(s,this.xTicks.minValueScale,this.xTicks.maxValueScale);const e=this.valueToPixelX(t);return this.transferX(i-e),this.xAxisScale}),this.xFormat=l?i=>parseFloat((l/Math.floor(this.xTicks.maxValue)*i).toFixed(2)):n,h&&(this.renderLabelX=(()=>{const i=this.xTicks.levelForStep(this.xAxisMinStep);let s="";this.xTicks.ticksAtLevel(i,!1).forEach(i=>{const t=Math.floor(this.valueToPixelX(i))-5,e=this.xFormat?this.xFormat(i):i;s+=`<span style="transform: translateX(${Math.floor(t)}px);">${e}</span>`}),this.axisXConfig.$container.innerHTML=s})),a&&(this.renderX=(()=>{let i,s,t;const e=this.ctx,a=this.pixelToValueX(0+this.axisMargin),h=this.pixelToValueX(this.canvas.width-2*this.axisMargin);this.xTicks.range(a,h,this.canvas.width-2*this.axisMargin);for(let a=this.xTicks.minTickLevel;a<=this.xTicks.maxTickLevel;++a)if((s=this.xTicks.tickRatios[a])>0){e.strokeStyle=`rgba(99, 99, 99, ${3*s})`,i=this.xTicks.ticksAtLevel(a,!0);for(const s of i)e.beginPath(),t=this.valueToPixelX(s),e.moveTo(Math.floor(t)+.5,0),e.lineTo(Math.floor(t)+.5,this.canvas.height),e.stroke()}}))}_initYAxios(){const{lods:i,minScale:s,maxScale:t,startOffset:e,showLine:a,$container:h,format:n,maxValue:l}=this.axisYConfig;this.yAxisOffset=e||0;const{w:o}=this.anchorInfo,r=Math.floor(o/10);this.yTicks=new linear_ticks_1.default,this.yTicks.initTicks(i,s,t).spacing(o/20,r),this.yAxisScale=EditorMath.clamp(this.yAxisScale,this.yTicks.minValueScale,this.yTicks.maxValueScale),this.yAxisMinStep=o/20,this.negative?(this.pixelToValueY=(i=>(i+=this.axisMargin,Math.floor((this.height/2-i+this.yAxisOffset)/this.yAxisScale))),this.valueToPixelY=(i=>Math.floor(-i*this.yAxisScale+this.height/2+this.yAxisOffset)-this.axisMargin)):(this.pixelToValueY=(i=>(i+=this.axisMargin,Math.floor((this.height-i+this.yAxisOffset)/this.yAxisScale))),this.valueToPixelY=(i=>Math.floor(-i*this.yAxisScale+this.height+this.yAxisOffset)-this.axisMargin));const x=this.pixelToValueY(0+this.axisMargin),c=this.pixelToValueY(this.canvas.height-2*this.axisMargin);this.yTicks.range(x,c,this.canvas.height-2*this.axisMargin),this.yMaxValue=this.yTicks.maxValue,this.yFormat=l?i=>parseFloat((l/Math.floor(this.yTicks.maxValue)*i).toFixed(2)):n,this.transferY=(i=>{if(!this.showY)return;const s=this.yAxisOffset+i;!this.negative&&s<0||(this.yAxisOffset=s)}),h&&(this.renderLabelY=(()=>{const i=this.yTicks.levelForStep(this.yAxisMinStep);let s="";this.yTicks.ticksAtLevel(i,!1).forEach(i=>{const t=Math.floor(this.valueToPixelY(i))-10,e=this.yFormat?this.yFormat(i):i;s+=`<span style="transform: translateY(${Math.floor(t)}px);">${e}</span>`}),this.axisYConfig.$container.innerHTML=s})),a&&(this.renderY=(()=>{let i,s,t;const e=this.ctx,a=this.pixelToValueY(0+this.axisMargin),h=this.pixelToValueY(this.canvas.height-2*this.axisMargin);this.yTicks.range(a,h,this.canvas.height-2*this.axisMargin);for(let a=this.yTicks.minTickLevel;a<=this.yTicks.maxTickLevel;++a)if((s=this.yTicks.tickRatios[a])>0){e.strokeStyle=`rgba(99, 99, 99, ${3*s})`,i=this.yTicks.ticksAtLevel(a,!0);for(const s of i)e.beginPath(),t=this.valueToPixelY(s),e.moveTo(0,Math.floor(t)+.5),e.lineTo(this.canvas.width,Math.floor(t)+.5),e.stroke()}})),this.yAxisScaleAt=function(i,s){const t=this.pixelToValueY(i);this.yAxisScale=EditorMath.clamp(s,this.yTicks.minValueScale,this.yTicks.maxValueScale);const e=this.valueToPixelY(t);return this.transferY(i-e),this.yAxisScale}}}exports.Grid=Grid;