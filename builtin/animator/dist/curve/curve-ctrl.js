"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.CurveCtrl=void 0;const events_1=require("events"),grid_1=require("./grid"),hermite_1=require("./hermite"),utils_1=require("./utils"),PIXEL_RANGE=20,UINT8_COLOR_DEFAULT=Array(4*PIXEL_RANGE*PIXEL_RANGE).fill(0).toString(),DEFAULT_CTRL_COLOR="rgba(255, 0, 0, 0.1)",AUX_LINE_COLOR="rgba(255, 0, 0, 0.3)",CLICK_RANGE=5;class CurveCtrl extends events_1.EventEmitter{constructor(t,i){var e,s;super(),this.wrapMode=2,this.ctrlKeys=[],this.multi=1,this.ctrlConfig={handlerSize:20,r:3,strokeStyle:DEFAULT_CTRL_COLOR,fillColor:"gold",focusColor:"#f5ee0c7a",precision:2,keyframes:[]},this.flags={flag:!1,tanDrag:!1,curveDrag:!1,keyDrag:!1},this.changeType="",this.isShowCtrl=!1,this.isShowPoint=!1,this.isShowAuxin=!1,this.hasBindHandle=!1,this.ctrlPoints=null,this.currentKeyIndex=null,this.rawKeyframes=[],this.mouseDownPoint={startX:0,startY:0},this.canvas=t,this.ctx=t.getContext("2d"),this.ctx.strokeStyle=this.ctrlConfig.strokeStyle;const r=t.cloneNode();r.className="grid";const n=t.cloneNode();n.className="curve",null===(e=t.parentNode)||void 0===e||e.insertBefore(n,t),null===(s=t.parentNode)||void 0===s||s.insertBefore(r,n),this.grid=new grid_1.Grid(r,i.gridConfig||{}),this.curve=new hermite_1.Hermite(n,this.grid,i.curveConfig||{}),this.ctrlConfig.handlerSize=i.handlerSize||20,this.bindHandler(!0)}static drawLine(t,i,e){e.beginPath(),e.moveTo(t.x,t.y),e.lineTo(i.x,i.y),e.closePath(),e.stroke()}static drawArc(t,i,e){e.beginPath(),e.moveTo(t.x,t.y),e.arc(t.x,t.y,i,0,2*Math.PI),e.closePath(),e.stroke(),e.fill()}setGridFormat(t,i){this.grid[`${i}Format`]=t}paint(t){this.clear(),this.grid.render(),this.curve.clear(),this.curve.paint(t),this.ctx.stroke(this.curve.curveCache),this.ctrlKeys=this.transToCtrlKey(t),this.painCtrlPoint()}rePaint(){this.clear(),this.grid.render(),this.curve.rePaint(),this.ctrlKeys=this.transToCtrlKey(this.curve.keyframes),this.painCtrlPoint()}updateWrapMode(t,i){this.curve.config[t]=i,"preWrapMode"===t?this.curve.paintPreWrapMode():this.curve.paintPostWrapMode()}moveTimeLine(t,i){this.grid.transferX&&this.grid.transferX(t),this.grid.transferY&&this.grid.transferY(i)}moveTimeLineX(t){this.grid.transferX(t)}moveTimeLineY(t){this.grid.transferY(t)}scaleTimeLine(t,i,e){this.grid.xAxisScaleAt(t,utils_1.smoothScale(e,this.grid.xAxisScale)),i>0&&this.grid.yAxisScaleAt(i,utils_1.smoothScale(e,this.grid.yAxisScale))}scaleTimeLineY(t,i){this.grid.yAxisScaleAt(t,utils_1.smoothScale(i,this.grid.yAxisScale))}scaleTimeLineX(t,i){this.grid.xAxisScaleAt(t,utils_1.smoothScale(i,this.grid.xAxisScale))}addKeyFrame(t){t=this.grid.pixelToValueX(t);const i=this.curve.addKeyFrame(t);if(null===i)return void console.warn("添加点无效",t);this.ctrlKeys.splice(i,0,this.calcCtrl(JSON.parse(JSON.stringify(this.curve.keyframes[i]))));const e=this.ctrlKeys[i];this.painCtrlPoint(),this.drawCtrl(e),this.emitChange(),this.emitConfirm()}transToCtrlKey(t){return t.map(t=>this.calcCtrl(t))}calcCtrl(t,i){let e,s;if("outTangent"!==i&&t.inTangent){const i=this.calcCtrlPoint(t.point,t.inTangent,"inTangent");e=this.grid.valueToPixel(i)}if("inTangent"!==i&&t.outTangent){const i=this.calcCtrlPoint(t.point,t.outTangent,"outTangent");s=this.grid.valueToPixel(i)}return{canvas:this.grid.valueToPixel(t.point),outCanvas:e,inCanvas:s,point:t.point,inTangent:t.inTangent,outTangent:t.outTangent}}calcCtrlPoint(t,i,e){if("number"!=typeof i)throw new Error("k should be number.");const{handlerSize:s}=this.ctrlConfig;let r=0,n=0;return i!==Number.POSITIVE_INFINITY?(r=Math.sqrt(s*s/(1+i*i)),r="inTangent"===e?t.x-r:t.x+r,n=t.y-i*(t.x-r)):(r=t.x,n="inTangent"===e?t.y+s:t.y-s),{x:r,y:n,type:e}}delKeyFrame(t){this.curve.delKeyFrame(t),this.ctrlPoints=null,this.ctrlKeys.splice(t,1),this.clear(),this.refreshRender(),this.painCtrlPoint()}refreshRender(){this.curve.rePaint(),this.resetCtrl(),this.lightCurve(),"number"==typeof this.currentKeyIndex&&(this.ctrlPoints=this.ctrlKeys[this.currentKeyIndex],this.drawCtrl(this.ctrlPoints))}clear(){const{width:t,height:i}=this.canvas;this.ctx.clearRect(0,0,t,i)}updateTan(t,i){const e=this.currentKeyIndex,{canvas:s}=this.ctrlPoints;let r=0;r=Math.abs(t-s.x)-10<0?Number.POSITIVE_INFINITY:-(i-s.y)/this.grid.yAxisScale/((t-s.x)/this.grid.xAxisScale),this.curve.updateTan(e,r,"inTangent"),this.curve.updateTan(e,r,"outTangent"),this.ctrlKeys[e]=this.calcCtrl(this.curve.keyframes[e]),this.refreshRender(),this.drawCtrl(this.ctrlPoints)}moveKey(t,i,e){this.changeType="keyframe";const s=this.curve.moveKey(t,i,e);return-1!==s&&(this.ctrlKeys.splice(e,1),this.ctrlKeys.splice(s,0,this.calcCtrl(JSON.parse(JSON.stringify(this.curve.keyframes[s])))),this.currentKeyIndex=s,this.refreshRender(),!0)}bindHandler(t){t&&this.hasBindHandle||!t&&!this.hasBindHandle||(t?(this.canvas.addEventListener("mousemove",this.onMouseMove.bind(this)),document.addEventListener("mouseup",this.onMouseUp.bind(this)),this.canvas.addEventListener("mousedown",this.onMouseDown.bind(this)),this.hasBindHandle=!0):(this.canvas.removeEventListener("mousemove",this.onMouseMove.bind(this)),document.removeEventListener("mouseup",this.onMouseUp.bind(this)),this.canvas.removeEventListener("mousedown",this.onMouseDown.bind(this)),this.hasBindHandle=!1))}onMouseDown(t){this.flags.flag=!1;const{r:i}=this.ctrlConfig,{offsetX:e,offsetY:s}=t,r=this.ctx.getImageData(e-PIXEL_RANGE/2,s-PIXEL_RANGE/2,PIXEL_RANGE,PIXEL_RANGE);this.mouseDownPoint.startX=t.x,this.mouseDownPoint.startY=t.y;for(let r=0;r<this.ctrlKeys.length;r++){const n=this.ctrlKeys[r],{x:h,y:a}=n.canvas;if(Math.abs(e-h)<2*CLICK_RANGE+i&&Math.abs(s-a)<2*CLICK_RANGE+i){if(2===t.button){const i=this;return void Editor.Menu.popup({x:t.pageX,y:t.pageY,menu:[{label:"Delete Key",click(){i.delKeyFrame(r)}}]})}return this.flags.flag=!0,this.currentKeyIndex=r,this.flags.keyDrag=!0,this.canvas.style.cursor="move",void this.showCtrl(n,r)}}if(this.isShowCtrl&&this.ctrlPoints)for(const t of["outCanvas","inCanvas"]){const r=this.ctrlPoints[t];if(!r)continue;const{x:n,y:h}=r;if(Math.abs(e-n)<CLICK_RANGE+i&&Math.abs(s-h)<CLICK_RANGE+i)return this.flags.tanDrag=!0,this.flags.flag=!0,void(this.ctrlPoints.dragInfo={type:"inCanvas"===t?"inTangent":"outTangent"})}if(r.data.toString()!==UINT8_COLOR_DEFAULT)if(this.flags.flag=!0,2===t.button){const i=this;Editor.Menu.popup({x:t.pageX,y:t.pageY,menu:[{label:"Add Key",click(){i.addKeyFrame(e)}}]})}else this.lightCurve(),this.canvas.style.cursor="ns-resize",!this.flags.tanDrag&&!this.flags.keyDrag&&(this.flags.curveDrag=!0);this.flags.flag||this.resetCtrl("hideCtrl")}onMouseMove(t){const{curveDrag:i,tanDrag:e,keyDrag:s}=this.flags;if(!e&&!i&&!s)return;const{offsetX:r,offsetY:n,movementY:h,x:a,y:o}=t;if(!(Math.abs(a-this.mouseDownPoint.startX)<.5||Math.abs(o-this.mouseDownPoint.startY)<.5)){if(e)return this.changeType="tangent",this.updateTan(r,n),void this.emitChange();if(s&&"number"==typeof this.currentKeyIndex)return this.moveKey(r,n,this.currentKeyIndex),void this.emitChange();if(i&&0!==h){if(!this.curve.moveAllY(h))return;this.ctrlKeys=this.transToCtrlKey(this.curve.keyframes),this.changeType="curve",this.emitChange(),this.resetCtrl(),this.lightCurve()}}}onMouseUp(t){this.canvas.style.cursor="default",this.flags.tanDrag=!1,this.flags.curveDrag=!1,this.flags.keyDrag=!1,this.isShowPoint=!1,this.changeType&&(this.emitChange(),this.emitConfirm(),this.changeType="")}showPoint(t,i){if(!t)return;this.isShowPoint=!0;const{x:e,y:s}=i;this.ctx.save(),this.ctx.strokeStyle="rgba(0, 255, 0, 0.2)",this.ctx.setLineDash([4,8]),this.ctx.moveTo(e,this.canvas.height-this.grid.axisMargin),this.ctx.lineTo(e,s),this.ctx.lineTo(this.grid.axisMargin,s),this.ctx.stroke(),this.ctx.fillStyle="gold",this.ctx.fillText(String(this.grid.yFormat(this.grid.pixelToValueY(s))),0,s),this.ctx.fillText(String(this.grid.xFormat(this.grid.pixelToValueX(e))),e-this.grid.axisMargin/2,this.canvas.height-this.grid.axisMargin/2),this.ctx.restore()}lightCurve(){const{focusColor:t}=this.ctrlConfig;this.ctx.strokeStyle=t,this.ctx.stroke(this.curve.curveCache),this.isShowAuxin=!0}showCtrl(t,i){this.currentKeyIndex!==t.index&&("number"==typeof this.currentKeyIndex&&(this.resetCtrl(),this.lightCurve()),this.ctrlPoints=t,this.drawCtrl(t))}drawCtrl(t){const i=this.ctx;this.isShowCtrl=!0;const{canvas:e,inCanvas:s,outCanvas:r}=t,{r:n,fillColor:h}=this.ctrlConfig;i.save(),i.fillStyle="rgba(0, 255, 0, 0.2)",i.fillRect(t.canvas.x-CLICK_RANGE,t.canvas.y-CLICK_RANGE,2*CLICK_RANGE,2*CLICK_RANGE),i.fillStyle=h,i.strokeStyle="white",s&&(CurveCtrl.drawLine(e,s,this.ctx),CurveCtrl.drawArc(s,n,this.ctx)),r&&(CurveCtrl.drawLine(e,r,this.ctx),CurveCtrl.drawArc(r,n,this.ctx)),i.restore(),this.showPoint(t,e)}resetCtrl(t){(this.isShowCtrl||this.isShowAuxin)&&(this.isShowAuxin=!1,this.isShowCtrl=!1,this.ctx.clearRect(0,0,this.canvas.width,this.canvas.height),this.ctx.strokeStyle=DEFAULT_CTRL_COLOR,this.clear(),this.ctx.stroke(this.curve.curveCache),this.painCtrlPoint(),t&&(this.currentKeyIndex=null,this.ctrlPoints=null))}painCtrlPoint(){const{r:t,fillColor:i,strokeStyle:e}=this.ctrlConfig;this.ctx.fillStyle=i,this.ctx.strokeStyle=e;for(const i of this.ctrlKeys)this.ctx.beginPath(),this.ctx.arc(i.canvas.x,i.canvas.y,t,0,2*Math.PI),this.ctx.closePath(),this.ctx.stroke(),this.ctx.fill()}emitConfirm(){this.emit("confirm",{})}emitChange(){this.emit("change",{})}}exports.CurveCtrl=CurveCtrl;