"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.Hermite=void 0;const utils_1=require("./utils");class Hermite{constructor(t,e,i){this.hermiteArgs=[],this.config={strokeStyle:"red",lineWidth:1,preWrapMode:2,postWrapMode:22,strokeStyleAxu:"rgba(255, 0, 0, 0.3)"},this.keyframes=[],this.canvas=t,this.ctx=t.getContext("2d"),this.ctx.strokeStyle=i.strokeStyle||this.config.strokeStyle,this.ctx.lineWidth=i.lineWidth||this.config.lineWidth,this.config=Object.assign(this.config,i),this.grid=e,this.origin=i.origin||{x:0,y:0},this.curveCache=new Path2D}static calcArgs(t,e,i,s){if(e===Number.POSITIVE_INFINITY||s===Number.POSITIVE_INFINITY)return{a:0,b:0,c:0,d:t.y};const r=t.x,n=t.y,a=i.x,h=i.y;let o,c,l,g,u,p,m,d;const f=[1,r,r*r,r*r*r,1,a,a*a,a*a*a,0,1,2*r,3*r*r,0,1,2*a,3*a*a];for(d=(t=>t[0]*t[4]*t[8]+t[1]*t[5]*t[6]+t[2]*t[3]*t[7]-t[2]*t[4]*t[6]-t[1]*t[3]*t[8]-t[0]*t[5]*t[7]),o=m=0;o<4;m+=d(p)*f[o]*(o%2?-1:1),o++)if(f[o])for(c=4,p=[];c<f.length;c++)c%4!==o&&p.push(f[c]);for(u=[],o=0;o<4;o++)for(c=0;c<4;u[o+4*c]=((o+c)%2?-1:1)*d(p)/m,c++)for(p=[],l=0;l<3;l++)for(g=0;g<3;g++)p.push(f[(o+l+1)%4*4+(c+g+1)%4]);const x=n*u[0]+h*u[1]+e*u[2]+s*u[3],y=n*u[4]+h*u[5]+e*u[6]+s*u[7],T=n*u[8]+h*u[9]+e*u[10]+s*u[11];return{a:n*u[12]+h*u[13]+e*u[14]+s*u[15],b:T,c:y,d:x}}static getRenderFunc(t){const{a:e,b:i,c:s,d:r}=t;return t=>e*t*t*t+i*t*t+s*t+r}static paintHermit(t,e,i){if(0===t.length||!e)return void console.error("paint hermit need keyframes and canvas!");const s=e.width,r=e.height,n=e.getContext("2d");let a;n.clearRect(0,0,s,r),n.strokeStyle="#a9adb9",a=i?r/s/2:r/s;const h=t.map(t=>{return{point:{x:t.time*s,y:t.value*r},outTangent:"number"==typeof t.outTangent?t.outTangent*a:1/0,inTangent:"number"==typeof t.inTangent?t.inTangent*a:1/0}});for(let t=0;t<h.length-1;t++){const e=h[t+1],s=h[t],a=Hermite.calcArgs(s.point,s.outTangent,e.point,e.inTangent),o=Hermite.getRenderFunc(a);n.beginPath();for(let t=s.point.x;t<=e.point.x;t++)i?n.lineTo(t,r-.5*o(t)-r/2):n.lineTo(t,r-o(t));s.outTangent!==Number.POSITIVE_INFINITY&&e.inTangent!==Number.POSITIVE_INFINITY||(n.lineTo(e.point.x,r-e.point.y),n.stroke()),n.stroke()}i&&(n.strokeStyle="#ccc",n.lineWidth=.5,n.beginPath(),n.moveTo(0,r/2),n.lineTo(s,r/2),n.stroke())}translate(t,e){}initKeyData(t){try{this.keyframes=require("lodash").cloneDeep(t)}catch(t){return void console.error(t)}}paint(t){try{this.keyframes=require("lodash").cloneDeep(t)}catch(t){return void console.error(t)}this.hermiteArgs=[],this.paintRect(),this.paintInWrapMode()}rePaint(){this.clear(),this.paintRect(),this.paintInWrapMode()}paintRect(t){const e=(null===t||void 0===t?void 0:t.end)||this.keyframes.length-1,i=(null===t||void 0===t?void 0:t.start)||0;this.curveCache=new Path2D;for(let t=i;t<e;t++){const e=this.keyframes[t+1],s=this.keyframes[t],r=this.grid.valueToPixel(s.point);t===i&&this.curveCache.moveTo(r.x,r.y);const n=this.getRenderFunc(s.point,s.outTangent,e.point,e.inTangent,t);for(let t=s.point.x;t<=e.point.x;t++){const e=this.grid.valueToPixel({x:t,y:n(t)});this.curveCache.lineTo(e.x,e.y)}if(s.outTangent===Number.POSITIVE_INFINITY||e.inTangent===Number.POSITIVE_INFINITY){const t=this.grid.valueToPixel(e.point);this.curveCache.lineTo(t.x,t.y)}}this.ctx.stroke(this.curveCache)}paintInWrapMode(){this.paintPostWrapMode(),this.paintPreWrapMode()}paintPreWrapMode(){this.ctx.save(),this.ctx.strokeStyle=this.config.strokeStyleAxu;const t=this.grid.valueToPixel(this.keyframes[this.keyframes.length-1].point),e=this.grid.valueToPixel(this.keyframes[0].point);this.ctx.clearRect(0,0,e.x,this.canvas.height);const i=t.x-e.x,s=Math.ceil(e.x/i),r=new Path2D;switch(this.config.preWrapMode){case 4:r.moveTo(e.x-this.grid.axisMargin,e.y),r.lineTo(0,e.y);break;case 2:{let n=utils_1.createMatrix();for(let a=0;a<s;a++)r.moveTo(e.x-i*a,e.y),n.translateSelf(-i,0),r.lineTo(e.x-i*a,t.y),r.addPath(this.curveCache,n);break}case 3:case 22:{const t=new Path2D;let n=utils_1.createMatrix();t.addPath(this.curveCache,n.scaleSelf(-1,1));let a=utils_1.createMatrix();for(let n=0;n<=s;n++)a=a.translateSelf(-i,0),n%2==0?r.addPath(t,utils_1.createMatrix().translateSelf(2*e.x-i*n)):r.addPath(this.curveCache,a);break}}this.ctx.stroke(r),this.ctx.restore()}paintPostWrapMode(){this.ctx.save(),this.ctx.strokeStyle=this.config.strokeStyleAxu;const t=this.grid.valueToPixel(this.keyframes[this.keyframes.length-1].point),e=this.grid.valueToPixel(this.keyframes[0].point);this.ctx.clearRect(t.x,0,this.canvas.width-t.x,this.canvas.height);const i=t.x-e.x,s=Math.ceil((this.canvas.width-t.x)/i),r=new Path2D;switch(r.moveTo(t.x,t.y),this.config.postWrapMode){case 4:r.lineTo(this.canvas.width-this.grid.axisMargin,t.y);break;case 2:{let n=utils_1.createMatrix();for(let a=0;a<s;a++)n.translateSelf(i,0),r.lineTo(t.x+i*a,e.y),r.addPath(this.curveCache,n);break}case 22:case 3:{const e=new Path2D;let n=utils_1.createMatrix();e.addPath(this.curveCache,n.scaleSelf(-1,1));let a=utils_1.createMatrix();for(let n=0;n<=s;n++)a=a.translateSelf(i,0),n%2==0?r.addPath(e,utils_1.createMatrix().translateSelf(2*t.x+i*n)):r.addPath(this.curveCache,a);break}}this.wrapModeCurveCache=r,this.ctx.stroke(r),this.ctx.restore()}moveAllY(t){if(0===t)return!1;this.clear();const e=new Path2D;let i=utils_1.createMatrix();i=i.translateSelf(0,t),e.addPath(this.curveCache,i),this.curveCache=e,this.ctx.stroke(this.curveCache),this.paintInWrapMode(),t/=this.grid.yAxisScale;for(let e=0;e<this.keyframes.length;e++){const i=this.keyframes[e],{point:s}=i;s.y+=-t,e<this.keyframes.length-1&&(this.hermiteArgs[e].d+=-t)}return!0}moveKey(t,e,i){const s=JSON.parse(JSON.stringify(this.keyframes[i]));s.point=this.grid.pixelToValue({x:t,y:e});const{width:r,height:n}=this.canvas;if(t<0||e>n||e<0||t>r)return-1;let a=this.keyframes[i+1],h=this.keyframes[i-1];return a&&s.point.x>a.point.x?(this.keyframes.splice(i,1),this.keyframes.splice(i+1,0,s),h&&(this.hermiteArgs[i-1]=Hermite.calcArgs(h.point,h.outTangent,a.point,a.inTangent)),i++,h=a,a=this.keyframes[i+1],i):h&&s.point.x<h.point.x?(this.keyframes.splice(i,1),this.keyframes.splice(i-1,0,s),a&&(this.hermiteArgs[i]=Hermite.calcArgs(h.point,h.outTangent,a.point,a.inTangent)),i--,a=h,h=this.keyframes[i-1],i):(a&&(this.hermiteArgs[i]=Hermite.calcArgs(s.point,s.outTangent,a.point,a.inTangent)),h&&(this.hermiteArgs[i-1]=Hermite.calcArgs(h.point,h.outTangent,s.point,s.inTangent)),this.keyframes[i]=s,i)}updateTan(t,e,i){if(0===t&&"inTangent"===i||t===this.keyframes.length-1&&"outTangent"===i)return;const s=this.keyframes[t];if(s[i]=e,"outTangent"===i){const e=this.keyframes[t+1];this.hermiteArgs[t]=Hermite.calcArgs(s.point,s.outTangent,e.point,e.inTangent)}else if("inTangent"===i){const e=this.keyframes[t-1];this.hermiteArgs[t-1]=Hermite.calcArgs(e.point,e.outTangent,s.point,s.inTangent)}}addKeyFrame(t){let e=null;for(let i=0;i<this.keyframes.length-1;i++){const s=this.keyframes[i].point,r=this.keyframes[i+1].point;if(t>s.x&&r.x>t){e=i;break}}if(null===e)return null;const i=this.hermiteArgs[e],s=this.calcSlope(t,i),r=Hermite.getRenderFunc(i)(t);return this.hermiteArgs.splice(e+1,0,i),this.keyframes.splice(e+1,0,{point:{x:t,y:r},outTangent:s,inTangent:s}),e+1}delKeyFrame(t){const e=this.keyframes[t+1],i=this.keyframes[t-1];if(e&&i){const s=Hermite.calcArgs(i.point,i.outTangent,e.point,e.inTangent);this.hermiteArgs.splice(t-1,0,s)}else e&&this.hermiteArgs.splice(t,1),i&&this.hermiteArgs.splice(t-1,1);this.keyframes.splice(t,1)}clear(){this.ctx.clearRect(0,0,this.canvas.width,this.canvas.height)}getRenderFunc(t,e,i,s,r){return this.hermiteArgs[r]||(this.hermiteArgs[r]=Hermite.calcArgs(t,e,i,s)),Hermite.getRenderFunc(this.hermiteArgs[r])}calcSlope(t,e){const{a:i,b:s,c:r}=e;return 3*i*t*t+2*s*t+r}}exports.Hermite=Hermite;