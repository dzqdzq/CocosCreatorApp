"use strict";Object.defineProperty(exports,"__esModule",{value:!0});const WebSocketServer=require("websocket").server,{serialize:serialize,deserialize:deserialize}=require("v8"),http=require("http"),PROFILER=!1,profilerStringify=PROFILER?e=>{const t=Date.now(),r=serialize(e),o=Date.now();return o-t>1&&(console.log("JSON.stringify time out",o-t,r),console.trace()),r}:e=>serialize(e),profilerParse=PROFILER?e=>{const t=Date.now(),r=deserialize(e),o=Date.now();return o-t>1&&console.log("JSON.parse time out",o-t,r.type),r}:e=>deserialize(e);class EditorServer{constructor(){this.resolveMap={},this.callbackMap={}}getPort(){return this.server.address().port}startServer(e){const t=this;this.server=http.createServer(function(e,t){console.log(new Date+" Received request for "+e.url),t.writeHead(404),t.end()}),this.server.on("error",e=>{"EADDRINUSE"===e.code&&console.error("Nativize IPC Serer error : EADDRINUSE",t.getPort())}),this.server.listen(e,function(){console.log(new Date+" Server is listening on port "+t.getPort())});this.wsServer=new WebSocketServer({httpServer:this.server,closeTimeout:18e5,keepaliveGracePeriod:18e5,autoAcceptConnections:!1,maxReceivedFrameSize:2048e4,maxReceivedMessageSize:2048e4}),this.wsServer.on("request",function(e){const r=e.accept("editor-native",e.origin);console.log(new Date+" Connection accepted."),r.on("message",function(e){if("utf8"!==e.type){PROFILER&&console.log("EditorReceiceTime",Date.now());const r=profilerParse(e.binaryData),o=t.resolveMap[r.id];o?(PROFILER&&console.log("requestResponseTime",r.id,Date.now()-o[2],o[3]),o[0](r),t.resolveMap[r.id]=null):r.ipc?t.retransmitIPC(r):console.log("receive nativize msg")}}),r.on("close",function(e,o){console.log("native ipc close",e,o),t.callbackMap.close&&t.callbackMap.close(r),t.connection=null}),t.connection=r,t.callbackMap.connect&&t.callbackMap.connect(r)}.bind(this))}send(e){this.connection?this.connection.sendBytes(profilerStringify(e)):console.error("nativize not connect")}request(e){return this.connection?new Promise((t,r)=>{this.resolveMap[e.id]=[t,r],this.connection.sendBytes(profilerStringify(e))}):Promise.reject("send fail!not connect")}on(e,t){this.callbackMap[e]=t}async retransmitIPC(e){const t=e.method;if(!Editor.Message[t])return void console.error("retransmitIPC failed:wrong method");if("broadcast"===t)return void await Editor.Message[t](e.msg,...e.data);const r=await Editor.Message[t](e.plugin,e.msg,...e.data),o={id:e.id,ipc:1,type:e.type,data:r};this.send(o)}}module.exports=EditorServer;